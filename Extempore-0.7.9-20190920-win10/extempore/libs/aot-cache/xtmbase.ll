@PIf = dllexport global float 0x400921fb60000000
@TWOPIf = dllexport global float 0x401921fb60000000
@Ef = dllexport global float 0x4005bf0a80000000
@PI = dllexport global double 3.1415926535897931160
@TWOPI = dllexport global double 6.2831853071795862320
@E = dllexport global double 2.7182818284590450908
@gsxtmbase0 = hidden constant [25 x i8] c"audio_64bit_adhoc_W2kxXQ\00"
@gsxtmbase1 = hidden constant [29 x i8] c"{i8*, i8*, i1 (i8*, i8*)*}**\00"
define dllexport fastcc i1 @audio_64bit_adhoc_W2kxXQ__1(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*)*}***}*
%audio_64bit_adhoc_W2kxXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*)*}***}, {{i8*, i8*, i1 (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%audio_64bit_adhoc_W2kxXQPtr = load {i8*, i8*, i1 (i8*, i8*)*}***, {i8*, i8*, i1 (i8*, i8*)*}**** %audio_64bit_adhoc_W2kxXQPtr_

; setup arguments


%val3 = trunc i64 0 to i1
ret i1 %val3
}
define dllexport ccc {i8*, i8*, i1 (i8*, i8*)*}** @audio_64bit_adhoc_W2kxXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone23 = load i8*, i8** %_impzPtr
%zone24 = bitcast i8* %tzone23 to %mzone*

; let assign value to symbol audio_64bit_adhoc_W2kxXQ
%dat_audio_64bit_adhoc_W2kxXQ = call i8* @llvm_zone_malloc(%mzone* %zone24, i64 8)
%audio_64bit_adhoc_W2kxXQPtr = bitcast i8* %dat_audio_64bit_adhoc_W2kxXQ to { i8*, i8*, i1 (i8*, i8*)*}***
%tzone4 = load i8*, i8** %_impzPtr
%zone5 = bitcast i8* %tzone4 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5)
; malloc closure structure
%clsptr6 = call i8* @llvm_zone_malloc(%mzone* %zone5, i64 24)
%closure7 = bitcast i8* %clsptr6 to { i8*, i8*, i1 (i8*, i8*)*}*

; malloc environment structure
%envptr8 = call i8* @llvm_zone_malloc(%mzone* %zone5, i64 8)
%environment9 = bitcast i8* %envptr8 to {{i8*, i8*, i1 (i8*, i8*)*}***}*

; malloc closure address table
%addytable10 = call %clsvar* @new_address_table()
%var11 = bitcast [25 x i8]* @gsxtmbase0 to i8*
%var12 = bitcast [29 x i8]* @gsxtmbase1 to i8*
%addytable13 = call %clsvar* @add_address_table(%mzone* %zone5, i8* %var11, i32 0, i8* %var12, i32 3, %clsvar* %addytable10)
%address-table14 = bitcast %clsvar* %addytable13 to i8*

; insert table, function and environment into closure struct
%closure.table17 = getelementptr { i8*, i8*, i1 (i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*)*}* %closure7, i32 0, i32 0
store i8* %address-table14, i8** %closure.table17
%closure.env18 = getelementptr { i8*, i8*, i1 (i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*)*}* %closure7, i32 0, i32 1
store i8* %envptr8, i8** %closure.env18
%closure.func19 = getelementptr { i8*, i8*, i1 (i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*)*}* %closure7, i32 0, i32 2
store i1 (i8*, i8*)* @audio_64bit_adhoc_W2kxXQ__1, i1 (i8*, i8*)** %closure.func19
%closure_size20 = call i64 @llvm_zone_mark_size(%mzone* %zone5)
call void @llvm_zone_ptr_set_size(i8* %clsptr6, i64 %closure_size20)
%wrapper_ptr21 = call i8* @llvm_zone_malloc(%mzone* %zone5, i64 8)
%closure_wrapper22 = bitcast i8* %wrapper_ptr21 to { i8*, i8*, i1 (i8*, i8*)*}**
store { i8*, i8*, i1 (i8*, i8*)*}* %closure7, { i8*, i8*, i1 (i8*, i8*)*}** %closure_wrapper22

; let value assignment
%audio_64bit_adhoc_W2kxXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*)*}** %closure_wrapper22, { i8*, i8*, i1 (i8*, i8*)*}** %closure_wrapper22
store { i8*, i8*, i1 (i8*, i8*)*}** %audio_64bit_adhoc_W2kxXQ, { i8*, i8*, i1 (i8*, i8*)*}*** %audio_64bit_adhoc_W2kxXQPtr

; add data to environment
; don't need to alloc for env var audio_64bit_adhoc_W2kxXQ
%tmp_envptr16 = getelementptr {{i8*, i8*, i1 (i8*, i8*)*}***}, {{i8*, i8*, i1 (i8*, i8*)*}***}* %environment9, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*)*}*** %audio_64bit_adhoc_W2kxXQPtr, {i8*, i8*, i1 (i8*, i8*)*}**** %tmp_envptr16


%val25 = load {i8*, i8*, i1 (i8*, i8*)*}**, {i8*, i8*, i1 (i8*, i8*)*}*** %audio_64bit_adhoc_W2kxXQPtr
ret {i8*, i8*, i1 (i8*, i8*)*}** %val25
}


@audio_64bit_adhoc_W2kxXQ_var = dllexport global [1 x i8*] [ i8* null ]

@audio_64bit_adhoc_W2kxXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @audio_64bit_adhoc_W2kxXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*)*}** @audio_64bit_adhoc_W2kxXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @audio_64bit_adhoc_W2kxXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @audio_64bit_adhoc_W2kxXQ() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*)*,  i1 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee)
ret i1 %result
}


define dllexport ccc i1 @audio_64bit_adhoc_W2kxXQ_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*)*,  i1 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee)
ret i1 %result
}


define dllexport ccc i8*  @audio_64bit_adhoc_W2kxXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*)*,  i1 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @audio_64bit_adhoc_W2kxXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audio_64bit_adhoc_W2kxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*)*,  i1 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@SPI = dllexport global float 0x400921fb60000000
@STWOPI = dllexport global float 0x401921fb60000000
@SE = dllexport global float 0x4005bf0a80000000
@SAMPLE_RATE = external global i32
@SAMPLERATE = dllexport global float zeroinitializer
@SRs = dllexport global float zeroinitializer
@SRf = dllexport global float zeroinitializer
@SRd = dllexport global double zeroinitializer
@SR = dllexport global i64 zeroinitializer
@CHANNELS = external global i32
@IN_CHANNELS = external global i32
@NUM_FRAMES = external global i32
@FRAMES = dllexport global i64 zeroinitializer
@NaNf = dllexport global float 0x0
@NaN = dllexport global double 0.00000000000000000000
@gsxtmbase2 = hidden constant [31 x i8] c"set_float_nans__adhoc_W3ZvaWRd\00"
@gsxtmbase3 = hidden constant [31 x i8] c"{i8*, i8*, void (i8*, i8*)*}**\00"
define dllexport fastcc void @set_float_nans__adhoc_W3ZvaWRd__26(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone27 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%set_float_nans__adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%set_float_nans__adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %set_float_nans__adhoc_W3ZvaWRdPtr_

; setup arguments


%tzone28 = load i8*, i8** %_impzPtr
%zone29 = bitcast i8* %tzone28 to %mzone*

; let assign value to symbol nan32
%nan32Ptr = alloca i32
%tzone30 = load i8*, i8** %_impzPtr
%zone31 = bitcast i8* %tzone30 to %mzone*

; let assign value to symbol nan64
%nan64Ptr = alloca i64
%tzone36 = load i8*, i8** %_impzPtr
%zone37 = bitcast i8* %tzone36 to %mzone*

; let assign value to symbol n32
%n32Ptr = alloca i32*
%tzone42 = load i8*, i8** %_impzPtr
%zone43 = bitcast i8* %tzone42 to %mzone*

; let assign value to symbol n64
%n64Ptr = alloca i64*

; let value assignment
%nan32 = select i1 true, i32 2143289344, i32 2143289344
store i32 %nan32, i32* %nan32Ptr


; let value assignment
%nan64 = select i1 true, i64 0, i64 0
store i64 %nan64, i64* %nan64Ptr

%tzone32 = load i8*, i8** %_impzPtr
%zone33 = bitcast i8* %tzone32 to %mzone*
%dat34 = call i8* @llvm_zone_malloc(%mzone* %zone33, i64 4)
call i8* @memset(i8* %dat34, i32 0, i64 4)
%val35 = bitcast i8* %dat34 to i32*

; let value assignment
%n32 = select i1 true, i32* %val35, i32* %val35
store i32* %n32, i32** %n32Ptr

%tzone38 = load i8*, i8** %_impzPtr
%zone39 = bitcast i8* %tzone38 to %mzone*
%dat40 = call i8* @llvm_zone_malloc(%mzone* %zone39, i64 8)
call i8* @memset(i8* %dat40, i32 0, i64 8)
%val41 = bitcast i8* %dat40 to i64*

; let value assignment
%n64 = select i1 true, i64* %val41, i64* %val41
store i64* %n64, i64** %n64Ptr

%val44 = load i32*, i32** %n32Ptr
%val45 = load i32, i32* %nan32Ptr
; set pointer
%val46 = getelementptr i32, i32* %val44, i64 0
store i32 %val45, i32* %val46
%val47 = load i64*, i64** %n64Ptr
%val48 = load i64, i64* %nan64Ptr
; set pointer
%val49 = getelementptr i64, i64* %val47, i64 0
store i64 %val48, i64* %val49
; do set!
%val50 = load i32*, i32** %n32Ptr
%val51 = bitcast i32* %val50 to float*
; pointer ref
%val52 = getelementptr float, float* %val51, i64 0
%val53 = load float, float* %val52
store float %val53, float* @NaNf
; do set!
%val54 = load i64*, i64** %n64Ptr
%val55 = bitcast i64* %val54 to double*
; pointer ref
%val56 = getelementptr double, double* %val55, i64 0
%val57 = load double, double* %val56
store double %val57, double* @NaN
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @set_float_nans__adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone78 = load i8*, i8** %_impzPtr
%zone79 = bitcast i8* %tzone78 to %mzone*

; let assign value to symbol set_float_nans__adhoc_W3ZvaWRd
%dat_set_float_nans__adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone79, i64 8)
%set_float_nans__adhoc_W3ZvaWRdPtr = bitcast i8* %dat_set_float_nans__adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone59 = load i8*, i8** %_impzPtr
%zone60 = bitcast i8* %tzone59 to %mzone*
call void @llvm_zone_mark(%mzone* %zone60)
; malloc closure structure
%clsptr61 = call i8* @llvm_zone_malloc(%mzone* %zone60, i64 24)
%closure62 = bitcast i8* %clsptr61 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr63 = call i8* @llvm_zone_malloc(%mzone* %zone60, i64 8)
%environment64 = bitcast i8* %envptr63 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable65 = call %clsvar* @new_address_table()
%var66 = bitcast [31 x i8]* @gsxtmbase2 to i8*
%var67 = bitcast [31 x i8]* @gsxtmbase3 to i8*
%addytable68 = call %clsvar* @add_address_table(%mzone* %zone60, i8* %var66, i32 0, i8* %var67, i32 3, %clsvar* %addytable65)
%address-table69 = bitcast %clsvar* %addytable68 to i8*

; insert table, function and environment into closure struct
%closure.table72 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure62, i32 0, i32 0
store i8* %address-table69, i8** %closure.table72
%closure.env73 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure62, i32 0, i32 1
store i8* %envptr63, i8** %closure.env73
%closure.func74 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure62, i32 0, i32 2
store void (i8*, i8*)* @set_float_nans__adhoc_W3ZvaWRd__26, void (i8*, i8*)** %closure.func74
%closure_size75 = call i64 @llvm_zone_mark_size(%mzone* %zone60)
call void @llvm_zone_ptr_set_size(i8* %clsptr61, i64 %closure_size75)
%wrapper_ptr76 = call i8* @llvm_zone_malloc(%mzone* %zone60, i64 8)
%closure_wrapper77 = bitcast i8* %wrapper_ptr76 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure62, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper77

; let value assignment
%set_float_nans__adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper77, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper77
store { i8*, i8*, void (i8*, i8*)*}** %set_float_nans__adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %set_float_nans__adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var set_float_nans__adhoc_W3ZvaWRd
%tmp_envptr71 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment64, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %set_float_nans__adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr71


%val80 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %set_float_nans__adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val80
}


@set_float_nans__adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@set_float_nans__adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @set_float_nans__adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @set_float_nans__adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @set_float_nans__adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @set_float_nans__adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @set_float_nans__adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @set_float_nans__adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @set_float_nans__adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_float_nans__adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase4 = hidden constant [28 x i8] c"print_return_adhoc_W3ZvaWRd\00"
define dllexport fastcc void @print_return_adhoc_W3ZvaWRd__81(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone82 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%print_return_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%print_return_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %print_return_adhoc_W3ZvaWRdPtr_

; setup arguments


%res83 = call ccc i32 @putchar(i32 10)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @print_return_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone104 = load i8*, i8** %_impzPtr
%zone105 = bitcast i8* %tzone104 to %mzone*

; let assign value to symbol print_return_adhoc_W3ZvaWRd
%dat_print_return_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone105, i64 8)
%print_return_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_print_return_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone85 = load i8*, i8** %_impzPtr
%zone86 = bitcast i8* %tzone85 to %mzone*
call void @llvm_zone_mark(%mzone* %zone86)
; malloc closure structure
%clsptr87 = call i8* @llvm_zone_malloc(%mzone* %zone86, i64 24)
%closure88 = bitcast i8* %clsptr87 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr89 = call i8* @llvm_zone_malloc(%mzone* %zone86, i64 8)
%environment90 = bitcast i8* %envptr89 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable91 = call %clsvar* @new_address_table()
%var92 = bitcast [28 x i8]* @gsxtmbase4 to i8*
%var93 = bitcast [31 x i8]* @gsxtmbase3 to i8*
%addytable94 = call %clsvar* @add_address_table(%mzone* %zone86, i8* %var92, i32 0, i8* %var93, i32 3, %clsvar* %addytable91)
%address-table95 = bitcast %clsvar* %addytable94 to i8*

; insert table, function and environment into closure struct
%closure.table98 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure88, i32 0, i32 0
store i8* %address-table95, i8** %closure.table98
%closure.env99 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure88, i32 0, i32 1
store i8* %envptr89, i8** %closure.env99
%closure.func100 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure88, i32 0, i32 2
store void (i8*, i8*)* @print_return_adhoc_W3ZvaWRd__81, void (i8*, i8*)** %closure.func100
%closure_size101 = call i64 @llvm_zone_mark_size(%mzone* %zone86)
call void @llvm_zone_ptr_set_size(i8* %clsptr87, i64 %closure_size101)
%wrapper_ptr102 = call i8* @llvm_zone_malloc(%mzone* %zone86, i64 8)
%closure_wrapper103 = bitcast i8* %wrapper_ptr102 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure88, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper103

; let value assignment
%print_return_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper103, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper103
store { i8*, i8*, void (i8*, i8*)*}** %print_return_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %print_return_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var print_return_adhoc_W3ZvaWRd
%tmp_envptr97 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment90, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %print_return_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr97


%val106 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %print_return_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val106
}


@print_return_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@print_return_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_return_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @print_return_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_return_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_return_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @print_return_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @print_return_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_return_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_return_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase5 = hidden constant [27 x i8] c"print_space_adhoc_W3ZvaWRd\00"
define dllexport fastcc void @print_space_adhoc_W3ZvaWRd__107(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone108 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%print_space_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%print_space_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %print_space_adhoc_W3ZvaWRdPtr_

; setup arguments


%res109 = call ccc i32 @putchar(i32 32)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @print_space_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone130 = load i8*, i8** %_impzPtr
%zone131 = bitcast i8* %tzone130 to %mzone*

; let assign value to symbol print_space_adhoc_W3ZvaWRd
%dat_print_space_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone131, i64 8)
%print_space_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_print_space_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone111 = load i8*, i8** %_impzPtr
%zone112 = bitcast i8* %tzone111 to %mzone*
call void @llvm_zone_mark(%mzone* %zone112)
; malloc closure structure
%clsptr113 = call i8* @llvm_zone_malloc(%mzone* %zone112, i64 24)
%closure114 = bitcast i8* %clsptr113 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr115 = call i8* @llvm_zone_malloc(%mzone* %zone112, i64 8)
%environment116 = bitcast i8* %envptr115 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable117 = call %clsvar* @new_address_table()
%var118 = bitcast [27 x i8]* @gsxtmbase5 to i8*
%var119 = bitcast [31 x i8]* @gsxtmbase3 to i8*
%addytable120 = call %clsvar* @add_address_table(%mzone* %zone112, i8* %var118, i32 0, i8* %var119, i32 3, %clsvar* %addytable117)
%address-table121 = bitcast %clsvar* %addytable120 to i8*

; insert table, function and environment into closure struct
%closure.table124 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure114, i32 0, i32 0
store i8* %address-table121, i8** %closure.table124
%closure.env125 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure114, i32 0, i32 1
store i8* %envptr115, i8** %closure.env125
%closure.func126 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure114, i32 0, i32 2
store void (i8*, i8*)* @print_space_adhoc_W3ZvaWRd__107, void (i8*, i8*)** %closure.func126
%closure_size127 = call i64 @llvm_zone_mark_size(%mzone* %zone112)
call void @llvm_zone_ptr_set_size(i8* %clsptr113, i64 %closure_size127)
%wrapper_ptr128 = call i8* @llvm_zone_malloc(%mzone* %zone112, i64 8)
%closure_wrapper129 = bitcast i8* %wrapper_ptr128 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure114, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper129

; let value assignment
%print_space_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper129, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper129
store { i8*, i8*, void (i8*, i8*)*}** %print_space_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %print_space_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var print_space_adhoc_W3ZvaWRd
%tmp_envptr123 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment116, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %print_space_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr123


%val132 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %print_space_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val132
}


@print_space_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@print_space_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_space_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @print_space_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_space_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_space_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @print_space_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @print_space_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_space_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_space_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase6 = hidden constant [3 x i8] c"%d\00"
@gsxtmbase7 = hidden constant [25 x i8] c"print_adhoc_W3ZvaWQsaTFd\00"
@gsxtmbase8 = hidden constant [35 x i8] c"{i8*, i8*, void (i8*, i8*, i1)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsaTFd__133(i8* %_impz,i8* %_impenv, i1 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone134 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i1)*}***}*
%print_adhoc_W3ZvaWQsaTFdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i1)*}***}, {{i8*, i8*, void (i8*, i8*, i1)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsaTFdPtr = load {i8*, i8*, void (i8*, i8*, i1)*}***, {i8*, i8*, void (i8*, i8*, i1)*}**** %print_adhoc_W3ZvaWQsaTFdPtr_

; setup arguments
%xPtr = alloca i1
store i1 %x, i1* %xPtr


%var135 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val136 = load i1, i1* %xPtr

%val137 = call i32 (i8*, ...) @printf(i8* %var135, i1 %val136)
ret void
}
@gsxtmbase9 = hidden constant [78 x i8] c"print_adhoc_W3ZvaWQsaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i1)*}** @print_adhoc_W3ZvaWQsaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone158 = load i8*, i8** %_impzPtr
%zone159 = bitcast i8* %tzone158 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsaTFd
%dat_print_adhoc_W3ZvaWQsaTFd = call i8* @llvm_zone_malloc(%mzone* %zone159, i64 8)
%print_adhoc_W3ZvaWQsaTFdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsaTFd to { i8*, i8*, void (i8*, i8*, i1)*}***
%tzone139 = load i8*, i8** %_impzPtr
%zone140 = bitcast i8* %tzone139 to %mzone*
call void @llvm_zone_mark(%mzone* %zone140)
; malloc closure structure
%clsptr141 = call i8* @llvm_zone_malloc(%mzone* %zone140, i64 24)
%closure142 = bitcast i8* %clsptr141 to { i8*, i8*, void (i8*, i8*, i1)*}*

; malloc environment structure
%envptr143 = call i8* @llvm_zone_malloc(%mzone* %zone140, i64 8)
%environment144 = bitcast i8* %envptr143 to {{i8*, i8*, void (i8*, i8*, i1)*}***}*

; malloc closure address table
%addytable145 = call %clsvar* @new_address_table()
%var146 = bitcast [25 x i8]* @gsxtmbase7 to i8*
%var147 = bitcast [35 x i8]* @gsxtmbase8 to i8*
%addytable148 = call %clsvar* @add_address_table(%mzone* %zone140, i8* %var146, i32 0, i8* %var147, i32 3, %clsvar* %addytable145)
%address-table149 = bitcast %clsvar* %addytable148 to i8*

; insert table, function and environment into closure struct
%closure.table152 = getelementptr { i8*, i8*, void (i8*, i8*, i1)*}, { i8*, i8*, void (i8*, i8*, i1)*}* %closure142, i32 0, i32 0
store i8* %address-table149, i8** %closure.table152
%closure.env153 = getelementptr { i8*, i8*, void (i8*, i8*, i1)*}, { i8*, i8*, void (i8*, i8*, i1)*}* %closure142, i32 0, i32 1
store i8* %envptr143, i8** %closure.env153
%closure.func154 = getelementptr { i8*, i8*, void (i8*, i8*, i1)*}, { i8*, i8*, void (i8*, i8*, i1)*}* %closure142, i32 0, i32 2
store void (i8*, i8*, i1)* @print_adhoc_W3ZvaWQsaTFd__133, void (i8*, i8*, i1)** %closure.func154
%closure_size155 = call i64 @llvm_zone_mark_size(%mzone* %zone140)
call void @llvm_zone_ptr_set_size(i8* %clsptr141, i64 %closure_size155)
%wrapper_ptr156 = call i8* @llvm_zone_malloc(%mzone* %zone140, i64 8)
%closure_wrapper157 = bitcast i8* %wrapper_ptr156 to { i8*, i8*, void (i8*, i8*, i1)*}**
store { i8*, i8*, void (i8*, i8*, i1)*}* %closure142, { i8*, i8*, void (i8*, i8*, i1)*}** %closure_wrapper157

; let value assignment
%print_adhoc_W3ZvaWQsaTFd = select i1 true, { i8*, i8*, void (i8*, i8*, i1)*}** %closure_wrapper157, { i8*, i8*, void (i8*, i8*, i1)*}** %closure_wrapper157
store { i8*, i8*, void (i8*, i8*, i1)*}** %print_adhoc_W3ZvaWQsaTFd, { i8*, i8*, void (i8*, i8*, i1)*}*** %print_adhoc_W3ZvaWQsaTFdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsaTFd
%tmp_envptr151 = getelementptr {{i8*, i8*, void (i8*, i8*, i1)*}***}, {{i8*, i8*, void (i8*, i8*, i1)*}***}* %environment144, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i1)*}*** %print_adhoc_W3ZvaWQsaTFdPtr, {i8*, i8*, void (i8*, i8*, i1)*}**** %tmp_envptr151


%val160 = load {i8*, i8*, void (i8*, i8*, i1)*}**, {i8*, i8*, void (i8*, i8*, i1)*}*** %print_adhoc_W3ZvaWQsaTFdPtr
ret {i8*, i8*, void (i8*, i8*, i1)*}** %val160
}


@print_adhoc_W3ZvaWQsaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i1)*}** @print_adhoc_W3ZvaWQsaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsaTFd(i1 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1)*}*, {i8*, i8*, void (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1)*,  void (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTFd_native(i1 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1)*}*, {i8*, i8*, void (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1)*,  void (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var161 = bitcast [78 x i8]* @gsxtmbase9 to i8*
call i32 (i8*, ...) @printf(i8* %var161)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i1  @i1value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1)*}*, {i8*, i8*, void (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1)*,  void (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1}*
%arg_p_0 = getelementptr {i1}, {i1}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i1)*}*, {i8*, i8*, void (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i1)*}, {i8*, i8*, void (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i1)*,  void (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i1 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase10 = hidden constant [25 x i8] c"print_adhoc_W3ZvaWQsaThd\00"
@gsxtmbase11 = hidden constant [35 x i8] c"{i8*, i8*, void (i8*, i8*, i8)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsaThd__162(i8* %_impz,i8* %_impenv, i8 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone163 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8)*}***}*
%print_adhoc_W3ZvaWQsaThdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8)*}***}, {{i8*, i8*, void (i8*, i8*, i8)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsaThdPtr = load {i8*, i8*, void (i8*, i8*, i8)*}***, {i8*, i8*, void (i8*, i8*, i8)*}**** %print_adhoc_W3ZvaWQsaThdPtr_

; setup arguments
%xPtr = alloca i8
store i8 %x, i8* %xPtr


%var164 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val165 = load i8, i8* %xPtr
%val166 = sext i8 %val165 to i32

%val167 = call i32 (i8*, ...) @printf(i8* %var164, i32 %val166)
ret void
}
@gsxtmbase12 = hidden constant [78 x i8] c"print_adhoc_W3ZvaWQsaThd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8)*}** @print_adhoc_W3ZvaWQsaThd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone188 = load i8*, i8** %_impzPtr
%zone189 = bitcast i8* %tzone188 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsaThd
%dat_print_adhoc_W3ZvaWQsaThd = call i8* @llvm_zone_malloc(%mzone* %zone189, i64 8)
%print_adhoc_W3ZvaWQsaThdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsaThd to { i8*, i8*, void (i8*, i8*, i8)*}***
%tzone169 = load i8*, i8** %_impzPtr
%zone170 = bitcast i8* %tzone169 to %mzone*
call void @llvm_zone_mark(%mzone* %zone170)
; malloc closure structure
%clsptr171 = call i8* @llvm_zone_malloc(%mzone* %zone170, i64 24)
%closure172 = bitcast i8* %clsptr171 to { i8*, i8*, void (i8*, i8*, i8)*}*

; malloc environment structure
%envptr173 = call i8* @llvm_zone_malloc(%mzone* %zone170, i64 8)
%environment174 = bitcast i8* %envptr173 to {{i8*, i8*, void (i8*, i8*, i8)*}***}*

; malloc closure address table
%addytable175 = call %clsvar* @new_address_table()
%var176 = bitcast [25 x i8]* @gsxtmbase10 to i8*
%var177 = bitcast [35 x i8]* @gsxtmbase11 to i8*
%addytable178 = call %clsvar* @add_address_table(%mzone* %zone170, i8* %var176, i32 0, i8* %var177, i32 3, %clsvar* %addytable175)
%address-table179 = bitcast %clsvar* %addytable178 to i8*

; insert table, function and environment into closure struct
%closure.table182 = getelementptr { i8*, i8*, void (i8*, i8*, i8)*}, { i8*, i8*, void (i8*, i8*, i8)*}* %closure172, i32 0, i32 0
store i8* %address-table179, i8** %closure.table182
%closure.env183 = getelementptr { i8*, i8*, void (i8*, i8*, i8)*}, { i8*, i8*, void (i8*, i8*, i8)*}* %closure172, i32 0, i32 1
store i8* %envptr173, i8** %closure.env183
%closure.func184 = getelementptr { i8*, i8*, void (i8*, i8*, i8)*}, { i8*, i8*, void (i8*, i8*, i8)*}* %closure172, i32 0, i32 2
store void (i8*, i8*, i8)* @print_adhoc_W3ZvaWQsaThd__162, void (i8*, i8*, i8)** %closure.func184
%closure_size185 = call i64 @llvm_zone_mark_size(%mzone* %zone170)
call void @llvm_zone_ptr_set_size(i8* %clsptr171, i64 %closure_size185)
%wrapper_ptr186 = call i8* @llvm_zone_malloc(%mzone* %zone170, i64 8)
%closure_wrapper187 = bitcast i8* %wrapper_ptr186 to { i8*, i8*, void (i8*, i8*, i8)*}**
store { i8*, i8*, void (i8*, i8*, i8)*}* %closure172, { i8*, i8*, void (i8*, i8*, i8)*}** %closure_wrapper187

; let value assignment
%print_adhoc_W3ZvaWQsaThd = select i1 true, { i8*, i8*, void (i8*, i8*, i8)*}** %closure_wrapper187, { i8*, i8*, void (i8*, i8*, i8)*}** %closure_wrapper187
store { i8*, i8*, void (i8*, i8*, i8)*}** %print_adhoc_W3ZvaWQsaThd, { i8*, i8*, void (i8*, i8*, i8)*}*** %print_adhoc_W3ZvaWQsaThdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsaThd
%tmp_envptr181 = getelementptr {{i8*, i8*, void (i8*, i8*, i8)*}***}, {{i8*, i8*, void (i8*, i8*, i8)*}***}* %environment174, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8)*}*** %print_adhoc_W3ZvaWQsaThdPtr, {i8*, i8*, void (i8*, i8*, i8)*}**** %tmp_envptr181


%val190 = load {i8*, i8*, void (i8*, i8*, i8)*}**, {i8*, i8*, void (i8*, i8*, i8)*}*** %print_adhoc_W3ZvaWQsaThdPtr
ret {i8*, i8*, void (i8*, i8*, i8)*}** %val190
}


@print_adhoc_W3ZvaWQsaThd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsaThd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsaThd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8)*}** @print_adhoc_W3ZvaWQsaThd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsaThd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsaThd(i8 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8)*}*, {i8*, i8*, void (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8)*,  void (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8 %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaThd_native(i8 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8)*}*, {i8*, i8*, void (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8)*,  void (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8 %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsaThd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var191 = bitcast [78 x i8]* @gsxtmbase12 to i8*
call i32 (i8*, ...) @printf(i8* %var191)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8  @i8value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8)*}*, {i8*, i8*, void (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8)*,  void (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8 %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaThd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8}*
%arg_p_0 = getelementptr {i8}, {i8}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8)*}*, {i8*, i8*, void (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8)*}, {i8*, i8*, void (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8)*,  void (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase13 = hidden constant [27 x i8] c"print_adhoc_W3ZvaWQsaTE2XQ\00"
@gsxtmbase14 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i16)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsaTE2XQ__192(i8* %_impz,i8* %_impenv, i16 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone193 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i16)*}***}*
%print_adhoc_W3ZvaWQsaTE2XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16)*}***}, {{i8*, i8*, void (i8*, i8*, i16)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsaTE2XQPtr = load {i8*, i8*, void (i8*, i8*, i16)*}***, {i8*, i8*, void (i8*, i8*, i16)*}**** %print_adhoc_W3ZvaWQsaTE2XQPtr_

; setup arguments
%xPtr = alloca i16
store i16 %x, i16* %xPtr


%var194 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val195 = load i16, i16* %xPtr
%val196 = sext i16 %val195 to i32

%val197 = call i32 (i8*, ...) @printf(i8* %var194, i32 %val196)
ret void
}
@gsxtmbase15 = hidden constant [80 x i8] c"print_adhoc_W3ZvaWQsaTE2XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i16)*}** @print_adhoc_W3ZvaWQsaTE2XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone218 = load i8*, i8** %_impzPtr
%zone219 = bitcast i8* %tzone218 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsaTE2XQ
%dat_print_adhoc_W3ZvaWQsaTE2XQ = call i8* @llvm_zone_malloc(%mzone* %zone219, i64 8)
%print_adhoc_W3ZvaWQsaTE2XQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsaTE2XQ to { i8*, i8*, void (i8*, i8*, i16)*}***
%tzone199 = load i8*, i8** %_impzPtr
%zone200 = bitcast i8* %tzone199 to %mzone*
call void @llvm_zone_mark(%mzone* %zone200)
; malloc closure structure
%clsptr201 = call i8* @llvm_zone_malloc(%mzone* %zone200, i64 24)
%closure202 = bitcast i8* %clsptr201 to { i8*, i8*, void (i8*, i8*, i16)*}*

; malloc environment structure
%envptr203 = call i8* @llvm_zone_malloc(%mzone* %zone200, i64 8)
%environment204 = bitcast i8* %envptr203 to {{i8*, i8*, void (i8*, i8*, i16)*}***}*

; malloc closure address table
%addytable205 = call %clsvar* @new_address_table()
%var206 = bitcast [27 x i8]* @gsxtmbase13 to i8*
%var207 = bitcast [36 x i8]* @gsxtmbase14 to i8*
%addytable208 = call %clsvar* @add_address_table(%mzone* %zone200, i8* %var206, i32 0, i8* %var207, i32 3, %clsvar* %addytable205)
%address-table209 = bitcast %clsvar* %addytable208 to i8*

; insert table, function and environment into closure struct
%closure.table212 = getelementptr { i8*, i8*, void (i8*, i8*, i16)*}, { i8*, i8*, void (i8*, i8*, i16)*}* %closure202, i32 0, i32 0
store i8* %address-table209, i8** %closure.table212
%closure.env213 = getelementptr { i8*, i8*, void (i8*, i8*, i16)*}, { i8*, i8*, void (i8*, i8*, i16)*}* %closure202, i32 0, i32 1
store i8* %envptr203, i8** %closure.env213
%closure.func214 = getelementptr { i8*, i8*, void (i8*, i8*, i16)*}, { i8*, i8*, void (i8*, i8*, i16)*}* %closure202, i32 0, i32 2
store void (i8*, i8*, i16)* @print_adhoc_W3ZvaWQsaTE2XQ__192, void (i8*, i8*, i16)** %closure.func214
%closure_size215 = call i64 @llvm_zone_mark_size(%mzone* %zone200)
call void @llvm_zone_ptr_set_size(i8* %clsptr201, i64 %closure_size215)
%wrapper_ptr216 = call i8* @llvm_zone_malloc(%mzone* %zone200, i64 8)
%closure_wrapper217 = bitcast i8* %wrapper_ptr216 to { i8*, i8*, void (i8*, i8*, i16)*}**
store { i8*, i8*, void (i8*, i8*, i16)*}* %closure202, { i8*, i8*, void (i8*, i8*, i16)*}** %closure_wrapper217

; let value assignment
%print_adhoc_W3ZvaWQsaTE2XQ = select i1 true, { i8*, i8*, void (i8*, i8*, i16)*}** %closure_wrapper217, { i8*, i8*, void (i8*, i8*, i16)*}** %closure_wrapper217
store { i8*, i8*, void (i8*, i8*, i16)*}** %print_adhoc_W3ZvaWQsaTE2XQ, { i8*, i8*, void (i8*, i8*, i16)*}*** %print_adhoc_W3ZvaWQsaTE2XQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsaTE2XQ
%tmp_envptr211 = getelementptr {{i8*, i8*, void (i8*, i8*, i16)*}***}, {{i8*, i8*, void (i8*, i8*, i16)*}***}* %environment204, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i16)*}*** %print_adhoc_W3ZvaWQsaTE2XQPtr, {i8*, i8*, void (i8*, i8*, i16)*}**** %tmp_envptr211


%val220 = load {i8*, i8*, void (i8*, i8*, i16)*}**, {i8*, i8*, void (i8*, i8*, i16)*}*** %print_adhoc_W3ZvaWQsaTE2XQPtr
ret {i8*, i8*, void (i8*, i8*, i16)*}** %val220
}


@print_adhoc_W3ZvaWQsaTE2XQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsaTE2XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsaTE2XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i16)*}** @print_adhoc_W3ZvaWQsaTE2XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i16)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsaTE2XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsaTE2XQ(i16 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16)*}*, {i8*, i8*, void (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16)*,  void (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16 %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTE2XQ_native(i16 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16)*}*, {i8*, i8*, void (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16)*,  void (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16 %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsaTE2XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var221 = bitcast [80 x i8]* @gsxtmbase15 to i8*
call i32 (i8*, ...) @printf(i8* %var221)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i16  @i16value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16)*}*, {i8*, i8*, void (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16)*,  void (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16 %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTE2XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16}*
%arg_p_0 = getelementptr {i16}, {i16}* %fstruct, i32 0, i32 0
%arg_0 = load i16, i16* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16)*}*, {i8*, i8*, void (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16)*}, {i8*, i8*, void (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16)*,  void (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase16 = hidden constant [27 x i8] c"print_adhoc_W3ZvaWQsaTMyXQ\00"
@gsxtmbase17 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i32)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsaTMyXQ__222(i8* %_impz,i8* %_impenv, i32 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone223 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32)*}***}*
%print_adhoc_W3ZvaWQsaTMyXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsaTMyXQPtr = load {i8*, i8*, void (i8*, i8*, i32)*}***, {i8*, i8*, void (i8*, i8*, i32)*}**** %print_adhoc_W3ZvaWQsaTMyXQPtr_

; setup arguments
%xPtr = alloca i32
store i32 %x, i32* %xPtr


%var224 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val225 = load i32, i32* %xPtr

%val226 = call i32 (i8*, ...) @printf(i8* %var224, i32 %val225)
ret void
}
@gsxtmbase18 = hidden constant [80 x i8] c"print_adhoc_W3ZvaWQsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32)*}** @print_adhoc_W3ZvaWQsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone247 = load i8*, i8** %_impzPtr
%zone248 = bitcast i8* %tzone247 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsaTMyXQ
%dat_print_adhoc_W3ZvaWQsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone248, i64 8)
%print_adhoc_W3ZvaWQsaTMyXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsaTMyXQ to { i8*, i8*, void (i8*, i8*, i32)*}***
%tzone228 = load i8*, i8** %_impzPtr
%zone229 = bitcast i8* %tzone228 to %mzone*
call void @llvm_zone_mark(%mzone* %zone229)
; malloc closure structure
%clsptr230 = call i8* @llvm_zone_malloc(%mzone* %zone229, i64 24)
%closure231 = bitcast i8* %clsptr230 to { i8*, i8*, void (i8*, i8*, i32)*}*

; malloc environment structure
%envptr232 = call i8* @llvm_zone_malloc(%mzone* %zone229, i64 8)
%environment233 = bitcast i8* %envptr232 to {{i8*, i8*, void (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable234 = call %clsvar* @new_address_table()
%var235 = bitcast [27 x i8]* @gsxtmbase16 to i8*
%var236 = bitcast [36 x i8]* @gsxtmbase17 to i8*
%addytable237 = call %clsvar* @add_address_table(%mzone* %zone229, i8* %var235, i32 0, i8* %var236, i32 3, %clsvar* %addytable234)
%address-table238 = bitcast %clsvar* %addytable237 to i8*

; insert table, function and environment into closure struct
%closure.table241 = getelementptr { i8*, i8*, void (i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i32)*}* %closure231, i32 0, i32 0
store i8* %address-table238, i8** %closure.table241
%closure.env242 = getelementptr { i8*, i8*, void (i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i32)*}* %closure231, i32 0, i32 1
store i8* %envptr232, i8** %closure.env242
%closure.func243 = getelementptr { i8*, i8*, void (i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i32)*}* %closure231, i32 0, i32 2
store void (i8*, i8*, i32)* @print_adhoc_W3ZvaWQsaTMyXQ__222, void (i8*, i8*, i32)** %closure.func243
%closure_size244 = call i64 @llvm_zone_mark_size(%mzone* %zone229)
call void @llvm_zone_ptr_set_size(i8* %clsptr230, i64 %closure_size244)
%wrapper_ptr245 = call i8* @llvm_zone_malloc(%mzone* %zone229, i64 8)
%closure_wrapper246 = bitcast i8* %wrapper_ptr245 to { i8*, i8*, void (i8*, i8*, i32)*}**
store { i8*, i8*, void (i8*, i8*, i32)*}* %closure231, { i8*, i8*, void (i8*, i8*, i32)*}** %closure_wrapper246

; let value assignment
%print_adhoc_W3ZvaWQsaTMyXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i32)*}** %closure_wrapper246, { i8*, i8*, void (i8*, i8*, i32)*}** %closure_wrapper246
store { i8*, i8*, void (i8*, i8*, i32)*}** %print_adhoc_W3ZvaWQsaTMyXQ, { i8*, i8*, void (i8*, i8*, i32)*}*** %print_adhoc_W3ZvaWQsaTMyXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsaTMyXQ
%tmp_envptr240 = getelementptr {{i8*, i8*, void (i8*, i8*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i32)*}***}* %environment233, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32)*}*** %print_adhoc_W3ZvaWQsaTMyXQPtr, {i8*, i8*, void (i8*, i8*, i32)*}**** %tmp_envptr240


%val249 = load {i8*, i8*, void (i8*, i8*, i32)*}**, {i8*, i8*, void (i8*, i8*, i32)*}*** %print_adhoc_W3ZvaWQsaTMyXQPtr
ret {i8*, i8*, void (i8*, i8*, i32)*}** %val249
}


@print_adhoc_W3ZvaWQsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32)*}** @print_adhoc_W3ZvaWQsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTMyXQ_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var250 = bitcast [80 x i8]* @gsxtmbase18 to i8*
call i32 (i8*, ...) @printf(i8* %var250)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase19 = hidden constant [5 x i8] c"%lld\00"
@gsxtmbase20 = hidden constant [27 x i8] c"print_adhoc_W3ZvaWQsaTY0XQ\00"
@gsxtmbase21 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i64)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsaTY0XQ__251(i8* %_impz,i8* %_impenv, i64 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone252 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i64)*}***}*
%print_adhoc_W3ZvaWQsaTY0XQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i64)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsaTY0XQPtr = load {i8*, i8*, void (i8*, i8*, i64)*}***, {i8*, i8*, void (i8*, i8*, i64)*}**** %print_adhoc_W3ZvaWQsaTY0XQPtr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr


%var253 = bitcast [5 x i8]* @gsxtmbase19 to i8*
%val254 = load i64, i64* %xPtr

%val255 = call i32 (i8*, ...) @printf(i8* %var253, i64 %val254)
ret void
}
@gsxtmbase22 = hidden constant [80 x i8] c"print_adhoc_W3ZvaWQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i64)*}** @print_adhoc_W3ZvaWQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone276 = load i8*, i8** %_impzPtr
%zone277 = bitcast i8* %tzone276 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsaTY0XQ
%dat_print_adhoc_W3ZvaWQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone277, i64 8)
%print_adhoc_W3ZvaWQsaTY0XQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsaTY0XQ to { i8*, i8*, void (i8*, i8*, i64)*}***
%tzone257 = load i8*, i8** %_impzPtr
%zone258 = bitcast i8* %tzone257 to %mzone*
call void @llvm_zone_mark(%mzone* %zone258)
; malloc closure structure
%clsptr259 = call i8* @llvm_zone_malloc(%mzone* %zone258, i64 24)
%closure260 = bitcast i8* %clsptr259 to { i8*, i8*, void (i8*, i8*, i64)*}*

; malloc environment structure
%envptr261 = call i8* @llvm_zone_malloc(%mzone* %zone258, i64 8)
%environment262 = bitcast i8* %envptr261 to {{i8*, i8*, void (i8*, i8*, i64)*}***}*

; malloc closure address table
%addytable263 = call %clsvar* @new_address_table()
%var264 = bitcast [27 x i8]* @gsxtmbase20 to i8*
%var265 = bitcast [36 x i8]* @gsxtmbase21 to i8*
%addytable266 = call %clsvar* @add_address_table(%mzone* %zone258, i8* %var264, i32 0, i8* %var265, i32 3, %clsvar* %addytable263)
%address-table267 = bitcast %clsvar* %addytable266 to i8*

; insert table, function and environment into closure struct
%closure.table270 = getelementptr { i8*, i8*, void (i8*, i8*, i64)*}, { i8*, i8*, void (i8*, i8*, i64)*}* %closure260, i32 0, i32 0
store i8* %address-table267, i8** %closure.table270
%closure.env271 = getelementptr { i8*, i8*, void (i8*, i8*, i64)*}, { i8*, i8*, void (i8*, i8*, i64)*}* %closure260, i32 0, i32 1
store i8* %envptr261, i8** %closure.env271
%closure.func272 = getelementptr { i8*, i8*, void (i8*, i8*, i64)*}, { i8*, i8*, void (i8*, i8*, i64)*}* %closure260, i32 0, i32 2
store void (i8*, i8*, i64)* @print_adhoc_W3ZvaWQsaTY0XQ__251, void (i8*, i8*, i64)** %closure.func272
%closure_size273 = call i64 @llvm_zone_mark_size(%mzone* %zone258)
call void @llvm_zone_ptr_set_size(i8* %clsptr259, i64 %closure_size273)
%wrapper_ptr274 = call i8* @llvm_zone_malloc(%mzone* %zone258, i64 8)
%closure_wrapper275 = bitcast i8* %wrapper_ptr274 to { i8*, i8*, void (i8*, i8*, i64)*}**
store { i8*, i8*, void (i8*, i8*, i64)*}* %closure260, { i8*, i8*, void (i8*, i8*, i64)*}** %closure_wrapper275

; let value assignment
%print_adhoc_W3ZvaWQsaTY0XQ = select i1 true, { i8*, i8*, void (i8*, i8*, i64)*}** %closure_wrapper275, { i8*, i8*, void (i8*, i8*, i64)*}** %closure_wrapper275
store { i8*, i8*, void (i8*, i8*, i64)*}** %print_adhoc_W3ZvaWQsaTY0XQ, { i8*, i8*, void (i8*, i8*, i64)*}*** %print_adhoc_W3ZvaWQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsaTY0XQ
%tmp_envptr269 = getelementptr {{i8*, i8*, void (i8*, i8*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i64)*}***}* %environment262, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i64)*}*** %print_adhoc_W3ZvaWQsaTY0XQPtr, {i8*, i8*, void (i8*, i8*, i64)*}**** %tmp_envptr269


%val278 = load {i8*, i8*, void (i8*, i8*, i64)*}**, {i8*, i8*, void (i8*, i8*, i64)*}*** %print_adhoc_W3ZvaWQsaTY0XQPtr
ret {i8*, i8*, void (i8*, i8*, i64)*}** %val278
}


@print_adhoc_W3ZvaWQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i64)*}** @print_adhoc_W3ZvaWQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsaTY0XQ(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64)*}*, {i8*, i8*, void (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64)*,  void (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTY0XQ_native(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64)*}*, {i8*, i8*, void (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64)*,  void (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var279 = bitcast [80 x i8]* @gsxtmbase22 to i8*
call i32 (i8*, ...) @printf(i8* %var279)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64)*}*, {i8*, i8*, void (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64)*,  void (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64}*
%arg_p_0 = getelementptr {i64}, {i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i64)*}*, {i8*, i8*, void (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i64)*,  void (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase23 = hidden constant [3 x i8] c"%f\00"
@gsxtmbase24 = hidden constant [29 x i8] c"print_adhoc_W3ZvaWQsZmxvYXRd\00"
@gsxtmbase25 = hidden constant [38 x i8] c"{i8*, i8*, void (i8*, i8*, float)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd__280(i8* %_impz,i8* %_impenv, float %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone281 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, float)*}***}*
%print_adhoc_W3ZvaWQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, float)*}***}, {{i8*, i8*, void (i8*, i8*, float)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsZmxvYXRdPtr = load {i8*, i8*, void (i8*, i8*, float)*}***, {i8*, i8*, void (i8*, i8*, float)*}**** %print_adhoc_W3ZvaWQsZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr


%var282 = bitcast [3 x i8]* @gsxtmbase23 to i8*
%val283 = load float, float* %xPtr
%res284 = call ccc double @ftod(float %val283)

%val285 = call i32 (i8*, ...) @printf(i8* %var282, double %res284)
ret void
}
@gsxtmbase26 = hidden constant [82 x i8] c"print_adhoc_W3ZvaWQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, float)*}** @print_adhoc_W3ZvaWQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone306 = load i8*, i8** %_impzPtr
%zone307 = bitcast i8* %tzone306 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsZmxvYXRd
%dat_print_adhoc_W3ZvaWQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone307, i64 8)
%print_adhoc_W3ZvaWQsZmxvYXRdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsZmxvYXRd to { i8*, i8*, void (i8*, i8*, float)*}***
%tzone287 = load i8*, i8** %_impzPtr
%zone288 = bitcast i8* %tzone287 to %mzone*
call void @llvm_zone_mark(%mzone* %zone288)
; malloc closure structure
%clsptr289 = call i8* @llvm_zone_malloc(%mzone* %zone288, i64 24)
%closure290 = bitcast i8* %clsptr289 to { i8*, i8*, void (i8*, i8*, float)*}*

; malloc environment structure
%envptr291 = call i8* @llvm_zone_malloc(%mzone* %zone288, i64 8)
%environment292 = bitcast i8* %envptr291 to {{i8*, i8*, void (i8*, i8*, float)*}***}*

; malloc closure address table
%addytable293 = call %clsvar* @new_address_table()
%var294 = bitcast [29 x i8]* @gsxtmbase24 to i8*
%var295 = bitcast [38 x i8]* @gsxtmbase25 to i8*
%addytable296 = call %clsvar* @add_address_table(%mzone* %zone288, i8* %var294, i32 0, i8* %var295, i32 3, %clsvar* %addytable293)
%address-table297 = bitcast %clsvar* %addytable296 to i8*

; insert table, function and environment into closure struct
%closure.table300 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure290, i32 0, i32 0
store i8* %address-table297, i8** %closure.table300
%closure.env301 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure290, i32 0, i32 1
store i8* %envptr291, i8** %closure.env301
%closure.func302 = getelementptr { i8*, i8*, void (i8*, i8*, float)*}, { i8*, i8*, void (i8*, i8*, float)*}* %closure290, i32 0, i32 2
store void (i8*, i8*, float)* @print_adhoc_W3ZvaWQsZmxvYXRd__280, void (i8*, i8*, float)** %closure.func302
%closure_size303 = call i64 @llvm_zone_mark_size(%mzone* %zone288)
call void @llvm_zone_ptr_set_size(i8* %clsptr289, i64 %closure_size303)
%wrapper_ptr304 = call i8* @llvm_zone_malloc(%mzone* %zone288, i64 8)
%closure_wrapper305 = bitcast i8* %wrapper_ptr304 to { i8*, i8*, void (i8*, i8*, float)*}**
store { i8*, i8*, void (i8*, i8*, float)*}* %closure290, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper305

; let value assignment
%print_adhoc_W3ZvaWQsZmxvYXRd = select i1 true, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper305, { i8*, i8*, void (i8*, i8*, float)*}** %closure_wrapper305
store { i8*, i8*, void (i8*, i8*, float)*}** %print_adhoc_W3ZvaWQsZmxvYXRd, { i8*, i8*, void (i8*, i8*, float)*}*** %print_adhoc_W3ZvaWQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsZmxvYXRd
%tmp_envptr299 = getelementptr {{i8*, i8*, void (i8*, i8*, float)*}***}, {{i8*, i8*, void (i8*, i8*, float)*}***}* %environment292, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, float)*}*** %print_adhoc_W3ZvaWQsZmxvYXRdPtr, {i8*, i8*, void (i8*, i8*, float)*}**** %tmp_envptr299


%val308 = load {i8*, i8*, void (i8*, i8*, float)*}**, {i8*, i8*, void (i8*, i8*, float)*}*** %print_adhoc_W3ZvaWQsZmxvYXRdPtr
ret {i8*, i8*, void (i8*, i8*, float)*}** %val308
}


@print_adhoc_W3ZvaWQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, float)*}** @print_adhoc_W3ZvaWQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsZmxvYXRd_native(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var309 = bitcast [82 x i8]* @gsxtmbase26 to i8*
call i32 (i8*, ...) @printf(i8* %var309)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float}*
%arg_p_0 = getelementptr {float}, {float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, float)*}**
%closure = load {i8*, i8*, void (i8*, i8*, float)*}*, {i8*, i8*, void (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, float)*}, {i8*, i8*, void (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, float)*,  void (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, float %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase27 = hidden constant [31 x i8] c"print_adhoc_W3ZvaWQsZG91YmxlXQ\00"
@gsxtmbase28 = hidden constant [39 x i8] c"{i8*, i8*, void (i8*, i8*, double)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsZG91YmxlXQ__310(i8* %_impz,i8* %_impenv, double %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone311 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, double)*}***}*
%print_adhoc_W3ZvaWQsZG91YmxlXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, double)*}***}, {{i8*, i8*, void (i8*, i8*, double)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsZG91YmxlXQPtr = load {i8*, i8*, void (i8*, i8*, double)*}***, {i8*, i8*, void (i8*, i8*, double)*}**** %print_adhoc_W3ZvaWQsZG91YmxlXQPtr_

; setup arguments
%xPtr = alloca double
store double %x, double* %xPtr


%var312 = bitcast [3 x i8]* @gsxtmbase23 to i8*
%val313 = load double, double* %xPtr

%val314 = call i32 (i8*, ...) @printf(i8* %var312, double %val313)
ret void
}
@gsxtmbase29 = hidden constant [84 x i8] c"print_adhoc_W3ZvaWQsZG91YmxlXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, double)*}** @print_adhoc_W3ZvaWQsZG91YmxlXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone335 = load i8*, i8** %_impzPtr
%zone336 = bitcast i8* %tzone335 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsZG91YmxlXQ
%dat_print_adhoc_W3ZvaWQsZG91YmxlXQ = call i8* @llvm_zone_malloc(%mzone* %zone336, i64 8)
%print_adhoc_W3ZvaWQsZG91YmxlXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsZG91YmxlXQ to { i8*, i8*, void (i8*, i8*, double)*}***
%tzone316 = load i8*, i8** %_impzPtr
%zone317 = bitcast i8* %tzone316 to %mzone*
call void @llvm_zone_mark(%mzone* %zone317)
; malloc closure structure
%clsptr318 = call i8* @llvm_zone_malloc(%mzone* %zone317, i64 24)
%closure319 = bitcast i8* %clsptr318 to { i8*, i8*, void (i8*, i8*, double)*}*

; malloc environment structure
%envptr320 = call i8* @llvm_zone_malloc(%mzone* %zone317, i64 8)
%environment321 = bitcast i8* %envptr320 to {{i8*, i8*, void (i8*, i8*, double)*}***}*

; malloc closure address table
%addytable322 = call %clsvar* @new_address_table()
%var323 = bitcast [31 x i8]* @gsxtmbase27 to i8*
%var324 = bitcast [39 x i8]* @gsxtmbase28 to i8*
%addytable325 = call %clsvar* @add_address_table(%mzone* %zone317, i8* %var323, i32 0, i8* %var324, i32 3, %clsvar* %addytable322)
%address-table326 = bitcast %clsvar* %addytable325 to i8*

; insert table, function and environment into closure struct
%closure.table329 = getelementptr { i8*, i8*, void (i8*, i8*, double)*}, { i8*, i8*, void (i8*, i8*, double)*}* %closure319, i32 0, i32 0
store i8* %address-table326, i8** %closure.table329
%closure.env330 = getelementptr { i8*, i8*, void (i8*, i8*, double)*}, { i8*, i8*, void (i8*, i8*, double)*}* %closure319, i32 0, i32 1
store i8* %envptr320, i8** %closure.env330
%closure.func331 = getelementptr { i8*, i8*, void (i8*, i8*, double)*}, { i8*, i8*, void (i8*, i8*, double)*}* %closure319, i32 0, i32 2
store void (i8*, i8*, double)* @print_adhoc_W3ZvaWQsZG91YmxlXQ__310, void (i8*, i8*, double)** %closure.func331
%closure_size332 = call i64 @llvm_zone_mark_size(%mzone* %zone317)
call void @llvm_zone_ptr_set_size(i8* %clsptr318, i64 %closure_size332)
%wrapper_ptr333 = call i8* @llvm_zone_malloc(%mzone* %zone317, i64 8)
%closure_wrapper334 = bitcast i8* %wrapper_ptr333 to { i8*, i8*, void (i8*, i8*, double)*}**
store { i8*, i8*, void (i8*, i8*, double)*}* %closure319, { i8*, i8*, void (i8*, i8*, double)*}** %closure_wrapper334

; let value assignment
%print_adhoc_W3ZvaWQsZG91YmxlXQ = select i1 true, { i8*, i8*, void (i8*, i8*, double)*}** %closure_wrapper334, { i8*, i8*, void (i8*, i8*, double)*}** %closure_wrapper334
store { i8*, i8*, void (i8*, i8*, double)*}** %print_adhoc_W3ZvaWQsZG91YmxlXQ, { i8*, i8*, void (i8*, i8*, double)*}*** %print_adhoc_W3ZvaWQsZG91YmxlXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsZG91YmxlXQ
%tmp_envptr328 = getelementptr {{i8*, i8*, void (i8*, i8*, double)*}***}, {{i8*, i8*, void (i8*, i8*, double)*}***}* %environment321, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, double)*}*** %print_adhoc_W3ZvaWQsZG91YmxlXQPtr, {i8*, i8*, void (i8*, i8*, double)*}**** %tmp_envptr328


%val337 = load {i8*, i8*, void (i8*, i8*, double)*}**, {i8*, i8*, void (i8*, i8*, double)*}*** %print_adhoc_W3ZvaWQsZG91YmxlXQPtr
ret {i8*, i8*, void (i8*, i8*, double)*}** %val337
}


@print_adhoc_W3ZvaWQsZG91YmxlXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsZG91YmxlXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsZG91YmxlXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, double)*}** @print_adhoc_W3ZvaWQsZG91YmxlXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsZG91YmxlXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsZG91YmxlXQ(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double)*}*, {i8*, i8*, void (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double)*,  void (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsZG91YmxlXQ_native(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double)*}*, {i8*, i8*, void (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double)*,  void (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsZG91YmxlXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var338 = bitcast [84 x i8]* @gsxtmbase29 to i8*
call i32 (i8*, ...) @printf(i8* %var338)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double)*}*, {i8*, i8*, void (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double)*,  void (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsZG91YmxlXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double}*
%arg_p_0 = getelementptr {double}, {double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, double)*}**
%closure = load {i8*, i8*, void (i8*, i8*, double)*}*, {i8*, i8*, void (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, double)*}, {i8*, i8*, void (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, double)*,  void (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, double %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase30 = hidden constant [31 x i8] c"print_adhoc_W3ZvaWQsbXpvbmUqXQ\00"
@gsxtmbase31 = hidden constant [40 x i8] c"{i8*, i8*, void (i8*, i8*, %mzone*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsbXpvbmUqXQ__339(i8* %_impz,i8* %_impenv, %mzone* %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone340 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}*
%print_adhoc_W3ZvaWQsbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}, {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsbXpvbmUqXQPtr = load {i8*, i8*, void (i8*, i8*, %mzone*)*}***, {i8*, i8*, void (i8*, i8*, %mzone*)*}**** %print_adhoc_W3ZvaWQsbXpvbmUqXQPtr_

; setup arguments
%zPtr = alloca %mzone*
store %mzone* %z, %mzone** %zPtr


%val341 = load %mzone*, %mzone** %zPtr
call ccc void @llvm_zone_print(%mzone* %val341)
ret void
}
@gsxtmbase32 = hidden constant [84 x i8] c"print_adhoc_W3ZvaWQsbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %mzone*)*}** @print_adhoc_W3ZvaWQsbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone363 = load i8*, i8** %_impzPtr
%zone364 = bitcast i8* %tzone363 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsbXpvbmUqXQ
%dat_print_adhoc_W3ZvaWQsbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone364, i64 8)
%print_adhoc_W3ZvaWQsbXpvbmUqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsbXpvbmUqXQ to { i8*, i8*, void (i8*, i8*, %mzone*)*}***
%tzone344 = load i8*, i8** %_impzPtr
%zone345 = bitcast i8* %tzone344 to %mzone*
call void @llvm_zone_mark(%mzone* %zone345)
; malloc closure structure
%clsptr346 = call i8* @llvm_zone_malloc(%mzone* %zone345, i64 24)
%closure347 = bitcast i8* %clsptr346 to { i8*, i8*, void (i8*, i8*, %mzone*)*}*

; malloc environment structure
%envptr348 = call i8* @llvm_zone_malloc(%mzone* %zone345, i64 8)
%environment349 = bitcast i8* %envptr348 to {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}*

; malloc closure address table
%addytable350 = call %clsvar* @new_address_table()
%var351 = bitcast [31 x i8]* @gsxtmbase30 to i8*
%var352 = bitcast [40 x i8]* @gsxtmbase31 to i8*
%addytable353 = call %clsvar* @add_address_table(%mzone* %zone345, i8* %var351, i32 0, i8* %var352, i32 3, %clsvar* %addytable350)
%address-table354 = bitcast %clsvar* %addytable353 to i8*

; insert table, function and environment into closure struct
%closure.table357 = getelementptr { i8*, i8*, void (i8*, i8*, %mzone*)*}, { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure347, i32 0, i32 0
store i8* %address-table354, i8** %closure.table357
%closure.env358 = getelementptr { i8*, i8*, void (i8*, i8*, %mzone*)*}, { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure347, i32 0, i32 1
store i8* %envptr348, i8** %closure.env358
%closure.func359 = getelementptr { i8*, i8*, void (i8*, i8*, %mzone*)*}, { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure347, i32 0, i32 2
store void (i8*, i8*, %mzone*)* @print_adhoc_W3ZvaWQsbXpvbmUqXQ__339, void (i8*, i8*, %mzone*)** %closure.func359
%closure_size360 = call i64 @llvm_zone_mark_size(%mzone* %zone345)
call void @llvm_zone_ptr_set_size(i8* %clsptr346, i64 %closure_size360)
%wrapper_ptr361 = call i8* @llvm_zone_malloc(%mzone* %zone345, i64 8)
%closure_wrapper362 = bitcast i8* %wrapper_ptr361 to { i8*, i8*, void (i8*, i8*, %mzone*)*}**
store { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure347, { i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_wrapper362

; let value assignment
%print_adhoc_W3ZvaWQsbXpvbmUqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_wrapper362, { i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_wrapper362
store { i8*, i8*, void (i8*, i8*, %mzone*)*}** %print_adhoc_W3ZvaWQsbXpvbmUqXQ, { i8*, i8*, void (i8*, i8*, %mzone*)*}*** %print_adhoc_W3ZvaWQsbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsbXpvbmUqXQ
%tmp_envptr356 = getelementptr {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}, {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}* %environment349, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %mzone*)*}*** %print_adhoc_W3ZvaWQsbXpvbmUqXQPtr, {i8*, i8*, void (i8*, i8*, %mzone*)*}**** %tmp_envptr356


%val365 = load {i8*, i8*, void (i8*, i8*, %mzone*)*}**, {i8*, i8*, void (i8*, i8*, %mzone*)*}*** %print_adhoc_W3ZvaWQsbXpvbmUqXQPtr
ret {i8*, i8*, void (i8*, i8*, %mzone*)*}** %val365
}


@print_adhoc_W3ZvaWQsbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %mzone*)*}** @print_adhoc_W3ZvaWQsbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsbXpvbmUqXQ(%mzone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsbXpvbmUqXQ_native(%mzone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var366 = bitcast [84 x i8]* @gsxtmbase32 to i8*
call i32 (i8*, ...) @printf(i8* %var366)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%mzone*}*
%arg_p_0 = getelementptr {%mzone*}, {%mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %mzone*, %mzone** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase33 = hidden constant [28 x i8] c"Zone_adhoc_W216b25lKixpNjRd\00"
@gsxtmbase34 = hidden constant [39 x i8] c"{i8*, i8*, %mzone* (i8*, i8*, i64)*}**\00"
define dllexport fastcc %mzone* @Zone_adhoc_W216b25lKixpNjRd__367(i8* %_impz,i8* %_impenv, i64 %size) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone368 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %mzone* (i8*, i8*, i64)*}***}*
%Zone_adhoc_W216b25lKixpNjRdPtr_ = getelementptr {{i8*, i8*, %mzone* (i8*, i8*, i64)*}***}, {{i8*, i8*, %mzone* (i8*, i8*, i64)*}***}* %impenv, i32 0, i32 0
%Zone_adhoc_W216b25lKixpNjRdPtr = load {i8*, i8*, %mzone* (i8*, i8*, i64)*}***, {i8*, i8*, %mzone* (i8*, i8*, i64)*}**** %Zone_adhoc_W216b25lKixpNjRdPtr_

; setup arguments
%sizePtr = alloca i64
store i64 %size, i64* %sizePtr


%val369 = load i64, i64* %sizePtr
%res370 = call ccc %mzone* @llvm_zone_create(i64 %val369)
ret %mzone* %res370
}
@gsxtmbase35 = hidden constant [81 x i8] c"Zone_adhoc_W216b25lKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %mzone* (i8*, i8*, i64)*}** @Zone_adhoc_W216b25lKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone390 = load i8*, i8** %_impzPtr
%zone391 = bitcast i8* %tzone390 to %mzone*

; let assign value to symbol Zone_adhoc_W216b25lKixpNjRd
%dat_Zone_adhoc_W216b25lKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone391, i64 8)
%Zone_adhoc_W216b25lKixpNjRdPtr = bitcast i8* %dat_Zone_adhoc_W216b25lKixpNjRd to { i8*, i8*, %mzone* (i8*, i8*, i64)*}***
%tzone371 = load i8*, i8** %_impzPtr
%zone372 = bitcast i8* %tzone371 to %mzone*
call void @llvm_zone_mark(%mzone* %zone372)
; malloc closure structure
%clsptr373 = call i8* @llvm_zone_malloc(%mzone* %zone372, i64 24)
%closure374 = bitcast i8* %clsptr373 to { i8*, i8*, %mzone* (i8*, i8*, i64)*}*

; malloc environment structure
%envptr375 = call i8* @llvm_zone_malloc(%mzone* %zone372, i64 8)
%environment376 = bitcast i8* %envptr375 to {{i8*, i8*, %mzone* (i8*, i8*, i64)*}***}*

; malloc closure address table
%addytable377 = call %clsvar* @new_address_table()
%var378 = bitcast [28 x i8]* @gsxtmbase33 to i8*
%var379 = bitcast [39 x i8]* @gsxtmbase34 to i8*
%addytable380 = call %clsvar* @add_address_table(%mzone* %zone372, i8* %var378, i32 0, i8* %var379, i32 3, %clsvar* %addytable377)
%address-table381 = bitcast %clsvar* %addytable380 to i8*

; insert table, function and environment into closure struct
%closure.table384 = getelementptr { i8*, i8*, %mzone* (i8*, i8*, i64)*}, { i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure374, i32 0, i32 0
store i8* %address-table381, i8** %closure.table384
%closure.env385 = getelementptr { i8*, i8*, %mzone* (i8*, i8*, i64)*}, { i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure374, i32 0, i32 1
store i8* %envptr375, i8** %closure.env385
%closure.func386 = getelementptr { i8*, i8*, %mzone* (i8*, i8*, i64)*}, { i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure374, i32 0, i32 2
store %mzone* (i8*, i8*, i64)* @Zone_adhoc_W216b25lKixpNjRd__367, %mzone* (i8*, i8*, i64)** %closure.func386
%closure_size387 = call i64 @llvm_zone_mark_size(%mzone* %zone372)
call void @llvm_zone_ptr_set_size(i8* %clsptr373, i64 %closure_size387)
%wrapper_ptr388 = call i8* @llvm_zone_malloc(%mzone* %zone372, i64 8)
%closure_wrapper389 = bitcast i8* %wrapper_ptr388 to { i8*, i8*, %mzone* (i8*, i8*, i64)*}**
store { i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure374, { i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_wrapper389

; let value assignment
%Zone_adhoc_W216b25lKixpNjRd = select i1 true, { i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_wrapper389, { i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_wrapper389
store { i8*, i8*, %mzone* (i8*, i8*, i64)*}** %Zone_adhoc_W216b25lKixpNjRd, { i8*, i8*, %mzone* (i8*, i8*, i64)*}*** %Zone_adhoc_W216b25lKixpNjRdPtr

; add data to environment
; don't need to alloc for env var Zone_adhoc_W216b25lKixpNjRd
%tmp_envptr383 = getelementptr {{i8*, i8*, %mzone* (i8*, i8*, i64)*}***}, {{i8*, i8*, %mzone* (i8*, i8*, i64)*}***}* %environment376, i32 0, i32 0
store {i8*, i8*, %mzone* (i8*, i8*, i64)*}*** %Zone_adhoc_W216b25lKixpNjRdPtr, {i8*, i8*, %mzone* (i8*, i8*, i64)*}**** %tmp_envptr383


%val392 = load {i8*, i8*, %mzone* (i8*, i8*, i64)*}**, {i8*, i8*, %mzone* (i8*, i8*, i64)*}*** %Zone_adhoc_W216b25lKixpNjRdPtr
ret {i8*, i8*, %mzone* (i8*, i8*, i64)*}** %val392
}


@Zone_adhoc_W216b25lKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@Zone_adhoc_W216b25lKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Zone_adhoc_W216b25lKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %mzone* (i8*, i8*, i64)*}** @Zone_adhoc_W216b25lKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Zone_adhoc_W216b25lKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %mzone* @Zone_adhoc_W216b25lKixpNjRd(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, i64)*}*, {i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, i64)*,  %mzone* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %mzone* %result
}


define dllexport ccc %mzone* @Zone_adhoc_W216b25lKixpNjRd_native(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, i64)*}*, {i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, i64)*,  %mzone* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %mzone* %result
}


define dllexport ccc i8*  @Zone_adhoc_W216b25lKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var393 = bitcast [81 x i8]* @gsxtmbase35 to i8*
call i32 (i8*, ...) @printf(i8* %var393)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, i64)*}*, {i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, i64)*,  %mzone* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%tmpres = bitcast %mzone* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Zone_adhoc_W216b25lKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64}*
%arg_p_0 = getelementptr {i64}, {i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Zone_adhoc_W216b25lKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, i64)*}*, {i8*, i8*, %mzone* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, i64)*}, {i8*, i8*, %mzone* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, i64)*,  %mzone* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase36 = hidden constant [38 x i8] c"reset_zone_adhoc_W216b25lKixtem9uZSpd\00"
@gsxtmbase37 = hidden constant [43 x i8] c"{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**\00"
define dllexport fastcc %mzone* @reset_zone_adhoc_W216b25lKixtem9uZSpd__394(i8* %_impz,i8* %_impenv, %mzone* %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone395 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***}*
%reset_zone_adhoc_W216b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***}, {{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***}* %impenv, i32 0, i32 0
%reset_zone_adhoc_W216b25lKixtem9uZSpdPtr = load {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**** %reset_zone_adhoc_W216b25lKixtem9uZSpdPtr_

; setup arguments
%zPtr = alloca %mzone*
store %mzone* %z, %mzone** %zPtr


%val396 = load %mzone*, %mzone** %zPtr
%res397 = call ccc %mzone* @llvm_zone_reset(%mzone* %val396)
ret %mzone* %res397
}
@gsxtmbase38 = hidden constant [91 x i8] c"reset_zone_adhoc_W216b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** @reset_zone_adhoc_W216b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone417 = load i8*, i8** %_impzPtr
%zone418 = bitcast i8* %tzone417 to %mzone*

; let assign value to symbol reset_zone_adhoc_W216b25lKixtem9uZSpd
%dat_reset_zone_adhoc_W216b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone418, i64 8)
%reset_zone_adhoc_W216b25lKixtem9uZSpdPtr = bitcast i8* %dat_reset_zone_adhoc_W216b25lKixtem9uZSpd to { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***
%tzone398 = load i8*, i8** %_impzPtr
%zone399 = bitcast i8* %tzone398 to %mzone*
call void @llvm_zone_mark(%mzone* %zone399)
; malloc closure structure
%clsptr400 = call i8* @llvm_zone_malloc(%mzone* %zone399, i64 24)
%closure401 = bitcast i8* %clsptr400 to { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*

; malloc environment structure
%envptr402 = call i8* @llvm_zone_malloc(%mzone* %zone399, i64 8)
%environment403 = bitcast i8* %envptr402 to {{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***}*

; malloc closure address table
%addytable404 = call %clsvar* @new_address_table()
%var405 = bitcast [38 x i8]* @gsxtmbase36 to i8*
%var406 = bitcast [43 x i8]* @gsxtmbase37 to i8*
%addytable407 = call %clsvar* @add_address_table(%mzone* %zone399, i8* %var405, i32 0, i8* %var406, i32 3, %clsvar* %addytable404)
%address-table408 = bitcast %clsvar* %addytable407 to i8*

; insert table, function and environment into closure struct
%closure.table411 = getelementptr { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure401, i32 0, i32 0
store i8* %address-table408, i8** %closure.table411
%closure.env412 = getelementptr { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure401, i32 0, i32 1
store i8* %envptr402, i8** %closure.env412
%closure.func413 = getelementptr { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure401, i32 0, i32 2
store %mzone* (i8*, i8*, %mzone*)* @reset_zone_adhoc_W216b25lKixtem9uZSpd__394, %mzone* (i8*, i8*, %mzone*)** %closure.func413
%closure_size414 = call i64 @llvm_zone_mark_size(%mzone* %zone399)
call void @llvm_zone_ptr_set_size(i8* %clsptr400, i64 %closure_size414)
%wrapper_ptr415 = call i8* @llvm_zone_malloc(%mzone* %zone399, i64 8)
%closure_wrapper416 = bitcast i8* %wrapper_ptr415 to { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**
store { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure401, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_wrapper416

; let value assignment
%reset_zone_adhoc_W216b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_wrapper416, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_wrapper416
store { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %reset_zone_adhoc_W216b25lKixtem9uZSpd, { i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*** %reset_zone_adhoc_W216b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var reset_zone_adhoc_W216b25lKixtem9uZSpd
%tmp_envptr410 = getelementptr {{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***}, {{i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}***}* %environment403, i32 0, i32 0
store {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*** %reset_zone_adhoc_W216b25lKixtem9uZSpdPtr, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**** %tmp_envptr410


%val419 = load {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*** %reset_zone_adhoc_W216b25lKixtem9uZSpdPtr
ret {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %val419
}


@reset_zone_adhoc_W216b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@reset_zone_adhoc_W216b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @reset_zone_adhoc_W216b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** @reset_zone_adhoc_W216b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @reset_zone_adhoc_W216b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %mzone* @reset_zone_adhoc_W216b25lKixtem9uZSpd(%mzone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, %mzone*)*,  %mzone* (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
ret %mzone* %result
}


define dllexport ccc %mzone* @reset_zone_adhoc_W216b25lKixtem9uZSpd_native(%mzone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, %mzone*)*,  %mzone* (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
ret %mzone* %result
}


define dllexport ccc i8*  @reset_zone_adhoc_W216b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var420 = bitcast [91 x i8]* @gsxtmbase38 to i8*
call i32 (i8*, ...) @printf(i8* %var420)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, %mzone*)*,  %mzone* (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
%tmpres = bitcast %mzone* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @reset_zone_adhoc_W216b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%mzone*}*
%arg_p_0 = getelementptr {%mzone*}, {%mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %mzone*, %mzone** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @reset_zone_adhoc_W216b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}*, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}, {i8*, i8*, %mzone* (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*, %mzone*)*,  %mzone* (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase39 = hidden constant [38 x i8] c"destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ\00"
define dllexport fastcc void @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ__421(i8* %_impz,i8* %_impenv, %mzone* %z) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone422 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}*
%destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}, {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}* %impenv, i32 0, i32 0
%destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr = load {i8*, i8*, void (i8*, i8*, %mzone*)*}***, {i8*, i8*, void (i8*, i8*, %mzone*)*}**** %destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr_

; setup arguments
%zPtr = alloca %mzone*
store %mzone* %z, %mzone** %zPtr


%val423 = load %mzone*, %mzone** %zPtr
call ccc void @llvm_zone_destroy(%mzone* %val423)
ret void
}
@gsxtmbase40 = hidden constant [91 x i8] c"destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %mzone*)*}** @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone444 = load i8*, i8** %_impzPtr
%zone445 = bitcast i8* %tzone444 to %mzone*

; let assign value to symbol destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ
%dat_destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone445, i64 8)
%destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr = bitcast i8* %dat_destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ to { i8*, i8*, void (i8*, i8*, %mzone*)*}***
%tzone425 = load i8*, i8** %_impzPtr
%zone426 = bitcast i8* %tzone425 to %mzone*
call void @llvm_zone_mark(%mzone* %zone426)
; malloc closure structure
%clsptr427 = call i8* @llvm_zone_malloc(%mzone* %zone426, i64 24)
%closure428 = bitcast i8* %clsptr427 to { i8*, i8*, void (i8*, i8*, %mzone*)*}*

; malloc environment structure
%envptr429 = call i8* @llvm_zone_malloc(%mzone* %zone426, i64 8)
%environment430 = bitcast i8* %envptr429 to {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}*

; malloc closure address table
%addytable431 = call %clsvar* @new_address_table()
%var432 = bitcast [38 x i8]* @gsxtmbase39 to i8*
%var433 = bitcast [40 x i8]* @gsxtmbase31 to i8*
%addytable434 = call %clsvar* @add_address_table(%mzone* %zone426, i8* %var432, i32 0, i8* %var433, i32 3, %clsvar* %addytable431)
%address-table435 = bitcast %clsvar* %addytable434 to i8*

; insert table, function and environment into closure struct
%closure.table438 = getelementptr { i8*, i8*, void (i8*, i8*, %mzone*)*}, { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure428, i32 0, i32 0
store i8* %address-table435, i8** %closure.table438
%closure.env439 = getelementptr { i8*, i8*, void (i8*, i8*, %mzone*)*}, { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure428, i32 0, i32 1
store i8* %envptr429, i8** %closure.env439
%closure.func440 = getelementptr { i8*, i8*, void (i8*, i8*, %mzone*)*}, { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure428, i32 0, i32 2
store void (i8*, i8*, %mzone*)* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ__421, void (i8*, i8*, %mzone*)** %closure.func440
%closure_size441 = call i64 @llvm_zone_mark_size(%mzone* %zone426)
call void @llvm_zone_ptr_set_size(i8* %clsptr427, i64 %closure_size441)
%wrapper_ptr442 = call i8* @llvm_zone_malloc(%mzone* %zone426, i64 8)
%closure_wrapper443 = bitcast i8* %wrapper_ptr442 to { i8*, i8*, void (i8*, i8*, %mzone*)*}**
store { i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure428, { i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_wrapper443

; let value assignment
%destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_wrapper443, { i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_wrapper443
store { i8*, i8*, void (i8*, i8*, %mzone*)*}** %destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ, { i8*, i8*, void (i8*, i8*, %mzone*)*}*** %destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ
%tmp_envptr437 = getelementptr {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}, {{i8*, i8*, void (i8*, i8*, %mzone*)*}***}* %environment430, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %mzone*)*}*** %destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr, {i8*, i8*, void (i8*, i8*, %mzone*)*}**** %tmp_envptr437


%val446 = load {i8*, i8*, void (i8*, i8*, %mzone*)*}**, {i8*, i8*, void (i8*, i8*, %mzone*)*}*** %destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQPtr
ret {i8*, i8*, void (i8*, i8*, %mzone*)*}** %val446
}


@destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %mzone*)*}** @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ(%mzone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
ret void
}


define dllexport ccc void @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_native(%mzone* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
ret void
}


define dllexport ccc i8*  @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var447 = bitcast [91 x i8]* @gsxtmbase40 to i8*
call i32 (i8*, ...) @printf(i8* %var447)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%mzone*}*
%arg_p_0 = getelementptr {%mzone*}, {%mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %mzone*, %mzone** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @destroy_zone_adhoc_W3ZvaWQsbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %mzone*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %mzone*)*}*, {i8*, i8*, void (i8*, i8*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %mzone*)*}, {i8*, i8*, void (i8*, i8*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %mzone*)*,  void (i8*, i8*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %mzone* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase41 = hidden constant [28 x i8] c"peek_zone_adhoc_W216b25lKl0\00"
@gsxtmbase42 = hidden constant [34 x i8] c"{i8*, i8*, %mzone* (i8*, i8*)*}**\00"
define dllexport fastcc %mzone* @peek_zone_adhoc_W216b25lKl0__448(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone449 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %mzone* (i8*, i8*)*}***}*
%peek_zone_adhoc_W216b25lKl0Ptr_ = getelementptr {{i8*, i8*, %mzone* (i8*, i8*)*}***}, {{i8*, i8*, %mzone* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%peek_zone_adhoc_W216b25lKl0Ptr = load {i8*, i8*, %mzone* (i8*, i8*)*}***, {i8*, i8*, %mzone* (i8*, i8*)*}**** %peek_zone_adhoc_W216b25lKl0Ptr_

; setup arguments


%res450 = call ccc %mzone* @llvm_peek_zone_stack()
ret %mzone* %res450
}
define dllexport ccc {i8*, i8*, %mzone* (i8*, i8*)*}** @peek_zone_adhoc_W216b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone470 = load i8*, i8** %_impzPtr
%zone471 = bitcast i8* %tzone470 to %mzone*

; let assign value to symbol peek_zone_adhoc_W216b25lKl0
%dat_peek_zone_adhoc_W216b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone471, i64 8)
%peek_zone_adhoc_W216b25lKl0Ptr = bitcast i8* %dat_peek_zone_adhoc_W216b25lKl0 to { i8*, i8*, %mzone* (i8*, i8*)*}***
%tzone451 = load i8*, i8** %_impzPtr
%zone452 = bitcast i8* %tzone451 to %mzone*
call void @llvm_zone_mark(%mzone* %zone452)
; malloc closure structure
%clsptr453 = call i8* @llvm_zone_malloc(%mzone* %zone452, i64 24)
%closure454 = bitcast i8* %clsptr453 to { i8*, i8*, %mzone* (i8*, i8*)*}*

; malloc environment structure
%envptr455 = call i8* @llvm_zone_malloc(%mzone* %zone452, i64 8)
%environment456 = bitcast i8* %envptr455 to {{i8*, i8*, %mzone* (i8*, i8*)*}***}*

; malloc closure address table
%addytable457 = call %clsvar* @new_address_table()
%var458 = bitcast [28 x i8]* @gsxtmbase41 to i8*
%var459 = bitcast [34 x i8]* @gsxtmbase42 to i8*
%addytable460 = call %clsvar* @add_address_table(%mzone* %zone452, i8* %var458, i32 0, i8* %var459, i32 3, %clsvar* %addytable457)
%address-table461 = bitcast %clsvar* %addytable460 to i8*

; insert table, function and environment into closure struct
%closure.table464 = getelementptr { i8*, i8*, %mzone* (i8*, i8*)*}, { i8*, i8*, %mzone* (i8*, i8*)*}* %closure454, i32 0, i32 0
store i8* %address-table461, i8** %closure.table464
%closure.env465 = getelementptr { i8*, i8*, %mzone* (i8*, i8*)*}, { i8*, i8*, %mzone* (i8*, i8*)*}* %closure454, i32 0, i32 1
store i8* %envptr455, i8** %closure.env465
%closure.func466 = getelementptr { i8*, i8*, %mzone* (i8*, i8*)*}, { i8*, i8*, %mzone* (i8*, i8*)*}* %closure454, i32 0, i32 2
store %mzone* (i8*, i8*)* @peek_zone_adhoc_W216b25lKl0__448, %mzone* (i8*, i8*)** %closure.func466
%closure_size467 = call i64 @llvm_zone_mark_size(%mzone* %zone452)
call void @llvm_zone_ptr_set_size(i8* %clsptr453, i64 %closure_size467)
%wrapper_ptr468 = call i8* @llvm_zone_malloc(%mzone* %zone452, i64 8)
%closure_wrapper469 = bitcast i8* %wrapper_ptr468 to { i8*, i8*, %mzone* (i8*, i8*)*}**
store { i8*, i8*, %mzone* (i8*, i8*)*}* %closure454, { i8*, i8*, %mzone* (i8*, i8*)*}** %closure_wrapper469

; let value assignment
%peek_zone_adhoc_W216b25lKl0 = select i1 true, { i8*, i8*, %mzone* (i8*, i8*)*}** %closure_wrapper469, { i8*, i8*, %mzone* (i8*, i8*)*}** %closure_wrapper469
store { i8*, i8*, %mzone* (i8*, i8*)*}** %peek_zone_adhoc_W216b25lKl0, { i8*, i8*, %mzone* (i8*, i8*)*}*** %peek_zone_adhoc_W216b25lKl0Ptr

; add data to environment
; don't need to alloc for env var peek_zone_adhoc_W216b25lKl0
%tmp_envptr463 = getelementptr {{i8*, i8*, %mzone* (i8*, i8*)*}***}, {{i8*, i8*, %mzone* (i8*, i8*)*}***}* %environment456, i32 0, i32 0
store {i8*, i8*, %mzone* (i8*, i8*)*}*** %peek_zone_adhoc_W216b25lKl0Ptr, {i8*, i8*, %mzone* (i8*, i8*)*}**** %tmp_envptr463


%val472 = load {i8*, i8*, %mzone* (i8*, i8*)*}**, {i8*, i8*, %mzone* (i8*, i8*)*}*** %peek_zone_adhoc_W216b25lKl0Ptr
ret {i8*, i8*, %mzone* (i8*, i8*)*}** %val472
}


@peek_zone_adhoc_W216b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@peek_zone_adhoc_W216b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @peek_zone_adhoc_W216b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %mzone* (i8*, i8*)*}** @peek_zone_adhoc_W216b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %mzone* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @peek_zone_adhoc_W216b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %mzone* @peek_zone_adhoc_W216b25lKl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*)*}*, {i8*, i8*, %mzone* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*)*,  %mzone* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee)
ret %mzone* %result
}


define dllexport ccc %mzone* @peek_zone_adhoc_W216b25lKl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*)*}*, {i8*, i8*, %mzone* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*)*,  %mzone* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee)
ret %mzone* %result
}


define dllexport ccc i8*  @peek_zone_adhoc_W216b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*)*}*, {i8*, i8*, %mzone* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*)*,  %mzone* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %mzone* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @peek_zone_adhoc_W216b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @peek_zone_adhoc_W216b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %mzone* (i8*, i8*)*}**
%closure = load {i8*, i8*, %mzone* (i8*, i8*)*}*, {i8*, i8*, %mzone* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %mzone* (i8*, i8*)*}, {i8*, i8*, %mzone* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %mzone* (i8*, i8*)*,  %mzone* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %mzone* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase43 = hidden constant [41 x i8] c"zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd\00"
@gsxtmbase44 = hidden constant [51 x i8] c"{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**\00"
define dllexport fastcc i1 @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd__473(i8* %_impz,i8* %_impenv, i1 %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone474 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**** %zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca i1
store i1 %x, i1* %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val475 = load i1, i1* %xPtr
ret i1 %val475
}
@gsxtmbase45 = hidden constant [94 x i8] c"zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone495 = load i8*, i8** %_impzPtr
%zone496 = bitcast i8* %tzone495 to %mzone*

; let assign value to symbol zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone496, i64 8)
%zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd to { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***
%tzone476 = load i8*, i8** %_impzPtr
%zone477 = bitcast i8* %tzone476 to %mzone*
call void @llvm_zone_mark(%mzone* %zone477)
; malloc closure structure
%clsptr478 = call i8* @llvm_zone_malloc(%mzone* %zone477, i64 24)
%closure479 = bitcast i8* %clsptr478 to { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr480 = call i8* @llvm_zone_malloc(%mzone* %zone477, i64 8)
%environment481 = bitcast i8* %envptr480 to {{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable482 = call %clsvar* @new_address_table()
%var483 = bitcast [41 x i8]* @gsxtmbase43 to i8*
%var484 = bitcast [51 x i8]* @gsxtmbase44 to i8*
%addytable485 = call %clsvar* @add_address_table(%mzone* %zone477, i8* %var483, i32 0, i8* %var484, i32 3, %clsvar* %addytable482)
%address-table486 = bitcast %clsvar* %addytable485 to i8*

; insert table, function and environment into closure struct
%closure.table489 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure479, i32 0, i32 0
store i8* %address-table486, i8** %closure.table489
%closure.env490 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure479, i32 0, i32 1
store i8* %envptr480, i8** %closure.env490
%closure.func491 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure479, i32 0, i32 2
store i1 (i8*, i8*, i1, %mzone*, %mzone*)* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd__473, i1 (i8*, i8*, i1, %mzone*, %mzone*)** %closure.func491
%closure_size492 = call i64 @llvm_zone_mark_size(%mzone* %zone477)
call void @llvm_zone_ptr_set_size(i8* %clsptr478, i64 %closure_size492)
%wrapper_ptr493 = call i8* @llvm_zone_malloc(%mzone* %zone477, i64 8)
%closure_wrapper494 = bitcast i8* %wrapper_ptr493 to { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**
store { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure479, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_wrapper494

; let value assignment
%zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_wrapper494, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_wrapper494
store { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd, { i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd
%tmp_envptr488 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}***}* %environment481, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**** %tmp_envptr488


%val497 = load {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %val497
}


@zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd(i1 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %mzone*, %mzone*)*,  i1 (i8*, i8*, i1, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i1 %result
}


define dllexport ccc i1 @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_native(i1 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %mzone*, %mzone*)*,  i1 (i8*, i8*, i1, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i1 %result
}


define dllexport ccc i8*  @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var498 = bitcast [94 x i8]* @gsxtmbase45 to i8*
call i32 (i8*, ...) @printf(i8* %var498)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i1  @i1value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var499 = bitcast [94 x i8]* @gsxtmbase45 to i8*
call i32 (i8*, ...) @printf(i8* %var499)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var500 = bitcast [94 x i8]* @gsxtmbase45 to i8*
call i32 (i8*, ...) @printf(i8* %var500)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %mzone*, %mzone*)*,  i1 (i8*, i8*, i1, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {i1, %mzone*, %mzone*}, {i1, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
%arg_p_1 = getelementptr {i1, %mzone*, %mzone*}, {i1, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {i1, %mzone*, %mzone*}, {i1, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kxLGkxLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}, {i8*, i8*, i1 (i8*, i8*, i1, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %mzone*, %mzone*)*,  i1 (i8*, i8*, i1, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase46 = hidden constant [41 x i8] c"zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd\00"
@gsxtmbase47 = hidden constant [51 x i8] c"{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**\00"
define dllexport fastcc i8 @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd__501(i8* %_impz,i8* %_impenv, i8 %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone502 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***}, {{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr = load {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**** %zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca i8
store i8 %x, i8* %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val503 = load i8, i8* %xPtr
ret i8 %val503
}
@gsxtmbase48 = hidden constant [94 x i8] c"zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone523 = load i8*, i8** %_impzPtr
%zone524 = bitcast i8* %tzone523 to %mzone*

; let assign value to symbol zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone524, i64 8)
%zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd to { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***
%tzone504 = load i8*, i8** %_impzPtr
%zone505 = bitcast i8* %tzone504 to %mzone*
call void @llvm_zone_mark(%mzone* %zone505)
; malloc closure structure
%clsptr506 = call i8* @llvm_zone_malloc(%mzone* %zone505, i64 24)
%closure507 = bitcast i8* %clsptr506 to { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr508 = call i8* @llvm_zone_malloc(%mzone* %zone505, i64 8)
%environment509 = bitcast i8* %envptr508 to {{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable510 = call %clsvar* @new_address_table()
%var511 = bitcast [41 x i8]* @gsxtmbase46 to i8*
%var512 = bitcast [51 x i8]* @gsxtmbase47 to i8*
%addytable513 = call %clsvar* @add_address_table(%mzone* %zone505, i8* %var511, i32 0, i8* %var512, i32 3, %clsvar* %addytable510)
%address-table514 = bitcast %clsvar* %addytable513 to i8*

; insert table, function and environment into closure struct
%closure.table517 = getelementptr { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure507, i32 0, i32 0
store i8* %address-table514, i8** %closure.table517
%closure.env518 = getelementptr { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure507, i32 0, i32 1
store i8* %envptr508, i8** %closure.env518
%closure.func519 = getelementptr { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure507, i32 0, i32 2
store i8 (i8*, i8*, i8, %mzone*, %mzone*)* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd__501, i8 (i8*, i8*, i8, %mzone*, %mzone*)** %closure.func519
%closure_size520 = call i64 @llvm_zone_mark_size(%mzone* %zone505)
call void @llvm_zone_ptr_set_size(i8* %clsptr506, i64 %closure_size520)
%wrapper_ptr521 = call i8* @llvm_zone_malloc(%mzone* %zone505, i64 8)
%closure_wrapper522 = bitcast i8* %wrapper_ptr521 to { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**
store { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure507, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_wrapper522

; let value assignment
%zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_wrapper522, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_wrapper522
store { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd, { i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd
%tmp_envptr516 = getelementptr {{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***}, {{i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}***}* %environment509, i32 0, i32 0
store {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**** %tmp_envptr516


%val525 = load {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %val525
}


@zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8 @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd(i8 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i8 (i8*, i8*, i8, %mzone*, %mzone*)*,  i8 (i8*, i8*, i8, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i8 %result
}


define dllexport ccc i8 @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_native(i8 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i8 (i8*, i8*, i8, %mzone*, %mzone*)*,  i8 (i8*, i8*, i8, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i8 %result
}


define dllexport ccc i8*  @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var526 = bitcast [94 x i8]* @gsxtmbase48 to i8*
call i32 (i8*, ...) @printf(i8* %var526)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8  @i8value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var527 = bitcast [94 x i8]* @gsxtmbase48 to i8*
call i32 (i8*, ...) @printf(i8* %var527)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var528 = bitcast [94 x i8]* @gsxtmbase48 to i8*
call i32 (i8*, ...) @printf(i8* %var528)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i8 (i8*, i8*, i8, %mzone*, %mzone*)*,  i8 (i8*, i8*, i8, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%res = call ccc i8* @mk_i8(i8* %_sc, i8 %result)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {i8, %mzone*, %mzone*}, {i8, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
%arg_p_1 = getelementptr {i8, %mzone*, %mzone*}, {i8, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {i8, %mzone*, %mzone*}, {i8, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k4LGk4LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}*, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}, {i8*, i8*, i8 (i8*, i8*, i8, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i8 (i8*, i8*, i8, %mzone*, %mzone*)*,  i8 (i8*, i8*, i8, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase49 = hidden constant [44 x i8] c"zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0\00"
@gsxtmbase50 = hidden constant [53 x i8] c"{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**\00"
define dllexport fastcc i32 @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0__529(i8* %_impz,i8* %_impenv, i32 %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone530 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**** %zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca i32
store i32 %x, i32* %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val531 = load i32, i32* %xPtr
ret i32 %val531
}
@gsxtmbase51 = hidden constant [97 x i8] c"zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone551 = load i8*, i8** %_impzPtr
%zone552 = bitcast i8* %tzone551 to %mzone*

; let assign value to symbol zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone552, i64 8)
%zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0 to { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***
%tzone532 = load i8*, i8** %_impzPtr
%zone533 = bitcast i8* %tzone532 to %mzone*
call void @llvm_zone_mark(%mzone* %zone533)
; malloc closure structure
%clsptr534 = call i8* @llvm_zone_malloc(%mzone* %zone533, i64 24)
%closure535 = bitcast i8* %clsptr534 to { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr536 = call i8* @llvm_zone_malloc(%mzone* %zone533, i64 8)
%environment537 = bitcast i8* %envptr536 to {{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable538 = call %clsvar* @new_address_table()
%var539 = bitcast [44 x i8]* @gsxtmbase49 to i8*
%var540 = bitcast [53 x i8]* @gsxtmbase50 to i8*
%addytable541 = call %clsvar* @add_address_table(%mzone* %zone533, i8* %var539, i32 0, i8* %var540, i32 3, %clsvar* %addytable538)
%address-table542 = bitcast %clsvar* %addytable541 to i8*

; insert table, function and environment into closure struct
%closure.table545 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure535, i32 0, i32 0
store i8* %address-table542, i8** %closure.table545
%closure.env546 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure535, i32 0, i32 1
store i8* %envptr536, i8** %closure.env546
%closure.func547 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure535, i32 0, i32 2
store i32 (i8*, i8*, i32, %mzone*, %mzone*)* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0__529, i32 (i8*, i8*, i32, %mzone*, %mzone*)** %closure.func547
%closure_size548 = call i64 @llvm_zone_mark_size(%mzone* %zone533)
call void @llvm_zone_ptr_set_size(i8* %clsptr534, i64 %closure_size548)
%wrapper_ptr549 = call i8* @llvm_zone_malloc(%mzone* %zone533, i64 8)
%closure_wrapper550 = bitcast i8* %wrapper_ptr549 to { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**
store { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure535, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_wrapper550

; let value assignment
%zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_wrapper550, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_wrapper550
store { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0, { i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0
%tmp_envptr544 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}***}* %environment537, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**** %tmp_envptr544


%val553 = load {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %val553
}


@zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0(i32 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, %mzone*, %mzone*)*,  i32 (i8*, i8*, i32, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i32 %result
}


define dllexport ccc i32 @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_native(i32 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, %mzone*, %mzone*)*,  i32 (i8*, i8*, i32, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i32 %result
}


define dllexport ccc i8*  @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var554 = bitcast [97 x i8]* @gsxtmbase51 to i8*
call i32 (i8*, ...) @printf(i8* %var554)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var555 = bitcast [97 x i8]* @gsxtmbase51 to i8*
call i32 (i8*, ...) @printf(i8* %var555)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var556 = bitcast [97 x i8]* @gsxtmbase51 to i8*
call i32 (i8*, ...) @printf(i8* %var556)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, %mzone*, %mzone*)*,  i32 (i8*, i8*, i32, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {i32, %mzone*, %mzone*}, {i32, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %mzone*, %mzone*}, {i32, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {i32, %mzone*, %mzone*}, {i32, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2kzMixpMzIsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}*, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}, {i8*, i8*, i32 (i8*, i8*, i32, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, %mzone*, %mzone*)*,  i32 (i8*, i8*, i32, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase52 = hidden constant [44 x i8] c"zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0\00"
@gsxtmbase53 = hidden constant [53 x i8] c"{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**\00"
define dllexport fastcc i64 @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0__557(i8* %_impz,i8* %_impenv, i64 %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone558 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***}, {{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**** %zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val559 = load i64, i64* %xPtr
ret i64 %val559
}
@gsxtmbase54 = hidden constant [97 x i8] c"zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone579 = load i8*, i8** %_impzPtr
%zone580 = bitcast i8* %tzone579 to %mzone*

; let assign value to symbol zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone580, i64 8)
%zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0 to { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***
%tzone560 = load i8*, i8** %_impzPtr
%zone561 = bitcast i8* %tzone560 to %mzone*
call void @llvm_zone_mark(%mzone* %zone561)
; malloc closure structure
%clsptr562 = call i8* @llvm_zone_malloc(%mzone* %zone561, i64 24)
%closure563 = bitcast i8* %clsptr562 to { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr564 = call i8* @llvm_zone_malloc(%mzone* %zone561, i64 8)
%environment565 = bitcast i8* %envptr564 to {{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable566 = call %clsvar* @new_address_table()
%var567 = bitcast [44 x i8]* @gsxtmbase52 to i8*
%var568 = bitcast [53 x i8]* @gsxtmbase53 to i8*
%addytable569 = call %clsvar* @add_address_table(%mzone* %zone561, i8* %var567, i32 0, i8* %var568, i32 3, %clsvar* %addytable566)
%address-table570 = bitcast %clsvar* %addytable569 to i8*

; insert table, function and environment into closure struct
%closure.table573 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure563, i32 0, i32 0
store i8* %address-table570, i8** %closure.table573
%closure.env574 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure563, i32 0, i32 1
store i8* %envptr564, i8** %closure.env574
%closure.func575 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure563, i32 0, i32 2
store i64 (i8*, i8*, i64, %mzone*, %mzone*)* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0__557, i64 (i8*, i8*, i64, %mzone*, %mzone*)** %closure.func575
%closure_size576 = call i64 @llvm_zone_mark_size(%mzone* %zone561)
call void @llvm_zone_ptr_set_size(i8* %clsptr562, i64 %closure_size576)
%wrapper_ptr577 = call i8* @llvm_zone_malloc(%mzone* %zone561, i64 8)
%closure_wrapper578 = bitcast i8* %wrapper_ptr577 to { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**
store { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure563, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_wrapper578

; let value assignment
%zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_wrapper578, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_wrapper578
store { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0, { i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0
%tmp_envptr572 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***}, {{i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}***}* %environment565, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**** %tmp_envptr572


%val581 = load {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %val581
}


@zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0(i64 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64, %mzone*, %mzone*)*,  i64 (i8*, i8*, i64, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i64 %result
}


define dllexport ccc i64 @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_native(i64 %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64, %mzone*, %mzone*)*,  i64 (i8*, i8*, i64, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret i64 %result
}


define dllexport ccc i8*  @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var582 = bitcast [97 x i8]* @gsxtmbase54 to i8*
call i32 (i8*, ...) @printf(i8* %var582)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var583 = bitcast [97 x i8]* @gsxtmbase54 to i8*
call i32 (i8*, ...) @printf(i8* %var583)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var584 = bitcast [97 x i8]* @gsxtmbase54 to i8*
call i32 (i8*, ...) @printf(i8* %var584)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64, %mzone*, %mzone*)*,  i64 (i8*, i8*, i64, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {i64, %mzone*, %mzone*}, {i64, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, %mzone*, %mzone*}, {i64, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {i64, %mzone*, %mzone*}, {i64, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2k2NCxpNjQsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}*, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}, {i8*, i8*, i64 (i8*, i8*, i64, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64, %mzone*, %mzone*)*,  i64 (i8*, i8*, i64, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase55 = hidden constant [49 x i8] c"zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd\00"
@gsxtmbase56 = hidden constant [57 x i8] c"{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**\00"
define dllexport fastcc float @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd__585(i8* %_impz,i8* %_impenv, float %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone586 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***}, {{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr = load {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**** %zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val587 = load float, float* %xPtr
ret float %val587
}
@gsxtmbase57 = hidden constant [102 x i8] c"zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone607 = load i8*, i8** %_impzPtr
%zone608 = bitcast i8* %tzone607 to %mzone*

; let assign value to symbol zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone608, i64 8)
%zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd to { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***
%tzone588 = load i8*, i8** %_impzPtr
%zone589 = bitcast i8* %tzone588 to %mzone*
call void @llvm_zone_mark(%mzone* %zone589)
; malloc closure structure
%clsptr590 = call i8* @llvm_zone_malloc(%mzone* %zone589, i64 24)
%closure591 = bitcast i8* %clsptr590 to { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr592 = call i8* @llvm_zone_malloc(%mzone* %zone589, i64 8)
%environment593 = bitcast i8* %envptr592 to {{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable594 = call %clsvar* @new_address_table()
%var595 = bitcast [49 x i8]* @gsxtmbase55 to i8*
%var596 = bitcast [57 x i8]* @gsxtmbase56 to i8*
%addytable597 = call %clsvar* @add_address_table(%mzone* %zone589, i8* %var595, i32 0, i8* %var596, i32 3, %clsvar* %addytable594)
%address-table598 = bitcast %clsvar* %addytable597 to i8*

; insert table, function and environment into closure struct
%closure.table601 = getelementptr { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure591, i32 0, i32 0
store i8* %address-table598, i8** %closure.table601
%closure.env602 = getelementptr { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure591, i32 0, i32 1
store i8* %envptr592, i8** %closure.env602
%closure.func603 = getelementptr { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure591, i32 0, i32 2
store float (i8*, i8*, float, %mzone*, %mzone*)* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd__585, float (i8*, i8*, float, %mzone*, %mzone*)** %closure.func603
%closure_size604 = call i64 @llvm_zone_mark_size(%mzone* %zone589)
call void @llvm_zone_ptr_set_size(i8* %clsptr590, i64 %closure_size604)
%wrapper_ptr605 = call i8* @llvm_zone_malloc(%mzone* %zone589, i64 8)
%closure_wrapper606 = bitcast i8* %wrapper_ptr605 to { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**
store { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure591, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_wrapper606

; let value assignment
%zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_wrapper606, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_wrapper606
store { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd, { i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd
%tmp_envptr600 = getelementptr {{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***}, {{i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}***}* %environment593, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**** %tmp_envptr600


%val609 = load {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %val609
}


@zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd(float %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %mzone*, %mzone*)*,  float (i8*, i8*, float, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret float %result
}


define dllexport ccc float @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_native(float %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %mzone*, %mzone*)*,  float (i8*, i8*, float, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret float %result
}


define dllexport ccc i8*  @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var610 = bitcast [102 x i8]* @gsxtmbase57 to i8*
call i32 (i8*, ...) @printf(i8* %var610)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var611 = bitcast [102 x i8]* @gsxtmbase57 to i8*
call i32 (i8*, ...) @printf(i8* %var611)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var612 = bitcast [102 x i8]* @gsxtmbase57 to i8*
call i32 (i8*, ...) @printf(i8* %var612)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %mzone*, %mzone*)*,  float (i8*, i8*, float, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {float, %mzone*, %mzone*}, {float, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, %mzone*, %mzone*}, {float, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {float, %mzone*, %mzone*}, {float, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2Zsb2F0LGZsb2F0LG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}*, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}, {i8*, i8*, float (i8*, i8*, float, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %mzone*, %mzone*)*,  float (i8*, i8*, float, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase58 = hidden constant [52 x i8] c"zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0\00"
@gsxtmbase59 = hidden constant [59 x i8] c"{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**\00"
define dllexport fastcc double @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0__613(i8* %_impz,i8* %_impenv, double %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone614 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***}, {{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**** %zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca double
store double %x, double* %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val615 = load double, double* %xPtr
ret double %val615
}
@gsxtmbase60 = hidden constant [105 x i8] c"zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone635 = load i8*, i8** %_impzPtr
%zone636 = bitcast i8* %tzone635 to %mzone*

; let assign value to symbol zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone636, i64 8)
%zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0 to { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***
%tzone616 = load i8*, i8** %_impzPtr
%zone617 = bitcast i8* %tzone616 to %mzone*
call void @llvm_zone_mark(%mzone* %zone617)
; malloc closure structure
%clsptr618 = call i8* @llvm_zone_malloc(%mzone* %zone617, i64 24)
%closure619 = bitcast i8* %clsptr618 to { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr620 = call i8* @llvm_zone_malloc(%mzone* %zone617, i64 8)
%environment621 = bitcast i8* %envptr620 to {{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable622 = call %clsvar* @new_address_table()
%var623 = bitcast [52 x i8]* @gsxtmbase58 to i8*
%var624 = bitcast [59 x i8]* @gsxtmbase59 to i8*
%addytable625 = call %clsvar* @add_address_table(%mzone* %zone617, i8* %var623, i32 0, i8* %var624, i32 3, %clsvar* %addytable622)
%address-table626 = bitcast %clsvar* %addytable625 to i8*

; insert table, function and environment into closure struct
%closure.table629 = getelementptr { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure619, i32 0, i32 0
store i8* %address-table626, i8** %closure.table629
%closure.env630 = getelementptr { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure619, i32 0, i32 1
store i8* %envptr620, i8** %closure.env630
%closure.func631 = getelementptr { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure619, i32 0, i32 2
store double (i8*, i8*, double, %mzone*, %mzone*)* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0__613, double (i8*, i8*, double, %mzone*, %mzone*)** %closure.func631
%closure_size632 = call i64 @llvm_zone_mark_size(%mzone* %zone617)
call void @llvm_zone_ptr_set_size(i8* %clsptr618, i64 %closure_size632)
%wrapper_ptr633 = call i8* @llvm_zone_malloc(%mzone* %zone617, i64 8)
%closure_wrapper634 = bitcast i8* %wrapper_ptr633 to { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**
store { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure619, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_wrapper634

; let value assignment
%zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_wrapper634, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_wrapper634
store { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0, { i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0
%tmp_envptr628 = getelementptr {{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***}, {{i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}***}* %environment621, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**** %tmp_envptr628


%val637 = load {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*** %zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %val637
}


@zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0(double %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %mzone*, %mzone*)*,  double (i8*, i8*, double, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret double %result
}


define dllexport ccc double @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_native(double %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %mzone*, %mzone*)*,  double (i8*, i8*, double, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret double %result
}


define dllexport ccc i8*  @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var638 = bitcast [105 x i8]* @gsxtmbase60 to i8*
call i32 (i8*, ...) @printf(i8* %var638)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var639 = bitcast [105 x i8]* @gsxtmbase60 to i8*
call i32 (i8*, ...) @printf(i8* %var639)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var640 = bitcast [105 x i8]* @gsxtmbase60 to i8*
call i32 (i8*, ...) @printf(i8* %var640)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %mzone*, %mzone*)*,  double (i8*, i8*, double, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {double, %mzone*, %mzone*}, {double, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, %mzone*, %mzone*}, {double, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {double, %mzone*, %mzone*}, {double, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W2RvdWJsZSxkb3VibGUsbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}*, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}, {i8*, i8*, double (i8*, i8*, double, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %mzone*, %mzone*)*,  double (i8*, i8*, double, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%String = type {i64,i8*}
@gsxtmbase61 = hidden constant [37 x i8] c"String_adhoc_W1N0cmluZyosaTY0LGk4Kl0\00"
@gsxtmbase62 = hidden constant [45 x i8] c"{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**\00"
define dllexport fastcc %String* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0__641(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone642 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}*
%String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**** %String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone647 = load i8*, i8** %_impzPtr
%zone648 = bitcast i8* %tzone647 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %String*
%tzone643 = load i8*, i8** %_impzPtr
%zone644 = bitcast i8* %tzone643 to %mzone*
%dat645 = call i8* @llvm_zone_malloc(%mzone* %zone644, i64 16)
call i8* @memset(i8* %dat645, i32 0, i64 16)
%val646 = bitcast i8* %dat645 to %String*

; let value assignment
%obj = select i1 true, %String* %val646, %String* %val646
store %String* %obj, %String** %objPtr

%val649 = load %String*, %String** %objPtr
%val650 = load i64, i64* %arg_0Ptr
; set tuple
%val651 = getelementptr %String, %String* %val649, i64 0, i32 0
store i64 %val650, i64* %val651
%val652 = load %String*, %String** %objPtr
%val653 = load i8*, i8** %arg_1Ptr
; set tuple
%val654 = getelementptr %String, %String* %val652, i64 0, i32 1
store i8* %val653, i8** %val654
%val655 = load %String*, %String** %objPtr
ret %String* %val655
}
@gsxtmbase63 = hidden constant [90 x i8] c"String_adhoc_W1N0cmluZyosaTY0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone675 = load i8*, i8** %_impzPtr
%zone676 = bitcast i8* %tzone675 to %mzone*

; let assign value to symbol String_adhoc_W1N0cmluZyosaTY0LGk4Kl0
%dat_String_adhoc_W1N0cmluZyosaTY0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone676, i64 8)
%String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr = bitcast i8* %dat_String_adhoc_W1N0cmluZyosaTY0LGk4Kl0 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***
%tzone656 = load i8*, i8** %_impzPtr
%zone657 = bitcast i8* %tzone656 to %mzone*
call void @llvm_zone_mark(%mzone* %zone657)
; malloc closure structure
%clsptr658 = call i8* @llvm_zone_malloc(%mzone* %zone657, i64 24)
%closure659 = bitcast i8* %clsptr658 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr660 = call i8* @llvm_zone_malloc(%mzone* %zone657, i64 8)
%environment661 = bitcast i8* %envptr660 to {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable662 = call %clsvar* @new_address_table()
%var663 = bitcast [37 x i8]* @gsxtmbase61 to i8*
%var664 = bitcast [45 x i8]* @gsxtmbase62 to i8*
%addytable665 = call %clsvar* @add_address_table(%mzone* %zone657, i8* %var663, i32 0, i8* %var664, i32 3, %clsvar* %addytable662)
%address-table666 = bitcast %clsvar* %addytable665 to i8*

; insert table, function and environment into closure struct
%closure.table669 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure659, i32 0, i32 0
store i8* %address-table666, i8** %closure.table669
%closure.env670 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure659, i32 0, i32 1
store i8* %envptr660, i8** %closure.env670
%closure.func671 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure659, i32 0, i32 2
store %String* (i8*, i8*, i64, i8*)* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0__641, %String* (i8*, i8*, i64, i8*)** %closure.func671
%closure_size672 = call i64 @llvm_zone_mark_size(%mzone* %zone657)
call void @llvm_zone_ptr_set_size(i8* %clsptr658, i64 %closure_size672)
%wrapper_ptr673 = call i8* @llvm_zone_malloc(%mzone* %zone657, i64 8)
%closure_wrapper674 = bitcast i8* %wrapper_ptr673 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure659, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper674

; let value assignment
%String_adhoc_W1N0cmluZyosaTY0LGk4Kl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper674, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper674
store { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %String_adhoc_W1N0cmluZyosaTY0LGk4Kl0, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var String_adhoc_W1N0cmluZyosaTY0LGk4Kl0
%tmp_envptr668 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}* %environment661, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**** %tmp_envptr668


%val677 = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %val677
}


@String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String* %result
}


define dllexport ccc %String* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String* %result
}


define dllexport ccc i8*  @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var678 = bitcast [90 x i8]* @gsxtmbase63 to i8*
call i32 (i8*, ...) @printf(i8* %var678)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var679 = bitcast [90 x i8]* @gsxtmbase63 to i8*
call i32 (i8*, ...) @printf(i8* %var679)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase64 = hidden constant [39 x i8] c"String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0\00"
define dllexport fastcc %String* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0__680(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone681 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}*
%String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**** %String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone686 = load i8*, i8** %_impzPtr
%zone687 = bitcast i8* %tzone686 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %String*
%tzone682 = load i8*, i8** %_impzPtr
%zone683 = bitcast i8* %tzone682 to %mzone*
%dat684 = call i8* @llvm_zone_malloc(%mzone* %zone683, i64 16)
call i8* @memset(i8* %dat684, i32 0, i64 16)
%val685 = bitcast i8* %dat684 to %String*

; let value assignment
%obj = select i1 true, %String* %val685, %String* %val685
store %String* %obj, %String** %objPtr

%val688 = load %String*, %String** %objPtr
%val689 = load i64, i64* %arg_0Ptr
; set tuple
%val690 = getelementptr %String, %String* %val688, i64 0, i32 0
store i64 %val689, i64* %val690
%val691 = load %String*, %String** %objPtr
%val692 = load i8*, i8** %arg_1Ptr
; set tuple
%val693 = getelementptr %String, %String* %val691, i64 0, i32 1
store i8* %val692, i8** %val693
%val694 = load %String*, %String** %objPtr
ret %String* %val694
}
@gsxtmbase65 = hidden constant [92 x i8] c"String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone714 = load i8*, i8** %_impzPtr
%zone715 = bitcast i8* %tzone714 to %mzone*

; let assign value to symbol String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0
%dat_String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone715, i64 8)
%String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr = bitcast i8* %dat_String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***
%tzone695 = load i8*, i8** %_impzPtr
%zone696 = bitcast i8* %tzone695 to %mzone*
call void @llvm_zone_mark(%mzone* %zone696)
; malloc closure structure
%clsptr697 = call i8* @llvm_zone_malloc(%mzone* %zone696, i64 24)
%closure698 = bitcast i8* %clsptr697 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr699 = call i8* @llvm_zone_malloc(%mzone* %zone696, i64 8)
%environment700 = bitcast i8* %envptr699 to {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable701 = call %clsvar* @new_address_table()
%var702 = bitcast [39 x i8]* @gsxtmbase64 to i8*
%var703 = bitcast [45 x i8]* @gsxtmbase62 to i8*
%addytable704 = call %clsvar* @add_address_table(%mzone* %zone696, i8* %var702, i32 0, i8* %var703, i32 3, %clsvar* %addytable701)
%address-table705 = bitcast %clsvar* %addytable704 to i8*

; insert table, function and environment into closure struct
%closure.table708 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure698, i32 0, i32 0
store i8* %address-table705, i8** %closure.table708
%closure.env709 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure698, i32 0, i32 1
store i8* %envptr699, i8** %closure.env709
%closure.func710 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure698, i32 0, i32 2
store %String* (i8*, i8*, i64, i8*)* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0__680, %String* (i8*, i8*, i64, i8*)** %closure.func710
%closure_size711 = call i64 @llvm_zone_mark_size(%mzone* %zone696)
call void @llvm_zone_ptr_set_size(i8* %clsptr697, i64 %closure_size711)
%wrapper_ptr712 = call i8* @llvm_zone_malloc(%mzone* %zone696, i64 8)
%closure_wrapper713 = bitcast i8* %wrapper_ptr712 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure698, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper713

; let value assignment
%String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper713, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper713
store { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0
%tmp_envptr707 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}* %environment700, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**** %tmp_envptr707


%val716 = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %val716
}


@String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String* %result
}


define dllexport ccc %String* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String* %result
}


define dllexport ccc i8*  @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var717 = bitcast [92 x i8]* @gsxtmbase65 to i8*
call i32 (i8*, ...) @printf(i8* %var717)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var718 = bitcast [92 x i8]* @gsxtmbase65 to i8*
call i32 (i8*, ...) @printf(i8* %var718)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase66 = hidden constant [39 x i8] c"String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0\00"
define dllexport fastcc %String* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0__719(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone720 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}*
%String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**** %String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone723 = load i8*, i8** %_impzPtr
%zone724 = bitcast i8* %tzone723 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %String*
%dat721 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat721, i32 0, i64 16)
%val722 = bitcast i8* %dat721 to %String*

; let value assignment
%obj = select i1 true, %String* %val722, %String* %val722
store %String* %obj, %String** %objPtr

%val725 = load %String*, %String** %objPtr
%val726 = load i64, i64* %arg_0Ptr
; set tuple
%val727 = getelementptr %String, %String* %val725, i64 0, i32 0
store i64 %val726, i64* %val727
%val728 = load %String*, %String** %objPtr
%val729 = load i8*, i8** %arg_1Ptr
; set tuple
%val730 = getelementptr %String, %String* %val728, i64 0, i32 1
store i8* %val729, i8** %val730
%val731 = load %String*, %String** %objPtr
ret %String* %val731
}
@gsxtmbase67 = hidden constant [92 x i8] c"String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone751 = load i8*, i8** %_impzPtr
%zone752 = bitcast i8* %tzone751 to %mzone*

; let assign value to symbol String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0
%dat_String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone752, i64 8)
%String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr = bitcast i8* %dat_String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***
%tzone732 = load i8*, i8** %_impzPtr
%zone733 = bitcast i8* %tzone732 to %mzone*
call void @llvm_zone_mark(%mzone* %zone733)
; malloc closure structure
%clsptr734 = call i8* @llvm_zone_malloc(%mzone* %zone733, i64 24)
%closure735 = bitcast i8* %clsptr734 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr736 = call i8* @llvm_zone_malloc(%mzone* %zone733, i64 8)
%environment737 = bitcast i8* %envptr736 to {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable738 = call %clsvar* @new_address_table()
%var739 = bitcast [39 x i8]* @gsxtmbase66 to i8*
%var740 = bitcast [45 x i8]* @gsxtmbase62 to i8*
%addytable741 = call %clsvar* @add_address_table(%mzone* %zone733, i8* %var739, i32 0, i8* %var740, i32 3, %clsvar* %addytable738)
%address-table742 = bitcast %clsvar* %addytable741 to i8*

; insert table, function and environment into closure struct
%closure.table745 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure735, i32 0, i32 0
store i8* %address-table742, i8** %closure.table745
%closure.env746 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure735, i32 0, i32 1
store i8* %envptr736, i8** %closure.env746
%closure.func747 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure735, i32 0, i32 2
store %String* (i8*, i8*, i64, i8*)* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0__719, %String* (i8*, i8*, i64, i8*)** %closure.func747
%closure_size748 = call i64 @llvm_zone_mark_size(%mzone* %zone733)
call void @llvm_zone_ptr_set_size(i8* %clsptr734, i64 %closure_size748)
%wrapper_ptr749 = call i8* @llvm_zone_malloc(%mzone* %zone733, i64 8)
%closure_wrapper750 = bitcast i8* %wrapper_ptr749 to { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure735, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper750

; let value assignment
%String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper750, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_wrapper750
store { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0, { i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0
%tmp_envptr744 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64, i8*)*}***}* %environment737, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**** %tmp_envptr744


%val753 = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*** %String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %val753
}


@String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String* %result
}


define dllexport ccc %String* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String* %result
}


define dllexport ccc i8*  @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var754 = bitcast [92 x i8]* @gsxtmbase67 to i8*
call i32 (i8*, ...) @printf(i8* %var754)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var755 = bitcast [92 x i8]* @gsxtmbase67 to i8*
call i32 (i8*, ...) @printf(i8* %var755)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64, i8*)*,  %String* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase68 = hidden constant [40 x i8] c"String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ\00"
@gsxtmbase69 = hidden constant [44 x i8] c"{i8*, i8*, %String (i8*, i8*, i64, i8*)*}**\00"
define dllexport fastcc %String @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ__756(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone757 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String (i8*, i8*, i64, i8*)*}***}*
%String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr_ = getelementptr {{i8*, i8*, %String (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr = load {i8*, i8*, %String (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}**** %String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone759 = load i8*, i8** %_impzPtr
%zone760 = bitcast i8* %tzone759 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %String*
%dat758 = alloca %String, align 16

; let value assignment
%obj = select i1 true, %String* %dat758, %String* %dat758
store %String* %obj, %String** %objPtr

%val761 = load %String*, %String** %objPtr
%val762 = load i64, i64* %arg_0Ptr
; set tuple
%val763 = getelementptr %String, %String* %val761, i64 0, i32 0
store i64 %val762, i64* %val763
%val764 = load %String*, %String** %objPtr
%val765 = load i8*, i8** %arg_1Ptr
; set tuple
%val766 = getelementptr %String, %String* %val764, i64 0, i32 1
store i8* %val765, i8** %val766
%val767 = load %String*, %String** %objPtr
; pointer ref
%val768 = getelementptr %String, %String* %val767, i64 0
%val769 = load %String, %String* %val768
ret %String %val769
}
@gsxtmbase70 = hidden constant [93 x i8] c"String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone789 = load i8*, i8** %_impzPtr
%zone790 = bitcast i8* %tzone789 to %mzone*

; let assign value to symbol String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ
%dat_String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone790, i64 8)
%String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr = bitcast i8* %dat_String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ to { i8*, i8*, %String (i8*, i8*, i64, i8*)*}***
%tzone770 = load i8*, i8** %_impzPtr
%zone771 = bitcast i8* %tzone770 to %mzone*
call void @llvm_zone_mark(%mzone* %zone771)
; malloc closure structure
%clsptr772 = call i8* @llvm_zone_malloc(%mzone* %zone771, i64 24)
%closure773 = bitcast i8* %clsptr772 to { i8*, i8*, %String (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr774 = call i8* @llvm_zone_malloc(%mzone* %zone771, i64 8)
%environment775 = bitcast i8* %envptr774 to {{i8*, i8*, %String (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable776 = call %clsvar* @new_address_table()
%var777 = bitcast [40 x i8]* @gsxtmbase68 to i8*
%var778 = bitcast [44 x i8]* @gsxtmbase69 to i8*
%addytable779 = call %clsvar* @add_address_table(%mzone* %zone771, i8* %var777, i32 0, i8* %var778, i32 3, %clsvar* %addytable776)
%address-table780 = bitcast %clsvar* %addytable779 to i8*

; insert table, function and environment into closure struct
%closure.table783 = getelementptr { i8*, i8*, %String (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure773, i32 0, i32 0
store i8* %address-table780, i8** %closure.table783
%closure.env784 = getelementptr { i8*, i8*, %String (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure773, i32 0, i32 1
store i8* %envptr774, i8** %closure.env784
%closure.func785 = getelementptr { i8*, i8*, %String (i8*, i8*, i64, i8*)*}, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure773, i32 0, i32 2
store %String (i8*, i8*, i64, i8*)* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ__756, %String (i8*, i8*, i64, i8*)** %closure.func785
%closure_size786 = call i64 @llvm_zone_mark_size(%mzone* %zone771)
call void @llvm_zone_ptr_set_size(i8* %clsptr772, i64 %closure_size786)
%wrapper_ptr787 = call i8* @llvm_zone_malloc(%mzone* %zone771, i64 8)
%closure_wrapper788 = bitcast i8* %wrapper_ptr787 to { i8*, i8*, %String (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure773, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure_wrapper788

; let value assignment
%String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ = select i1 true, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure_wrapper788, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure_wrapper788
store { i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ, { i8*, i8*, %String (i8*, i8*, i64, i8*)*}*** %String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ
%tmp_envptr782 = getelementptr {{i8*, i8*, %String (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %String (i8*, i8*, i64, i8*)*}***}* %environment775, i32 0, i32 0
store {i8*, i8*, %String (i8*, i8*, i64, i8*)*}*** %String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}**** %tmp_envptr782


%val791 = load {i8*, i8*, %String (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}*** %String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQPtr
ret {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %val791
}


@String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String (i8*, i8*, i64, i8*)*,  %String (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String %result
}


define dllexport ccc %String @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String (i8*, i8*, i64, i8*)*,  %String (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %String %result
}


define dllexport ccc void @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_val_adhoc_W1N0cmluZyxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %String (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String (i8*, i8*, i64, i8*)*}, {i8*, i8*, %String (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String (i8*, i8*, i64, i8*)*,  %String (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase71 = hidden constant [36 x i8] c"hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0\00"
@gsxtmbase72 = hidden constant [45 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*)*}**\00"
define dllexport fastcc %String* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0__794(i8* %_impz,i8* %_impenv, %String* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone795 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*
%hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_

; setup arguments
%xPtr = alloca %String*
store %String* %x, %String** %xPtr


%tzone798 = load i8*, i8** %_impzPtr
%zone799 = bitcast i8* %tzone798 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %String*
%dat796 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat796, i32 0, i64 16)
%val797 = bitcast i8* %dat796 to %String*

; let value assignment
%obj = select i1 true, %String* %val797, %String* %val797
store %String* %obj, %String** %objPtr

%val800 = load %String*, %String** %objPtr
%val801 = load %String*, %String** %xPtr
; tuple ref
%val802 = getelementptr %String, %String* %val801, i64 0, i32 0
%val803 = load i64, i64* %val802
; set tuple
%val804 = getelementptr %String, %String* %val800, i64 0, i32 0
store i64 %val803, i64* %val804
%val805 = load %String*, %String** %objPtr
%val806 = load %String*, %String** %xPtr
; tuple ref
%val807 = getelementptr %String, %String* %val806, i64 0, i32 1
%val808 = load i8*, i8** %val807
; set tuple
%val809 = getelementptr %String, %String* %val805, i64 0, i32 1
store i8* %val808, i8** %val809
%val810 = load %String*, %String** %objPtr
ret %String* %val810
}
@gsxtmbase73 = hidden constant [89 x i8] c"hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone830 = load i8*, i8** %_impzPtr
%zone831 = bitcast i8* %tzone830 to %mzone*

; let assign value to symbol hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0
%dat_hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone831, i64 8)
%hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*)*}***
%tzone811 = load i8*, i8** %_impzPtr
%zone812 = bitcast i8* %tzone811 to %mzone*
call void @llvm_zone_mark(%mzone* %zone812)
; malloc closure structure
%clsptr813 = call i8* @llvm_zone_malloc(%mzone* %zone812, i64 24)
%closure814 = bitcast i8* %clsptr813 to { i8*, i8*, %String* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr815 = call i8* @llvm_zone_malloc(%mzone* %zone812, i64 8)
%environment816 = bitcast i8* %envptr815 to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable817 = call %clsvar* @new_address_table()
%var818 = bitcast [36 x i8]* @gsxtmbase71 to i8*
%var819 = bitcast [45 x i8]* @gsxtmbase72 to i8*
%addytable820 = call %clsvar* @add_address_table(%mzone* %zone812, i8* %var818, i32 0, i8* %var819, i32 3, %clsvar* %addytable817)
%address-table821 = bitcast %clsvar* %addytable820 to i8*

; insert table, function and environment into closure struct
%closure.table824 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure814, i32 0, i32 0
store i8* %address-table821, i8** %closure.table824
%closure.env825 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure814, i32 0, i32 1
store i8* %envptr815, i8** %closure.env825
%closure.func826 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure814, i32 0, i32 2
store %String* (i8*, i8*, %String*)* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0__794, %String* (i8*, i8*, %String*)** %closure.func826
%closure_size827 = call i64 @llvm_zone_mark_size(%mzone* %zone812)
call void @llvm_zone_ptr_set_size(i8* %clsptr813, i64 %closure_size827)
%wrapper_ptr828 = call i8* @llvm_zone_malloc(%mzone* %zone812, i64 8)
%closure_wrapper829 = bitcast i8* %wrapper_ptr828 to { i8*, i8*, %String* (i8*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure814, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper829

; let value assignment
%hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper829, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper829
store { i8*, i8*, %String* (i8*, i8*, %String*)*}** %hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*)*}*** %hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0
%tmp_envptr823 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %environment816, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %tmp_envptr823


%val832 = load {i8*, i8*, %String* (i8*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*)*}** %val832
}


@hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var833 = bitcast [89 x i8]* @gsxtmbase73 to i8*
call i32 (i8*, ...) @printf(i8* %var833)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase74 = hidden constant [32 x i8] c"hfree_adhoc_W3ZvaWQsU3RyaW5nKl0\00"
@gsxtmbase75 = hidden constant [41 x i8] c"{i8*, i8*, void (i8*, i8*, %String*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0__834(i8* %_impz,i8* %_impenv, %String* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone835 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %String*)*}***}*
%hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr = load {i8*, i8*, void (i8*, i8*, %String*)*}***, {i8*, i8*, void (i8*, i8*, %String*)*}**** %hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr_

; setup arguments
%xPtr = alloca %String*
store %String* %x, %String** %xPtr


%val836 = load %String*, %String** %xPtr
%val837 = bitcast %String* %val836 to i8*
call ccc void @free(i8* %val837)
ret void
}
@gsxtmbase76 = hidden constant [85 x i8] c"hfree_adhoc_W3ZvaWQsU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %String*)*}** @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone859 = load i8*, i8** %_impzPtr
%zone860 = bitcast i8* %tzone859 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU3RyaW5nKl0
%dat_hfree_adhoc_W3ZvaWQsU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone860, i64 8)
%hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU3RyaW5nKl0 to { i8*, i8*, void (i8*, i8*, %String*)*}***
%tzone840 = load i8*, i8** %_impzPtr
%zone841 = bitcast i8* %tzone840 to %mzone*
call void @llvm_zone_mark(%mzone* %zone841)
; malloc closure structure
%clsptr842 = call i8* @llvm_zone_malloc(%mzone* %zone841, i64 24)
%closure843 = bitcast i8* %clsptr842 to { i8*, i8*, void (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr844 = call i8* @llvm_zone_malloc(%mzone* %zone841, i64 8)
%environment845 = bitcast i8* %envptr844 to {{i8*, i8*, void (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable846 = call %clsvar* @new_address_table()
%var847 = bitcast [32 x i8]* @gsxtmbase74 to i8*
%var848 = bitcast [41 x i8]* @gsxtmbase75 to i8*
%addytable849 = call %clsvar* @add_address_table(%mzone* %zone841, i8* %var847, i32 0, i8* %var848, i32 3, %clsvar* %addytable846)
%address-table850 = bitcast %clsvar* %addytable849 to i8*

; insert table, function and environment into closure struct
%closure.table853 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure843, i32 0, i32 0
store i8* %address-table850, i8** %closure.table853
%closure.env854 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure843, i32 0, i32 1
store i8* %envptr844, i8** %closure.env854
%closure.func855 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure843, i32 0, i32 2
store void (i8*, i8*, %String*)* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0__834, void (i8*, i8*, %String*)** %closure.func855
%closure_size856 = call i64 @llvm_zone_mark_size(%mzone* %zone841)
call void @llvm_zone_ptr_set_size(i8* %clsptr842, i64 %closure_size856)
%wrapper_ptr857 = call i8* @llvm_zone_malloc(%mzone* %zone841, i64 8)
%closure_wrapper858 = bitcast i8* %wrapper_ptr857 to { i8*, i8*, void (i8*, i8*, %String*)*}**
store { i8*, i8*, void (i8*, i8*, %String*)*}* %closure843, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper858

; let value assignment
%hfree_adhoc_W3ZvaWQsU3RyaW5nKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper858, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper858
store { i8*, i8*, void (i8*, i8*, %String*)*}** %hfree_adhoc_W3ZvaWQsU3RyaW5nKl0, { i8*, i8*, void (i8*, i8*, %String*)*}*** %hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU3RyaW5nKl0
%tmp_envptr852 = getelementptr {{i8*, i8*, void (i8*, i8*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %String*)*}***}* %environment845, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %String*)*}*** %hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr, {i8*, i8*, void (i8*, i8*, %String*)*}**** %tmp_envptr852


%val861 = load {i8*, i8*, void (i8*, i8*, %String*)*}**, {i8*, i8*, void (i8*, i8*, %String*)*}*** %hfree_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %String*)*}** %val861
}


@hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %String*)*}** @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var862 = bitcast [85 x i8]* @gsxtmbase76 to i8*
call i32 (i8*, ...) @printf(i8* %var862)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase77 = hidden constant [55 x i8] c"zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmbase78 = hidden constant [63 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ__863(i8* %_impz,i8* %_impenv, %String* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone864 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %String*
store %String* %x, %String** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val866 = load %mzone*, %mzone** %fromzPtr
%val867 = load %String*, %String** %xPtr
%val868 = bitcast %String* %val867 to i8*
%res869 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val866, i8* %val868)
br i1 %res869, label %then865, label %else865

then865:
%val870 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val870)
%zone_ptr871 = bitcast %mzone* %val870 to i8*
store i8* %zone_ptr871, i8** %_impzPtr
%tzone877 = load i8*, i8** %_impzPtr
%zone878 = bitcast i8* %tzone877 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %String*
%tzone873 = load i8*, i8** %_impzPtr
%zone874 = bitcast i8* %tzone873 to %mzone*
%dat875 = call i8* @llvm_zone_malloc(%mzone* %zone874, i64 16)
call i8* @memset(i8* %dat875, i32 0, i64 16)
%val876 = bitcast i8* %dat875 to %String*

; let value assignment
%obj = select i1 true, %String* %val876, %String* %val876
store %String* %obj, %String** %objPtr

; promote local stack var allocations
%tzone917 = load i8*, i8** %_impzPtr
%zone918 = bitcast i8* %tzone917 to %mzone*
%ifptr884 = alloca i8*
%val879 = load %String*, %String** %objPtr
%val880 = load %String*, %String** %xPtr
; tuple ref
%val881 = getelementptr %String, %String* %val880, i64 0, i32 0
%val882 = load i64, i64* %val881
; set tuple
%val883 = getelementptr %String, %String* %val879, i64 0, i32 0
store i64 %val882, i64* %val883
%val885 = load %mzone*, %mzone** %fromzPtr
%val886 = load %String*, %String** %xPtr
; tuple ref
%val887 = getelementptr %String, %String* %val886, i64 0, i32 1
%val888 = load i8*, i8** %val887
%val889 = bitcast i8* %val888 to i8*
%res890 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val885, i8* %val889)
br i1 %res890, label %then884, label %else884

then884:
%tzone895 = load i8*, i8** %_impzPtr
%zone896 = bitcast i8* %tzone895 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i8*
%tzone891 = load i8*, i8** %_impzPtr
%zone892 = bitcast i8* %tzone891 to %mzone*
%dat893 = call i8* @llvm_zone_malloc(%mzone* %zone892, i64 1)
call i8* @memset(i8* %dat893, i32 0, i64 1)
%val894 = bitcast i8* %dat893 to i8*

; let value assignment
%newptr = select i1 true, i8* %val894, i8* %val894
store i8* %newptr, i8** %newptrPtr

%val897 = load i8*, i8** %newptrPtr
%val898 = bitcast i8* %val897 to i8*
%val899 = load %String*, %String** %xPtr
; tuple ref
%val900 = getelementptr %String, %String* %val899, i64 0, i32 1
%val901 = load i8*, i8** %val900
%val902 = bitcast i8* %val901 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val898, i8* %val902, i64 1, i32 1, i1 0)
%val904 = load %String*, %String** %objPtr
%val905 = load i8*, i8** %newptrPtr
; set tuple
%val906 = getelementptr %String, %String* %val904, i64 0, i32 1
store i8* %val905, i8** %val906
store i8* %val905, i8** %ifptr884
br label %ifcont884

else884:
%val907 = load %String*, %String** %objPtr
%val908 = load %String*, %String** %xPtr
; tuple ref
%val909 = getelementptr %String, %String* %val908, i64 0, i32 1
%val910 = load i8*, i8** %val909
; set tuple
%val911 = getelementptr %String, %String* %val907, i64 0, i32 1
store i8* %val910, i8** %val911
store i8* %val910, i8** %ifptr884
br label %ifcont884

ifcont884:
%ifres912 = load i8*, i8** %ifptr884

%oldzone913 = call %mzone* @llvm_pop_zone_stack()
%newzone914 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr915 = bitcast %mzone* %newzone914 to i8*
store i8* %zone_ptr915, i8** %_impzPtr
%val916 = load %String*, %String** %objPtr
ret %String* %val916

else865:
%val919 = load %String*, %String** %xPtr
ret %String* %val919
}
@gsxtmbase79 = hidden constant [108 x i8] c"zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone939 = load i8*, i8** %_impzPtr
%zone940 = bitcast i8* %tzone939 to %mzone*

; let assign value to symbol zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone940, i64 8)
%zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***
%tzone920 = load i8*, i8** %_impzPtr
%zone921 = bitcast i8* %tzone920 to %mzone*
call void @llvm_zone_mark(%mzone* %zone921)
; malloc closure structure
%clsptr922 = call i8* @llvm_zone_malloc(%mzone* %zone921, i64 24)
%closure923 = bitcast i8* %clsptr922 to { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr924 = call i8* @llvm_zone_malloc(%mzone* %zone921, i64 8)
%environment925 = bitcast i8* %envptr924 to {{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable926 = call %clsvar* @new_address_table()
%var927 = bitcast [55 x i8]* @gsxtmbase77 to i8*
%var928 = bitcast [63 x i8]* @gsxtmbase78 to i8*
%addytable929 = call %clsvar* @add_address_table(%mzone* %zone921, i8* %var927, i32 0, i8* %var928, i32 3, %clsvar* %addytable926)
%address-table930 = bitcast %clsvar* %addytable929 to i8*

; insert table, function and environment into closure struct
%closure.table933 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure923, i32 0, i32 0
store i8* %address-table930, i8** %closure.table933
%closure.env934 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure923, i32 0, i32 1
store i8* %envptr924, i8** %closure.env934
%closure.func935 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure923, i32 0, i32 2
store %String* (i8*, i8*, %String*, %mzone*, %mzone*)* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ__863, %String* (i8*, i8*, %String*, %mzone*, %mzone*)** %closure.func935
%closure_size936 = call i64 @llvm_zone_mark_size(%mzone* %zone921)
call void @llvm_zone_ptr_set_size(i8* %clsptr922, i64 %closure_size936)
%wrapper_ptr937 = call i8* @llvm_zone_malloc(%mzone* %zone921, i64 8)
%closure_wrapper938 = bitcast i8* %wrapper_ptr937 to { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure923, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_wrapper938

; let value assignment
%zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_wrapper938, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_wrapper938
store { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ
%tmp_envptr932 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}***}* %environment925, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**** %tmp_envptr932


%val941 = load {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %val941
}


@zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %mzone*, %mzone*)*,  %String* (i8*, i8*, %String*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_native(%String* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %mzone*, %mzone*)*,  %String* (i8*, i8*, %String*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var942 = bitcast [108 x i8]* @gsxtmbase79 to i8*
call i32 (i8*, ...) @printf(i8* %var942)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var943 = bitcast [108 x i8]* @gsxtmbase79 to i8*
call i32 (i8*, ...) @printf(i8* %var943)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var944 = bitcast [108 x i8]* @gsxtmbase79 to i8*
call i32 (i8*, ...) @printf(i8* %var944)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %mzone*, %mzone*)*,  %String* (i8*, i8*, %String*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%String*, %mzone*, %mzone*}, {%String*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %mzone*, %mzone*}, {%String*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%String*, %mzone*, %mzone*}, {%String*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %mzone*, %mzone*)*,  %String* (i8*, i8*, %String*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase80 = hidden constant [32 x i8] c"String_adhoc_W1N0cmluZyosaTgqXQ\00"
@gsxtmbase81 = hidden constant [40 x i8] c"{i8*, i8*, %String* (i8*, i8*, i8*)*}**\00"
define dllexport fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ__945(i8* %_impz,i8* %_impenv, i8* %cstr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone946 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*
%String_adhoc_W1N0cmluZyosaTgqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%String_adhoc_W1N0cmluZyosaTgqXQPtr = load {i8*, i8*, %String* (i8*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %String_adhoc_W1N0cmluZyosaTgqXQPtr_

; setup arguments
%cstrPtr = alloca i8*
store i8* %cstr, i8** %cstrPtr


%tzone949 = load i8*, i8** %_impzPtr
%zone950 = bitcast i8* %tzone949 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%tzone959 = load i8*, i8** %_impzPtr
%zone960 = bitcast i8* %tzone959 to %mzone*

; let assign value to symbol buf
%bufPtr = alloca i8*
%val947 = load i8*, i8** %cstrPtr
%res948 = call ccc i64 @strlen(i8* %val947)

; let value assignment
%len = select i1 true, i64 %res948, i64 %res948
store i64 %len, i64* %lenPtr

%val951 = load i64, i64* %lenPtr
%val952 = add i64 %val951, 1
%val953 = getelementptr i64, i64* null, i32 1
%zonesize954 = mul i64 1, %val952
%tzone955 = load i8*, i8** %_impzPtr
%zone956 = bitcast i8* %tzone955 to %mzone*
%dat957 = call i8* @llvm_zone_malloc(%mzone* %zone956, i64 %zonesize954)
call i8* @memset(i8* %dat957, i32 0, i64 %zonesize954)
%val958 = bitcast i8* %dat957 to i8*

; let value assignment
%buf = select i1 true, i8* %val958, i8* %val958
store i8* %buf, i8** %bufPtr

%val961 = load i8*, i8** %bufPtr
%val962 = load i8*, i8** %cstrPtr
%val963 = load i64, i64* %lenPtr
%val964 = add i64 %val963, 1
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val961, i8* %val962, i64 %val964, i32 1, i1 0)
%val966 = load i64, i64* %lenPtr
%val967 = load i8*, i8** %bufPtr
%res968 = call fastcc %String* @String_z_adhoc_W1N0cmluZyosaTY0LGk4Kl0(i64 %val966, i8* %val967)
ret %String* %res968
}
@gsxtmbase82 = hidden constant [85 x i8] c"String_adhoc_W1N0cmluZyosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @String_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone988 = load i8*, i8** %_impzPtr
%zone989 = bitcast i8* %tzone988 to %mzone*

; let assign value to symbol String_adhoc_W1N0cmluZyosaTgqXQ
%dat_String_adhoc_W1N0cmluZyosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone989, i64 8)
%String_adhoc_W1N0cmluZyosaTgqXQPtr = bitcast i8* %dat_String_adhoc_W1N0cmluZyosaTgqXQ to { i8*, i8*, %String* (i8*, i8*, i8*)*}***
%tzone969 = load i8*, i8** %_impzPtr
%zone970 = bitcast i8* %tzone969 to %mzone*
call void @llvm_zone_mark(%mzone* %zone970)
; malloc closure structure
%clsptr971 = call i8* @llvm_zone_malloc(%mzone* %zone970, i64 24)
%closure972 = bitcast i8* %clsptr971 to { i8*, i8*, %String* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr973 = call i8* @llvm_zone_malloc(%mzone* %zone970, i64 8)
%environment974 = bitcast i8* %envptr973 to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable975 = call %clsvar* @new_address_table()
%var976 = bitcast [32 x i8]* @gsxtmbase80 to i8*
%var977 = bitcast [40 x i8]* @gsxtmbase81 to i8*
%addytable978 = call %clsvar* @add_address_table(%mzone* %zone970, i8* %var976, i32 0, i8* %var977, i32 3, %clsvar* %addytable975)
%address-table979 = bitcast %clsvar* %addytable978 to i8*

; insert table, function and environment into closure struct
%closure.table982 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure972, i32 0, i32 0
store i8* %address-table979, i8** %closure.table982
%closure.env983 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure972, i32 0, i32 1
store i8* %envptr973, i8** %closure.env983
%closure.func984 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure972, i32 0, i32 2
store %String* (i8*, i8*, i8*)* @String_adhoc_W1N0cmluZyosaTgqXQ__945, %String* (i8*, i8*, i8*)** %closure.func984
%closure_size985 = call i64 @llvm_zone_mark_size(%mzone* %zone970)
call void @llvm_zone_ptr_set_size(i8* %clsptr971, i64 %closure_size985)
%wrapper_ptr986 = call i8* @llvm_zone_malloc(%mzone* %zone970, i64 8)
%closure_wrapper987 = bitcast i8* %wrapper_ptr986 to { i8*, i8*, %String* (i8*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure972, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper987

; let value assignment
%String_adhoc_W1N0cmluZyosaTgqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper987, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper987
store { i8*, i8*, %String* (i8*, i8*, i8*)*}** %String_adhoc_W1N0cmluZyosaTgqXQ, { i8*, i8*, %String* (i8*, i8*, i8*)*}*** %String_adhoc_W1N0cmluZyosaTgqXQPtr

; add data to environment
; don't need to alloc for env var String_adhoc_W1N0cmluZyosaTgqXQ
%tmp_envptr981 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %environment974, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %String_adhoc_W1N0cmluZyosaTgqXQPtr, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %tmp_envptr981


%val990 = load {i8*, i8*, %String* (i8*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %String_adhoc_W1N0cmluZyosaTgqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, i8*)*}** %val990
}


@String_adhoc_W1N0cmluZyosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@String_adhoc_W1N0cmluZyosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_adhoc_W1N0cmluZyosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @String_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_adhoc_W1N0cmluZyosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @String_adhoc_W1N0cmluZyosaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @String_adhoc_W1N0cmluZyosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var991 = bitcast [85 x i8]* @gsxtmbase82 to i8*
call i32 (i8*, ...) @printf(i8* %var991)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @String_adhoc_W1N0cmluZyosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase83 = hidden constant [29 x i8] c"Str_adhoc_W1N0cmluZyosaTgqXQ\00"
define dllexport fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ__992(i8* %_impz,i8* %_impenv, i8* %cstr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone993 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*
%Str_adhoc_W1N0cmluZyosaTgqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%Str_adhoc_W1N0cmluZyosaTgqXQPtr = load {i8*, i8*, %String* (i8*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %Str_adhoc_W1N0cmluZyosaTgqXQPtr_

; setup arguments
%cstrPtr = alloca i8*
store i8* %cstr, i8** %cstrPtr


%val994 = load i8*, i8** %cstrPtr
%res995 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val994)
ret %String* %res995
}
@gsxtmbase84 = hidden constant [82 x i8] c"Str_adhoc_W1N0cmluZyosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @Str_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1015 = load i8*, i8** %_impzPtr
%zone1016 = bitcast i8* %tzone1015 to %mzone*

; let assign value to symbol Str_adhoc_W1N0cmluZyosaTgqXQ
%dat_Str_adhoc_W1N0cmluZyosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1016, i64 8)
%Str_adhoc_W1N0cmluZyosaTgqXQPtr = bitcast i8* %dat_Str_adhoc_W1N0cmluZyosaTgqXQ to { i8*, i8*, %String* (i8*, i8*, i8*)*}***
%tzone996 = load i8*, i8** %_impzPtr
%zone997 = bitcast i8* %tzone996 to %mzone*
call void @llvm_zone_mark(%mzone* %zone997)
; malloc closure structure
%clsptr998 = call i8* @llvm_zone_malloc(%mzone* %zone997, i64 24)
%closure999 = bitcast i8* %clsptr998 to { i8*, i8*, %String* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr1000 = call i8* @llvm_zone_malloc(%mzone* %zone997, i64 8)
%environment1001 = bitcast i8* %envptr1000 to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable1002 = call %clsvar* @new_address_table()
%var1003 = bitcast [29 x i8]* @gsxtmbase83 to i8*
%var1004 = bitcast [40 x i8]* @gsxtmbase81 to i8*
%addytable1005 = call %clsvar* @add_address_table(%mzone* %zone997, i8* %var1003, i32 0, i8* %var1004, i32 3, %clsvar* %addytable1002)
%address-table1006 = bitcast %clsvar* %addytable1005 to i8*

; insert table, function and environment into closure struct
%closure.table1009 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure999, i32 0, i32 0
store i8* %address-table1006, i8** %closure.table1009
%closure.env1010 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure999, i32 0, i32 1
store i8* %envptr1000, i8** %closure.env1010
%closure.func1011 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure999, i32 0, i32 2
store %String* (i8*, i8*, i8*)* @Str_adhoc_W1N0cmluZyosaTgqXQ__992, %String* (i8*, i8*, i8*)** %closure.func1011
%closure_size1012 = call i64 @llvm_zone_mark_size(%mzone* %zone997)
call void @llvm_zone_ptr_set_size(i8* %clsptr998, i64 %closure_size1012)
%wrapper_ptr1013 = call i8* @llvm_zone_malloc(%mzone* %zone997, i64 8)
%closure_wrapper1014 = bitcast i8* %wrapper_ptr1013 to { i8*, i8*, %String* (i8*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure999, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper1014

; let value assignment
%Str_adhoc_W1N0cmluZyosaTgqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper1014, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper1014
store { i8*, i8*, %String* (i8*, i8*, i8*)*}** %Str_adhoc_W1N0cmluZyosaTgqXQ, { i8*, i8*, %String* (i8*, i8*, i8*)*}*** %Str_adhoc_W1N0cmluZyosaTgqXQPtr

; add data to environment
; don't need to alloc for env var Str_adhoc_W1N0cmluZyosaTgqXQ
%tmp_envptr1008 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %environment1001, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %Str_adhoc_W1N0cmluZyosaTgqXQPtr, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %tmp_envptr1008


%val1017 = load {i8*, i8*, %String* (i8*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %Str_adhoc_W1N0cmluZyosaTgqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, i8*)*}** %val1017
}


@Str_adhoc_W1N0cmluZyosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Str_adhoc_W1N0cmluZyosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Str_adhoc_W1N0cmluZyosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @Str_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Str_adhoc_W1N0cmluZyosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @Str_adhoc_W1N0cmluZyosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1018 = bitcast [82 x i8]* @gsxtmbase84 to i8*
call i32 (i8*, ...) @printf(i8* %var1018)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Str_adhoc_W1N0cmluZyosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Str_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase85 = hidden constant [34 x i8] c"String_h_adhoc_W1N0cmluZyosaTgqXQ\00"
define dllexport fastcc %String* @String_h_adhoc_W1N0cmluZyosaTgqXQ__1019(i8* %_impz,i8* %_impenv, i8* %cstr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1020 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*
%String_h_adhoc_W1N0cmluZyosaTgqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%String_h_adhoc_W1N0cmluZyosaTgqXQPtr = load {i8*, i8*, %String* (i8*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %String_h_adhoc_W1N0cmluZyosaTgqXQPtr_

; setup arguments
%cstrPtr = alloca i8*
store i8* %cstr, i8** %cstrPtr


%tzone1023 = load i8*, i8** %_impzPtr
%zone1024 = bitcast i8* %tzone1023 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%tzone1031 = load i8*, i8** %_impzPtr
%zone1032 = bitcast i8* %tzone1031 to %mzone*

; let assign value to symbol buf
%bufPtr = alloca i8*
%val1021 = load i8*, i8** %cstrPtr
%res1022 = call ccc i64 @strlen(i8* %val1021)

; let value assignment
%len = select i1 true, i64 %res1022, i64 %res1022
store i64 %len, i64* %lenPtr

%val1025 = load i64, i64* %lenPtr
%val1026 = add i64 %val1025, 1
%val1027 = getelementptr i64, i64* null, i32 1
%zonesize1028 = mul i64 1, %val1026
%dat1029 = call i8* @malloc(i64 %zonesize1028)
call i8* @memset(i8* %dat1029, i32 0, i64 %zonesize1028)
%val1030 = bitcast i8* %dat1029 to i8*

; let value assignment
%buf = select i1 true, i8* %val1030, i8* %val1030
store i8* %buf, i8** %bufPtr

%val1033 = load i8*, i8** %bufPtr
%val1034 = load i8*, i8** %cstrPtr
%val1035 = load i64, i64* %lenPtr
%val1036 = add i64 %val1035, 1
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val1033, i8* %val1034, i64 %val1036, i32 1, i1 0)
%val1038 = load i64, i64* %lenPtr
%val1039 = load i8*, i8** %bufPtr
%res1040 = call fastcc %String* @String_h_adhoc_W1N0cmluZyosaTY0LGk4Kl0(i64 %val1038, i8* %val1039)
ret %String* %res1040
}
@gsxtmbase86 = hidden constant [87 x i8] c"String_h_adhoc_W1N0cmluZyosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @String_h_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1060 = load i8*, i8** %_impzPtr
%zone1061 = bitcast i8* %tzone1060 to %mzone*

; let assign value to symbol String_h_adhoc_W1N0cmluZyosaTgqXQ
%dat_String_h_adhoc_W1N0cmluZyosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1061, i64 8)
%String_h_adhoc_W1N0cmluZyosaTgqXQPtr = bitcast i8* %dat_String_h_adhoc_W1N0cmluZyosaTgqXQ to { i8*, i8*, %String* (i8*, i8*, i8*)*}***
%tzone1041 = load i8*, i8** %_impzPtr
%zone1042 = bitcast i8* %tzone1041 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1042)
; malloc closure structure
%clsptr1043 = call i8* @llvm_zone_malloc(%mzone* %zone1042, i64 24)
%closure1044 = bitcast i8* %clsptr1043 to { i8*, i8*, %String* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr1045 = call i8* @llvm_zone_malloc(%mzone* %zone1042, i64 8)
%environment1046 = bitcast i8* %envptr1045 to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable1047 = call %clsvar* @new_address_table()
%var1048 = bitcast [34 x i8]* @gsxtmbase85 to i8*
%var1049 = bitcast [40 x i8]* @gsxtmbase81 to i8*
%addytable1050 = call %clsvar* @add_address_table(%mzone* %zone1042, i8* %var1048, i32 0, i8* %var1049, i32 3, %clsvar* %addytable1047)
%address-table1051 = bitcast %clsvar* %addytable1050 to i8*

; insert table, function and environment into closure struct
%closure.table1054 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure1044, i32 0, i32 0
store i8* %address-table1051, i8** %closure.table1054
%closure.env1055 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure1044, i32 0, i32 1
store i8* %envptr1045, i8** %closure.env1055
%closure.func1056 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure1044, i32 0, i32 2
store %String* (i8*, i8*, i8*)* @String_h_adhoc_W1N0cmluZyosaTgqXQ__1019, %String* (i8*, i8*, i8*)** %closure.func1056
%closure_size1057 = call i64 @llvm_zone_mark_size(%mzone* %zone1042)
call void @llvm_zone_ptr_set_size(i8* %clsptr1043, i64 %closure_size1057)
%wrapper_ptr1058 = call i8* @llvm_zone_malloc(%mzone* %zone1042, i64 8)
%closure_wrapper1059 = bitcast i8* %wrapper_ptr1058 to { i8*, i8*, %String* (i8*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure1044, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper1059

; let value assignment
%String_h_adhoc_W1N0cmluZyosaTgqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper1059, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper1059
store { i8*, i8*, %String* (i8*, i8*, i8*)*}** %String_h_adhoc_W1N0cmluZyosaTgqXQ, { i8*, i8*, %String* (i8*, i8*, i8*)*}*** %String_h_adhoc_W1N0cmluZyosaTgqXQPtr

; add data to environment
; don't need to alloc for env var String_h_adhoc_W1N0cmluZyosaTgqXQ
%tmp_envptr1053 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %environment1046, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %String_h_adhoc_W1N0cmluZyosaTgqXQPtr, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %tmp_envptr1053


%val1062 = load {i8*, i8*, %String* (i8*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %String_h_adhoc_W1N0cmluZyosaTgqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, i8*)*}** %val1062
}


@String_h_adhoc_W1N0cmluZyosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@String_h_adhoc_W1N0cmluZyosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_h_adhoc_W1N0cmluZyosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @String_h_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_h_adhoc_W1N0cmluZyosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @String_h_adhoc_W1N0cmluZyosaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @String_h_adhoc_W1N0cmluZyosaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @String_h_adhoc_W1N0cmluZyosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1063 = bitcast [87 x i8]* @gsxtmbase86 to i8*
call i32 (i8*, ...) @printf(i8* %var1063)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @String_h_adhoc_W1N0cmluZyosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_h_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase87 = hidden constant [38 x i8] c"String_free_adhoc_W3ZvaWQsU3RyaW5nKl0\00"
define dllexport fastcc void @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0__1064(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1065 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %String*)*}***}*
%String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr = load {i8*, i8*, void (i8*, i8*, %String*)*}***, {i8*, i8*, void (i8*, i8*, %String*)*}**** %String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1066 = load %String*, %String** %sPtr
; tuple ref
%val1067 = getelementptr %String, %String* %val1066, i64 0, i32 1
%val1068 = load i8*, i8** %val1067
%val1069 = bitcast i8* %val1068 to i8*
call ccc void @free(i8* %val1069)
%val1071 = load %String*, %String** %sPtr
%val1072 = bitcast %String* %val1071 to i8*
call ccc void @free(i8* %val1072)
ret void
}
@gsxtmbase88 = hidden constant [91 x i8] c"String_free_adhoc_W3ZvaWQsU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %String*)*}** @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1094 = load i8*, i8** %_impzPtr
%zone1095 = bitcast i8* %tzone1094 to %mzone*

; let assign value to symbol String_free_adhoc_W3ZvaWQsU3RyaW5nKl0
%dat_String_free_adhoc_W3ZvaWQsU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1095, i64 8)
%String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr = bitcast i8* %dat_String_free_adhoc_W3ZvaWQsU3RyaW5nKl0 to { i8*, i8*, void (i8*, i8*, %String*)*}***
%tzone1075 = load i8*, i8** %_impzPtr
%zone1076 = bitcast i8* %tzone1075 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1076)
; malloc closure structure
%clsptr1077 = call i8* @llvm_zone_malloc(%mzone* %zone1076, i64 24)
%closure1078 = bitcast i8* %clsptr1077 to { i8*, i8*, void (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1079 = call i8* @llvm_zone_malloc(%mzone* %zone1076, i64 8)
%environment1080 = bitcast i8* %envptr1079 to {{i8*, i8*, void (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1081 = call %clsvar* @new_address_table()
%var1082 = bitcast [38 x i8]* @gsxtmbase87 to i8*
%var1083 = bitcast [41 x i8]* @gsxtmbase75 to i8*
%addytable1084 = call %clsvar* @add_address_table(%mzone* %zone1076, i8* %var1082, i32 0, i8* %var1083, i32 3, %clsvar* %addytable1081)
%address-table1085 = bitcast %clsvar* %addytable1084 to i8*

; insert table, function and environment into closure struct
%closure.table1088 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1078, i32 0, i32 0
store i8* %address-table1085, i8** %closure.table1088
%closure.env1089 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1078, i32 0, i32 1
store i8* %envptr1079, i8** %closure.env1089
%closure.func1090 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1078, i32 0, i32 2
store void (i8*, i8*, %String*)* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0__1064, void (i8*, i8*, %String*)** %closure.func1090
%closure_size1091 = call i64 @llvm_zone_mark_size(%mzone* %zone1076)
call void @llvm_zone_ptr_set_size(i8* %clsptr1077, i64 %closure_size1091)
%wrapper_ptr1092 = call i8* @llvm_zone_malloc(%mzone* %zone1076, i64 8)
%closure_wrapper1093 = bitcast i8* %wrapper_ptr1092 to { i8*, i8*, void (i8*, i8*, %String*)*}**
store { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1078, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1093

; let value assignment
%String_free_adhoc_W3ZvaWQsU3RyaW5nKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1093, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1093
store { i8*, i8*, void (i8*, i8*, %String*)*}** %String_free_adhoc_W3ZvaWQsU3RyaW5nKl0, { i8*, i8*, void (i8*, i8*, %String*)*}*** %String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var String_free_adhoc_W3ZvaWQsU3RyaW5nKl0
%tmp_envptr1087 = getelementptr {{i8*, i8*, void (i8*, i8*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %String*)*}***}* %environment1080, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %String*)*}*** %String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr, {i8*, i8*, void (i8*, i8*, %String*)*}**** %tmp_envptr1087


%val1096 = load {i8*, i8*, void (i8*, i8*, %String*)*}**, {i8*, i8*, void (i8*, i8*, %String*)*}*** %String_free_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %String*)*}** %val1096
}


@String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %String*)*}** @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret void
}


define dllexport ccc void @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret void
}


define dllexport ccc i8*  @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1097 = bitcast [91 x i8]* @gsxtmbase88 to i8*
call i32 (i8*, ...) @printf(i8* %var1097)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_free_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase89 = hidden constant [1 x i8] c"\00"
@gsxtmbase90 = hidden constant [5 x i8] c"'%s'\00"
@gsxtmbase91 = hidden constant [32 x i8] c"print_adhoc_W3ZvaWQsU3RyaW5nKl0\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0__1098(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1099 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %String*)*}***}*
%print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr = load {i8*, i8*, void (i8*, i8*, %String*)*}***, {i8*, i8*, void (i8*, i8*, %String*)*}**** %print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1101 = load %String*, %String** %sPtr
%val1102 = icmp eq %String* %val1101, null
br i1 %val1102, label %then1100, label %else1100

then1100:
%var1103 = bitcast [1 x i8]* @gsxtmbase89 to i8*

%val1104 = call i32 (i8*, ...) @printf(i8* %var1103)
ret void

else1100:
%var1106 = bitcast [5 x i8]* @gsxtmbase90 to i8*
%val1107 = load %String*, %String** %sPtr
; tuple ref
%val1108 = getelementptr %String, %String* %val1107, i64 0, i32 1
%val1109 = load i8*, i8** %val1108

%val1110 = call i32 (i8*, ...) @printf(i8* %var1106, i8* %val1109)
ret void
}
@gsxtmbase92 = hidden constant [85 x i8] c"print_adhoc_W3ZvaWQsU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %String*)*}** @print_adhoc_W3ZvaWQsU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1131 = load i8*, i8** %_impzPtr
%zone1132 = bitcast i8* %tzone1131 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU3RyaW5nKl0
%dat_print_adhoc_W3ZvaWQsU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1132, i64 8)
%print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU3RyaW5nKl0 to { i8*, i8*, void (i8*, i8*, %String*)*}***
%tzone1112 = load i8*, i8** %_impzPtr
%zone1113 = bitcast i8* %tzone1112 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1113)
; malloc closure structure
%clsptr1114 = call i8* @llvm_zone_malloc(%mzone* %zone1113, i64 24)
%closure1115 = bitcast i8* %clsptr1114 to { i8*, i8*, void (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1116 = call i8* @llvm_zone_malloc(%mzone* %zone1113, i64 8)
%environment1117 = bitcast i8* %envptr1116 to {{i8*, i8*, void (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1118 = call %clsvar* @new_address_table()
%var1119 = bitcast [32 x i8]* @gsxtmbase91 to i8*
%var1120 = bitcast [41 x i8]* @gsxtmbase75 to i8*
%addytable1121 = call %clsvar* @add_address_table(%mzone* %zone1113, i8* %var1119, i32 0, i8* %var1120, i32 3, %clsvar* %addytable1118)
%address-table1122 = bitcast %clsvar* %addytable1121 to i8*

; insert table, function and environment into closure struct
%closure.table1125 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1115, i32 0, i32 0
store i8* %address-table1122, i8** %closure.table1125
%closure.env1126 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1115, i32 0, i32 1
store i8* %envptr1116, i8** %closure.env1126
%closure.func1127 = getelementptr { i8*, i8*, void (i8*, i8*, %String*)*}, { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1115, i32 0, i32 2
store void (i8*, i8*, %String*)* @print_adhoc_W3ZvaWQsU3RyaW5nKl0__1098, void (i8*, i8*, %String*)** %closure.func1127
%closure_size1128 = call i64 @llvm_zone_mark_size(%mzone* %zone1113)
call void @llvm_zone_ptr_set_size(i8* %clsptr1114, i64 %closure_size1128)
%wrapper_ptr1129 = call i8* @llvm_zone_malloc(%mzone* %zone1113, i64 8)
%closure_wrapper1130 = bitcast i8* %wrapper_ptr1129 to { i8*, i8*, void (i8*, i8*, %String*)*}**
store { i8*, i8*, void (i8*, i8*, %String*)*}* %closure1115, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1130

; let value assignment
%print_adhoc_W3ZvaWQsU3RyaW5nKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1130, { i8*, i8*, void (i8*, i8*, %String*)*}** %closure_wrapper1130
store { i8*, i8*, void (i8*, i8*, %String*)*}** %print_adhoc_W3ZvaWQsU3RyaW5nKl0, { i8*, i8*, void (i8*, i8*, %String*)*}*** %print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU3RyaW5nKl0
%tmp_envptr1124 = getelementptr {{i8*, i8*, void (i8*, i8*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %String*)*}***}* %environment1117, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %String*)*}*** %print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr, {i8*, i8*, void (i8*, i8*, %String*)*}**** %tmp_envptr1124


%val1133 = load {i8*, i8*, void (i8*, i8*, %String*)*}**, {i8*, i8*, void (i8*, i8*, %String*)*}*** %print_adhoc_W3ZvaWQsU3RyaW5nKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %String*)*}** %val1133
}


@print_adhoc_W3ZvaWQsU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %String*)*}** @print_adhoc_W3ZvaWQsU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1134 = bitcast [85 x i8]* @gsxtmbase92 to i8*
call i32 (i8*, ...) @printf(i8* %var1134)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %String*)*}, {i8*, i8*, void (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %String*)*,  void (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase93 = hidden constant [39 x i8] c"toString_adhoc_W1N0cmluZyosU3RyaW5nKl0\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0__1135(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1136 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*
%toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1137 = load %String*, %String** %sPtr
ret %String* %val1137
}
@gsxtmbase94 = hidden constant [92 x i8] c"toString_adhoc_W1N0cmluZyosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1157 = load i8*, i8** %_impzPtr
%zone1158 = bitcast i8* %tzone1157 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosU3RyaW5nKl0
%dat_toString_adhoc_W1N0cmluZyosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1158, i64 8)
%toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*)*}***
%tzone1138 = load i8*, i8** %_impzPtr
%zone1139 = bitcast i8* %tzone1138 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1139)
; malloc closure structure
%clsptr1140 = call i8* @llvm_zone_malloc(%mzone* %zone1139, i64 24)
%closure1141 = bitcast i8* %clsptr1140 to { i8*, i8*, %String* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1142 = call i8* @llvm_zone_malloc(%mzone* %zone1139, i64 8)
%environment1143 = bitcast i8* %envptr1142 to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1144 = call %clsvar* @new_address_table()
%var1145 = bitcast [39 x i8]* @gsxtmbase93 to i8*
%var1146 = bitcast [45 x i8]* @gsxtmbase72 to i8*
%addytable1147 = call %clsvar* @add_address_table(%mzone* %zone1139, i8* %var1145, i32 0, i8* %var1146, i32 3, %clsvar* %addytable1144)
%address-table1148 = bitcast %clsvar* %addytable1147 to i8*

; insert table, function and environment into closure struct
%closure.table1151 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1141, i32 0, i32 0
store i8* %address-table1148, i8** %closure.table1151
%closure.env1152 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1141, i32 0, i32 1
store i8* %envptr1142, i8** %closure.env1152
%closure.func1153 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1141, i32 0, i32 2
store %String* (i8*, i8*, %String*)* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0__1135, %String* (i8*, i8*, %String*)** %closure.func1153
%closure_size1154 = call i64 @llvm_zone_mark_size(%mzone* %zone1139)
call void @llvm_zone_ptr_set_size(i8* %clsptr1140, i64 %closure_size1154)
%wrapper_ptr1155 = call i8* @llvm_zone_malloc(%mzone* %zone1139, i64 8)
%closure_wrapper1156 = bitcast i8* %wrapper_ptr1155 to { i8*, i8*, %String* (i8*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1141, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1156

; let value assignment
%toString_adhoc_W1N0cmluZyosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1156, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1156
store { i8*, i8*, %String* (i8*, i8*, %String*)*}** %toString_adhoc_W1N0cmluZyosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*)*}*** %toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosU3RyaW5nKl0
%tmp_envptr1150 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %environment1143, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %tmp_envptr1150


%val1159 = load {i8*, i8*, %String* (i8*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %toString_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*)*}** %val1159
}


@toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1160 = bitcast [92 x i8]* @gsxtmbase94 to i8*
call i32 (i8*, ...) @printf(i8* %var1160)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase95 = hidden constant [39 x i8] c"String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ\00"
@gsxtmbase96 = hidden constant [40 x i8] c"{i8*, i8*, i64 (i8*, i8*, %String*)*}**\00"
define dllexport fastcc i64 @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ__1161(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1162 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}*
%String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr = load {i8*, i8*, i64 (i8*, i8*, %String*)*}***, {i8*, i8*, i64 (i8*, i8*, %String*)*}**** %String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1163 = load %String*, %String** %sPtr
; tuple ref
%val1164 = getelementptr %String, %String* %val1163, i64 0, i32 1
%val1165 = load i8*, i8** %val1164
%res1166 = call ccc i64 @strlen(i8* %val1165)
ret i64 %res1166
}
@gsxtmbase97 = hidden constant [92 x i8] c"String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %String*)*}** @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1186 = load i8*, i8** %_impzPtr
%zone1187 = bitcast i8* %tzone1186 to %mzone*

; let assign value to symbol String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ
%dat_String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1187, i64 8)
%String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr = bitcast i8* %dat_String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ to { i8*, i8*, i64 (i8*, i8*, %String*)*}***
%tzone1167 = load i8*, i8** %_impzPtr
%zone1168 = bitcast i8* %tzone1167 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1168)
; malloc closure structure
%clsptr1169 = call i8* @llvm_zone_malloc(%mzone* %zone1168, i64 24)
%closure1170 = bitcast i8* %clsptr1169 to { i8*, i8*, i64 (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1171 = call i8* @llvm_zone_malloc(%mzone* %zone1168, i64 8)
%environment1172 = bitcast i8* %envptr1171 to {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1173 = call %clsvar* @new_address_table()
%var1174 = bitcast [39 x i8]* @gsxtmbase95 to i8*
%var1175 = bitcast [40 x i8]* @gsxtmbase96 to i8*
%addytable1176 = call %clsvar* @add_address_table(%mzone* %zone1168, i8* %var1174, i32 0, i8* %var1175, i32 3, %clsvar* %addytable1173)
%address-table1177 = bitcast %clsvar* %addytable1176 to i8*

; insert table, function and environment into closure struct
%closure.table1180 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1170, i32 0, i32 0
store i8* %address-table1177, i8** %closure.table1180
%closure.env1181 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1170, i32 0, i32 1
store i8* %envptr1171, i8** %closure.env1181
%closure.func1182 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1170, i32 0, i32 2
store i64 (i8*, i8*, %String*)* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ__1161, i64 (i8*, i8*, %String*)** %closure.func1182
%closure_size1183 = call i64 @llvm_zone_mark_size(%mzone* %zone1168)
call void @llvm_zone_ptr_set_size(i8* %clsptr1169, i64 %closure_size1183)
%wrapper_ptr1184 = call i8* @llvm_zone_malloc(%mzone* %zone1168, i64 8)
%closure_wrapper1185 = bitcast i8* %wrapper_ptr1184 to { i8*, i8*, i64 (i8*, i8*, %String*)*}**
store { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1170, { i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_wrapper1185

; let value assignment
%String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_wrapper1185, { i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_wrapper1185
store { i8*, i8*, i64 (i8*, i8*, %String*)*}** %String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ, { i8*, i8*, i64 (i8*, i8*, %String*)*}*** %String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ
%tmp_envptr1179 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}* %environment1172, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %String*)*}*** %String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr, {i8*, i8*, i64 (i8*, i8*, %String*)*}**** %tmp_envptr1179


%val1188 = load {i8*, i8*, i64 (i8*, i8*, %String*)*}**, {i8*, i8*, i64 (i8*, i8*, %String*)*}*** %String_strlen_adhoc_W2k2NCxTdHJpbmcqXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %String*)*}** %val1188
}


@String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %String*)*}** @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1189 = bitcast [92 x i8]* @gsxtmbase97 to i8*
call i32 (i8*, ...) @printf(i8* %var1189)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_strlen_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase98 = hidden constant [32 x i8] c"length_adhoc_W2k2NCxTdHJpbmcqXQ\00"
define dllexport fastcc i64 @length_adhoc_W2k2NCxTdHJpbmcqXQ__1190(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1191 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}*
%length_adhoc_W2k2NCxTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%length_adhoc_W2k2NCxTdHJpbmcqXQPtr = load {i8*, i8*, i64 (i8*, i8*, %String*)*}***, {i8*, i8*, i64 (i8*, i8*, %String*)*}**** %length_adhoc_W2k2NCxTdHJpbmcqXQPtr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1192 = load %String*, %String** %sPtr
; tuple ref
%val1193 = getelementptr %String, %String* %val1192, i64 0, i32 0
%val1194 = load i64, i64* %val1193
ret i64 %val1194
}
@gsxtmbase99 = hidden constant [85 x i8] c"length_adhoc_W2k2NCxTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %String*)*}** @length_adhoc_W2k2NCxTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1214 = load i8*, i8** %_impzPtr
%zone1215 = bitcast i8* %tzone1214 to %mzone*

; let assign value to symbol length_adhoc_W2k2NCxTdHJpbmcqXQ
%dat_length_adhoc_W2k2NCxTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1215, i64 8)
%length_adhoc_W2k2NCxTdHJpbmcqXQPtr = bitcast i8* %dat_length_adhoc_W2k2NCxTdHJpbmcqXQ to { i8*, i8*, i64 (i8*, i8*, %String*)*}***
%tzone1195 = load i8*, i8** %_impzPtr
%zone1196 = bitcast i8* %tzone1195 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1196)
; malloc closure structure
%clsptr1197 = call i8* @llvm_zone_malloc(%mzone* %zone1196, i64 24)
%closure1198 = bitcast i8* %clsptr1197 to { i8*, i8*, i64 (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1199 = call i8* @llvm_zone_malloc(%mzone* %zone1196, i64 8)
%environment1200 = bitcast i8* %envptr1199 to {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1201 = call %clsvar* @new_address_table()
%var1202 = bitcast [32 x i8]* @gsxtmbase98 to i8*
%var1203 = bitcast [40 x i8]* @gsxtmbase96 to i8*
%addytable1204 = call %clsvar* @add_address_table(%mzone* %zone1196, i8* %var1202, i32 0, i8* %var1203, i32 3, %clsvar* %addytable1201)
%address-table1205 = bitcast %clsvar* %addytable1204 to i8*

; insert table, function and environment into closure struct
%closure.table1208 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1198, i32 0, i32 0
store i8* %address-table1205, i8** %closure.table1208
%closure.env1209 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1198, i32 0, i32 1
store i8* %envptr1199, i8** %closure.env1209
%closure.func1210 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1198, i32 0, i32 2
store i64 (i8*, i8*, %String*)* @length_adhoc_W2k2NCxTdHJpbmcqXQ__1190, i64 (i8*, i8*, %String*)** %closure.func1210
%closure_size1211 = call i64 @llvm_zone_mark_size(%mzone* %zone1196)
call void @llvm_zone_ptr_set_size(i8* %clsptr1197, i64 %closure_size1211)
%wrapper_ptr1212 = call i8* @llvm_zone_malloc(%mzone* %zone1196, i64 8)
%closure_wrapper1213 = bitcast i8* %wrapper_ptr1212 to { i8*, i8*, i64 (i8*, i8*, %String*)*}**
store { i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure1198, { i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_wrapper1213

; let value assignment
%length_adhoc_W2k2NCxTdHJpbmcqXQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_wrapper1213, { i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_wrapper1213
store { i8*, i8*, i64 (i8*, i8*, %String*)*}** %length_adhoc_W2k2NCxTdHJpbmcqXQ, { i8*, i8*, i64 (i8*, i8*, %String*)*}*** %length_adhoc_W2k2NCxTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var length_adhoc_W2k2NCxTdHJpbmcqXQ
%tmp_envptr1207 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %String*)*}***}* %environment1200, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %String*)*}*** %length_adhoc_W2k2NCxTdHJpbmcqXQPtr, {i8*, i8*, i64 (i8*, i8*, %String*)*}**** %tmp_envptr1207


%val1216 = load {i8*, i8*, i64 (i8*, i8*, %String*)*}**, {i8*, i8*, i64 (i8*, i8*, %String*)*}*** %length_adhoc_W2k2NCxTdHJpbmcqXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %String*)*}** %val1216
}


@length_adhoc_W2k2NCxTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@length_adhoc_W2k2NCxTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @length_adhoc_W2k2NCxTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %String*)*}** @length_adhoc_W2k2NCxTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @length_adhoc_W2k2NCxTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @length_adhoc_W2k2NCxTdHJpbmcqXQ(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @length_adhoc_W2k2NCxTdHJpbmcqXQ_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @length_adhoc_W2k2NCxTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1217 = bitcast [85 x i8]* @gsxtmbase99 to i8*
call i32 (i8*, ...) @printf(i8* %var1217)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @length_adhoc_W2k2NCxTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*)*,  i64 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase100 = hidden constant [32 x i8] c"validate_adhoc_W2kxLFN0cmluZypd\00"
@gsxtmbase101 = hidden constant [39 x i8] c"{i8*, i8*, i1 (i8*, i8*, %String*)*}**\00"
define dllexport fastcc i1 @validate_adhoc_W2kxLFN0cmluZypd__1218(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1219 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %String*)*}***}*
%validate_adhoc_W2kxLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %String*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%validate_adhoc_W2kxLFN0cmluZypdPtr = load {i8*, i8*, i1 (i8*, i8*, %String*)*}***, {i8*, i8*, i1 (i8*, i8*, %String*)*}**** %validate_adhoc_W2kxLFN0cmluZypdPtr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1220 = load %String*, %String** %sPtr
; tuple ref
%val1221 = getelementptr %String, %String* %val1220, i64 0, i32 0
%val1222 = load i64, i64* %val1221
%val1223 = load %String*, %String** %sPtr
; tuple ref
%val1224 = getelementptr %String, %String* %val1223, i64 0, i32 1
%val1225 = load i8*, i8** %val1224
%res1226 = call ccc i64 @strlen(i8* %val1225)
%cmp1227 = icmp eq i64 %val1222, %res1226
ret i1 %cmp1227
}
@gsxtmbase102 = hidden constant [85 x i8] c"validate_adhoc_W2kxLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %String*)*}** @validate_adhoc_W2kxLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1247 = load i8*, i8** %_impzPtr
%zone1248 = bitcast i8* %tzone1247 to %mzone*

; let assign value to symbol validate_adhoc_W2kxLFN0cmluZypd
%dat_validate_adhoc_W2kxLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone1248, i64 8)
%validate_adhoc_W2kxLFN0cmluZypdPtr = bitcast i8* %dat_validate_adhoc_W2kxLFN0cmluZypd to { i8*, i8*, i1 (i8*, i8*, %String*)*}***
%tzone1228 = load i8*, i8** %_impzPtr
%zone1229 = bitcast i8* %tzone1228 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1229)
; malloc closure structure
%clsptr1230 = call i8* @llvm_zone_malloc(%mzone* %zone1229, i64 24)
%closure1231 = bitcast i8* %clsptr1230 to { i8*, i8*, i1 (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1232 = call i8* @llvm_zone_malloc(%mzone* %zone1229, i64 8)
%environment1233 = bitcast i8* %envptr1232 to {{i8*, i8*, i1 (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1234 = call %clsvar* @new_address_table()
%var1235 = bitcast [32 x i8]* @gsxtmbase100 to i8*
%var1236 = bitcast [39 x i8]* @gsxtmbase101 to i8*
%addytable1237 = call %clsvar* @add_address_table(%mzone* %zone1229, i8* %var1235, i32 0, i8* %var1236, i32 3, %clsvar* %addytable1234)
%address-table1238 = bitcast %clsvar* %addytable1237 to i8*

; insert table, function and environment into closure struct
%closure.table1241 = getelementptr { i8*, i8*, i1 (i8*, i8*, %String*)*}, { i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure1231, i32 0, i32 0
store i8* %address-table1238, i8** %closure.table1241
%closure.env1242 = getelementptr { i8*, i8*, i1 (i8*, i8*, %String*)*}, { i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure1231, i32 0, i32 1
store i8* %envptr1232, i8** %closure.env1242
%closure.func1243 = getelementptr { i8*, i8*, i1 (i8*, i8*, %String*)*}, { i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure1231, i32 0, i32 2
store i1 (i8*, i8*, %String*)* @validate_adhoc_W2kxLFN0cmluZypd__1218, i1 (i8*, i8*, %String*)** %closure.func1243
%closure_size1244 = call i64 @llvm_zone_mark_size(%mzone* %zone1229)
call void @llvm_zone_ptr_set_size(i8* %clsptr1230, i64 %closure_size1244)
%wrapper_ptr1245 = call i8* @llvm_zone_malloc(%mzone* %zone1229, i64 8)
%closure_wrapper1246 = bitcast i8* %wrapper_ptr1245 to { i8*, i8*, i1 (i8*, i8*, %String*)*}**
store { i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure1231, { i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_wrapper1246

; let value assignment
%validate_adhoc_W2kxLFN0cmluZypd = select i1 true, { i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_wrapper1246, { i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_wrapper1246
store { i8*, i8*, i1 (i8*, i8*, %String*)*}** %validate_adhoc_W2kxLFN0cmluZypd, { i8*, i8*, i1 (i8*, i8*, %String*)*}*** %validate_adhoc_W2kxLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var validate_adhoc_W2kxLFN0cmluZypd
%tmp_envptr1240 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %String*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %String*)*}***}* %environment1233, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %String*)*}*** %validate_adhoc_W2kxLFN0cmluZypdPtr, {i8*, i8*, i1 (i8*, i8*, %String*)*}**** %tmp_envptr1240


%val1249 = load {i8*, i8*, i1 (i8*, i8*, %String*)*}**, {i8*, i8*, i1 (i8*, i8*, %String*)*}*** %validate_adhoc_W2kxLFN0cmluZypdPtr
ret {i8*, i8*, i1 (i8*, i8*, %String*)*}** %val1249
}


@validate_adhoc_W2kxLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@validate_adhoc_W2kxLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @validate_adhoc_W2kxLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %String*)*}** @validate_adhoc_W2kxLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @validate_adhoc_W2kxLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @validate_adhoc_W2kxLFN0cmluZypd(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*)*,  i1 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i1 %result
}


define dllexport ccc i1 @validate_adhoc_W2kxLFN0cmluZypd_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*)*,  i1 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i1 %result
}


define dllexport ccc i8*  @validate_adhoc_W2kxLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1250 = bitcast [85 x i8]* @gsxtmbase102 to i8*
call i32 (i8*, ...) @printf(i8* %var1250)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*)*,  i1 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @validate_adhoc_W2kxLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @validate_adhoc_W2kxLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*)*,  i1 (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase103 = hidden constant [33 x i8] c"cstring_adhoc_W2k4KixTdHJpbmcqXQ\00"
@gsxtmbase104 = hidden constant [40 x i8] c"{i8*, i8*, i8* (i8*, i8*, %String*)*}**\00"
define dllexport fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ__1251(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1252 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, %String*)*}***}*
%cstring_adhoc_W2k4KixTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, %String*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%cstring_adhoc_W2k4KixTdHJpbmcqXQPtr = load {i8*, i8*, i8* (i8*, i8*, %String*)*}***, {i8*, i8*, i8* (i8*, i8*, %String*)*}**** %cstring_adhoc_W2k4KixTdHJpbmcqXQPtr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1253 = load %String*, %String** %sPtr
; tuple ref
%val1254 = getelementptr %String, %String* %val1253, i64 0, i32 1
%val1255 = load i8*, i8** %val1254
ret i8* %val1255
}
@gsxtmbase105 = hidden constant [86 x i8] c"cstring_adhoc_W2k4KixTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, %String*)*}** @cstring_adhoc_W2k4KixTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1275 = load i8*, i8** %_impzPtr
%zone1276 = bitcast i8* %tzone1275 to %mzone*

; let assign value to symbol cstring_adhoc_W2k4KixTdHJpbmcqXQ
%dat_cstring_adhoc_W2k4KixTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1276, i64 8)
%cstring_adhoc_W2k4KixTdHJpbmcqXQPtr = bitcast i8* %dat_cstring_adhoc_W2k4KixTdHJpbmcqXQ to { i8*, i8*, i8* (i8*, i8*, %String*)*}***
%tzone1256 = load i8*, i8** %_impzPtr
%zone1257 = bitcast i8* %tzone1256 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1257)
; malloc closure structure
%clsptr1258 = call i8* @llvm_zone_malloc(%mzone* %zone1257, i64 24)
%closure1259 = bitcast i8* %clsptr1258 to { i8*, i8*, i8* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1260 = call i8* @llvm_zone_malloc(%mzone* %zone1257, i64 8)
%environment1261 = bitcast i8* %envptr1260 to {{i8*, i8*, i8* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1262 = call %clsvar* @new_address_table()
%var1263 = bitcast [33 x i8]* @gsxtmbase103 to i8*
%var1264 = bitcast [40 x i8]* @gsxtmbase104 to i8*
%addytable1265 = call %clsvar* @add_address_table(%mzone* %zone1257, i8* %var1263, i32 0, i8* %var1264, i32 3, %clsvar* %addytable1262)
%address-table1266 = bitcast %clsvar* %addytable1265 to i8*

; insert table, function and environment into closure struct
%closure.table1269 = getelementptr { i8*, i8*, i8* (i8*, i8*, %String*)*}, { i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure1259, i32 0, i32 0
store i8* %address-table1266, i8** %closure.table1269
%closure.env1270 = getelementptr { i8*, i8*, i8* (i8*, i8*, %String*)*}, { i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure1259, i32 0, i32 1
store i8* %envptr1260, i8** %closure.env1270
%closure.func1271 = getelementptr { i8*, i8*, i8* (i8*, i8*, %String*)*}, { i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure1259, i32 0, i32 2
store i8* (i8*, i8*, %String*)* @cstring_adhoc_W2k4KixTdHJpbmcqXQ__1251, i8* (i8*, i8*, %String*)** %closure.func1271
%closure_size1272 = call i64 @llvm_zone_mark_size(%mzone* %zone1257)
call void @llvm_zone_ptr_set_size(i8* %clsptr1258, i64 %closure_size1272)
%wrapper_ptr1273 = call i8* @llvm_zone_malloc(%mzone* %zone1257, i64 8)
%closure_wrapper1274 = bitcast i8* %wrapper_ptr1273 to { i8*, i8*, i8* (i8*, i8*, %String*)*}**
store { i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure1259, { i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_wrapper1274

; let value assignment
%cstring_adhoc_W2k4KixTdHJpbmcqXQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_wrapper1274, { i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_wrapper1274
store { i8*, i8*, i8* (i8*, i8*, %String*)*}** %cstring_adhoc_W2k4KixTdHJpbmcqXQ, { i8*, i8*, i8* (i8*, i8*, %String*)*}*** %cstring_adhoc_W2k4KixTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var cstring_adhoc_W2k4KixTdHJpbmcqXQ
%tmp_envptr1268 = getelementptr {{i8*, i8*, i8* (i8*, i8*, %String*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %String*)*}***}* %environment1261, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, %String*)*}*** %cstring_adhoc_W2k4KixTdHJpbmcqXQPtr, {i8*, i8*, i8* (i8*, i8*, %String*)*}**** %tmp_envptr1268


%val1277 = load {i8*, i8*, i8* (i8*, i8*, %String*)*}**, {i8*, i8*, i8* (i8*, i8*, %String*)*}*** %cstring_adhoc_W2k4KixTdHJpbmcqXQPtr
ret {i8*, i8*, i8* (i8*, i8*, %String*)*}** %val1277
}


@cstring_adhoc_W2k4KixTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@cstring_adhoc_W2k4KixTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @cstring_adhoc_W2k4KixTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, %String*)*}** @cstring_adhoc_W2k4KixTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %String*)*}*, {i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %String*)*,  i8* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i8* %result
}


define dllexport ccc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %String*)*}*, {i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %String*)*,  i8* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @cstring_adhoc_W2k4KixTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1278 = bitcast [86 x i8]* @gsxtmbase105 to i8*
call i32 (i8*, ...) @printf(i8* %var1278)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %String*)*}*, {i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %String*)*,  i8* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @cstring_adhoc_W2k4KixTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %String*)*}*, {i8*, i8*, i8* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %String*)*}, {i8*, i8*, i8* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %String*)*,  i8* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase106 = hidden constant [37 x i8] c"String_adhoc_W1N0cmluZyosU3RyaW5nKl0\00"
define dllexport fastcc %String* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0__1279(i8* %_impz,i8* %_impenv, %String* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1280 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*
%String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr


%val1281 = load %String*, %String** %sPtr
; tuple ref
%val1282 = getelementptr %String, %String* %val1281, i64 0, i32 1
%val1283 = load i8*, i8** %val1282
%res1284 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1283)
ret %String* %res1284
}
@gsxtmbase107 = hidden constant [90 x i8] c"String_adhoc_W1N0cmluZyosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1304 = load i8*, i8** %_impzPtr
%zone1305 = bitcast i8* %tzone1304 to %mzone*

; let assign value to symbol String_adhoc_W1N0cmluZyosU3RyaW5nKl0
%dat_String_adhoc_W1N0cmluZyosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1305, i64 8)
%String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = bitcast i8* %dat_String_adhoc_W1N0cmluZyosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*)*}***
%tzone1285 = load i8*, i8** %_impzPtr
%zone1286 = bitcast i8* %tzone1285 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1286)
; malloc closure structure
%clsptr1287 = call i8* @llvm_zone_malloc(%mzone* %zone1286, i64 24)
%closure1288 = bitcast i8* %clsptr1287 to { i8*, i8*, %String* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1289 = call i8* @llvm_zone_malloc(%mzone* %zone1286, i64 8)
%environment1290 = bitcast i8* %envptr1289 to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1291 = call %clsvar* @new_address_table()
%var1292 = bitcast [37 x i8]* @gsxtmbase106 to i8*
%var1293 = bitcast [45 x i8]* @gsxtmbase72 to i8*
%addytable1294 = call %clsvar* @add_address_table(%mzone* %zone1286, i8* %var1292, i32 0, i8* %var1293, i32 3, %clsvar* %addytable1291)
%address-table1295 = bitcast %clsvar* %addytable1294 to i8*

; insert table, function and environment into closure struct
%closure.table1298 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1288, i32 0, i32 0
store i8* %address-table1295, i8** %closure.table1298
%closure.env1299 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1288, i32 0, i32 1
store i8* %envptr1289, i8** %closure.env1299
%closure.func1300 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1288, i32 0, i32 2
store %String* (i8*, i8*, %String*)* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0__1279, %String* (i8*, i8*, %String*)** %closure.func1300
%closure_size1301 = call i64 @llvm_zone_mark_size(%mzone* %zone1286)
call void @llvm_zone_ptr_set_size(i8* %clsptr1287, i64 %closure_size1301)
%wrapper_ptr1302 = call i8* @llvm_zone_malloc(%mzone* %zone1286, i64 8)
%closure_wrapper1303 = bitcast i8* %wrapper_ptr1302 to { i8*, i8*, %String* (i8*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1288, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1303

; let value assignment
%String_adhoc_W1N0cmluZyosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1303, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1303
store { i8*, i8*, %String* (i8*, i8*, %String*)*}** %String_adhoc_W1N0cmluZyosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*)*}*** %String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var String_adhoc_W1N0cmluZyosU3RyaW5nKl0
%tmp_envptr1297 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %environment1290, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %tmp_envptr1297


%val1306 = load {i8*, i8*, %String* (i8*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %String_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*)*}** %val1306
}


@String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1307 = bitcast [90 x i8]* @gsxtmbase107 to i8*
call i32 (i8*, ...) @printf(i8* %var1307)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase108 = hidden constant [51 x i8] c"substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ\00"
@gsxtmbase109 = hidden constant [55 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**\00"
define dllexport fastcc %String* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ__1308(i8* %_impz,i8* %_impenv, %String* %s, i64 %start, i64 %end) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1309 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***}*
%substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***}* %impenv, i32 0, i32 0
%substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**** %substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr_

; setup arguments
%sPtr = alloca %String*
store %String* %s, %String** %sPtr
%startPtr = alloca i64
store i64 %start, i64* %startPtr
%endPtr = alloca i64
store i64 %end, i64* %endPtr

; promote local stack var allocations
%tzone1382 = load i8*, i8** %_impzPtr
%zone1383 = bitcast i8* %tzone1382 to %mzone*
%ifptr1311 = alloca i1
%ifptr1316 = alloca i1
%ifptr1323 = alloca i1

%val1312 = load i64, i64* %startPtr
%cmp1313 = icmp slt i64 %val1312, 0
br i1 %cmp1313, label %then1311, label %else1311

then1311:
%val1314 = load i64, i64* %startPtr
%cmp1315 = icmp slt i64 %val1314, 0
store i1 %cmp1315, i1* %ifptr1311
br label %ifcont1311

else1311:
%val1317 = load i64, i64* %endPtr
%val1318 = load i64, i64* %startPtr
%cmp1319 = icmp slt i64 %val1317, %val1318
br i1 %cmp1319, label %then1316, label %else1316

then1316:
%val1320 = load i64, i64* %endPtr
%val1321 = load i64, i64* %startPtr
%cmp1322 = icmp slt i64 %val1320, %val1321
store i1 %cmp1322, i1* %ifptr1316
br label %ifcont1316

else1316:
%val1324 = load i64, i64* %endPtr
%val1325 = load %String*, %String** %sPtr
; tuple ref
%val1326 = getelementptr %String, %String* %val1325, i64 0, i32 0
%val1327 = load i64, i64* %val1326
%cmp1328 = icmp sgt i64 %val1324, %val1327
br i1 %cmp1328, label %then1323, label %else1323

then1323:
%val1329 = load i64, i64* %endPtr
%val1330 = load %String*, %String** %sPtr
; tuple ref
%val1331 = getelementptr %String, %String* %val1330, i64 0, i32 0
%val1332 = load i64, i64* %val1331
%cmp1333 = icmp sgt i64 %val1329, %val1332
store i1 %cmp1333, i1* %ifptr1323
br label %ifcont1323

else1323:
%res1334 = call ccc i1 @impc_false()
store i1 %res1334, i1* %ifptr1323
br label %ifcont1323

ifcont1323:
%ifres1335 = load i1, i1* %ifptr1323

store i1 %ifres1335, i1* %ifptr1316
br label %ifcont1316

ifcont1316:
%ifres1336 = load i1, i1* %ifptr1316

store i1 %ifres1336, i1* %ifptr1311
br label %ifcont1311

ifcont1311:
%ifres1337 = load i1, i1* %ifptr1311

br i1 %ifres1337, label %then1310, label %else1310

then1310:
%null1338 = bitcast i8* null to %String*
ret %String* %null1338

else1310:
%tzone1349 = load i8*, i8** %_impzPtr
%zone1350 = bitcast i8* %tzone1349 to %mzone*

; let assign value to symbol buf
%bufPtr = alloca i8*
%tzone1351 = load i8*, i8** %_impzPtr
%zone1352 = bitcast i8* %tzone1351 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val1339 = load i64, i64* %endPtr
%val1340 = load i64, i64* %startPtr
%val1341 = sub i64 %val1339, %val1340
%val1342 = add i64 %val1341, 1
%val1343 = getelementptr i64, i64* null, i32 1
%zonesize1344 = mul i64 1, %val1342
%tzone1345 = load i8*, i8** %_impzPtr
%zone1346 = bitcast i8* %tzone1345 to %mzone*
%dat1347 = call i8* @llvm_zone_malloc(%mzone* %zone1346, i64 %zonesize1344)
call i8* @memset(i8* %dat1347, i32 0, i64 %zonesize1344)
%val1348 = bitcast i8* %dat1347 to i8*

; let value assignment
%buf = select i1 true, i8* %val1348, i8* %val1348
store i8* %buf, i8** %bufPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val1357 = load i64, i64* %endPtr
%val1358 = load i64, i64* %startPtr
%val1359 = sub i64 %val1357, %val1358
store i64 0, i64* %iPtr
%val1371 = load i64, i64* %iPtr
%num1372 = add i64 %val1359, %val1371
%comp1373 = icmp ult i64 %val1359, 1
br i1 %comp1373, label %after1353, label %loop1353

loop1353:
%val1360 = load i64, i64* %iPtr
%val1361 = load i8*, i8** %bufPtr
%val1362 = load i64, i64* %iPtr
%val1363 = load i64, i64* %startPtr
%val1364 = add i64 %val1362, %val1363
%val1365 = load %String*, %String** %sPtr
; tuple ref
%val1366 = getelementptr %String, %String* %val1365, i64 0, i32 1
%val1367 = load i8*, i8** %val1366
; pointer ref
%val1368 = getelementptr i8, i8* %val1367, i64 %val1364
%val1369 = load i8, i8* %val1368
; set pointer
%val1370 = getelementptr i8, i8* %val1361, i64 %val1360
store i8 %val1369, i8* %val1370
%loop_cnt1353 = load i64, i64* %iPtr
%next1353 = add i64 %loop_cnt1353, 1
store i64 %next1353, i64* %iPtr
%cmp1353 = icmp ult i64 %next1353, %num1372
br i1 %cmp1353, label %loop1353, label %after1353

after1353:
%val1375 = load i64, i64* %endPtr
%val1376 = load i64, i64* %startPtr
%val1377 = sub i64 %val1375, %val1376
%val1378 = load i8*, i8** %bufPtr
; set pointer
%val1379 = getelementptr i8, i8* %val1378, i64 %val1377
store i8 0, i8* %val1379
%val1380 = load i8*, i8** %bufPtr
%res1381 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1380)
ret %String* %res1381
}
@gsxtmbase110 = hidden constant [104 x i8] c"substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1403 = load i8*, i8** %_impzPtr
%zone1404 = bitcast i8* %tzone1403 to %mzone*

; let assign value to symbol substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ
%dat_substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1404, i64 8)
%substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr = bitcast i8* %dat_substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ to { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***
%tzone1384 = load i8*, i8** %_impzPtr
%zone1385 = bitcast i8* %tzone1384 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1385)
; malloc closure structure
%clsptr1386 = call i8* @llvm_zone_malloc(%mzone* %zone1385, i64 24)
%closure1387 = bitcast i8* %clsptr1386 to { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*

; malloc environment structure
%envptr1388 = call i8* @llvm_zone_malloc(%mzone* %zone1385, i64 8)
%environment1389 = bitcast i8* %envptr1388 to {{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***}*

; malloc closure address table
%addytable1390 = call %clsvar* @new_address_table()
%var1391 = bitcast [51 x i8]* @gsxtmbase108 to i8*
%var1392 = bitcast [55 x i8]* @gsxtmbase109 to i8*
%addytable1393 = call %clsvar* @add_address_table(%mzone* %zone1385, i8* %var1391, i32 0, i8* %var1392, i32 3, %clsvar* %addytable1390)
%address-table1394 = bitcast %clsvar* %addytable1393 to i8*

; insert table, function and environment into closure struct
%closure.table1397 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure1387, i32 0, i32 0
store i8* %address-table1394, i8** %closure.table1397
%closure.env1398 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure1387, i32 0, i32 1
store i8* %envptr1388, i8** %closure.env1398
%closure.func1399 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure1387, i32 0, i32 2
store %String* (i8*, i8*, %String*, i64, i64)* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ__1308, %String* (i8*, i8*, %String*, i64, i64)** %closure.func1399
%closure_size1400 = call i64 @llvm_zone_mark_size(%mzone* %zone1385)
call void @llvm_zone_ptr_set_size(i8* %clsptr1386, i64 %closure_size1400)
%wrapper_ptr1401 = call i8* @llvm_zone_malloc(%mzone* %zone1385, i64 8)
%closure_wrapper1402 = bitcast i8* %wrapper_ptr1401 to { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure1387, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_wrapper1402

; let value assignment
%substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_wrapper1402, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_wrapper1402
store { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ, { i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*** %substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ
%tmp_envptr1396 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}***}* %environment1389, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*** %substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**** %tmp_envptr1396


%val1405 = load {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*** %substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %val1405
}


@substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ(%String* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i64, i64)*,  %String* (i8*, i8*, %String*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2)
ret %String* %result
}


define dllexport ccc %String* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_native(%String* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i64, i64)*,  %String* (i8*, i8*, %String*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1406 = bitcast [104 x i8]* @gsxtmbase110 to i8*
call i32 (i8*, ...) @printf(i8* %var1406)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1407 = bitcast [104 x i8]* @gsxtmbase110 to i8*
call i32 (i8*, ...) @printf(i8* %var1407)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1408 = bitcast [104 x i8]* @gsxtmbase110 to i8*
call i32 (i8*, ...) @printf(i8* %var1408)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i64, i64)*,  %String* (i8*, i8*, %String*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i64, i64}*
%arg_p_0 = getelementptr {%String*, i64, i64}, {%String*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i64, i64}, {%String*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {%String*, i64, i64}, {%String*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i64, i64)*,  %String* (i8*, i8*, %String*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase111 = hidden constant [46 x i8] c"cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ\00"
@gsxtmbase112 = hidden constant [55 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**\00"
define dllexport fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ__1409(i8* %_impz,i8* %_impenv, %String* %s1, %String* %s2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1410 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***}*
%cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**** %cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr_

; setup arguments
%s1Ptr = alloca %String*
store %String* %s1, %String** %s1Ptr
%s2Ptr = alloca %String*
store %String* %s2, %String** %s2Ptr


%val1412 = load %String*, %String** %s2Ptr
%val1413 = icmp eq %String* %val1412, null
br i1 %val1413, label %then1411, label %else1411

then1411:
%val1414 = load %String*, %String** %s1Ptr
%res1415 = call fastcc %String* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %val1414)
ret %String* %res1415

else1411:
%val1417 = load %String*, %String** %s1Ptr
%val1418 = icmp eq %String* %val1417, null
br i1 %val1418, label %then1416, label %else1416

then1416:
%val1419 = load %String*, %String** %s2Ptr
%res1420 = call fastcc %String* @String_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %val1419)
ret %String* %res1420

else1416:
%tzone1428 = load i8*, i8** %_impzPtr
%zone1429 = bitcast i8* %tzone1428 to %mzone*

; let assign value to symbol size
%sizePtr = alloca i64
%tzone1438 = load i8*, i8** %_impzPtr
%zone1439 = bitcast i8* %tzone1438 to %mzone*

; let assign value to symbol news
%newsPtr = alloca i8*
%val1421 = load %String*, %String** %s1Ptr
; tuple ref
%val1422 = getelementptr %String, %String* %val1421, i64 0, i32 0
%val1423 = load i64, i64* %val1422
%val1424 = load %String*, %String** %s2Ptr
; tuple ref
%val1425 = getelementptr %String, %String* %val1424, i64 0, i32 0
%val1426 = load i64, i64* %val1425
%val1427 = add i64 %val1423, %val1426

; let value assignment
%size = select i1 true, i64 %val1427, i64 %val1427
store i64 %size, i64* %sizePtr

%val1430 = load i64, i64* %sizePtr
%val1431 = add i64 1, %val1430
%val1432 = getelementptr i64, i64* null, i32 1
%zonesize1433 = mul i64 1, %val1431
%tzone1434 = load i8*, i8** %_impzPtr
%zone1435 = bitcast i8* %tzone1434 to %mzone*
%dat1436 = call i8* @llvm_zone_malloc(%mzone* %zone1435, i64 %zonesize1433)
call i8* @memset(i8* %dat1436, i32 0, i64 %zonesize1433)
%val1437 = bitcast i8* %dat1436 to i8*

; let value assignment
%news = select i1 true, i8* %val1437, i8* %val1437
store i8* %news, i8** %newsPtr

%val1440 = load i8*, i8** %newsPtr
%val1441 = load %String*, %String** %s1Ptr
; tuple ref
%val1442 = getelementptr %String, %String* %val1441, i64 0, i32 1
%val1443 = load i8*, i8** %val1442
%res1444 = call ccc i8* @strcpy(i8* %val1440, i8* %val1443)
%val1445 = load i8*, i8** %newsPtr
%val1446 = load %String*, %String** %s2Ptr
; tuple ref
%val1447 = getelementptr %String, %String* %val1446, i64 0, i32 1
%val1448 = load i8*, i8** %val1447
%val1449 = load i64, i64* %sizePtr
%res1450 = call ccc i8* @strncat(i8* %val1445, i8* %val1448, i64 %val1449)
%val1451 = load i8*, i8** %newsPtr
%res1452 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1451)
ret %String* %res1452
}
@gsxtmbase113 = hidden constant [99 x i8] c"cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1472 = load i8*, i8** %_impzPtr
%zone1473 = bitcast i8* %tzone1472 to %mzone*

; let assign value to symbol cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ
%dat_cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1473, i64 8)
%cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr = bitcast i8* %dat_cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ to { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***
%tzone1453 = load i8*, i8** %_impzPtr
%zone1454 = bitcast i8* %tzone1453 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1454)
; malloc closure structure
%clsptr1455 = call i8* @llvm_zone_malloc(%mzone* %zone1454, i64 24)
%closure1456 = bitcast i8* %clsptr1455 to { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*

; malloc environment structure
%envptr1457 = call i8* @llvm_zone_malloc(%mzone* %zone1454, i64 8)
%environment1458 = bitcast i8* %envptr1457 to {{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***}*

; malloc closure address table
%addytable1459 = call %clsvar* @new_address_table()
%var1460 = bitcast [46 x i8]* @gsxtmbase111 to i8*
%var1461 = bitcast [55 x i8]* @gsxtmbase112 to i8*
%addytable1462 = call %clsvar* @add_address_table(%mzone* %zone1454, i8* %var1460, i32 0, i8* %var1461, i32 3, %clsvar* %addytable1459)
%address-table1463 = bitcast %clsvar* %addytable1462 to i8*

; insert table, function and environment into closure struct
%closure.table1466 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure1456, i32 0, i32 0
store i8* %address-table1463, i8** %closure.table1466
%closure.env1467 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure1456, i32 0, i32 1
store i8* %envptr1457, i8** %closure.env1467
%closure.func1468 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure1456, i32 0, i32 2
store %String* (i8*, i8*, %String*, %String*)* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ__1409, %String* (i8*, i8*, %String*, %String*)** %closure.func1468
%closure_size1469 = call i64 @llvm_zone_mark_size(%mzone* %zone1454)
call void @llvm_zone_ptr_set_size(i8* %clsptr1455, i64 %closure_size1469)
%wrapper_ptr1470 = call i8* @llvm_zone_malloc(%mzone* %zone1454, i64 8)
%closure_wrapper1471 = bitcast i8* %wrapper_ptr1470 to { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure1456, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_wrapper1471

; let value assignment
%cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_wrapper1471, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_wrapper1471
store { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ, { i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*** %cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ
%tmp_envptr1465 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}***}* %environment1458, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*** %cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**** %tmp_envptr1465


%val1474 = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*** %cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %val1474
}


@cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret %String* %result
}


define dllexport ccc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_native(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret %String* %result
}


define dllexport ccc i8*  @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1475 = bitcast [99 x i8]* @gsxtmbase113 to i8*
call i32 (i8*, ...) @printf(i8* %var1475)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1476 = bitcast [99 x i8]* @gsxtmbase113 to i8*
call i32 (i8*, ...) @printf(i8* %var1476)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase114 = hidden constant [40 x i8] c"equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0\00"
@gsxtmbase115 = hidden constant [49 x i8] c"{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**\00"
define dllexport fastcc i1 @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0__1477(i8* %_impz,i8* %_impenv, %String* %s1, %String* %s2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1478 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***}*
%equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr = load {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**** %equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr_

; setup arguments
%s1Ptr = alloca %String*
store %String* %s1, %String** %s1Ptr
%s2Ptr = alloca %String*
store %String* %s2, %String** %s2Ptr


%val1480 = load %String*, %String** %s1Ptr
; tuple ref
%val1481 = getelementptr %String, %String* %val1480, i64 0, i32 1
%val1482 = load i8*, i8** %val1481
%val1483 = load %String*, %String** %s2Ptr
; tuple ref
%val1484 = getelementptr %String, %String* %val1483, i64 0, i32 1
%val1485 = load i8*, i8** %val1484
%res1486 = call ccc i32 @strcmp(i8* %val1482, i8* %val1485)
%cmp1487 = icmp eq i32 %res1486, 0
br i1 %cmp1487, label %then1479, label %else1479

then1479:
%val1488 = trunc i64 1 to i1
ret i1 %val1488

else1479:
%val1489 = trunc i64 0 to i1
ret i1 %val1489
}
@gsxtmbase116 = hidden constant [93 x i8] c"equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1509 = load i8*, i8** %_impzPtr
%zone1510 = bitcast i8* %tzone1509 to %mzone*

; let assign value to symbol equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0
%dat_equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1510, i64 8)
%equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr = bitcast i8* %dat_equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0 to { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***
%tzone1490 = load i8*, i8** %_impzPtr
%zone1491 = bitcast i8* %tzone1490 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1491)
; malloc closure structure
%clsptr1492 = call i8* @llvm_zone_malloc(%mzone* %zone1491, i64 24)
%closure1493 = bitcast i8* %clsptr1492 to { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*

; malloc environment structure
%envptr1494 = call i8* @llvm_zone_malloc(%mzone* %zone1491, i64 8)
%environment1495 = bitcast i8* %envptr1494 to {{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***}*

; malloc closure address table
%addytable1496 = call %clsvar* @new_address_table()
%var1497 = bitcast [40 x i8]* @gsxtmbase114 to i8*
%var1498 = bitcast [49 x i8]* @gsxtmbase115 to i8*
%addytable1499 = call %clsvar* @add_address_table(%mzone* %zone1491, i8* %var1497, i32 0, i8* %var1498, i32 3, %clsvar* %addytable1496)
%address-table1500 = bitcast %clsvar* %addytable1499 to i8*

; insert table, function and environment into closure struct
%closure.table1503 = getelementptr { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure1493, i32 0, i32 0
store i8* %address-table1500, i8** %closure.table1503
%closure.env1504 = getelementptr { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure1493, i32 0, i32 1
store i8* %envptr1494, i8** %closure.env1504
%closure.func1505 = getelementptr { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure1493, i32 0, i32 2
store i1 (i8*, i8*, %String*, %String*)* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0__1477, i1 (i8*, i8*, %String*, %String*)** %closure.func1505
%closure_size1506 = call i64 @llvm_zone_mark_size(%mzone* %zone1491)
call void @llvm_zone_ptr_set_size(i8* %clsptr1492, i64 %closure_size1506)
%wrapper_ptr1507 = call i8* @llvm_zone_malloc(%mzone* %zone1491, i64 8)
%closure_wrapper1508 = bitcast i8* %wrapper_ptr1507 to { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**
store { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure1493, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_wrapper1508

; let value assignment
%equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_wrapper1508, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_wrapper1508
store { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0, { i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*** %equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0
%tmp_envptr1502 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}***}* %environment1495, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*** %equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**** %tmp_envptr1502


%val1511 = load {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*** %equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %val1511
}


@equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*, %String*)*,  i1 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret i1 %result
}


define dllexport ccc i1 @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_native(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*, %String*)*,  i1 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret i1 %result
}


define dllexport ccc i8*  @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1512 = bitcast [93 x i8]* @gsxtmbase116 to i8*
call i32 (i8*, ...) @printf(i8* %var1512)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1513 = bitcast [93 x i8]* @gsxtmbase116 to i8*
call i32 (i8*, ...) @printf(i8* %var1513)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*, %String*)*,  i1 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i1 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %String*, %String*)*,  i1 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase117 = hidden constant [35 x i8] c"trim_adhoc_W1N0cmluZyosU3RyaW5nKl0\00"
define dllexport fastcc %String* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0__1514(i8* %_impz,i8* %_impenv, %String* %e) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1515 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*
%trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_

; setup arguments
%ePtr = alloca %String*
store %String* %e, %String** %ePtr


%tzone1519 = load i8*, i8** %_impzPtr
%zone1520 = bitcast i8* %tzone1519 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%tzone1524 = load i8*, i8** %_impzPtr
%zone1525 = bitcast i8* %tzone1524 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%tzone1526 = load i8*, i8** %_impzPtr
%zone1527 = bitcast i8* %tzone1526 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%tzone1528 = load i8*, i8** %_impzPtr
%zone1529 = bitcast i8* %tzone1528 to %mzone*

; let assign value to symbol start
%startPtr = alloca i64
%tzone1530 = load i8*, i8** %_impzPtr
%zone1531 = bitcast i8* %tzone1530 to %mzone*

; let assign value to symbol end
%endPtr = alloca i64
%val1516 = load %String*, %String** %ePtr
; tuple ref
%val1517 = getelementptr %String, %String* %val1516, i64 0, i32 1
%val1518 = load i8*, i8** %val1517

; let value assignment
%s = select i1 true, i8* %val1518, i8* %val1518
store i8* %s, i8** %sPtr

%val1521 = load %String*, %String** %ePtr
; tuple ref
%val1522 = getelementptr %String, %String* %val1521, i64 0, i32 0
%val1523 = load i64, i64* %val1522

; let value assignment
%len = select i1 true, i64 %val1523, i64 %val1523
store i64 %len, i64* %lenPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%start = select i1 true, i64 -1, i64 -1
store i64 %start, i64* %startPtr


; let value assignment
%end = select i1 true, i64 0, i64 0
store i64 %end, i64* %endPtr

; promote local stack var allocations
%tzone1623 = load i8*, i8** %_impzPtr
%zone1624 = bitcast i8* %tzone1623 to %mzone*
%ifptr1598 = alloca i1
%ifptr1601 = alloca i1
%ifptr1578 = alloca i1
%ifptr1581 = alloca i1
%ifptr1554 = alloca i1
%ifptr1558 = alloca i1
%ifptr1533 = alloca i1
%ifptr1537 = alloca i1
; while loop
%val1534 = load i64, i64* %iPtr
%val1535 = load i64, i64* %lenPtr
%cmp1536 = icmp slt i64 %val1534, %val1535
br i1 %cmp1536, label %then1533, label %else1533

then1533:
%val1538 = load i64, i64* %iPtr
%val1539 = load i8*, i8** %sPtr
; pointer ref
%val1540 = getelementptr i8, i8* %val1539, i64 %val1538
%val1541 = load i8, i8* %val1540
%cmp1542 = icmp eq i8 %val1541, 32
br i1 %cmp1542, label %then1537, label %else1537

then1537:
%val1543 = load i64, i64* %iPtr
%val1544 = load i8*, i8** %sPtr
; pointer ref
%val1545 = getelementptr i8, i8* %val1544, i64 %val1543
%val1546 = load i8, i8* %val1545
%cmp1547 = icmp eq i8 %val1546, 32
store i1 %cmp1547, i1* %ifptr1537
br label %ifcont1537

else1537:
%res1548 = call ccc i1 @impc_false()
store i1 %res1548, i1* %ifptr1537
br label %ifcont1537

ifcont1537:
%ifres1549 = load i1, i1* %ifptr1537

store i1 %ifres1549, i1* %ifptr1533
br label %ifcont1533

else1533:
%res1550 = call ccc i1 @impc_false()
store i1 %res1550, i1* %ifptr1533
br label %ifcont1533

ifcont1533:
%ifres1551 = load i1, i1* %ifptr1533

br i1 %ifres1551, label %loop1532, label %after1532

loop1532:
; do set!
%val1552 = load i64, i64* %iPtr
%val1553 = add i64 %val1552, 1
store i64 %val1553, i64* %iPtr
%val1555 = load i64, i64* %iPtr
%val1556 = load i64, i64* %lenPtr
%cmp1557 = icmp slt i64 %val1555, %val1556
br i1 %cmp1557, label %then1554, label %else1554

then1554:
%val1559 = load i64, i64* %iPtr
%val1560 = load i8*, i8** %sPtr
; pointer ref
%val1561 = getelementptr i8, i8* %val1560, i64 %val1559
%val1562 = load i8, i8* %val1561
%cmp1563 = icmp eq i8 %val1562, 32
br i1 %cmp1563, label %then1558, label %else1558

then1558:
%val1564 = load i64, i64* %iPtr
%val1565 = load i8*, i8** %sPtr
; pointer ref
%val1566 = getelementptr i8, i8* %val1565, i64 %val1564
%val1567 = load i8, i8* %val1566
%cmp1568 = icmp eq i8 %val1567, 32
store i1 %cmp1568, i1* %ifptr1558
br label %ifcont1558

else1558:
%res1569 = call ccc i1 @impc_false()
store i1 %res1569, i1* %ifptr1558
br label %ifcont1558

ifcont1558:
%ifres1570 = load i1, i1* %ifptr1558

store i1 %ifres1570, i1* %ifptr1554
br label %ifcont1554

else1554:
%res1571 = call ccc i1 @impc_false()
store i1 %res1571, i1* %ifptr1554
br label %ifcont1554

ifcont1554:
%ifres1572 = load i1, i1* %ifptr1554

br i1 %ifres1572, label %loop1532, label %after1532

after1532:
; do set!
%val1574 = load i64, i64* %iPtr
store i64 %val1574, i64* %startPtr
; do set!
%val1575 = load i64, i64* %lenPtr
%val1576 = sub i64 %val1575, 1
store i64 %val1576, i64* %iPtr
; while loop
%val1579 = load i64, i64* %iPtr
%cmp1580 = icmp sgt i64 %val1579, -1
br i1 %cmp1580, label %then1578, label %else1578

then1578:
%val1582 = load i64, i64* %iPtr
%val1583 = load i8*, i8** %sPtr
; pointer ref
%val1584 = getelementptr i8, i8* %val1583, i64 %val1582
%val1585 = load i8, i8* %val1584
%cmp1586 = icmp eq i8 %val1585, 32
br i1 %cmp1586, label %then1581, label %else1581

then1581:
%val1587 = load i64, i64* %iPtr
%val1588 = load i8*, i8** %sPtr
; pointer ref
%val1589 = getelementptr i8, i8* %val1588, i64 %val1587
%val1590 = load i8, i8* %val1589
%cmp1591 = icmp eq i8 %val1590, 32
store i1 %cmp1591, i1* %ifptr1581
br label %ifcont1581

else1581:
%res1592 = call ccc i1 @impc_false()
store i1 %res1592, i1* %ifptr1581
br label %ifcont1581

ifcont1581:
%ifres1593 = load i1, i1* %ifptr1581

store i1 %ifres1593, i1* %ifptr1578
br label %ifcont1578

else1578:
%res1594 = call ccc i1 @impc_false()
store i1 %res1594, i1* %ifptr1578
br label %ifcont1578

ifcont1578:
%ifres1595 = load i1, i1* %ifptr1578

br i1 %ifres1595, label %loop1577, label %after1577

loop1577:
; do set!
%val1596 = load i64, i64* %iPtr
%val1597 = sub i64 %val1596, 1
store i64 %val1597, i64* %iPtr
%val1599 = load i64, i64* %iPtr
%cmp1600 = icmp sgt i64 %val1599, -1
br i1 %cmp1600, label %then1598, label %else1598

then1598:
%val1602 = load i64, i64* %iPtr
%val1603 = load i8*, i8** %sPtr
; pointer ref
%val1604 = getelementptr i8, i8* %val1603, i64 %val1602
%val1605 = load i8, i8* %val1604
%cmp1606 = icmp eq i8 %val1605, 32
br i1 %cmp1606, label %then1601, label %else1601

then1601:
%val1607 = load i64, i64* %iPtr
%val1608 = load i8*, i8** %sPtr
; pointer ref
%val1609 = getelementptr i8, i8* %val1608, i64 %val1607
%val1610 = load i8, i8* %val1609
%cmp1611 = icmp eq i8 %val1610, 32
store i1 %cmp1611, i1* %ifptr1601
br label %ifcont1601

else1601:
%res1612 = call ccc i1 @impc_false()
store i1 %res1612, i1* %ifptr1601
br label %ifcont1601

ifcont1601:
%ifres1613 = load i1, i1* %ifptr1601

store i1 %ifres1613, i1* %ifptr1598
br label %ifcont1598

else1598:
%res1614 = call ccc i1 @impc_false()
store i1 %res1614, i1* %ifptr1598
br label %ifcont1598

ifcont1598:
%ifres1615 = load i1, i1* %ifptr1598

br i1 %ifres1615, label %loop1577, label %after1577

after1577:
; do set!
%val1617 = load i64, i64* %iPtr
%val1618 = add i64 1, %val1617
store i64 %val1618, i64* %endPtr
%val1619 = load %String*, %String** %ePtr
%val1620 = load i64, i64* %startPtr
%val1621 = load i64, i64* %endPtr
%res1622 = call fastcc %String* @substring_adhoc_W1N0cmluZyosU3RyaW5nKixpNjQsaTY0XQ(%String* %val1619, i64 %val1620, i64 %val1621)
ret %String* %res1622
}
@gsxtmbase118 = hidden constant [88 x i8] c"trim_adhoc_W1N0cmluZyosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1644 = load i8*, i8** %_impzPtr
%zone1645 = bitcast i8* %tzone1644 to %mzone*

; let assign value to symbol trim_adhoc_W1N0cmluZyosU3RyaW5nKl0
%dat_trim_adhoc_W1N0cmluZyosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1645, i64 8)
%trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = bitcast i8* %dat_trim_adhoc_W1N0cmluZyosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*)*}***
%tzone1625 = load i8*, i8** %_impzPtr
%zone1626 = bitcast i8* %tzone1625 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1626)
; malloc closure structure
%clsptr1627 = call i8* @llvm_zone_malloc(%mzone* %zone1626, i64 24)
%closure1628 = bitcast i8* %clsptr1627 to { i8*, i8*, %String* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr1629 = call i8* @llvm_zone_malloc(%mzone* %zone1626, i64 8)
%environment1630 = bitcast i8* %envptr1629 to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable1631 = call %clsvar* @new_address_table()
%var1632 = bitcast [35 x i8]* @gsxtmbase117 to i8*
%var1633 = bitcast [45 x i8]* @gsxtmbase72 to i8*
%addytable1634 = call %clsvar* @add_address_table(%mzone* %zone1626, i8* %var1632, i32 0, i8* %var1633, i32 3, %clsvar* %addytable1631)
%address-table1635 = bitcast %clsvar* %addytable1634 to i8*

; insert table, function and environment into closure struct
%closure.table1638 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1628, i32 0, i32 0
store i8* %address-table1635, i8** %closure.table1638
%closure.env1639 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1628, i32 0, i32 1
store i8* %envptr1629, i8** %closure.env1639
%closure.func1640 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1628, i32 0, i32 2
store %String* (i8*, i8*, %String*)* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0__1514, %String* (i8*, i8*, %String*)** %closure.func1640
%closure_size1641 = call i64 @llvm_zone_mark_size(%mzone* %zone1626)
call void @llvm_zone_ptr_set_size(i8* %clsptr1627, i64 %closure_size1641)
%wrapper_ptr1642 = call i8* @llvm_zone_malloc(%mzone* %zone1626, i64 8)
%closure_wrapper1643 = bitcast i8* %wrapper_ptr1642 to { i8*, i8*, %String* (i8*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure1628, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1643

; let value assignment
%trim_adhoc_W1N0cmluZyosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1643, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper1643
store { i8*, i8*, %String* (i8*, i8*, %String*)*}** %trim_adhoc_W1N0cmluZyosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*)*}*** %trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var trim_adhoc_W1N0cmluZyosU3RyaW5nKl0
%tmp_envptr1637 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %environment1630, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %tmp_envptr1637


%val1646 = load {i8*, i8*, %String* (i8*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %trim_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*)*}** %val1646
}


@trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1647 = bitcast [88 x i8]* @gsxtmbase118 to i8*
call i32 (i8*, ...) @printf(i8* %var1647)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @trim_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase119 = hidden constant [47 x i8] c"levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd\00"
@gsxtmbase120 = hidden constant [50 x i8] c"{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**\00"
@gsxtmbase121 = hidden constant [3 x i8] c"s2\00"
@gsxtmbase122 = hidden constant [9 x i8] c"%String*\00"
@gsxtmbase123 = hidden constant [3 x i8] c"s1\00"
@gsxtmbase124 = hidden constant [5 x i8] c"min3\00"
@gsxtmbase125 = hidden constant [45 x i8] c"{i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}**\00"
@gsxtmbase126 = hidden constant [9 x i8] c"prev_row\00"
@gsxtmbase127 = hidden constant [5 x i8] c"i64*\00"
@gsxtmbase128 = hidden constant [4 x i8] c"row\00"
@gsxtmbase129 = hidden constant [6 x i8] c"s2len\00"
@gsxtmbase130 = hidden constant [4 x i8] c"i64\00"
@gsxtmbase131 = hidden constant [7 x i8] c"s2cstr\00"
@gsxtmbase132 = hidden constant [4 x i8] c"i8*\00"
@gsxtmbase133 = hidden constant [6 x i8] c"s1len\00"
@gsxtmbase134 = hidden constant [7 x i8] c"s1cstr\00"
@gsxtmbase135 = hidden constant [2 x i8] c"j\00"
@gsxtmbase136 = hidden constant [2 x i8] c"i\00"
define dllexport fastcc i64 @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd__1649(i8* %_impz,i8* %_impenv, i64 %a, i64 %b, i64 %c) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1681 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}*
%levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 0
%levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr_
%s2Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 1
%s2Ptr = load %String**, %String*** %s2Ptr_
%s1Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 2
%s1Ptr = load %String**, %String*** %s1Ptr_
%min3Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 3
%min3Ptr = load {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}**** %min3Ptr_
%prev_rowPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 4
%prev_rowPtr = load i64**, i64*** %prev_rowPtr_
%rowPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 5
%rowPtr = load i64**, i64*** %rowPtr_
%s2lenPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 6
%s2lenPtr = load i64*, i64** %s2lenPtr_
%s2cstrPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 7
%s2cstrPtr = load i8**, i8*** %s2cstrPtr_
%s1lenPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 8
%s1lenPtr = load i64*, i64** %s1lenPtr_
%s1cstrPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 9
%s1cstrPtr = load i8**, i8*** %s1cstrPtr_
%jPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 10
%jPtr = load i64*, i64** %jPtr_
%iPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %impenv, i32 0, i32 11
%iPtr = load i64*, i64** %iPtr_

; setup arguments
%aPtr = alloca i64
store i64 %a, i64* %aPtr
%bPtr = alloca i64
store i64 %b, i64* %bPtr
%cPtr = alloca i64
store i64 %c, i64* %cPtr


%val1683 = load i64, i64* %aPtr
%val1684 = load i64, i64* %bPtr
%cmp1685 = icmp slt i64 %val1683, %val1684
br i1 %cmp1685, label %then1682, label %else1682

then1682:
%val1687 = load i64, i64* %aPtr
%val1688 = load i64, i64* %cPtr
%cmp1689 = icmp slt i64 %val1687, %val1688
br i1 %cmp1689, label %then1686, label %else1686

then1686:
%val1690 = load i64, i64* %aPtr
ret i64 %val1690

else1686:
%val1691 = load i64, i64* %cPtr
ret i64 %val1691

else1682:
%val1693 = load i64, i64* %bPtr
%val1694 = load i64, i64* %cPtr
%cmp1695 = icmp slt i64 %val1693, %val1694
br i1 %cmp1695, label %then1692, label %else1692

then1692:
%val1696 = load i64, i64* %bPtr
ret i64 %val1696

else1692:
%val1697 = load i64, i64* %cPtr
ret i64 %val1697
}
define dllexport fastcc i64 @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd__1648(i8* %_impz,i8* %_impenv, %String* %s1, %String* %s2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1650 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***}*
%levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr_

; setup arguments
%dat_s1 = call i8* @llvm_zone_malloc(%mzone* %zone1650, i64 8)
%s1Ptr = bitcast i8* %dat_s1 to %String**
store %String* %s1, %String** %s1Ptr
%dat_s2 = call i8* @llvm_zone_malloc(%mzone* %zone1650, i64 8)
%s2Ptr = bitcast i8* %dat_s2 to %String**
store %String* %s2, %String** %s2Ptr


%tzone1651 = load i8*, i8** %_impzPtr
%zone1652 = bitcast i8* %tzone1651 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone1652, i64 8)
%iPtr = bitcast i8* %dat_i to i64*
%tzone1653 = load i8*, i8** %_impzPtr
%zone1654 = bitcast i8* %tzone1653 to %mzone*

; let assign value to symbol j
%dat_j = call i8* @llvm_zone_malloc(%mzone* %zone1654, i64 8)
%jPtr = bitcast i8* %dat_j to i64*
%tzone1657 = load i8*, i8** %_impzPtr
%zone1658 = bitcast i8* %tzone1657 to %mzone*

; let assign value to symbol s1cstr
%dat_s1cstr = call i8* @llvm_zone_malloc(%mzone* %zone1658, i64 8)
%s1cstrPtr = bitcast i8* %dat_s1cstr to i8**
%tzone1661 = load i8*, i8** %_impzPtr
%zone1662 = bitcast i8* %tzone1661 to %mzone*

; let assign value to symbol s1len
%dat_s1len = call i8* @llvm_zone_malloc(%mzone* %zone1662, i64 8)
%s1lenPtr = bitcast i8* %dat_s1len to i64*
%tzone1665 = load i8*, i8** %_impzPtr
%zone1666 = bitcast i8* %tzone1665 to %mzone*

; let assign value to symbol s2cstr
%dat_s2cstr = call i8* @llvm_zone_malloc(%mzone* %zone1666, i64 8)
%s2cstrPtr = bitcast i8* %dat_s2cstr to i8**
%tzone1669 = load i8*, i8** %_impzPtr
%zone1670 = bitcast i8* %tzone1669 to %mzone*

; let assign value to symbol s2len
%dat_s2len = call i8* @llvm_zone_malloc(%mzone* %zone1670, i64 8)
%s2lenPtr = bitcast i8* %dat_s2len to i64*
%tzone1674 = load i8*, i8** %_impzPtr
%zone1675 = bitcast i8* %tzone1674 to %mzone*

; let assign value to symbol row
%dat_row = call i8* @llvm_zone_malloc(%mzone* %zone1675, i64 8)
%rowPtr = bitcast i8* %dat_row to i64**
%tzone1679 = load i8*, i8** %_impzPtr
%zone1680 = bitcast i8* %tzone1679 to %mzone*

; let assign value to symbol prev_row
%dat_prev_row = call i8* @llvm_zone_malloc(%mzone* %zone1680, i64 8)
%prev_rowPtr = bitcast i8* %dat_prev_row to i64**
%tzone1772 = load i8*, i8** %_impzPtr
%zone1773 = bitcast i8* %tzone1772 to %mzone*

; let assign value to symbol min3
%dat_min3 = call i8* @llvm_zone_malloc(%mzone* %zone1773, i64 8)
%min3Ptr = bitcast i8* %dat_min3 to { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***

; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr


; let value assignment
%j = select i1 true, i64 0, i64 0
store i64 %j, i64* %jPtr

%val1655 = load %String*, %String** %s1Ptr
%res1656 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val1655)

; let value assignment
%s1cstr = select i1 true, i8* %res1656, i8* %res1656
store i8* %s1cstr, i8** %s1cstrPtr

%val1659 = load %String*, %String** %s1Ptr
%res1660 = call fastcc i64 @length_adhoc_W2k2NCxTdHJpbmcqXQ(%String* %val1659)

; let value assignment
%s1len = select i1 true, i64 %res1660, i64 %res1660
store i64 %s1len, i64* %s1lenPtr

%val1663 = load %String*, %String** %s2Ptr
%res1664 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val1663)

; let value assignment
%s2cstr = select i1 true, i8* %res1664, i8* %res1664
store i8* %s2cstr, i8** %s2cstrPtr

%val1667 = load %String*, %String** %s2Ptr
%res1668 = call fastcc i64 @length_adhoc_W2k2NCxTdHJpbmcqXQ(%String* %val1667)

; let value assignment
%s2len = select i1 true, i64 %res1668, i64 %res1668
store i64 %s2len, i64* %s2lenPtr

%val1671 = load i64, i64* %s1lenPtr
%val1672 = add i64 %val1671, 1
%dat1673 = alloca i64, i64 %val1672, align 16

; let value assignment
%row = select i1 true, i64* %dat1673, i64* %dat1673
store i64* %row, i64** %rowPtr

%val1676 = load i64, i64* %s1lenPtr
%val1677 = add i64 %val1676, 1
%dat1678 = alloca i64, i64 %val1677, align 16

; let value assignment
%prev_row = select i1 true, i64* %dat1678, i64* %dat1678
store i64* %prev_row, i64** %prev_rowPtr

%tzone1698 = load i8*, i8** %_impzPtr
%zone1699 = bitcast i8* %tzone1698 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1699)
; malloc closure structure
%clsptr1700 = call i8* @llvm_zone_malloc(%mzone* %zone1699, i64 24)
%closure1701 = bitcast i8* %clsptr1700 to { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}*

; malloc environment structure
%envptr1702 = call i8* @llvm_zone_malloc(%mzone* %zone1699, i64 96)
%environment1703 = bitcast i8* %envptr1702 to {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}*

; malloc closure address table
%addytable1704 = call %clsvar* @new_address_table()
%var1705 = bitcast [47 x i8]* @gsxtmbase119 to i8*
%var1706 = bitcast [50 x i8]* @gsxtmbase120 to i8*
%addytable1707 = call %clsvar* @add_address_table(%mzone* %zone1699, i8* %var1705, i32 0, i8* %var1706, i32 3, %clsvar* %addytable1704)
%var1708 = bitcast [3 x i8]* @gsxtmbase121 to i8*
%var1709 = bitcast [9 x i8]* @gsxtmbase122 to i8*
%addytable1710 = call %clsvar* @add_address_table(%mzone* %zone1699, i8* %var1708, i32 8, i8* %var1709, i32 3, %clsvar* %addytable1707)
%var1711 = bitcast [3 x i8]* @gsxtmbase123 to i8*
%var1712 = bitcast [9 x i8]* @gsxtmbase122 to i8*
%addytable1713 = call %clsvar* @add_address_table(%mzone* %zone1699, i8* %var1711, i32 16, i8* %var1712, i32 3, %clsvar* %addytable1710)
%var1714 = bitcast [5 x i8]* @gsxtmbase124 to i8*
%var1715 = bitcast [45 x i8]* @gsxtmbase125 to i8*
%addytable1716 = call %clsvar* @add_address_table(%mzone* %zone1699, i8* %var1714, i32 24, i8* %var1715, i32 3, %clsvar* %addytable1713)
%var1717 = bitcast [9 x i8]* @gsxtmbase126 to i8*
%var1718 = bitcast [5 x i8]* @gsxtmbase127 to i8*
%addytable1719 = call %clsvar* @add_address_table(%mzone* %zone1699, i8* %var1717, i32 32, i8* %var1718, i32 3, %clsvar* %addytable1716)
%var1720 = bitcast [4 x i8]* @gsxtmbase128 to i8*
%var1721 = bitcast [5 x i8]* @gsxtmbase127 to i8*
%addytable1722 = call %clsvar* @add_address_table(%mzone* %zone1699, i8* %var1720, i32 40, i8* %var1721, i32 3, %clsvar* %addytable1719)
%var1723 = bitcast [6 x i8]* @gsxtmbase129 to i8*
%var1724 = bitcast [4 x i8]* @gsxtmbase130 to i8*
%addytable1725 = call %clsvar* @add_address_table(%mzone* %zone1699, i8* %var1723, i32 48, i8* %var1724, i32 3, %clsvar* %addytable1722)
%var1726 = bitcast [7 x i8]* @gsxtmbase131 to i8*
%var1727 = bitcast [4 x i8]* @gsxtmbase132 to i8*
%addytable1728 = call %clsvar* @add_address_table(%mzone* %zone1699, i8* %var1726, i32 56, i8* %var1727, i32 3, %clsvar* %addytable1725)
%var1729 = bitcast [6 x i8]* @gsxtmbase133 to i8*
%var1730 = bitcast [4 x i8]* @gsxtmbase130 to i8*
%addytable1731 = call %clsvar* @add_address_table(%mzone* %zone1699, i8* %var1729, i32 64, i8* %var1730, i32 3, %clsvar* %addytable1728)
%var1732 = bitcast [7 x i8]* @gsxtmbase134 to i8*
%var1733 = bitcast [4 x i8]* @gsxtmbase132 to i8*
%addytable1734 = call %clsvar* @add_address_table(%mzone* %zone1699, i8* %var1732, i32 72, i8* %var1733, i32 3, %clsvar* %addytable1731)
%var1735 = bitcast [2 x i8]* @gsxtmbase135 to i8*
%var1736 = bitcast [4 x i8]* @gsxtmbase130 to i8*
%addytable1737 = call %clsvar* @add_address_table(%mzone* %zone1699, i8* %var1735, i32 80, i8* %var1736, i32 3, %clsvar* %addytable1734)
%var1738 = bitcast [2 x i8]* @gsxtmbase136 to i8*
%var1739 = bitcast [4 x i8]* @gsxtmbase130 to i8*
%addytable1740 = call %clsvar* @add_address_table(%mzone* %zone1699, i8* %var1738, i32 88, i8* %var1739, i32 3, %clsvar* %addytable1737)
%address-table1741 = bitcast %clsvar* %addytable1740 to i8*

; insert table, function and environment into closure struct
%closure.table1766 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}* %closure1701, i32 0, i32 0
store i8* %address-table1741, i8** %closure.table1766
%closure.env1767 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}* %closure1701, i32 0, i32 1
store i8* %envptr1702, i8** %closure.env1767
%closure.func1768 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}* %closure1701, i32 0, i32 2
store i64 (i8*, i8*, i64, i64, i64)* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd__1649, i64 (i8*, i8*, i64, i64, i64)** %closure.func1768
%closure_size1769 = call i64 @llvm_zone_mark_size(%mzone* %zone1699)
call void @llvm_zone_ptr_set_size(i8* %clsptr1700, i64 %closure_size1769)
%wrapper_ptr1770 = call i8* @llvm_zone_malloc(%mzone* %zone1699, i64 8)
%closure_wrapper1771 = bitcast i8* %wrapper_ptr1770 to { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}**
store { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}* %closure1701, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}** %closure_wrapper1771

; let value assignment
%min3 = select i1 true, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}** %closure_wrapper1771, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}** %closure_wrapper1771
store { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}** %min3, { i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}*** %min3Ptr

; add data to environment
; don't need to alloc for env var levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd
%tmp_envptr1743 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1703, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**** %tmp_envptr1743

; don't need to alloc for env var s2
%tmp_envptr1745 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1703, i32 0, i32 1
store %String** %s2Ptr, %String*** %tmp_envptr1745

; don't need to alloc for env var s1
%tmp_envptr1747 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1703, i32 0, i32 2
store %String** %s1Ptr, %String*** %tmp_envptr1747

; don't need to alloc for env var min3
%tmp_envptr1749 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1703, i32 0, i32 3
store {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}*** %min3Ptr, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}**** %tmp_envptr1749

; don't need to alloc for env var prev_row
%tmp_envptr1751 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1703, i32 0, i32 4
store i64** %prev_rowPtr, i64*** %tmp_envptr1751

; don't need to alloc for env var row
%tmp_envptr1753 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1703, i32 0, i32 5
store i64** %rowPtr, i64*** %tmp_envptr1753

; don't need to alloc for env var s2len
%tmp_envptr1755 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1703, i32 0, i32 6
store i64* %s2lenPtr, i64** %tmp_envptr1755

; don't need to alloc for env var s2cstr
%tmp_envptr1757 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1703, i32 0, i32 7
store i8** %s2cstrPtr, i8*** %tmp_envptr1757

; don't need to alloc for env var s1len
%tmp_envptr1759 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1703, i32 0, i32 8
store i64* %s1lenPtr, i64** %tmp_envptr1759

; don't need to alloc for env var s1cstr
%tmp_envptr1761 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1703, i32 0, i32 9
store i8** %s1cstrPtr, i8*** %tmp_envptr1761

; don't need to alloc for env var j
%tmp_envptr1763 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1703, i32 0, i32 10
store i64* %jPtr, i64** %tmp_envptr1763

; don't need to alloc for env var i
%tmp_envptr1765 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***, %String**, %String**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}***, i64**, i64**, i64*, i8**, i64*, i8**, i64*, i64*}* %environment1703, i32 0, i32 11
store i64* %iPtr, i64** %tmp_envptr1765


; promote local stack var allocations
%tzone1856 = load i8*, i8** %_impzPtr
%zone1857 = bitcast i8* %tzone1856 to %mzone*
%ifptr1815 = alloca i64
; setup loop
%val1777 = load i64, i64* %s2lenPtr
%val1778 = add i64 %val1777, 1
store i64 0, i64* %iPtr
%val1783 = load i64, i64* %iPtr
%num1784 = add i64 %val1778, %val1783
%comp1785 = icmp ult i64 %val1778, 1
br i1 %comp1785, label %after1774, label %loop1774

loop1774:
%val1779 = load i64, i64* %iPtr
%val1780 = load i64*, i64** %prev_rowPtr
%val1781 = load i64, i64* %iPtr
; set pointer
%val1782 = getelementptr i64, i64* %val1780, i64 %val1779
store i64 %val1781, i64* %val1782
%loop_cnt1774 = load i64, i64* %iPtr
%next1774 = add i64 %loop_cnt1774, 1
store i64 %next1774, i64* %iPtr
%cmp1774 = icmp ult i64 %next1774, %num1784
br i1 %cmp1774, label %loop1774, label %after1774

after1774:
; setup loop
%val1789 = load i64, i64* %s1lenPtr
store i64 0, i64* %iPtr
%val1848 = load i64, i64* %iPtr
%num1849 = add i64 %val1789, %val1848
%comp1850 = icmp ult i64 %val1789, 1
br i1 %comp1850, label %after1787, label %loop1787

loop1787:
%val1790 = load i64*, i64** %rowPtr
%val1791 = load i64, i64* %iPtr
%val1792 = add i64 %val1791, 1
; set pointer
%val1793 = getelementptr i64, i64* %val1790, i64 0
store i64 %val1792, i64* %val1793
; setup loop
%val1796 = load i64, i64* %s2lenPtr
store i64 0, i64* %jPtr
%val1838 = load i64, i64* %jPtr
%num1839 = add i64 %val1796, %val1838
%comp1840 = icmp ult i64 %val1796, 1
br i1 %comp1840, label %after1794, label %loop1794

loop1794:
%val1797 = load i64, i64* %jPtr
%val1798 = add i64 %val1797, 1
%val1799 = load i64*, i64** %rowPtr
%val1800 = load i64, i64* %jPtr
%val1801 = load i64*, i64** %rowPtr
; pointer ref
%val1802 = getelementptr i64, i64* %val1801, i64 %val1800
%val1803 = load i64, i64* %val1802
%val1804 = add i64 %val1803, 1
%val1805 = load i64, i64* %jPtr
%val1806 = add i64 %val1805, 1
%val1807 = load i64*, i64** %prev_rowPtr
; pointer ref
%val1808 = getelementptr i64, i64* %val1807, i64 %val1806
%val1809 = load i64, i64* %val1808
%val1810 = add i64 1, %val1809
%val1811 = load i64, i64* %jPtr
%val1812 = load i64*, i64** %prev_rowPtr
; pointer ref
%val1813 = getelementptr i64, i64* %val1812, i64 %val1811
%val1814 = load i64, i64* %val1813
%val1816 = load i64, i64* %jPtr
%val1817 = load i8*, i8** %s1cstrPtr
; pointer ref
%val1818 = getelementptr i8, i8* %val1817, i64 %val1816
%val1819 = load i8, i8* %val1818
%val1820 = load i64, i64* %iPtr
%val1821 = load i8*, i8** %s2cstrPtr
; pointer ref
%val1822 = getelementptr i8, i8* %val1821, i64 %val1820
%val1823 = load i8, i8* %val1822
%cmp1824 = icmp eq i8 %val1819, %val1823
br i1 %cmp1824, label %then1815, label %else1815

then1815:
store i64 0, i64* %ifptr1815
br label %ifcont1815

else1815:
store i64 1, i64* %ifptr1815
br label %ifcont1815

ifcont1815:
%ifres1825 = load i64, i64* %ifptr1815

%val1826 = add i64 %val1814, %ifres1825

; apply closure 
%vval1827 = load {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}**, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}*** %min3Ptr
%val1828 = load {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}*,{i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}** %vval1827
%fPtr1829 = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}* %val1828, i32 0, i32 2
%ePtr1830 = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64, i64)*}* %val1828, i32 0, i32 1
%f1831 = load i64 (i8*, i8*, i64, i64, i64)*, i64 (i8*, i8*, i64, i64, i64)** %fPtr1829
%e1832 = load i8*, i8** %ePtr1830
%tzone1833 = load i8*, i8** %_impzPtr
%zone1834 = bitcast i8* %tzone1833 to %mzone*
%z1835 = bitcast %mzone* %zone1834 to i8*
%result1836 = tail call fastcc i64 %f1831(i8* %z1835, i8* %e1832, i64 %val1804, i64 %val1810, i64 %val1826)
; set pointer
%val1837 = getelementptr i64, i64* %val1799, i64 %val1798
store i64 %result1836, i64* %val1837
%loop_cnt1794 = load i64, i64* %jPtr
%next1794 = add i64 %loop_cnt1794, 1
store i64 %next1794, i64* %jPtr
%cmp1794 = icmp ult i64 %next1794, %num1839
br i1 %cmp1794, label %loop1794, label %after1794

after1794:
%tzone1843 = load i8*, i8** %_impzPtr
%zone1844 = bitcast i8* %tzone1843 to %mzone*

; let assign value to symbol tmp_row
%tmp_rowPtr = alloca i64*
%null1842 = bitcast i8* null to i64*

; let value assignment
%tmp_row = select i1 true, i64* %null1842, i64* %null1842
store i64* %tmp_row, i64** %tmp_rowPtr

; do set!
%val1845 = load i64*, i64** %prev_rowPtr
store i64* %val1845, i64** %tmp_rowPtr
; do set!
%val1846 = load i64*, i64** %rowPtr
store i64* %val1846, i64** %prev_rowPtr
; do set!
%val1847 = load i64*, i64** %tmp_rowPtr
store i64* %val1847, i64** %rowPtr
%loop_cnt1787 = load i64, i64* %iPtr
%next1787 = add i64 %loop_cnt1787, 1
store i64 %next1787, i64* %iPtr
%cmp1787 = icmp ult i64 %next1787, %num1849
br i1 %cmp1787, label %loop1787, label %after1787

after1787:
%val1852 = load i64, i64* %s2lenPtr
%val1853 = load i64*, i64** %prev_rowPtr
; pointer ref
%val1854 = getelementptr i64, i64* %val1853, i64 %val1852
%val1855 = load i64, i64* %val1854
ret i64 %val1855
}
@gsxtmbase137 = hidden constant [100 x i8] c"levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1877 = load i8*, i8** %_impzPtr
%zone1878 = bitcast i8* %tzone1877 to %mzone*

; let assign value to symbol levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd
%dat_levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone1878, i64 8)
%levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr = bitcast i8* %dat_levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd to { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***
%tzone1858 = load i8*, i8** %_impzPtr
%zone1859 = bitcast i8* %tzone1858 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1859)
; malloc closure structure
%clsptr1860 = call i8* @llvm_zone_malloc(%mzone* %zone1859, i64 24)
%closure1861 = bitcast i8* %clsptr1860 to { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*

; malloc environment structure
%envptr1862 = call i8* @llvm_zone_malloc(%mzone* %zone1859, i64 8)
%environment1863 = bitcast i8* %envptr1862 to {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***}*

; malloc closure address table
%addytable1864 = call %clsvar* @new_address_table()
%var1865 = bitcast [47 x i8]* @gsxtmbase119 to i8*
%var1866 = bitcast [50 x i8]* @gsxtmbase120 to i8*
%addytable1867 = call %clsvar* @add_address_table(%mzone* %zone1859, i8* %var1865, i32 0, i8* %var1866, i32 3, %clsvar* %addytable1864)
%address-table1868 = bitcast %clsvar* %addytable1867 to i8*

; insert table, function and environment into closure struct
%closure.table1871 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure1861, i32 0, i32 0
store i8* %address-table1868, i8** %closure.table1871
%closure.env1872 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure1861, i32 0, i32 1
store i8* %envptr1862, i8** %closure.env1872
%closure.func1873 = getelementptr { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure1861, i32 0, i32 2
store i64 (i8*, i8*, %String*, %String*)* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd__1648, i64 (i8*, i8*, %String*, %String*)** %closure.func1873
%closure_size1874 = call i64 @llvm_zone_mark_size(%mzone* %zone1859)
call void @llvm_zone_ptr_set_size(i8* %clsptr1860, i64 %closure_size1874)
%wrapper_ptr1875 = call i8* @llvm_zone_malloc(%mzone* %zone1859, i64 8)
%closure_wrapper1876 = bitcast i8* %wrapper_ptr1875 to { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**
store { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure1861, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_wrapper1876

; let value assignment
%levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd = select i1 true, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_wrapper1876, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_wrapper1876
store { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd, { i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd
%tmp_envptr1870 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}***}* %environment1863, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**** %tmp_envptr1870


%val1879 = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*** %levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypdPtr
ret {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %val1879
}


@levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*, %String*)*,  i64 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret i64 %result
}


define dllexport ccc i64 @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_native(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*, %String*)*,  i64 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret i64 %result
}


define dllexport ccc i8*  @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1880 = bitcast [100 x i8]* @gsxtmbase137 to i8*
call i32 (i8*, ...) @printf(i8* %var1880)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1881 = bitcast [100 x i8]* @gsxtmbase137 to i8*
call i32 (i8*, ...) @printf(i8* %var1881)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*, %String*)*,  i64 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}, {i8*, i8*, i64 (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %String*, %String*)*,  i64 (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase138 = hidden constant [50 x i8] c"similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd\00"
@gsxtmbase139 = hidden constant [53 x i8] c"{i8*, i8*, double (i8*, i8*, %String*, %String*)*}**\00"
define dllexport fastcc double @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd__1882(i8* %_impz,i8* %_impenv, %String* %s1, %String* %s2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1883 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, %String*, %String*)*}***}*
%similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, double (i8*, i8*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr = load {i8*, i8*, double (i8*, i8*, %String*, %String*)*}***, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**** %similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr_

; setup arguments
%s1Ptr = alloca %String*
store %String* %s1, %String** %s1Ptr
%s2Ptr = alloca %String*
store %String* %s2, %String** %s2Ptr


%val1884 = load %String*, %String** %s1Ptr
%val1885 = load %String*, %String** %s2Ptr
%res1886 = call fastcc i64 @levenshtein_adhoc_W2k2NCxTdHJpbmcqLFN0cmluZypd(%String* %val1884, %String* %val1885)
%val1887 = add i64 1, %res1886
%res1888 = call ccc double @i64tod(i64 %val1887)
%val1889 = fdiv double 1.0000000000000000000, %res1888
ret double %val1889
}
@gsxtmbase140 = hidden constant [103 x i8] c"similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1909 = load i8*, i8** %_impzPtr
%zone1910 = bitcast i8* %tzone1909 to %mzone*

; let assign value to symbol similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd
%dat_similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone1910, i64 8)
%similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr = bitcast i8* %dat_similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd to { i8*, i8*, double (i8*, i8*, %String*, %String*)*}***
%tzone1890 = load i8*, i8** %_impzPtr
%zone1891 = bitcast i8* %tzone1890 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1891)
; malloc closure structure
%clsptr1892 = call i8* @llvm_zone_malloc(%mzone* %zone1891, i64 24)
%closure1893 = bitcast i8* %clsptr1892 to { i8*, i8*, double (i8*, i8*, %String*, %String*)*}*

; malloc environment structure
%envptr1894 = call i8* @llvm_zone_malloc(%mzone* %zone1891, i64 8)
%environment1895 = bitcast i8* %envptr1894 to {{i8*, i8*, double (i8*, i8*, %String*, %String*)*}***}*

; malloc closure address table
%addytable1896 = call %clsvar* @new_address_table()
%var1897 = bitcast [50 x i8]* @gsxtmbase138 to i8*
%var1898 = bitcast [53 x i8]* @gsxtmbase139 to i8*
%addytable1899 = call %clsvar* @add_address_table(%mzone* %zone1891, i8* %var1897, i32 0, i8* %var1898, i32 3, %clsvar* %addytable1896)
%address-table1900 = bitcast %clsvar* %addytable1899 to i8*

; insert table, function and environment into closure struct
%closure.table1903 = getelementptr { i8*, i8*, double (i8*, i8*, %String*, %String*)*}, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure1893, i32 0, i32 0
store i8* %address-table1900, i8** %closure.table1903
%closure.env1904 = getelementptr { i8*, i8*, double (i8*, i8*, %String*, %String*)*}, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure1893, i32 0, i32 1
store i8* %envptr1894, i8** %closure.env1904
%closure.func1905 = getelementptr { i8*, i8*, double (i8*, i8*, %String*, %String*)*}, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure1893, i32 0, i32 2
store double (i8*, i8*, %String*, %String*)* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd__1882, double (i8*, i8*, %String*, %String*)** %closure.func1905
%closure_size1906 = call i64 @llvm_zone_mark_size(%mzone* %zone1891)
call void @llvm_zone_ptr_set_size(i8* %clsptr1892, i64 %closure_size1906)
%wrapper_ptr1907 = call i8* @llvm_zone_malloc(%mzone* %zone1891, i64 8)
%closure_wrapper1908 = bitcast i8* %wrapper_ptr1907 to { i8*, i8*, double (i8*, i8*, %String*, %String*)*}**
store { i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure1893, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_wrapper1908

; let value assignment
%similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd = select i1 true, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_wrapper1908, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_wrapper1908
store { i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd, { i8*, i8*, double (i8*, i8*, %String*, %String*)*}*** %similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd
%tmp_envptr1902 = getelementptr {{i8*, i8*, double (i8*, i8*, %String*, %String*)*}***}, {{i8*, i8*, double (i8*, i8*, %String*, %String*)*}***}* %environment1895, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, %String*, %String*)*}*** %similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**** %tmp_envptr1902


%val1911 = load {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}*** %similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypdPtr
ret {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %val1911
}


@similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %String*, %String*)*,  double (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret double %result
}


define dllexport ccc double @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_native(%String* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %String*, %String*)*,  double (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
ret double %result
}


define dllexport ccc i8*  @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1912 = bitcast [103 x i8]* @gsxtmbase140 to i8*
call i32 (i8*, ...) @printf(i8* %var1912)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1913 = bitcast [103 x i8]* @gsxtmbase140 to i8*
call i32 (i8*, ...) @printf(i8* %var1913)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %String*, %String*)*,  double (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc void @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*}, {%String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @similarity_adhoc_W2RvdWJsZSxTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %String*, %String*)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %String*, %String*)*}*, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %String*, %String*)*}, {i8*, i8*, double (i8*, i8*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %String*, %String*)*,  double (i8*, i8*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase141 = hidden constant [43 x i8] c"replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd\00"
@gsxtmbase142 = hidden constant [50 x i8] c"{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**\00"
define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd__1914(i8* %_impz,i8* %_impenv, i8* %orig, i8* %rep, i8* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1915 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}*
%replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**** %replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr_

; setup arguments
%origPtr = alloca i8*
store i8* %orig, i8** %origPtr
%repPtr = alloca i8*
store i8* %rep, i8** %repPtr
%withPtr = alloca i8*
store i8* %with, i8** %withPtr


%val1917 = load i8*, i8** %origPtr
%val1918 = load i8*, i8** %repPtr
%res1919 = call ccc i8* @strstr(i8* %val1917, i8* %val1918)
%val1920 = icmp eq i8* %res1919, null
br i1 %val1920, label %then1916, label %else1916

then1916:
%val1921 = load i8*, i8** %origPtr
%res1922 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1921)
ret %String* %res1922

else1916:
%tzone1925 = load i8*, i8** %_impzPtr
%zone1926 = bitcast i8* %tzone1925 to %mzone*

; let assign value to symbol origl
%origlPtr = alloca i64
%tzone1929 = load i8*, i8** %_impzPtr
%zone1930 = bitcast i8* %tzone1929 to %mzone*

; let assign value to symbol repl
%replPtr = alloca i64
%tzone1933 = load i8*, i8** %_impzPtr
%zone1934 = bitcast i8* %tzone1933 to %mzone*

; let assign value to symbol withl
%withlPtr = alloca i64
%tzone1938 = load i8*, i8** %_impzPtr
%zone1939 = bitcast i8* %tzone1938 to %mzone*

; let assign value to symbol pos
%posPtr = alloca i8*
%tzone1945 = load i8*, i8** %_impzPtr
%zone1946 = bitcast i8* %tzone1945 to %mzone*

; let assign value to symbol start
%startPtr = alloca i64
%tzone1955 = load i8*, i8** %_impzPtr
%zone1956 = bitcast i8* %tzone1955 to %mzone*

; let assign value to symbol newstr
%newstrPtr = alloca i8*
%val1923 = load i8*, i8** %origPtr
%res1924 = call ccc i64 @strlen(i8* %val1923)

; let value assignment
%origl = select i1 true, i64 %res1924, i64 %res1924
store i64 %origl, i64* %origlPtr

%val1927 = load i8*, i8** %repPtr
%res1928 = call ccc i64 @strlen(i8* %val1927)

; let value assignment
%repl = select i1 true, i64 %res1928, i64 %res1928
store i64 %repl, i64* %replPtr

%val1931 = load i8*, i8** %withPtr
%res1932 = call ccc i64 @strlen(i8* %val1931)

; let value assignment
%withl = select i1 true, i64 %res1932, i64 %res1932
store i64 %withl, i64* %withlPtr

%val1935 = load i8*, i8** %origPtr
%val1936 = load i8*, i8** %repPtr
%res1937 = call ccc i8* @strstr(i8* %val1935, i8* %val1936)

; let value assignment
%pos = select i1 true, i8* %res1937, i8* %res1937
store i8* %pos, i8** %posPtr

%val1940 = load i8*, i8** %posPtr
%res1941 = call ccc i64 @ptrtoi64(i8* %val1940)
%val1942 = load i8*, i8** %origPtr
%res1943 = call ccc i64 @ptrtoi64(i8* %val1942)
%val1944 = sub i64 %res1941, %res1943

; let value assignment
%start = select i1 true, i64 %val1944, i64 %val1944
store i64 %start, i64* %startPtr

%val1947 = load i8*, i8** %origPtr
%res1948 = call ccc i64 @strlen(i8* %val1947)
%val1949 = add i64 1, %res1948
%val1950 = load i64, i64* %withlPtr
%val1951 = load i64, i64* %replPtr
%val1952 = sub i64 %val1950, %val1951
%val1953 = add i64 %val1949, %val1952
%dat1954 = alloca i8, i64 %val1953, align 16

; let value assignment
%newstr = select i1 true, i8* %dat1954, i8* %dat1954
store i8* %newstr, i8** %newstrPtr

%val1957 = load i8*, i8** %newstrPtr
%val1958 = load i8*, i8** %origPtr
%res1959 = call ccc i64 @strlen(i8* %val1958)
%val1960 = add i64 1, %res1959
%val1961 = load i64, i64* %withlPtr
%val1962 = load i64, i64* %replPtr
%val1963 = sub i64 %val1961, %val1962
%val1964 = add i64 %val1960, %val1963
%res1965 = call ccc i8* @memset(i8* %val1957, i32 0, i64 %val1964)
%val1966 = load i8*, i8** %newstrPtr
%val1967 = load i8*, i8** %origPtr
%val1968 = load i64, i64* %startPtr
%res1969 = call ccc i8* @strncpy(i8* %val1966, i8* %val1967, i64 %val1968)
%val1970 = load i64, i64* %startPtr
%val1971 = load i8*, i8** %newstrPtr
; pointer ref
%val1972 = getelementptr i8, i8* %val1971, i64 %val1970
%val1973 = load i8*, i8** %withPtr
%val1974 = load i64, i64* %withlPtr
%res1975 = call ccc i8* @strncpy(i8* %val1972, i8* %val1973, i64 %val1974)
%val1976 = load i64, i64* %startPtr
%val1977 = load i64, i64* %withlPtr
%val1978 = add i64 %val1976, %val1977
%val1979 = load i8*, i8** %newstrPtr
; pointer ref
%val1980 = getelementptr i8, i8* %val1979, i64 %val1978
%val1981 = load i64, i64* %startPtr
%val1982 = load i64, i64* %replPtr
%val1983 = add i64 %val1981, %val1982
%val1984 = load i8*, i8** %origPtr
; pointer ref
%val1985 = getelementptr i8, i8* %val1984, i64 %val1983
%val1986 = load i64, i64* %origlPtr
%val1987 = load i64, i64* %startPtr
%val1988 = load i64, i64* %replPtr
%val1989 = add i64 %val1987, %val1988
%val1990 = sub i64 %val1986, %val1989
%res1991 = call ccc i8* @strncpy(i8* %val1980, i8* %val1985, i64 %val1990)
%val1992 = load i8*, i8** %newstrPtr
%res1993 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1992)
ret %String* %res1993
}
@gsxtmbase143 = hidden constant [96 x i8] c"replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2013 = load i8*, i8** %_impzPtr
%zone2014 = bitcast i8* %tzone2013 to %mzone*

; let assign value to symbol replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd
%dat_replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone2014, i64 8)
%replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr = bitcast i8* %dat_replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd to { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***
%tzone1994 = load i8*, i8** %_impzPtr
%zone1995 = bitcast i8* %tzone1994 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1995)
; malloc closure structure
%clsptr1996 = call i8* @llvm_zone_malloc(%mzone* %zone1995, i64 24)
%closure1997 = bitcast i8* %clsptr1996 to { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr1998 = call i8* @llvm_zone_malloc(%mzone* %zone1995, i64 8)
%environment1999 = bitcast i8* %envptr1998 to {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2000 = call %clsvar* @new_address_table()
%var2001 = bitcast [43 x i8]* @gsxtmbase141 to i8*
%var2002 = bitcast [50 x i8]* @gsxtmbase142 to i8*
%addytable2003 = call %clsvar* @add_address_table(%mzone* %zone1995, i8* %var2001, i32 0, i8* %var2002, i32 3, %clsvar* %addytable2000)
%address-table2004 = bitcast %clsvar* %addytable2003 to i8*

; insert table, function and environment into closure struct
%closure.table2007 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure1997, i32 0, i32 0
store i8* %address-table2004, i8** %closure.table2007
%closure.env2008 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure1997, i32 0, i32 1
store i8* %envptr1998, i8** %closure.env2008
%closure.func2009 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure1997, i32 0, i32 2
store %String* (i8*, i8*, i8*, i8*, i8*)* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd__1914, %String* (i8*, i8*, i8*, i8*, i8*)** %closure.func2009
%closure_size2010 = call i64 @llvm_zone_mark_size(%mzone* %zone1995)
call void @llvm_zone_ptr_set_size(i8* %clsptr1996, i64 %closure_size2010)
%wrapper_ptr2011 = call i8* @llvm_zone_malloc(%mzone* %zone1995, i64 8)
%closure_wrapper2012 = bitcast i8* %wrapper_ptr2011 to { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure1997, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper2012

; let value assignment
%replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper2012, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper2012
store { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*** %replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr

; add data to environment
; don't need to alloc for env var replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd
%tmp_envptr2006 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}* %environment1999, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*** %replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**** %tmp_envptr2006


%val2015 = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*** %replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr
ret {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %val2015
}


@replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_native(i8* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2016 = bitcast [96 x i8]* @gsxtmbase143 to i8*
call i32 (i8*, ...) @printf(i8* %var2016)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2017 = bitcast [96 x i8]* @gsxtmbase143 to i8*
call i32 (i8*, ...) @printf(i8* %var2017)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2018 = bitcast [96 x i8]* @gsxtmbase143 to i8*
call i32 (i8*, ...) @printf(i8* %var2018)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase144 = hidden constant [49 x i8] c"replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ\00"
@gsxtmbase145 = hidden constant [55 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**\00"
define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ__2019(i8* %_impz,i8* %_impenv, %String* %orig, i8* %rep, i8* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2020 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}*
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr_

; setup arguments
%origPtr = alloca %String*
store %String* %orig, %String** %origPtr
%repPtr = alloca i8*
store i8* %rep, i8** %repPtr
%withPtr = alloca i8*
store i8* %with, i8** %withPtr


%val2021 = load %String*, %String** %origPtr
%res2022 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2021)
%val2023 = load i8*, i8** %repPtr
%val2024 = load i8*, i8** %withPtr
%res2025 = call fastcc %String* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %res2022, i8* %val2023, i8* %val2024)
ret %String* %res2025
}
@gsxtmbase146 = hidden constant [102 x i8] c"replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2045 = load i8*, i8** %_impzPtr
%zone2046 = bitcast i8* %tzone2045 to %mzone*

; let assign value to symbol replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ
%dat_replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2046, i64 8)
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr = bitcast i8* %dat_replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***
%tzone2026 = load i8*, i8** %_impzPtr
%zone2027 = bitcast i8* %tzone2026 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2027)
; malloc closure structure
%clsptr2028 = call i8* @llvm_zone_malloc(%mzone* %zone2027, i64 24)
%closure2029 = bitcast i8* %clsptr2028 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*

; malloc environment structure
%envptr2030 = call i8* @llvm_zone_malloc(%mzone* %zone2027, i64 8)
%environment2031 = bitcast i8* %envptr2030 to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2032 = call %clsvar* @new_address_table()
%var2033 = bitcast [49 x i8]* @gsxtmbase144 to i8*
%var2034 = bitcast [55 x i8]* @gsxtmbase145 to i8*
%addytable2035 = call %clsvar* @add_address_table(%mzone* %zone2027, i8* %var2033, i32 0, i8* %var2034, i32 3, %clsvar* %addytable2032)
%address-table2036 = bitcast %clsvar* %addytable2035 to i8*

; insert table, function and environment into closure struct
%closure.table2039 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2029, i32 0, i32 0
store i8* %address-table2036, i8** %closure.table2039
%closure.env2040 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2029, i32 0, i32 1
store i8* %envptr2030, i8** %closure.env2040
%closure.func2041 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2029, i32 0, i32 2
store %String* (i8*, i8*, %String*, i8*, i8*)* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ__2019, %String* (i8*, i8*, %String*, i8*, i8*)** %closure.func2041
%closure_size2042 = call i64 @llvm_zone_mark_size(%mzone* %zone2027)
call void @llvm_zone_ptr_set_size(i8* %clsptr2028, i64 %closure_size2042)
%wrapper_ptr2043 = call i8* @llvm_zone_malloc(%mzone* %zone2027, i64 8)
%closure_wrapper2044 = bitcast i8* %wrapper_ptr2043 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2029, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_wrapper2044

; let value assignment
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_wrapper2044, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_wrapper2044
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr

; add data to environment
; don't need to alloc for env var replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ
%tmp_envptr2038 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}* %environment2031, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**** %tmp_envptr2038


%val2047 = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %val2047
}


@replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ(%String* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_native(%String* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2048 = bitcast [102 x i8]* @gsxtmbase146 to i8*
call i32 (i8*, ...) @printf(i8* %var2048)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2049 = bitcast [102 x i8]* @gsxtmbase146 to i8*
call i32 (i8*, ...) @printf(i8* %var2049)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2050 = bitcast [102 x i8]* @gsxtmbase146 to i8*
call i32 (i8*, ...) @printf(i8* %var2050)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i8*, i8*}*
%arg_p_0 = getelementptr {%String*, i8*, i8*}, {%String*, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i8*, i8*}, {%String*, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {%String*, i8*, i8*}, {%String*, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase147 = hidden constant [54 x i8] c"replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0\00"
@gsxtmbase148 = hidden constant [60 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**\00"
define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0__2051(i8* %_impz,i8* %_impenv, %String* %orig, i8* %rep, %String* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2052 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}*
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr_

; setup arguments
%origPtr = alloca %String*
store %String* %orig, %String** %origPtr
%repPtr = alloca i8*
store i8* %rep, i8** %repPtr
%withPtr = alloca %String*
store %String* %with, %String** %withPtr


%val2053 = load %String*, %String** %origPtr
%res2054 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2053)
%val2055 = load i8*, i8** %repPtr
%val2056 = load %String*, %String** %withPtr
%res2057 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2056)
%res2058 = call fastcc %String* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %res2054, i8* %val2055, i8* %res2057)
ret %String* %res2058
}
@gsxtmbase149 = hidden constant [107 x i8] c"replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2078 = load i8*, i8** %_impzPtr
%zone2079 = bitcast i8* %tzone2078 to %mzone*

; let assign value to symbol replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0
%dat_replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2079, i64 8)
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr = bitcast i8* %dat_replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***
%tzone2059 = load i8*, i8** %_impzPtr
%zone2060 = bitcast i8* %tzone2059 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2060)
; malloc closure structure
%clsptr2061 = call i8* @llvm_zone_malloc(%mzone* %zone2060, i64 24)
%closure2062 = bitcast i8* %clsptr2061 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*

; malloc environment structure
%envptr2063 = call i8* @llvm_zone_malloc(%mzone* %zone2060, i64 8)
%environment2064 = bitcast i8* %envptr2063 to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}*

; malloc closure address table
%addytable2065 = call %clsvar* @new_address_table()
%var2066 = bitcast [54 x i8]* @gsxtmbase147 to i8*
%var2067 = bitcast [60 x i8]* @gsxtmbase148 to i8*
%addytable2068 = call %clsvar* @add_address_table(%mzone* %zone2060, i8* %var2066, i32 0, i8* %var2067, i32 3, %clsvar* %addytable2065)
%address-table2069 = bitcast %clsvar* %addytable2068 to i8*

; insert table, function and environment into closure struct
%closure.table2072 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2062, i32 0, i32 0
store i8* %address-table2069, i8** %closure.table2072
%closure.env2073 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2062, i32 0, i32 1
store i8* %envptr2063, i8** %closure.env2073
%closure.func2074 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2062, i32 0, i32 2
store %String* (i8*, i8*, %String*, i8*, %String*)* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0__2051, %String* (i8*, i8*, %String*, i8*, %String*)** %closure.func2074
%closure_size2075 = call i64 @llvm_zone_mark_size(%mzone* %zone2060)
call void @llvm_zone_ptr_set_size(i8* %clsptr2061, i64 %closure_size2075)
%wrapper_ptr2076 = call i8* @llvm_zone_malloc(%mzone* %zone2060, i64 8)
%closure_wrapper2077 = bitcast i8* %wrapper_ptr2076 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2062, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_wrapper2077

; let value assignment
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_wrapper2077, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_wrapper2077
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0
%tmp_envptr2071 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}* %environment2064, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**** %tmp_envptr2071


%val2080 = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %val2080
}


@replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0(%String* %arg_0,i8* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_native(%String* %arg_0,i8* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2081 = bitcast [107 x i8]* @gsxtmbase149 to i8*
call i32 (i8*, ...) @printf(i8* %var2081)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2082 = bitcast [107 x i8]* @gsxtmbase149 to i8*
call i32 (i8*, ...) @printf(i8* %var2082)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2083 = bitcast [107 x i8]* @gsxtmbase149 to i8*
call i32 (i8*, ...) @printf(i8* %var2083)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i8*, %String*}*
%arg_p_0 = getelementptr {%String*, i8*, %String*}, {%String*, i8*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i8*, %String*}, {%String*, i8*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {%String*, i8*, %String*}, {%String*, i8*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase150 = hidden constant [59 x i8] c"replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd\00"
@gsxtmbase151 = hidden constant [65 x i8] c"{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**\00"
define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd__2084(i8* %_impz,i8* %_impenv, %String* %orig, %String* %rep, %String* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2085 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}*
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr_

; setup arguments
%origPtr = alloca %String*
store %String* %orig, %String** %origPtr
%repPtr = alloca %String*
store %String* %rep, %String** %repPtr
%withPtr = alloca %String*
store %String* %with, %String** %withPtr


%val2086 = load %String*, %String** %origPtr
%res2087 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2086)
%val2088 = load %String*, %String** %repPtr
%res2089 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2088)
%val2090 = load %String*, %String** %withPtr
%res2091 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2090)
%res2092 = call fastcc %String* @replace_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %res2087, i8* %res2089, i8* %res2091)
ret %String* %res2092
}
@gsxtmbase152 = hidden constant [112 x i8] c"replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2112 = load i8*, i8** %_impzPtr
%zone2113 = bitcast i8* %tzone2112 to %mzone*

; let assign value to symbol replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd
%dat_replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone2113, i64 8)
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr = bitcast i8* %dat_replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd to { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***
%tzone2093 = load i8*, i8** %_impzPtr
%zone2094 = bitcast i8* %tzone2093 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2094)
; malloc closure structure
%clsptr2095 = call i8* @llvm_zone_malloc(%mzone* %zone2094, i64 24)
%closure2096 = bitcast i8* %clsptr2095 to { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*

; malloc environment structure
%envptr2097 = call i8* @llvm_zone_malloc(%mzone* %zone2094, i64 8)
%environment2098 = bitcast i8* %envptr2097 to {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}*

; malloc closure address table
%addytable2099 = call %clsvar* @new_address_table()
%var2100 = bitcast [59 x i8]* @gsxtmbase150 to i8*
%var2101 = bitcast [65 x i8]* @gsxtmbase151 to i8*
%addytable2102 = call %clsvar* @add_address_table(%mzone* %zone2094, i8* %var2100, i32 0, i8* %var2101, i32 3, %clsvar* %addytable2099)
%address-table2103 = bitcast %clsvar* %addytable2102 to i8*

; insert table, function and environment into closure struct
%closure.table2106 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2096, i32 0, i32 0
store i8* %address-table2103, i8** %closure.table2106
%closure.env2107 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2096, i32 0, i32 1
store i8* %envptr2097, i8** %closure.env2107
%closure.func2108 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2096, i32 0, i32 2
store %String* (i8*, i8*, %String*, %String*, %String*)* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd__2084, %String* (i8*, i8*, %String*, %String*, %String*)** %closure.func2108
%closure_size2109 = call i64 @llvm_zone_mark_size(%mzone* %zone2094)
call void @llvm_zone_ptr_set_size(i8* %clsptr2095, i64 %closure_size2109)
%wrapper_ptr2110 = call i8* @llvm_zone_malloc(%mzone* %zone2094, i64 8)
%closure_wrapper2111 = bitcast i8* %wrapper_ptr2110 to { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2096, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper2111

; let value assignment
%replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper2111, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper2111
store { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd
%tmp_envptr2105 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}* %environment2098, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**** %tmp_envptr2105


%val2114 = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*** %replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %val2114
}


@replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd(%String* %arg_0,%String* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_native(%String* %arg_0,%String* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2115 = bitcast [112 x i8]* @gsxtmbase152 to i8*
call i32 (i8*, ...) @printf(i8* %var2115)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2116 = bitcast [112 x i8]* @gsxtmbase152 to i8*
call i32 (i8*, ...) @printf(i8* %var2116)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2117 = bitcast [112 x i8]* @gsxtmbase152 to i8*
call i32 (i8*, ...) @printf(i8* %var2117)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
%arg_p_2 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase153 = hidden constant [47 x i8] c"replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd\00"
define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd__2118(i8* %_impz,i8* %_impenv, i8* %orig, i8* %rep, i8* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2119 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}*
%replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**** %replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr_

; setup arguments
%origPtr = alloca i8*
store i8* %orig, i8** %origPtr
%repPtr = alloca i8*
store i8* %rep, i8** %repPtr
%withPtr = alloca i8*
store i8* %with, i8** %withPtr


%tzone2122 = load i8*, i8** %_impzPtr
%zone2123 = bitcast i8* %tzone2122 to %mzone*

; let assign value to symbol s1
%s1Ptr = alloca %String*
%tzone2126 = load i8*, i8** %_impzPtr
%zone2127 = bitcast i8* %tzone2126 to %mzone*

; let assign value to symbol s2
%s2Ptr = alloca %String*
%tzone2128 = load i8*, i8** %_impzPtr
%zone2129 = bitcast i8* %tzone2128 to %mzone*

; let assign value to symbol cnt
%cntPtr = alloca i64
%val2120 = load i8*, i8** %origPtr
%res2121 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2120)

; let value assignment
%s1 = select i1 true, %String* %res2121, %String* %res2121
store %String* %s1, %String** %s1Ptr

%val2124 = load i8*, i8** %withPtr
%res2125 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2124)

; let value assignment
%s2 = select i1 true, %String* %res2125, %String* %res2125
store %String* %s2, %String** %s2Ptr


; let value assignment
%cnt = select i1 true, i64 0, i64 0
store i64 %cnt, i64* %cntPtr

; promote local stack var allocations
%tzone2174 = load i8*, i8** %_impzPtr
%zone2175 = bitcast i8* %tzone2174 to %mzone*
%ifptr2155 = alloca i1
%ifptr2163 = alloca i1
%ifptr2156 = alloca i1
%ifptr2131 = alloca i1
%ifptr2139 = alloca i1
%ifptr2132 = alloca i1
; while loop
%val2133 = load %String*, %String** %s1Ptr
%val2134 = load %String*, %String** %s2Ptr
%res2135 = call fastcc i1 @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0(%String* %val2133, %String* %val2134)
br i1 %res2135, label %then2132, label %else2132

then2132:
%res2136 = call ccc i1 @impc_false()
store i1 %res2136, i1* %ifptr2132
br label %ifcont2132

else2132:
%res2137 = call ccc i1 @impc_true()
store i1 %res2137, i1* %ifptr2132
br label %ifcont2132

ifcont2132:
%ifres2138 = load i1, i1* %ifptr2132

br i1 %ifres2138, label %then2131, label %else2131

then2131:
%val2140 = load i64, i64* %cntPtr
%cmp2141 = icmp slt i64 %val2140, 100
br i1 %cmp2141, label %then2139, label %else2139

then2139:
%val2142 = load i64, i64* %cntPtr
%cmp2143 = icmp slt i64 %val2142, 100
store i1 %cmp2143, i1* %ifptr2139
br label %ifcont2139

else2139:
%res2144 = call ccc i1 @impc_false()
store i1 %res2144, i1* %ifptr2139
br label %ifcont2139

ifcont2139:
%ifres2145 = load i1, i1* %ifptr2139

store i1 %ifres2145, i1* %ifptr2131
br label %ifcont2131

else2131:
%res2146 = call ccc i1 @impc_false()
store i1 %res2146, i1* %ifptr2131
br label %ifcont2131

ifcont2131:
%ifres2147 = load i1, i1* %ifptr2131

br i1 %ifres2147, label %loop2130, label %after2130

loop2130:
; do set!
%val2148 = load %String*, %String** %s1Ptr
store %String* %val2148, %String** %s2Ptr
; do set!
%val2149 = load %String*, %String** %s1Ptr
%val2150 = load i8*, i8** %repPtr
%val2151 = load i8*, i8** %withPtr
%res2152 = call fastcc %String* @replace_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ(%String* %val2149, i8* %val2150, i8* %val2151)
store %String* %res2152, %String** %s1Ptr
; do set!
%val2153 = load i64, i64* %cntPtr
%val2154 = add i64 %val2153, 1
store i64 %val2154, i64* %cntPtr
%val2157 = load %String*, %String** %s1Ptr
%val2158 = load %String*, %String** %s2Ptr
%res2159 = call fastcc i1 @equal_adhoc_W2kxLFN0cmluZyosU3RyaW5nKl0(%String* %val2157, %String* %val2158)
br i1 %res2159, label %then2156, label %else2156

then2156:
%res2160 = call ccc i1 @impc_false()
store i1 %res2160, i1* %ifptr2156
br label %ifcont2156

else2156:
%res2161 = call ccc i1 @impc_true()
store i1 %res2161, i1* %ifptr2156
br label %ifcont2156

ifcont2156:
%ifres2162 = load i1, i1* %ifptr2156

br i1 %ifres2162, label %then2155, label %else2155

then2155:
%val2164 = load i64, i64* %cntPtr
%cmp2165 = icmp slt i64 %val2164, 100
br i1 %cmp2165, label %then2163, label %else2163

then2163:
%val2166 = load i64, i64* %cntPtr
%cmp2167 = icmp slt i64 %val2166, 100
store i1 %cmp2167, i1* %ifptr2163
br label %ifcont2163

else2163:
%res2168 = call ccc i1 @impc_false()
store i1 %res2168, i1* %ifptr2163
br label %ifcont2163

ifcont2163:
%ifres2169 = load i1, i1* %ifptr2163

store i1 %ifres2169, i1* %ifptr2155
br label %ifcont2155

else2155:
%res2170 = call ccc i1 @impc_false()
store i1 %res2170, i1* %ifptr2155
br label %ifcont2155

ifcont2155:
%ifres2171 = load i1, i1* %ifptr2155

br i1 %ifres2171, label %loop2130, label %after2130

after2130:
%val2173 = load %String*, %String** %s1Ptr
ret %String* %val2173
}
@gsxtmbase154 = hidden constant [100 x i8] c"replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2195 = load i8*, i8** %_impzPtr
%zone2196 = bitcast i8* %tzone2195 to %mzone*

; let assign value to symbol replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd
%dat_replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone2196, i64 8)
%replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr = bitcast i8* %dat_replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd to { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***
%tzone2176 = load i8*, i8** %_impzPtr
%zone2177 = bitcast i8* %tzone2176 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2177)
; malloc closure structure
%clsptr2178 = call i8* @llvm_zone_malloc(%mzone* %zone2177, i64 24)
%closure2179 = bitcast i8* %clsptr2178 to { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2180 = call i8* @llvm_zone_malloc(%mzone* %zone2177, i64 8)
%environment2181 = bitcast i8* %envptr2180 to {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2182 = call %clsvar* @new_address_table()
%var2183 = bitcast [47 x i8]* @gsxtmbase153 to i8*
%var2184 = bitcast [50 x i8]* @gsxtmbase142 to i8*
%addytable2185 = call %clsvar* @add_address_table(%mzone* %zone2177, i8* %var2183, i32 0, i8* %var2184, i32 3, %clsvar* %addytable2182)
%address-table2186 = bitcast %clsvar* %addytable2185 to i8*

; insert table, function and environment into closure struct
%closure.table2189 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure2179, i32 0, i32 0
store i8* %address-table2186, i8** %closure.table2189
%closure.env2190 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure2179, i32 0, i32 1
store i8* %envptr2180, i8** %closure.env2190
%closure.func2191 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure2179, i32 0, i32 2
store %String* (i8*, i8*, i8*, i8*, i8*)* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd__2118, %String* (i8*, i8*, i8*, i8*, i8*)** %closure.func2191
%closure_size2192 = call i64 @llvm_zone_mark_size(%mzone* %zone2177)
call void @llvm_zone_ptr_set_size(i8* %clsptr2178, i64 %closure_size2192)
%wrapper_ptr2193 = call i8* @llvm_zone_malloc(%mzone* %zone2177, i64 8)
%closure_wrapper2194 = bitcast i8* %wrapper_ptr2193 to { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure2179, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper2194

; let value assignment
%replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper2194, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper2194
store { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd, { i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*** %replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr

; add data to environment
; don't need to alloc for env var replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd
%tmp_envptr2188 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}***}* %environment2181, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*** %replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**** %tmp_envptr2188


%val2197 = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*** %replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpdPtr
ret {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %val2197
}


@replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_native(i8* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2198 = bitcast [100 x i8]* @gsxtmbase154 to i8*
call i32 (i8*, ...) @printf(i8* %var2198)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2199 = bitcast [100 x i8]* @gsxtmbase154 to i8*
call i32 (i8*, ...) @printf(i8* %var2199)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2200 = bitcast [100 x i8]* @gsxtmbase154 to i8*
call i32 (i8*, ...) @printf(i8* %var2200)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase155 = hidden constant [53 x i8] c"replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ\00"
define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ__2201(i8* %_impz,i8* %_impenv, %String* %orig, i8* %rep, i8* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2202 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}*
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr_

; setup arguments
%origPtr = alloca %String*
store %String* %orig, %String** %origPtr
%repPtr = alloca i8*
store i8* %rep, i8** %repPtr
%withPtr = alloca i8*
store i8* %with, i8** %withPtr


%val2203 = load %String*, %String** %origPtr
%res2204 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2203)
%val2205 = load i8*, i8** %repPtr
%val2206 = load i8*, i8** %withPtr
%res2207 = call fastcc %String* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %res2204, i8* %val2205, i8* %val2206)
ret %String* %res2207
}
@gsxtmbase156 = hidden constant [106 x i8] c"replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2227 = load i8*, i8** %_impzPtr
%zone2228 = bitcast i8* %tzone2227 to %mzone*

; let assign value to symbol replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ
%dat_replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2228, i64 8)
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr = bitcast i8* %dat_replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***
%tzone2208 = load i8*, i8** %_impzPtr
%zone2209 = bitcast i8* %tzone2208 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2209)
; malloc closure structure
%clsptr2210 = call i8* @llvm_zone_malloc(%mzone* %zone2209, i64 24)
%closure2211 = bitcast i8* %clsptr2210 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*

; malloc environment structure
%envptr2212 = call i8* @llvm_zone_malloc(%mzone* %zone2209, i64 8)
%environment2213 = bitcast i8* %envptr2212 to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2214 = call %clsvar* @new_address_table()
%var2215 = bitcast [53 x i8]* @gsxtmbase155 to i8*
%var2216 = bitcast [55 x i8]* @gsxtmbase145 to i8*
%addytable2217 = call %clsvar* @add_address_table(%mzone* %zone2209, i8* %var2215, i32 0, i8* %var2216, i32 3, %clsvar* %addytable2214)
%address-table2218 = bitcast %clsvar* %addytable2217 to i8*

; insert table, function and environment into closure struct
%closure.table2221 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2211, i32 0, i32 0
store i8* %address-table2218, i8** %closure.table2221
%closure.env2222 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2211, i32 0, i32 1
store i8* %envptr2212, i8** %closure.env2222
%closure.func2223 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2211, i32 0, i32 2
store %String* (i8*, i8*, %String*, i8*, i8*)* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ__2201, %String* (i8*, i8*, %String*, i8*, i8*)** %closure.func2223
%closure_size2224 = call i64 @llvm_zone_mark_size(%mzone* %zone2209)
call void @llvm_zone_ptr_set_size(i8* %clsptr2210, i64 %closure_size2224)
%wrapper_ptr2225 = call i8* @llvm_zone_malloc(%mzone* %zone2209, i64 8)
%closure_wrapper2226 = bitcast i8* %wrapper_ptr2225 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure2211, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_wrapper2226

; let value assignment
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_wrapper2226, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_wrapper2226
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr

; add data to environment
; don't need to alloc for env var replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ
%tmp_envptr2220 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}***}* %environment2213, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**** %tmp_envptr2220


%val2229 = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %val2229
}


@replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ(%String* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_native(%String* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2230 = bitcast [106 x i8]* @gsxtmbase156 to i8*
call i32 (i8*, ...) @printf(i8* %var2230)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2231 = bitcast [106 x i8]* @gsxtmbase156 to i8*
call i32 (i8*, ...) @printf(i8* %var2231)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2232 = bitcast [106 x i8]* @gsxtmbase156 to i8*
call i32 (i8*, ...) @printf(i8* %var2232)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i8*, i8*}*
%arg_p_0 = getelementptr {%String*, i8*, i8*}, {%String*, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i8*, i8*}, {%String*, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {%String*, i8*, i8*}, {%String*, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, i8*)*,  %String* (i8*, i8*, %String*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase157 = hidden constant [58 x i8] c"replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0\00"
define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0__2233(i8* %_impz,i8* %_impenv, %String* %orig, i8* %rep, %String* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2234 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}*
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr_

; setup arguments
%origPtr = alloca %String*
store %String* %orig, %String** %origPtr
%repPtr = alloca i8*
store i8* %rep, i8** %repPtr
%withPtr = alloca %String*
store %String* %with, %String** %withPtr


%val2235 = load %String*, %String** %origPtr
%res2236 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2235)
%val2237 = load i8*, i8** %repPtr
%val2238 = load %String*, %String** %withPtr
%res2239 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2238)
%res2240 = call fastcc %String* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %res2236, i8* %val2237, i8* %res2239)
ret %String* %res2240
}
@gsxtmbase158 = hidden constant [111 x i8] c"replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2260 = load i8*, i8** %_impzPtr
%zone2261 = bitcast i8* %tzone2260 to %mzone*

; let assign value to symbol replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0
%dat_replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2261, i64 8)
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr = bitcast i8* %dat_replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***
%tzone2241 = load i8*, i8** %_impzPtr
%zone2242 = bitcast i8* %tzone2241 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2242)
; malloc closure structure
%clsptr2243 = call i8* @llvm_zone_malloc(%mzone* %zone2242, i64 24)
%closure2244 = bitcast i8* %clsptr2243 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*

; malloc environment structure
%envptr2245 = call i8* @llvm_zone_malloc(%mzone* %zone2242, i64 8)
%environment2246 = bitcast i8* %envptr2245 to {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}*

; malloc closure address table
%addytable2247 = call %clsvar* @new_address_table()
%var2248 = bitcast [58 x i8]* @gsxtmbase157 to i8*
%var2249 = bitcast [60 x i8]* @gsxtmbase148 to i8*
%addytable2250 = call %clsvar* @add_address_table(%mzone* %zone2242, i8* %var2248, i32 0, i8* %var2249, i32 3, %clsvar* %addytable2247)
%address-table2251 = bitcast %clsvar* %addytable2250 to i8*

; insert table, function and environment into closure struct
%closure.table2254 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2244, i32 0, i32 0
store i8* %address-table2251, i8** %closure.table2254
%closure.env2255 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2244, i32 0, i32 1
store i8* %envptr2245, i8** %closure.env2255
%closure.func2256 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2244, i32 0, i32 2
store %String* (i8*, i8*, %String*, i8*, %String*)* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0__2233, %String* (i8*, i8*, %String*, i8*, %String*)** %closure.func2256
%closure_size2257 = call i64 @llvm_zone_mark_size(%mzone* %zone2242)
call void @llvm_zone_ptr_set_size(i8* %clsptr2243, i64 %closure_size2257)
%wrapper_ptr2258 = call i8* @llvm_zone_malloc(%mzone* %zone2242, i64 8)
%closure_wrapper2259 = bitcast i8* %wrapper_ptr2258 to { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure2244, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_wrapper2259

; let value assignment
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_wrapper2259, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_wrapper2259
store { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0
%tmp_envptr2253 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}***}* %environment2246, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**** %tmp_envptr2253


%val2262 = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %val2262
}


@replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0(%String* %arg_0,i8* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_native(%String* %arg_0,i8* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2263 = bitcast [111 x i8]* @gsxtmbase158 to i8*
call i32 (i8*, ...) @printf(i8* %var2263)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2264 = bitcast [111 x i8]* @gsxtmbase158 to i8*
call i32 (i8*, ...) @printf(i8* %var2264)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2265 = bitcast [111 x i8]* @gsxtmbase158 to i8*
call i32 (i8*, ...) @printf(i8* %var2265)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i8*, %String*}*
%arg_p_0 = getelementptr {%String*, i8*, %String*}, {%String*, i8*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i8*, %String*}, {%String*, i8*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {%String*, i8*, %String*}, {%String*, i8*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixpOCosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, i8*, %String*)*,  %String* (i8*, i8*, %String*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i8* %arg_1, %String* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase159 = hidden constant [63 x i8] c"replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd\00"
define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd__2266(i8* %_impz,i8* %_impenv, %String* %orig, %String* %rep, %String* %with) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2267 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}*
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr_

; setup arguments
%origPtr = alloca %String*
store %String* %orig, %String** %origPtr
%repPtr = alloca %String*
store %String* %rep, %String** %repPtr
%withPtr = alloca %String*
store %String* %with, %String** %withPtr


%val2268 = load %String*, %String** %origPtr
%res2269 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2268)
%val2270 = load %String*, %String** %repPtr
%res2271 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2270)
%val2272 = load %String*, %String** %withPtr
%res2273 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val2272)
%res2274 = call fastcc %String* @replace_all_adhoc_W1N0cmluZyosaTgqLGk4KixpOCpd(i8* %res2269, i8* %res2271, i8* %res2273)
ret %String* %res2274
}
@gsxtmbase160 = hidden constant [116 x i8] c"replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2294 = load i8*, i8** %_impzPtr
%zone2295 = bitcast i8* %tzone2294 to %mzone*

; let assign value to symbol replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd
%dat_replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone2295, i64 8)
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr = bitcast i8* %dat_replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd to { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***
%tzone2275 = load i8*, i8** %_impzPtr
%zone2276 = bitcast i8* %tzone2275 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2276)
; malloc closure structure
%clsptr2277 = call i8* @llvm_zone_malloc(%mzone* %zone2276, i64 24)
%closure2278 = bitcast i8* %clsptr2277 to { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*

; malloc environment structure
%envptr2279 = call i8* @llvm_zone_malloc(%mzone* %zone2276, i64 8)
%environment2280 = bitcast i8* %envptr2279 to {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}*

; malloc closure address table
%addytable2281 = call %clsvar* @new_address_table()
%var2282 = bitcast [63 x i8]* @gsxtmbase159 to i8*
%var2283 = bitcast [65 x i8]* @gsxtmbase151 to i8*
%addytable2284 = call %clsvar* @add_address_table(%mzone* %zone2276, i8* %var2282, i32 0, i8* %var2283, i32 3, %clsvar* %addytable2281)
%address-table2285 = bitcast %clsvar* %addytable2284 to i8*

; insert table, function and environment into closure struct
%closure.table2288 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2278, i32 0, i32 0
store i8* %address-table2285, i8** %closure.table2288
%closure.env2289 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2278, i32 0, i32 1
store i8* %envptr2279, i8** %closure.env2289
%closure.func2290 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2278, i32 0, i32 2
store %String* (i8*, i8*, %String*, %String*, %String*)* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd__2266, %String* (i8*, i8*, %String*, %String*, %String*)** %closure.func2290
%closure_size2291 = call i64 @llvm_zone_mark_size(%mzone* %zone2276)
call void @llvm_zone_ptr_set_size(i8* %clsptr2277, i64 %closure_size2291)
%wrapper_ptr2292 = call i8* @llvm_zone_malloc(%mzone* %zone2276, i64 8)
%closure_wrapper2293 = bitcast i8* %wrapper_ptr2292 to { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure2278, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper2293

; let value assignment
%replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper2293, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper2293
store { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd, { i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd
%tmp_envptr2287 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}***}* %environment2280, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**** %tmp_envptr2287


%val2296 = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*** %replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr
ret {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %val2296
}


@replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd(%String* %arg_0,%String* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc %String* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_native(%String* %arg_0,%String* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
ret %String* %result
}


define dllexport ccc i8*  @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2297 = bitcast [116 x i8]* @gsxtmbase160 to i8*
call i32 (i8*, ...) @printf(i8* %var2297)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2298 = bitcast [116 x i8]* @gsxtmbase160 to i8*
call i32 (i8*, ...) @printf(i8* %var2298)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2299 = bitcast [116 x i8]* @gsxtmbase160 to i8*
call i32 (i8*, ...) @printf(i8* %var2299)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
%arg_p_2 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @replace_all_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*, %String*, %String*)*,  %String* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase161 = hidden constant [2 x i8] c"
\00"
@gsxtmbase162 = hidden constant [33 x i8] c"format_return_adhoc_W1N0cmluZypd\00"
@gsxtmbase163 = hidden constant [35 x i8] c"{i8*, i8*, %String* (i8*, i8*)*}**\00"
define dllexport fastcc %String* @format_return_adhoc_W1N0cmluZypd__2300(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2301 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*)*}***}*
%format_return_adhoc_W1N0cmluZypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%format_return_adhoc_W1N0cmluZypdPtr = load {i8*, i8*, %String* (i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*)*}**** %format_return_adhoc_W1N0cmluZypdPtr_

; setup arguments


%tzone2303 = load i8*, i8** %_impzPtr
%zone2304 = bitcast i8* %tzone2303 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2302 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2302, i8* %dat2302
store i8* %str, i8** %strPtr

%val2305 = load i8*, i8** %strPtr
%var2306 = bitcast [2 x i8]* @gsxtmbase161 to i8*

%val2307 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2305, i8* %var2306)
%val2308 = load i8*, i8** %strPtr
%res2309 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2308)
ret %String* %res2309
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*)*}** @format_return_adhoc_W1N0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2329 = load i8*, i8** %_impzPtr
%zone2330 = bitcast i8* %tzone2329 to %mzone*

; let assign value to symbol format_return_adhoc_W1N0cmluZypd
%dat_format_return_adhoc_W1N0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone2330, i64 8)
%format_return_adhoc_W1N0cmluZypdPtr = bitcast i8* %dat_format_return_adhoc_W1N0cmluZypd to { i8*, i8*, %String* (i8*, i8*)*}***
%tzone2310 = load i8*, i8** %_impzPtr
%zone2311 = bitcast i8* %tzone2310 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2311)
; malloc closure structure
%clsptr2312 = call i8* @llvm_zone_malloc(%mzone* %zone2311, i64 24)
%closure2313 = bitcast i8* %clsptr2312 to { i8*, i8*, %String* (i8*, i8*)*}*

; malloc environment structure
%envptr2314 = call i8* @llvm_zone_malloc(%mzone* %zone2311, i64 8)
%environment2315 = bitcast i8* %envptr2314 to {{i8*, i8*, %String* (i8*, i8*)*}***}*

; malloc closure address table
%addytable2316 = call %clsvar* @new_address_table()
%var2317 = bitcast [33 x i8]* @gsxtmbase162 to i8*
%var2318 = bitcast [35 x i8]* @gsxtmbase163 to i8*
%addytable2319 = call %clsvar* @add_address_table(%mzone* %zone2311, i8* %var2317, i32 0, i8* %var2318, i32 3, %clsvar* %addytable2316)
%address-table2320 = bitcast %clsvar* %addytable2319 to i8*

; insert table, function and environment into closure struct
%closure.table2323 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2313, i32 0, i32 0
store i8* %address-table2320, i8** %closure.table2323
%closure.env2324 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2313, i32 0, i32 1
store i8* %envptr2314, i8** %closure.env2324
%closure.func2325 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2313, i32 0, i32 2
store %String* (i8*, i8*)* @format_return_adhoc_W1N0cmluZypd__2300, %String* (i8*, i8*)** %closure.func2325
%closure_size2326 = call i64 @llvm_zone_mark_size(%mzone* %zone2311)
call void @llvm_zone_ptr_set_size(i8* %clsptr2312, i64 %closure_size2326)
%wrapper_ptr2327 = call i8* @llvm_zone_malloc(%mzone* %zone2311, i64 8)
%closure_wrapper2328 = bitcast i8* %wrapper_ptr2327 to { i8*, i8*, %String* (i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*)*}* %closure2313, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2328

; let value assignment
%format_return_adhoc_W1N0cmluZypd = select i1 true, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2328, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2328
store { i8*, i8*, %String* (i8*, i8*)*}** %format_return_adhoc_W1N0cmluZypd, { i8*, i8*, %String* (i8*, i8*)*}*** %format_return_adhoc_W1N0cmluZypdPtr

; add data to environment
; don't need to alloc for env var format_return_adhoc_W1N0cmluZypd
%tmp_envptr2322 = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %environment2315, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*)*}*** %format_return_adhoc_W1N0cmluZypdPtr, {i8*, i8*, %String* (i8*, i8*)*}**** %tmp_envptr2322


%val2331 = load {i8*, i8*, %String* (i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*)*}*** %format_return_adhoc_W1N0cmluZypdPtr
ret {i8*, i8*, %String* (i8*, i8*)*}** %val2331
}


@format_return_adhoc_W1N0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@format_return_adhoc_W1N0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_return_adhoc_W1N0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*)*}** @format_return_adhoc_W1N0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_return_adhoc_W1N0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_return_adhoc_W1N0cmluZypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc %String* @format_return_adhoc_W1N0cmluZypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc i8*  @format_return_adhoc_W1N0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_return_adhoc_W1N0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase164 = hidden constant [2 x i8] c" \00"
@gsxtmbase165 = hidden constant [32 x i8] c"format_space_adhoc_W1N0cmluZypd\00"
define dllexport fastcc %String* @format_space_adhoc_W1N0cmluZypd__2332(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2333 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*)*}***}*
%format_space_adhoc_W1N0cmluZypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%format_space_adhoc_W1N0cmluZypdPtr = load {i8*, i8*, %String* (i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*)*}**** %format_space_adhoc_W1N0cmluZypdPtr_

; setup arguments


%var2334 = bitcast [2 x i8]* @gsxtmbase164 to i8*
%res2335 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var2334)
ret %String* %res2335
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*)*}** @format_space_adhoc_W1N0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2355 = load i8*, i8** %_impzPtr
%zone2356 = bitcast i8* %tzone2355 to %mzone*

; let assign value to symbol format_space_adhoc_W1N0cmluZypd
%dat_format_space_adhoc_W1N0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone2356, i64 8)
%format_space_adhoc_W1N0cmluZypdPtr = bitcast i8* %dat_format_space_adhoc_W1N0cmluZypd to { i8*, i8*, %String* (i8*, i8*)*}***
%tzone2336 = load i8*, i8** %_impzPtr
%zone2337 = bitcast i8* %tzone2336 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2337)
; malloc closure structure
%clsptr2338 = call i8* @llvm_zone_malloc(%mzone* %zone2337, i64 24)
%closure2339 = bitcast i8* %clsptr2338 to { i8*, i8*, %String* (i8*, i8*)*}*

; malloc environment structure
%envptr2340 = call i8* @llvm_zone_malloc(%mzone* %zone2337, i64 8)
%environment2341 = bitcast i8* %envptr2340 to {{i8*, i8*, %String* (i8*, i8*)*}***}*

; malloc closure address table
%addytable2342 = call %clsvar* @new_address_table()
%var2343 = bitcast [32 x i8]* @gsxtmbase165 to i8*
%var2344 = bitcast [35 x i8]* @gsxtmbase163 to i8*
%addytable2345 = call %clsvar* @add_address_table(%mzone* %zone2337, i8* %var2343, i32 0, i8* %var2344, i32 3, %clsvar* %addytable2342)
%address-table2346 = bitcast %clsvar* %addytable2345 to i8*

; insert table, function and environment into closure struct
%closure.table2349 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2339, i32 0, i32 0
store i8* %address-table2346, i8** %closure.table2349
%closure.env2350 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2339, i32 0, i32 1
store i8* %envptr2340, i8** %closure.env2350
%closure.func2351 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2339, i32 0, i32 2
store %String* (i8*, i8*)* @format_space_adhoc_W1N0cmluZypd__2332, %String* (i8*, i8*)** %closure.func2351
%closure_size2352 = call i64 @llvm_zone_mark_size(%mzone* %zone2337)
call void @llvm_zone_ptr_set_size(i8* %clsptr2338, i64 %closure_size2352)
%wrapper_ptr2353 = call i8* @llvm_zone_malloc(%mzone* %zone2337, i64 8)
%closure_wrapper2354 = bitcast i8* %wrapper_ptr2353 to { i8*, i8*, %String* (i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*)*}* %closure2339, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2354

; let value assignment
%format_space_adhoc_W1N0cmluZypd = select i1 true, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2354, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2354
store { i8*, i8*, %String* (i8*, i8*)*}** %format_space_adhoc_W1N0cmluZypd, { i8*, i8*, %String* (i8*, i8*)*}*** %format_space_adhoc_W1N0cmluZypdPtr

; add data to environment
; don't need to alloc for env var format_space_adhoc_W1N0cmluZypd
%tmp_envptr2348 = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %environment2341, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*)*}*** %format_space_adhoc_W1N0cmluZypdPtr, {i8*, i8*, %String* (i8*, i8*)*}**** %tmp_envptr2348


%val2357 = load {i8*, i8*, %String* (i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*)*}*** %format_space_adhoc_W1N0cmluZypdPtr
ret {i8*, i8*, %String* (i8*, i8*)*}** %val2357
}


@format_space_adhoc_W1N0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@format_space_adhoc_W1N0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_space_adhoc_W1N0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*)*}** @format_space_adhoc_W1N0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_space_adhoc_W1N0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_space_adhoc_W1N0cmluZypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc %String* @format_space_adhoc_W1N0cmluZypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc i8*  @format_space_adhoc_W1N0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_space_adhoc_W1N0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase166 = hidden constant [30 x i8] c"format_adhoc_W1N0cmluZyosaTFd\00"
@gsxtmbase167 = hidden constant [39 x i8] c"{i8*, i8*, %String* (i8*, i8*, i1)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTFd__2358(i8* %_impz,i8* %_impenv, i1 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2359 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i1)*}***}*
%format_adhoc_W1N0cmluZyosaTFdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i1)*}***}, {{i8*, i8*, %String* (i8*, i8*, i1)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosaTFdPtr = load {i8*, i8*, %String* (i8*, i8*, i1)*}***, {i8*, i8*, %String* (i8*, i8*, i1)*}**** %format_adhoc_W1N0cmluZyosaTFdPtr_

; setup arguments
%xPtr = alloca i1
store i1 %x, i1* %xPtr


%tzone2361 = load i8*, i8** %_impzPtr
%zone2362 = bitcast i8* %tzone2361 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2360 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2360, i8* %dat2360
store i8* %str, i8** %strPtr

%val2363 = load i8*, i8** %strPtr
%var2364 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2365 = load i1, i1* %xPtr

%val2366 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2363, i8* %var2364, i1 %val2365)
%val2367 = load i8*, i8** %strPtr
%res2368 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2367)
ret %String* %res2368
}
@gsxtmbase168 = hidden constant [83 x i8] c"format_adhoc_W1N0cmluZyosaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i1)*}** @format_adhoc_W1N0cmluZyosaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2388 = load i8*, i8** %_impzPtr
%zone2389 = bitcast i8* %tzone2388 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosaTFd
%dat_format_adhoc_W1N0cmluZyosaTFd = call i8* @llvm_zone_malloc(%mzone* %zone2389, i64 8)
%format_adhoc_W1N0cmluZyosaTFdPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosaTFd to { i8*, i8*, %String* (i8*, i8*, i1)*}***
%tzone2369 = load i8*, i8** %_impzPtr
%zone2370 = bitcast i8* %tzone2369 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2370)
; malloc closure structure
%clsptr2371 = call i8* @llvm_zone_malloc(%mzone* %zone2370, i64 24)
%closure2372 = bitcast i8* %clsptr2371 to { i8*, i8*, %String* (i8*, i8*, i1)*}*

; malloc environment structure
%envptr2373 = call i8* @llvm_zone_malloc(%mzone* %zone2370, i64 8)
%environment2374 = bitcast i8* %envptr2373 to {{i8*, i8*, %String* (i8*, i8*, i1)*}***}*

; malloc closure address table
%addytable2375 = call %clsvar* @new_address_table()
%var2376 = bitcast [30 x i8]* @gsxtmbase166 to i8*
%var2377 = bitcast [39 x i8]* @gsxtmbase167 to i8*
%addytable2378 = call %clsvar* @add_address_table(%mzone* %zone2370, i8* %var2376, i32 0, i8* %var2377, i32 3, %clsvar* %addytable2375)
%address-table2379 = bitcast %clsvar* %addytable2378 to i8*

; insert table, function and environment into closure struct
%closure.table2382 = getelementptr { i8*, i8*, %String* (i8*, i8*, i1)*}, { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2372, i32 0, i32 0
store i8* %address-table2379, i8** %closure.table2382
%closure.env2383 = getelementptr { i8*, i8*, %String* (i8*, i8*, i1)*}, { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2372, i32 0, i32 1
store i8* %envptr2373, i8** %closure.env2383
%closure.func2384 = getelementptr { i8*, i8*, %String* (i8*, i8*, i1)*}, { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2372, i32 0, i32 2
store %String* (i8*, i8*, i1)* @format_adhoc_W1N0cmluZyosaTFd__2358, %String* (i8*, i8*, i1)** %closure.func2384
%closure_size2385 = call i64 @llvm_zone_mark_size(%mzone* %zone2370)
call void @llvm_zone_ptr_set_size(i8* %clsptr2371, i64 %closure_size2385)
%wrapper_ptr2386 = call i8* @llvm_zone_malloc(%mzone* %zone2370, i64 8)
%closure_wrapper2387 = bitcast i8* %wrapper_ptr2386 to { i8*, i8*, %String* (i8*, i8*, i1)*}**
store { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2372, { i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_wrapper2387

; let value assignment
%format_adhoc_W1N0cmluZyosaTFd = select i1 true, { i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_wrapper2387, { i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_wrapper2387
store { i8*, i8*, %String* (i8*, i8*, i1)*}** %format_adhoc_W1N0cmluZyosaTFd, { i8*, i8*, %String* (i8*, i8*, i1)*}*** %format_adhoc_W1N0cmluZyosaTFdPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosaTFd
%tmp_envptr2381 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i1)*}***}, {{i8*, i8*, %String* (i8*, i8*, i1)*}***}* %environment2374, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i1)*}*** %format_adhoc_W1N0cmluZyosaTFdPtr, {i8*, i8*, %String* (i8*, i8*, i1)*}**** %tmp_envptr2381


%val2390 = load {i8*, i8*, %String* (i8*, i8*, i1)*}**, {i8*, i8*, %String* (i8*, i8*, i1)*}*** %format_adhoc_W1N0cmluZyosaTFdPtr
ret {i8*, i8*, %String* (i8*, i8*, i1)*}** %val2390
}


@format_adhoc_W1N0cmluZyosaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i1)*}** @format_adhoc_W1N0cmluZyosaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTFd(i1 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosaTFd_native(i1 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2391 = bitcast [83 x i8]* @gsxtmbase168 to i8*
call i32 (i8*, ...) @printf(i8* %var2391)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i1  @i1value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1}*
%arg_p_0 = getelementptr {i1}, {i1}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase169 = hidden constant [30 x i8] c"format_adhoc_W1N0cmluZyosaThd\00"
@gsxtmbase170 = hidden constant [39 x i8] c"{i8*, i8*, %String* (i8*, i8*, i8)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaThd__2392(i8* %_impz,i8* %_impenv, i8 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2393 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8)*}***}*
%format_adhoc_W1N0cmluZyosaThdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosaThdPtr = load {i8*, i8*, %String* (i8*, i8*, i8)*}***, {i8*, i8*, %String* (i8*, i8*, i8)*}**** %format_adhoc_W1N0cmluZyosaThdPtr_

; setup arguments
%xPtr = alloca i8
store i8 %x, i8* %xPtr


%tzone2395 = load i8*, i8** %_impzPtr
%zone2396 = bitcast i8* %tzone2395 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2394 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2394, i8* %dat2394
store i8* %str, i8** %strPtr

%val2397 = load i8*, i8** %strPtr
%var2398 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2399 = load i8, i8* %xPtr

%val2400 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2397, i8* %var2398, i8 %val2399)
%val2401 = load i8*, i8** %strPtr
%res2402 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2401)
ret %String* %res2402
}
@gsxtmbase171 = hidden constant [83 x i8] c"format_adhoc_W1N0cmluZyosaThd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8)*}** @format_adhoc_W1N0cmluZyosaThd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2422 = load i8*, i8** %_impzPtr
%zone2423 = bitcast i8* %tzone2422 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosaThd
%dat_format_adhoc_W1N0cmluZyosaThd = call i8* @llvm_zone_malloc(%mzone* %zone2423, i64 8)
%format_adhoc_W1N0cmluZyosaThdPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosaThd to { i8*, i8*, %String* (i8*, i8*, i8)*}***
%tzone2403 = load i8*, i8** %_impzPtr
%zone2404 = bitcast i8* %tzone2403 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2404)
; malloc closure structure
%clsptr2405 = call i8* @llvm_zone_malloc(%mzone* %zone2404, i64 24)
%closure2406 = bitcast i8* %clsptr2405 to { i8*, i8*, %String* (i8*, i8*, i8)*}*

; malloc environment structure
%envptr2407 = call i8* @llvm_zone_malloc(%mzone* %zone2404, i64 8)
%environment2408 = bitcast i8* %envptr2407 to {{i8*, i8*, %String* (i8*, i8*, i8)*}***}*

; malloc closure address table
%addytable2409 = call %clsvar* @new_address_table()
%var2410 = bitcast [30 x i8]* @gsxtmbase169 to i8*
%var2411 = bitcast [39 x i8]* @gsxtmbase170 to i8*
%addytable2412 = call %clsvar* @add_address_table(%mzone* %zone2404, i8* %var2410, i32 0, i8* %var2411, i32 3, %clsvar* %addytable2409)
%address-table2413 = bitcast %clsvar* %addytable2412 to i8*

; insert table, function and environment into closure struct
%closure.table2416 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8)*}, { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2406, i32 0, i32 0
store i8* %address-table2413, i8** %closure.table2416
%closure.env2417 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8)*}, { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2406, i32 0, i32 1
store i8* %envptr2407, i8** %closure.env2417
%closure.func2418 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8)*}, { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2406, i32 0, i32 2
store %String* (i8*, i8*, i8)* @format_adhoc_W1N0cmluZyosaThd__2392, %String* (i8*, i8*, i8)** %closure.func2418
%closure_size2419 = call i64 @llvm_zone_mark_size(%mzone* %zone2404)
call void @llvm_zone_ptr_set_size(i8* %clsptr2405, i64 %closure_size2419)
%wrapper_ptr2420 = call i8* @llvm_zone_malloc(%mzone* %zone2404, i64 8)
%closure_wrapper2421 = bitcast i8* %wrapper_ptr2420 to { i8*, i8*, %String* (i8*, i8*, i8)*}**
store { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2406, { i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_wrapper2421

; let value assignment
%format_adhoc_W1N0cmluZyosaThd = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_wrapper2421, { i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_wrapper2421
store { i8*, i8*, %String* (i8*, i8*, i8)*}** %format_adhoc_W1N0cmluZyosaThd, { i8*, i8*, %String* (i8*, i8*, i8)*}*** %format_adhoc_W1N0cmluZyosaThdPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosaThd
%tmp_envptr2415 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8)*}***}* %environment2408, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8)*}*** %format_adhoc_W1N0cmluZyosaThdPtr, {i8*, i8*, %String* (i8*, i8*, i8)*}**** %tmp_envptr2415


%val2424 = load {i8*, i8*, %String* (i8*, i8*, i8)*}**, {i8*, i8*, %String* (i8*, i8*, i8)*}*** %format_adhoc_W1N0cmluZyosaThdPtr
ret {i8*, i8*, %String* (i8*, i8*, i8)*}** %val2424
}


@format_adhoc_W1N0cmluZyosaThd_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosaThd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosaThd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8)*}** @format_adhoc_W1N0cmluZyosaThd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosaThd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaThd(i8 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosaThd_native(i8 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosaThd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2425 = bitcast [83 x i8]* @gsxtmbase171 to i8*
call i32 (i8*, ...) @printf(i8* %var2425)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8  @i8value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosaThd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8}*
%arg_p_0 = getelementptr {i8}, {i8}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase172 = hidden constant [32 x i8] c"format_adhoc_W1N0cmluZyosaTE2XQ\00"
@gsxtmbase173 = hidden constant [40 x i8] c"{i8*, i8*, %String* (i8*, i8*, i16)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTE2XQ__2426(i8* %_impz,i8* %_impenv, i16 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2427 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i16)*}***}*
%format_adhoc_W1N0cmluZyosaTE2XQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i16)*}***}, {{i8*, i8*, %String* (i8*, i8*, i16)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosaTE2XQPtr = load {i8*, i8*, %String* (i8*, i8*, i16)*}***, {i8*, i8*, %String* (i8*, i8*, i16)*}**** %format_adhoc_W1N0cmluZyosaTE2XQPtr_

; setup arguments
%xPtr = alloca i16
store i16 %x, i16* %xPtr


%tzone2429 = load i8*, i8** %_impzPtr
%zone2430 = bitcast i8* %tzone2429 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2428 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2428, i8* %dat2428
store i8* %str, i8** %strPtr

%val2431 = load i8*, i8** %strPtr
%var2432 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2433 = load i16, i16* %xPtr

%val2434 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2431, i8* %var2432, i16 %val2433)
%val2435 = load i8*, i8** %strPtr
%res2436 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2435)
ret %String* %res2436
}
@gsxtmbase174 = hidden constant [85 x i8] c"format_adhoc_W1N0cmluZyosaTE2XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i16)*}** @format_adhoc_W1N0cmluZyosaTE2XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2456 = load i8*, i8** %_impzPtr
%zone2457 = bitcast i8* %tzone2456 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosaTE2XQ
%dat_format_adhoc_W1N0cmluZyosaTE2XQ = call i8* @llvm_zone_malloc(%mzone* %zone2457, i64 8)
%format_adhoc_W1N0cmluZyosaTE2XQPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosaTE2XQ to { i8*, i8*, %String* (i8*, i8*, i16)*}***
%tzone2437 = load i8*, i8** %_impzPtr
%zone2438 = bitcast i8* %tzone2437 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2438)
; malloc closure structure
%clsptr2439 = call i8* @llvm_zone_malloc(%mzone* %zone2438, i64 24)
%closure2440 = bitcast i8* %clsptr2439 to { i8*, i8*, %String* (i8*, i8*, i16)*}*

; malloc environment structure
%envptr2441 = call i8* @llvm_zone_malloc(%mzone* %zone2438, i64 8)
%environment2442 = bitcast i8* %envptr2441 to {{i8*, i8*, %String* (i8*, i8*, i16)*}***}*

; malloc closure address table
%addytable2443 = call %clsvar* @new_address_table()
%var2444 = bitcast [32 x i8]* @gsxtmbase172 to i8*
%var2445 = bitcast [40 x i8]* @gsxtmbase173 to i8*
%addytable2446 = call %clsvar* @add_address_table(%mzone* %zone2438, i8* %var2444, i32 0, i8* %var2445, i32 3, %clsvar* %addytable2443)
%address-table2447 = bitcast %clsvar* %addytable2446 to i8*

; insert table, function and environment into closure struct
%closure.table2450 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16)*}, { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2440, i32 0, i32 0
store i8* %address-table2447, i8** %closure.table2450
%closure.env2451 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16)*}, { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2440, i32 0, i32 1
store i8* %envptr2441, i8** %closure.env2451
%closure.func2452 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16)*}, { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2440, i32 0, i32 2
store %String* (i8*, i8*, i16)* @format_adhoc_W1N0cmluZyosaTE2XQ__2426, %String* (i8*, i8*, i16)** %closure.func2452
%closure_size2453 = call i64 @llvm_zone_mark_size(%mzone* %zone2438)
call void @llvm_zone_ptr_set_size(i8* %clsptr2439, i64 %closure_size2453)
%wrapper_ptr2454 = call i8* @llvm_zone_malloc(%mzone* %zone2438, i64 8)
%closure_wrapper2455 = bitcast i8* %wrapper_ptr2454 to { i8*, i8*, %String* (i8*, i8*, i16)*}**
store { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2440, { i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_wrapper2455

; let value assignment
%format_adhoc_W1N0cmluZyosaTE2XQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_wrapper2455, { i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_wrapper2455
store { i8*, i8*, %String* (i8*, i8*, i16)*}** %format_adhoc_W1N0cmluZyosaTE2XQ, { i8*, i8*, %String* (i8*, i8*, i16)*}*** %format_adhoc_W1N0cmluZyosaTE2XQPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosaTE2XQ
%tmp_envptr2449 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i16)*}***}, {{i8*, i8*, %String* (i8*, i8*, i16)*}***}* %environment2442, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i16)*}*** %format_adhoc_W1N0cmluZyosaTE2XQPtr, {i8*, i8*, %String* (i8*, i8*, i16)*}**** %tmp_envptr2449


%val2458 = load {i8*, i8*, %String* (i8*, i8*, i16)*}**, {i8*, i8*, %String* (i8*, i8*, i16)*}*** %format_adhoc_W1N0cmluZyosaTE2XQPtr
ret {i8*, i8*, %String* (i8*, i8*, i16)*}** %val2458
}


@format_adhoc_W1N0cmluZyosaTE2XQ_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosaTE2XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosaTE2XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i16)*}** @format_adhoc_W1N0cmluZyosaTE2XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosaTE2XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTE2XQ(i16 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosaTE2XQ_native(i16 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosaTE2XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2459 = bitcast [85 x i8]* @gsxtmbase174 to i8*
call i32 (i8*, ...) @printf(i8* %var2459)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i16  @i16value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosaTE2XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16}*
%arg_p_0 = getelementptr {i16}, {i16}* %fstruct, i32 0, i32 0
%arg_0 = load i16, i16* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase175 = hidden constant [32 x i8] c"format_adhoc_W1N0cmluZyosaTMyXQ\00"
@gsxtmbase176 = hidden constant [40 x i8] c"{i8*, i8*, %String* (i8*, i8*, i32)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTMyXQ__2460(i8* %_impz,i8* %_impenv, i32 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2461 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i32)*}***}*
%format_adhoc_W1N0cmluZyosaTMyXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i32)*}***}, {{i8*, i8*, %String* (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosaTMyXQPtr = load {i8*, i8*, %String* (i8*, i8*, i32)*}***, {i8*, i8*, %String* (i8*, i8*, i32)*}**** %format_adhoc_W1N0cmluZyosaTMyXQPtr_

; setup arguments
%xPtr = alloca i32
store i32 %x, i32* %xPtr


%tzone2463 = load i8*, i8** %_impzPtr
%zone2464 = bitcast i8* %tzone2463 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2462 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2462, i8* %dat2462
store i8* %str, i8** %strPtr

%val2465 = load i8*, i8** %strPtr
%var2466 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2467 = load i32, i32* %xPtr

%val2468 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2465, i8* %var2466, i32 %val2467)
%val2469 = load i8*, i8** %strPtr
%res2470 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2469)
ret %String* %res2470
}
@gsxtmbase177 = hidden constant [85 x i8] c"format_adhoc_W1N0cmluZyosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i32)*}** @format_adhoc_W1N0cmluZyosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2490 = load i8*, i8** %_impzPtr
%zone2491 = bitcast i8* %tzone2490 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosaTMyXQ
%dat_format_adhoc_W1N0cmluZyosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone2491, i64 8)
%format_adhoc_W1N0cmluZyosaTMyXQPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosaTMyXQ to { i8*, i8*, %String* (i8*, i8*, i32)*}***
%tzone2471 = load i8*, i8** %_impzPtr
%zone2472 = bitcast i8* %tzone2471 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2472)
; malloc closure structure
%clsptr2473 = call i8* @llvm_zone_malloc(%mzone* %zone2472, i64 24)
%closure2474 = bitcast i8* %clsptr2473 to { i8*, i8*, %String* (i8*, i8*, i32)*}*

; malloc environment structure
%envptr2475 = call i8* @llvm_zone_malloc(%mzone* %zone2472, i64 8)
%environment2476 = bitcast i8* %envptr2475 to {{i8*, i8*, %String* (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable2477 = call %clsvar* @new_address_table()
%var2478 = bitcast [32 x i8]* @gsxtmbase175 to i8*
%var2479 = bitcast [40 x i8]* @gsxtmbase176 to i8*
%addytable2480 = call %clsvar* @add_address_table(%mzone* %zone2472, i8* %var2478, i32 0, i8* %var2479, i32 3, %clsvar* %addytable2477)
%address-table2481 = bitcast %clsvar* %addytable2480 to i8*

; insert table, function and environment into closure struct
%closure.table2484 = getelementptr { i8*, i8*, %String* (i8*, i8*, i32)*}, { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2474, i32 0, i32 0
store i8* %address-table2481, i8** %closure.table2484
%closure.env2485 = getelementptr { i8*, i8*, %String* (i8*, i8*, i32)*}, { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2474, i32 0, i32 1
store i8* %envptr2475, i8** %closure.env2485
%closure.func2486 = getelementptr { i8*, i8*, %String* (i8*, i8*, i32)*}, { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2474, i32 0, i32 2
store %String* (i8*, i8*, i32)* @format_adhoc_W1N0cmluZyosaTMyXQ__2460, %String* (i8*, i8*, i32)** %closure.func2486
%closure_size2487 = call i64 @llvm_zone_mark_size(%mzone* %zone2472)
call void @llvm_zone_ptr_set_size(i8* %clsptr2473, i64 %closure_size2487)
%wrapper_ptr2488 = call i8* @llvm_zone_malloc(%mzone* %zone2472, i64 8)
%closure_wrapper2489 = bitcast i8* %wrapper_ptr2488 to { i8*, i8*, %String* (i8*, i8*, i32)*}**
store { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2474, { i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_wrapper2489

; let value assignment
%format_adhoc_W1N0cmluZyosaTMyXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_wrapper2489, { i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_wrapper2489
store { i8*, i8*, %String* (i8*, i8*, i32)*}** %format_adhoc_W1N0cmluZyosaTMyXQ, { i8*, i8*, %String* (i8*, i8*, i32)*}*** %format_adhoc_W1N0cmluZyosaTMyXQPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosaTMyXQ
%tmp_envptr2483 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i32)*}***}, {{i8*, i8*, %String* (i8*, i8*, i32)*}***}* %environment2476, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i32)*}*** %format_adhoc_W1N0cmluZyosaTMyXQPtr, {i8*, i8*, %String* (i8*, i8*, i32)*}**** %tmp_envptr2483


%val2492 = load {i8*, i8*, %String* (i8*, i8*, i32)*}**, {i8*, i8*, %String* (i8*, i8*, i32)*}*** %format_adhoc_W1N0cmluZyosaTMyXQPtr
ret {i8*, i8*, %String* (i8*, i8*, i32)*}** %val2492
}


@format_adhoc_W1N0cmluZyosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i32)*}** @format_adhoc_W1N0cmluZyosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTMyXQ(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosaTMyXQ_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2493 = bitcast [85 x i8]* @gsxtmbase177 to i8*
call i32 (i8*, ...) @printf(i8* %var2493)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase178 = hidden constant [32 x i8] c"format_adhoc_W1N0cmluZyosaTY0XQ\00"
@gsxtmbase179 = hidden constant [40 x i8] c"{i8*, i8*, %String* (i8*, i8*, i64)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTY0XQ__2494(i8* %_impz,i8* %_impenv, i64 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2495 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i64)*}***}*
%format_adhoc_W1N0cmluZyosaTY0XQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosaTY0XQPtr = load {i8*, i8*, %String* (i8*, i8*, i64)*}***, {i8*, i8*, %String* (i8*, i8*, i64)*}**** %format_adhoc_W1N0cmluZyosaTY0XQPtr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr


%tzone2497 = load i8*, i8** %_impzPtr
%zone2498 = bitcast i8* %tzone2497 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2496 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2496, i8* %dat2496
store i8* %str, i8** %strPtr

%val2499 = load i8*, i8** %strPtr
%var2500 = bitcast [5 x i8]* @gsxtmbase19 to i8*
%val2501 = load i64, i64* %xPtr

%val2502 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2499, i8* %var2500, i64 %val2501)
%val2503 = load i8*, i8** %strPtr
%res2504 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2503)
ret %String* %res2504
}
@gsxtmbase180 = hidden constant [85 x i8] c"format_adhoc_W1N0cmluZyosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i64)*}** @format_adhoc_W1N0cmluZyosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2524 = load i8*, i8** %_impzPtr
%zone2525 = bitcast i8* %tzone2524 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosaTY0XQ
%dat_format_adhoc_W1N0cmluZyosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone2525, i64 8)
%format_adhoc_W1N0cmluZyosaTY0XQPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosaTY0XQ to { i8*, i8*, %String* (i8*, i8*, i64)*}***
%tzone2505 = load i8*, i8** %_impzPtr
%zone2506 = bitcast i8* %tzone2505 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2506)
; malloc closure structure
%clsptr2507 = call i8* @llvm_zone_malloc(%mzone* %zone2506, i64 24)
%closure2508 = bitcast i8* %clsptr2507 to { i8*, i8*, %String* (i8*, i8*, i64)*}*

; malloc environment structure
%envptr2509 = call i8* @llvm_zone_malloc(%mzone* %zone2506, i64 8)
%environment2510 = bitcast i8* %envptr2509 to {{i8*, i8*, %String* (i8*, i8*, i64)*}***}*

; malloc closure address table
%addytable2511 = call %clsvar* @new_address_table()
%var2512 = bitcast [32 x i8]* @gsxtmbase178 to i8*
%var2513 = bitcast [40 x i8]* @gsxtmbase179 to i8*
%addytable2514 = call %clsvar* @add_address_table(%mzone* %zone2506, i8* %var2512, i32 0, i8* %var2513, i32 3, %clsvar* %addytable2511)
%address-table2515 = bitcast %clsvar* %addytable2514 to i8*

; insert table, function and environment into closure struct
%closure.table2518 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64)*}, { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2508, i32 0, i32 0
store i8* %address-table2515, i8** %closure.table2518
%closure.env2519 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64)*}, { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2508, i32 0, i32 1
store i8* %envptr2509, i8** %closure.env2519
%closure.func2520 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64)*}, { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2508, i32 0, i32 2
store %String* (i8*, i8*, i64)* @format_adhoc_W1N0cmluZyosaTY0XQ__2494, %String* (i8*, i8*, i64)** %closure.func2520
%closure_size2521 = call i64 @llvm_zone_mark_size(%mzone* %zone2506)
call void @llvm_zone_ptr_set_size(i8* %clsptr2507, i64 %closure_size2521)
%wrapper_ptr2522 = call i8* @llvm_zone_malloc(%mzone* %zone2506, i64 8)
%closure_wrapper2523 = bitcast i8* %wrapper_ptr2522 to { i8*, i8*, %String* (i8*, i8*, i64)*}**
store { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2508, { i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_wrapper2523

; let value assignment
%format_adhoc_W1N0cmluZyosaTY0XQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_wrapper2523, { i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_wrapper2523
store { i8*, i8*, %String* (i8*, i8*, i64)*}** %format_adhoc_W1N0cmluZyosaTY0XQ, { i8*, i8*, %String* (i8*, i8*, i64)*}*** %format_adhoc_W1N0cmluZyosaTY0XQPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosaTY0XQ
%tmp_envptr2517 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64)*}***}* %environment2510, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i64)*}*** %format_adhoc_W1N0cmluZyosaTY0XQPtr, {i8*, i8*, %String* (i8*, i8*, i64)*}**** %tmp_envptr2517


%val2526 = load {i8*, i8*, %String* (i8*, i8*, i64)*}**, {i8*, i8*, %String* (i8*, i8*, i64)*}*** %format_adhoc_W1N0cmluZyosaTY0XQPtr
ret {i8*, i8*, %String* (i8*, i8*, i64)*}** %val2526
}


@format_adhoc_W1N0cmluZyosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i64)*}** @format_adhoc_W1N0cmluZyosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosaTY0XQ(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosaTY0XQ_native(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2527 = bitcast [85 x i8]* @gsxtmbase180 to i8*
call i32 (i8*, ...) @printf(i8* %var2527)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64}*
%arg_p_0 = getelementptr {i64}, {i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase181 = hidden constant [34 x i8] c"format_adhoc_W1N0cmluZyosZmxvYXRd\00"
@gsxtmbase182 = hidden constant [42 x i8] c"{i8*, i8*, %String* (i8*, i8*, float)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosZmxvYXRd__2528(i8* %_impz,i8* %_impenv, float %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2529 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, float)*}***}*
%format_adhoc_W1N0cmluZyosZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, float)*}***}, {{i8*, i8*, %String* (i8*, i8*, float)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosZmxvYXRdPtr = load {i8*, i8*, %String* (i8*, i8*, float)*}***, {i8*, i8*, %String* (i8*, i8*, float)*}**** %format_adhoc_W1N0cmluZyosZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr


%tzone2531 = load i8*, i8** %_impzPtr
%zone2532 = bitcast i8* %tzone2531 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2530 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2530, i8* %dat2530
store i8* %str, i8** %strPtr

%val2533 = load i8*, i8** %strPtr
%var2534 = bitcast [3 x i8]* @gsxtmbase23 to i8*
%val2535 = load float, float* %xPtr
%res2536 = call ccc double @ftod(float %val2535)

%val2537 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2533, i8* %var2534, double %res2536)
%val2538 = load i8*, i8** %strPtr
%res2539 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2538)
ret %String* %res2539
}
@gsxtmbase183 = hidden constant [87 x i8] c"format_adhoc_W1N0cmluZyosZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, float)*}** @format_adhoc_W1N0cmluZyosZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2559 = load i8*, i8** %_impzPtr
%zone2560 = bitcast i8* %tzone2559 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosZmxvYXRd
%dat_format_adhoc_W1N0cmluZyosZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone2560, i64 8)
%format_adhoc_W1N0cmluZyosZmxvYXRdPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosZmxvYXRd to { i8*, i8*, %String* (i8*, i8*, float)*}***
%tzone2540 = load i8*, i8** %_impzPtr
%zone2541 = bitcast i8* %tzone2540 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2541)
; malloc closure structure
%clsptr2542 = call i8* @llvm_zone_malloc(%mzone* %zone2541, i64 24)
%closure2543 = bitcast i8* %clsptr2542 to { i8*, i8*, %String* (i8*, i8*, float)*}*

; malloc environment structure
%envptr2544 = call i8* @llvm_zone_malloc(%mzone* %zone2541, i64 8)
%environment2545 = bitcast i8* %envptr2544 to {{i8*, i8*, %String* (i8*, i8*, float)*}***}*

; malloc closure address table
%addytable2546 = call %clsvar* @new_address_table()
%var2547 = bitcast [34 x i8]* @gsxtmbase181 to i8*
%var2548 = bitcast [42 x i8]* @gsxtmbase182 to i8*
%addytable2549 = call %clsvar* @add_address_table(%mzone* %zone2541, i8* %var2547, i32 0, i8* %var2548, i32 3, %clsvar* %addytable2546)
%address-table2550 = bitcast %clsvar* %addytable2549 to i8*

; insert table, function and environment into closure struct
%closure.table2553 = getelementptr { i8*, i8*, %String* (i8*, i8*, float)*}, { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2543, i32 0, i32 0
store i8* %address-table2550, i8** %closure.table2553
%closure.env2554 = getelementptr { i8*, i8*, %String* (i8*, i8*, float)*}, { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2543, i32 0, i32 1
store i8* %envptr2544, i8** %closure.env2554
%closure.func2555 = getelementptr { i8*, i8*, %String* (i8*, i8*, float)*}, { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2543, i32 0, i32 2
store %String* (i8*, i8*, float)* @format_adhoc_W1N0cmluZyosZmxvYXRd__2528, %String* (i8*, i8*, float)** %closure.func2555
%closure_size2556 = call i64 @llvm_zone_mark_size(%mzone* %zone2541)
call void @llvm_zone_ptr_set_size(i8* %clsptr2542, i64 %closure_size2556)
%wrapper_ptr2557 = call i8* @llvm_zone_malloc(%mzone* %zone2541, i64 8)
%closure_wrapper2558 = bitcast i8* %wrapper_ptr2557 to { i8*, i8*, %String* (i8*, i8*, float)*}**
store { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2543, { i8*, i8*, %String* (i8*, i8*, float)*}** %closure_wrapper2558

; let value assignment
%format_adhoc_W1N0cmluZyosZmxvYXRd = select i1 true, { i8*, i8*, %String* (i8*, i8*, float)*}** %closure_wrapper2558, { i8*, i8*, %String* (i8*, i8*, float)*}** %closure_wrapper2558
store { i8*, i8*, %String* (i8*, i8*, float)*}** %format_adhoc_W1N0cmluZyosZmxvYXRd, { i8*, i8*, %String* (i8*, i8*, float)*}*** %format_adhoc_W1N0cmluZyosZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosZmxvYXRd
%tmp_envptr2552 = getelementptr {{i8*, i8*, %String* (i8*, i8*, float)*}***}, {{i8*, i8*, %String* (i8*, i8*, float)*}***}* %environment2545, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, float)*}*** %format_adhoc_W1N0cmluZyosZmxvYXRdPtr, {i8*, i8*, %String* (i8*, i8*, float)*}**** %tmp_envptr2552


%val2561 = load {i8*, i8*, %String* (i8*, i8*, float)*}**, {i8*, i8*, %String* (i8*, i8*, float)*}*** %format_adhoc_W1N0cmluZyosZmxvYXRdPtr
ret {i8*, i8*, %String* (i8*, i8*, float)*}** %val2561
}


@format_adhoc_W1N0cmluZyosZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, float)*}** @format_adhoc_W1N0cmluZyosZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosZmxvYXRd(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosZmxvYXRd_native(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2562 = bitcast [87 x i8]* @gsxtmbase183 to i8*
call i32 (i8*, ...) @printf(i8* %var2562)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float}*
%arg_p_0 = getelementptr {float}, {float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase184 = hidden constant [36 x i8] c"format_adhoc_W1N0cmluZyosZG91YmxlXQ\00"
@gsxtmbase185 = hidden constant [43 x i8] c"{i8*, i8*, %String* (i8*, i8*, double)*}**\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosZG91YmxlXQ__2563(i8* %_impz,i8* %_impenv, double %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2564 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, double)*}***}*
%format_adhoc_W1N0cmluZyosZG91YmxlXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, double)*}***}, {{i8*, i8*, %String* (i8*, i8*, double)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosZG91YmxlXQPtr = load {i8*, i8*, %String* (i8*, i8*, double)*}***, {i8*, i8*, %String* (i8*, i8*, double)*}**** %format_adhoc_W1N0cmluZyosZG91YmxlXQPtr_

; setup arguments
%xPtr = alloca double
store double %x, double* %xPtr


%tzone2566 = load i8*, i8** %_impzPtr
%zone2567 = bitcast i8* %tzone2566 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat2565 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat2565, i8* %dat2565
store i8* %str, i8** %strPtr

%val2568 = load i8*, i8** %strPtr
%var2569 = bitcast [3 x i8]* @gsxtmbase23 to i8*
%val2570 = load double, double* %xPtr

%val2571 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2568, i8* %var2569, double %val2570)
%val2572 = load i8*, i8** %strPtr
%res2573 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2572)
ret %String* %res2573
}
@gsxtmbase186 = hidden constant [89 x i8] c"format_adhoc_W1N0cmluZyosZG91YmxlXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, double)*}** @format_adhoc_W1N0cmluZyosZG91YmxlXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2593 = load i8*, i8** %_impzPtr
%zone2594 = bitcast i8* %tzone2593 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosZG91YmxlXQ
%dat_format_adhoc_W1N0cmluZyosZG91YmxlXQ = call i8* @llvm_zone_malloc(%mzone* %zone2594, i64 8)
%format_adhoc_W1N0cmluZyosZG91YmxlXQPtr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosZG91YmxlXQ to { i8*, i8*, %String* (i8*, i8*, double)*}***
%tzone2574 = load i8*, i8** %_impzPtr
%zone2575 = bitcast i8* %tzone2574 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2575)
; malloc closure structure
%clsptr2576 = call i8* @llvm_zone_malloc(%mzone* %zone2575, i64 24)
%closure2577 = bitcast i8* %clsptr2576 to { i8*, i8*, %String* (i8*, i8*, double)*}*

; malloc environment structure
%envptr2578 = call i8* @llvm_zone_malloc(%mzone* %zone2575, i64 8)
%environment2579 = bitcast i8* %envptr2578 to {{i8*, i8*, %String* (i8*, i8*, double)*}***}*

; malloc closure address table
%addytable2580 = call %clsvar* @new_address_table()
%var2581 = bitcast [36 x i8]* @gsxtmbase184 to i8*
%var2582 = bitcast [43 x i8]* @gsxtmbase185 to i8*
%addytable2583 = call %clsvar* @add_address_table(%mzone* %zone2575, i8* %var2581, i32 0, i8* %var2582, i32 3, %clsvar* %addytable2580)
%address-table2584 = bitcast %clsvar* %addytable2583 to i8*

; insert table, function and environment into closure struct
%closure.table2587 = getelementptr { i8*, i8*, %String* (i8*, i8*, double)*}, { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2577, i32 0, i32 0
store i8* %address-table2584, i8** %closure.table2587
%closure.env2588 = getelementptr { i8*, i8*, %String* (i8*, i8*, double)*}, { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2577, i32 0, i32 1
store i8* %envptr2578, i8** %closure.env2588
%closure.func2589 = getelementptr { i8*, i8*, %String* (i8*, i8*, double)*}, { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2577, i32 0, i32 2
store %String* (i8*, i8*, double)* @format_adhoc_W1N0cmluZyosZG91YmxlXQ__2563, %String* (i8*, i8*, double)** %closure.func2589
%closure_size2590 = call i64 @llvm_zone_mark_size(%mzone* %zone2575)
call void @llvm_zone_ptr_set_size(i8* %clsptr2576, i64 %closure_size2590)
%wrapper_ptr2591 = call i8* @llvm_zone_malloc(%mzone* %zone2575, i64 8)
%closure_wrapper2592 = bitcast i8* %wrapper_ptr2591 to { i8*, i8*, %String* (i8*, i8*, double)*}**
store { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2577, { i8*, i8*, %String* (i8*, i8*, double)*}** %closure_wrapper2592

; let value assignment
%format_adhoc_W1N0cmluZyosZG91YmxlXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, double)*}** %closure_wrapper2592, { i8*, i8*, %String* (i8*, i8*, double)*}** %closure_wrapper2592
store { i8*, i8*, %String* (i8*, i8*, double)*}** %format_adhoc_W1N0cmluZyosZG91YmxlXQ, { i8*, i8*, %String* (i8*, i8*, double)*}*** %format_adhoc_W1N0cmluZyosZG91YmxlXQPtr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosZG91YmxlXQ
%tmp_envptr2586 = getelementptr {{i8*, i8*, %String* (i8*, i8*, double)*}***}, {{i8*, i8*, %String* (i8*, i8*, double)*}***}* %environment2579, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, double)*}*** %format_adhoc_W1N0cmluZyosZG91YmxlXQPtr, {i8*, i8*, %String* (i8*, i8*, double)*}**** %tmp_envptr2586


%val2595 = load {i8*, i8*, %String* (i8*, i8*, double)*}**, {i8*, i8*, %String* (i8*, i8*, double)*}*** %format_adhoc_W1N0cmluZyosZG91YmxlXQPtr
ret {i8*, i8*, %String* (i8*, i8*, double)*}** %val2595
}


@format_adhoc_W1N0cmluZyosZG91YmxlXQ_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosZG91YmxlXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosZG91YmxlXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, double)*}** @format_adhoc_W1N0cmluZyosZG91YmxlXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosZG91YmxlXQ(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_native(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosZG91YmxlXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2596 = bitcast [89 x i8]* @gsxtmbase186 to i8*
call i32 (i8*, ...) @printf(i8* %var2596)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosZG91YmxlXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double}*
%arg_p_0 = getelementptr {double}, {double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase187 = hidden constant [37 x i8] c"format_adhoc_W1N0cmluZyosU3RyaW5nKl0\00"
define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0__2597(i8* %_impz,i8* %_impenv, %String* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2598 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*
%format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %String*)*}***, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr_

; setup arguments
%xPtr = alloca %String*
store %String* %x, %String** %xPtr


%val2599 = load %String*, %String** %xPtr
ret %String* %val2599
}
@gsxtmbase188 = hidden constant [90 x i8] c"format_adhoc_W1N0cmluZyosU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2619 = load i8*, i8** %_impzPtr
%zone2620 = bitcast i8* %tzone2619 to %mzone*

; let assign value to symbol format_adhoc_W1N0cmluZyosU3RyaW5nKl0
%dat_format_adhoc_W1N0cmluZyosU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2620, i64 8)
%format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr = bitcast i8* %dat_format_adhoc_W1N0cmluZyosU3RyaW5nKl0 to { i8*, i8*, %String* (i8*, i8*, %String*)*}***
%tzone2600 = load i8*, i8** %_impzPtr
%zone2601 = bitcast i8* %tzone2600 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2601)
; malloc closure structure
%clsptr2602 = call i8* @llvm_zone_malloc(%mzone* %zone2601, i64 24)
%closure2603 = bitcast i8* %clsptr2602 to { i8*, i8*, %String* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr2604 = call i8* @llvm_zone_malloc(%mzone* %zone2601, i64 8)
%environment2605 = bitcast i8* %envptr2604 to {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable2606 = call %clsvar* @new_address_table()
%var2607 = bitcast [37 x i8]* @gsxtmbase187 to i8*
%var2608 = bitcast [45 x i8]* @gsxtmbase72 to i8*
%addytable2609 = call %clsvar* @add_address_table(%mzone* %zone2601, i8* %var2607, i32 0, i8* %var2608, i32 3, %clsvar* %addytable2606)
%address-table2610 = bitcast %clsvar* %addytable2609 to i8*

; insert table, function and environment into closure struct
%closure.table2613 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure2603, i32 0, i32 0
store i8* %address-table2610, i8** %closure.table2613
%closure.env2614 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure2603, i32 0, i32 1
store i8* %envptr2604, i8** %closure.env2614
%closure.func2615 = getelementptr { i8*, i8*, %String* (i8*, i8*, %String*)*}, { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure2603, i32 0, i32 2
store %String* (i8*, i8*, %String*)* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0__2597, %String* (i8*, i8*, %String*)** %closure.func2615
%closure_size2616 = call i64 @llvm_zone_mark_size(%mzone* %zone2601)
call void @llvm_zone_ptr_set_size(i8* %clsptr2602, i64 %closure_size2616)
%wrapper_ptr2617 = call i8* @llvm_zone_malloc(%mzone* %zone2601, i64 8)
%closure_wrapper2618 = bitcast i8* %wrapper_ptr2617 to { i8*, i8*, %String* (i8*, i8*, %String*)*}**
store { i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure2603, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper2618

; let value assignment
%format_adhoc_W1N0cmluZyosU3RyaW5nKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper2618, { i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_wrapper2618
store { i8*, i8*, %String* (i8*, i8*, %String*)*}** %format_adhoc_W1N0cmluZyosU3RyaW5nKl0, { i8*, i8*, %String* (i8*, i8*, %String*)*}*** %format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var format_adhoc_W1N0cmluZyosU3RyaW5nKl0
%tmp_envptr2612 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %String*)*}***}* %environment2605, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %String*)*}**** %tmp_envptr2612


%val2621 = load {i8*, i8*, %String* (i8*, i8*, %String*)*}**, {i8*, i8*, %String* (i8*, i8*, %String*)*}*** %format_adhoc_W1N0cmluZyosU3RyaW5nKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %String*)*}** %val2621
}


@format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %String*)*}** @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2622 = bitcast [90 x i8]* @gsxtmbase188 to i8*
call i32 (i8*, ...) @printf(i8* %var2622)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @format_adhoc_W1N0cmluZyosU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %String*)*}*, {i8*, i8*, %String* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %String*)*}, {i8*, i8*, %String* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %String*)*,  %String* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase189 = hidden constant [35 x i8] c"toString_return_adhoc_W1N0cmluZypd\00"
define dllexport fastcc %String* @toString_return_adhoc_W1N0cmluZypd__2623(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2624 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*)*}***}*
%toString_return_adhoc_W1N0cmluZypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%toString_return_adhoc_W1N0cmluZypdPtr = load {i8*, i8*, %String* (i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*)*}**** %toString_return_adhoc_W1N0cmluZypdPtr_

; setup arguments


%var2625 = bitcast [2 x i8]* @gsxtmbase161 to i8*
%res2626 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var2625)
ret %String* %res2626
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*)*}** @toString_return_adhoc_W1N0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2646 = load i8*, i8** %_impzPtr
%zone2647 = bitcast i8* %tzone2646 to %mzone*

; let assign value to symbol toString_return_adhoc_W1N0cmluZypd
%dat_toString_return_adhoc_W1N0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone2647, i64 8)
%toString_return_adhoc_W1N0cmluZypdPtr = bitcast i8* %dat_toString_return_adhoc_W1N0cmluZypd to { i8*, i8*, %String* (i8*, i8*)*}***
%tzone2627 = load i8*, i8** %_impzPtr
%zone2628 = bitcast i8* %tzone2627 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2628)
; malloc closure structure
%clsptr2629 = call i8* @llvm_zone_malloc(%mzone* %zone2628, i64 24)
%closure2630 = bitcast i8* %clsptr2629 to { i8*, i8*, %String* (i8*, i8*)*}*

; malloc environment structure
%envptr2631 = call i8* @llvm_zone_malloc(%mzone* %zone2628, i64 8)
%environment2632 = bitcast i8* %envptr2631 to {{i8*, i8*, %String* (i8*, i8*)*}***}*

; malloc closure address table
%addytable2633 = call %clsvar* @new_address_table()
%var2634 = bitcast [35 x i8]* @gsxtmbase189 to i8*
%var2635 = bitcast [35 x i8]* @gsxtmbase163 to i8*
%addytable2636 = call %clsvar* @add_address_table(%mzone* %zone2628, i8* %var2634, i32 0, i8* %var2635, i32 3, %clsvar* %addytable2633)
%address-table2637 = bitcast %clsvar* %addytable2636 to i8*

; insert table, function and environment into closure struct
%closure.table2640 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2630, i32 0, i32 0
store i8* %address-table2637, i8** %closure.table2640
%closure.env2641 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2630, i32 0, i32 1
store i8* %envptr2631, i8** %closure.env2641
%closure.func2642 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2630, i32 0, i32 2
store %String* (i8*, i8*)* @toString_return_adhoc_W1N0cmluZypd__2623, %String* (i8*, i8*)** %closure.func2642
%closure_size2643 = call i64 @llvm_zone_mark_size(%mzone* %zone2628)
call void @llvm_zone_ptr_set_size(i8* %clsptr2629, i64 %closure_size2643)
%wrapper_ptr2644 = call i8* @llvm_zone_malloc(%mzone* %zone2628, i64 8)
%closure_wrapper2645 = bitcast i8* %wrapper_ptr2644 to { i8*, i8*, %String* (i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*)*}* %closure2630, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2645

; let value assignment
%toString_return_adhoc_W1N0cmluZypd = select i1 true, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2645, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2645
store { i8*, i8*, %String* (i8*, i8*)*}** %toString_return_adhoc_W1N0cmluZypd, { i8*, i8*, %String* (i8*, i8*)*}*** %toString_return_adhoc_W1N0cmluZypdPtr

; add data to environment
; don't need to alloc for env var toString_return_adhoc_W1N0cmluZypd
%tmp_envptr2639 = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %environment2632, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*)*}*** %toString_return_adhoc_W1N0cmluZypdPtr, {i8*, i8*, %String* (i8*, i8*)*}**** %tmp_envptr2639


%val2648 = load {i8*, i8*, %String* (i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*)*}*** %toString_return_adhoc_W1N0cmluZypdPtr
ret {i8*, i8*, %String* (i8*, i8*)*}** %val2648
}


@toString_return_adhoc_W1N0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_return_adhoc_W1N0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_return_adhoc_W1N0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*)*}** @toString_return_adhoc_W1N0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_return_adhoc_W1N0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_return_adhoc_W1N0cmluZypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc %String* @toString_return_adhoc_W1N0cmluZypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc i8*  @toString_return_adhoc_W1N0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_return_adhoc_W1N0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_return_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase190 = hidden constant [34 x i8] c"toString_space_adhoc_W1N0cmluZypd\00"
define dllexport fastcc %String* @toString_space_adhoc_W1N0cmluZypd__2649(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2650 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*)*}***}*
%toString_space_adhoc_W1N0cmluZypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%toString_space_adhoc_W1N0cmluZypdPtr = load {i8*, i8*, %String* (i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*)*}**** %toString_space_adhoc_W1N0cmluZypdPtr_

; setup arguments


%var2651 = bitcast [2 x i8]* @gsxtmbase164 to i8*
%res2652 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var2651)
ret %String* %res2652
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*)*}** @toString_space_adhoc_W1N0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2672 = load i8*, i8** %_impzPtr
%zone2673 = bitcast i8* %tzone2672 to %mzone*

; let assign value to symbol toString_space_adhoc_W1N0cmluZypd
%dat_toString_space_adhoc_W1N0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone2673, i64 8)
%toString_space_adhoc_W1N0cmluZypdPtr = bitcast i8* %dat_toString_space_adhoc_W1N0cmluZypd to { i8*, i8*, %String* (i8*, i8*)*}***
%tzone2653 = load i8*, i8** %_impzPtr
%zone2654 = bitcast i8* %tzone2653 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2654)
; malloc closure structure
%clsptr2655 = call i8* @llvm_zone_malloc(%mzone* %zone2654, i64 24)
%closure2656 = bitcast i8* %clsptr2655 to { i8*, i8*, %String* (i8*, i8*)*}*

; malloc environment structure
%envptr2657 = call i8* @llvm_zone_malloc(%mzone* %zone2654, i64 8)
%environment2658 = bitcast i8* %envptr2657 to {{i8*, i8*, %String* (i8*, i8*)*}***}*

; malloc closure address table
%addytable2659 = call %clsvar* @new_address_table()
%var2660 = bitcast [34 x i8]* @gsxtmbase190 to i8*
%var2661 = bitcast [35 x i8]* @gsxtmbase163 to i8*
%addytable2662 = call %clsvar* @add_address_table(%mzone* %zone2654, i8* %var2660, i32 0, i8* %var2661, i32 3, %clsvar* %addytable2659)
%address-table2663 = bitcast %clsvar* %addytable2662 to i8*

; insert table, function and environment into closure struct
%closure.table2666 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2656, i32 0, i32 0
store i8* %address-table2663, i8** %closure.table2666
%closure.env2667 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2656, i32 0, i32 1
store i8* %envptr2657, i8** %closure.env2667
%closure.func2668 = getelementptr { i8*, i8*, %String* (i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*)*}* %closure2656, i32 0, i32 2
store %String* (i8*, i8*)* @toString_space_adhoc_W1N0cmluZypd__2649, %String* (i8*, i8*)** %closure.func2668
%closure_size2669 = call i64 @llvm_zone_mark_size(%mzone* %zone2654)
call void @llvm_zone_ptr_set_size(i8* %clsptr2655, i64 %closure_size2669)
%wrapper_ptr2670 = call i8* @llvm_zone_malloc(%mzone* %zone2654, i64 8)
%closure_wrapper2671 = bitcast i8* %wrapper_ptr2670 to { i8*, i8*, %String* (i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*)*}* %closure2656, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2671

; let value assignment
%toString_space_adhoc_W1N0cmluZypd = select i1 true, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2671, { i8*, i8*, %String* (i8*, i8*)*}** %closure_wrapper2671
store { i8*, i8*, %String* (i8*, i8*)*}** %toString_space_adhoc_W1N0cmluZypd, { i8*, i8*, %String* (i8*, i8*)*}*** %toString_space_adhoc_W1N0cmluZypdPtr

; add data to environment
; don't need to alloc for env var toString_space_adhoc_W1N0cmluZypd
%tmp_envptr2665 = getelementptr {{i8*, i8*, %String* (i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*)*}***}* %environment2658, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*)*}*** %toString_space_adhoc_W1N0cmluZypdPtr, {i8*, i8*, %String* (i8*, i8*)*}**** %tmp_envptr2665


%val2674 = load {i8*, i8*, %String* (i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*)*}*** %toString_space_adhoc_W1N0cmluZypdPtr
ret {i8*, i8*, %String* (i8*, i8*)*}** %val2674
}


@toString_space_adhoc_W1N0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_space_adhoc_W1N0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_space_adhoc_W1N0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*)*}** @toString_space_adhoc_W1N0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_space_adhoc_W1N0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_space_adhoc_W1N0cmluZypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc %String* @toString_space_adhoc_W1N0cmluZypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
ret %String* %result
}


define dllexport ccc i8*  @toString_space_adhoc_W1N0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_space_adhoc_W1N0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_space_adhoc_W1N0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*)*,  %String* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase191 = hidden constant [32 x i8] c"toString_adhoc_W1N0cmluZyosaTFd\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTFd__2675(i8* %_impz,i8* %_impenv, i1 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2676 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i1)*}***}*
%toString_adhoc_W1N0cmluZyosaTFdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i1)*}***}, {{i8*, i8*, %String* (i8*, i8*, i1)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosaTFdPtr = load {i8*, i8*, %String* (i8*, i8*, i1)*}***, {i8*, i8*, %String* (i8*, i8*, i1)*}**** %toString_adhoc_W1N0cmluZyosaTFdPtr_

; setup arguments
%xPtr = alloca i1
store i1 %x, i1* %xPtr


%tzone2678 = load i8*, i8** %_impzPtr
%zone2679 = bitcast i8* %tzone2678 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat2677 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat2677, i8* %dat2677
store i8* %s, i8** %sPtr

%val2680 = load i8*, i8** %sPtr
%var2681 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2682 = load i1, i1* %xPtr

%val2683 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2680, i8* %var2681, i1 %val2682)
%val2684 = load i8*, i8** %sPtr
%res2685 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2684)
ret %String* %res2685
}
@gsxtmbase192 = hidden constant [85 x i8] c"toString_adhoc_W1N0cmluZyosaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i1)*}** @toString_adhoc_W1N0cmluZyosaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2705 = load i8*, i8** %_impzPtr
%zone2706 = bitcast i8* %tzone2705 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosaTFd
%dat_toString_adhoc_W1N0cmluZyosaTFd = call i8* @llvm_zone_malloc(%mzone* %zone2706, i64 8)
%toString_adhoc_W1N0cmluZyosaTFdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosaTFd to { i8*, i8*, %String* (i8*, i8*, i1)*}***
%tzone2686 = load i8*, i8** %_impzPtr
%zone2687 = bitcast i8* %tzone2686 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2687)
; malloc closure structure
%clsptr2688 = call i8* @llvm_zone_malloc(%mzone* %zone2687, i64 24)
%closure2689 = bitcast i8* %clsptr2688 to { i8*, i8*, %String* (i8*, i8*, i1)*}*

; malloc environment structure
%envptr2690 = call i8* @llvm_zone_malloc(%mzone* %zone2687, i64 8)
%environment2691 = bitcast i8* %envptr2690 to {{i8*, i8*, %String* (i8*, i8*, i1)*}***}*

; malloc closure address table
%addytable2692 = call %clsvar* @new_address_table()
%var2693 = bitcast [32 x i8]* @gsxtmbase191 to i8*
%var2694 = bitcast [39 x i8]* @gsxtmbase167 to i8*
%addytable2695 = call %clsvar* @add_address_table(%mzone* %zone2687, i8* %var2693, i32 0, i8* %var2694, i32 3, %clsvar* %addytable2692)
%address-table2696 = bitcast %clsvar* %addytable2695 to i8*

; insert table, function and environment into closure struct
%closure.table2699 = getelementptr { i8*, i8*, %String* (i8*, i8*, i1)*}, { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2689, i32 0, i32 0
store i8* %address-table2696, i8** %closure.table2699
%closure.env2700 = getelementptr { i8*, i8*, %String* (i8*, i8*, i1)*}, { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2689, i32 0, i32 1
store i8* %envptr2690, i8** %closure.env2700
%closure.func2701 = getelementptr { i8*, i8*, %String* (i8*, i8*, i1)*}, { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2689, i32 0, i32 2
store %String* (i8*, i8*, i1)* @toString_adhoc_W1N0cmluZyosaTFd__2675, %String* (i8*, i8*, i1)** %closure.func2701
%closure_size2702 = call i64 @llvm_zone_mark_size(%mzone* %zone2687)
call void @llvm_zone_ptr_set_size(i8* %clsptr2688, i64 %closure_size2702)
%wrapper_ptr2703 = call i8* @llvm_zone_malloc(%mzone* %zone2687, i64 8)
%closure_wrapper2704 = bitcast i8* %wrapper_ptr2703 to { i8*, i8*, %String* (i8*, i8*, i1)*}**
store { i8*, i8*, %String* (i8*, i8*, i1)*}* %closure2689, { i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_wrapper2704

; let value assignment
%toString_adhoc_W1N0cmluZyosaTFd = select i1 true, { i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_wrapper2704, { i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_wrapper2704
store { i8*, i8*, %String* (i8*, i8*, i1)*}** %toString_adhoc_W1N0cmluZyosaTFd, { i8*, i8*, %String* (i8*, i8*, i1)*}*** %toString_adhoc_W1N0cmluZyosaTFdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosaTFd
%tmp_envptr2698 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i1)*}***}, {{i8*, i8*, %String* (i8*, i8*, i1)*}***}* %environment2691, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i1)*}*** %toString_adhoc_W1N0cmluZyosaTFdPtr, {i8*, i8*, %String* (i8*, i8*, i1)*}**** %tmp_envptr2698


%val2707 = load {i8*, i8*, %String* (i8*, i8*, i1)*}**, {i8*, i8*, %String* (i8*, i8*, i1)*}*** %toString_adhoc_W1N0cmluZyosaTFdPtr
ret {i8*, i8*, %String* (i8*, i8*, i1)*}** %val2707
}


@toString_adhoc_W1N0cmluZyosaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i1)*}** @toString_adhoc_W1N0cmluZyosaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTFd(i1 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosaTFd_native(i1 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2708 = bitcast [85 x i8]* @gsxtmbase192 to i8*
call i32 (i8*, ...) @printf(i8* %var2708)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i1  @i1value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1}*
%arg_p_0 = getelementptr {i1}, {i1}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i1)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i1)*}*, {i8*, i8*, %String* (i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i1)*}, {i8*, i8*, %String* (i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i1)*,  %String* (i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i1 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase193 = hidden constant [32 x i8] c"toString_adhoc_W1N0cmluZyosaThd\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaThd__2709(i8* %_impz,i8* %_impenv, i8 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2710 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8)*}***}*
%toString_adhoc_W1N0cmluZyosaThdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosaThdPtr = load {i8*, i8*, %String* (i8*, i8*, i8)*}***, {i8*, i8*, %String* (i8*, i8*, i8)*}**** %toString_adhoc_W1N0cmluZyosaThdPtr_

; setup arguments
%xPtr = alloca i8
store i8 %x, i8* %xPtr


%tzone2712 = load i8*, i8** %_impzPtr
%zone2713 = bitcast i8* %tzone2712 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat2711 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat2711, i8* %dat2711
store i8* %s, i8** %sPtr

%val2714 = load i8*, i8** %sPtr
%var2715 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2716 = load i8, i8* %xPtr

%val2717 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2714, i8* %var2715, i8 %val2716)
%val2718 = load i8*, i8** %sPtr
%res2719 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2718)
ret %String* %res2719
}
@gsxtmbase194 = hidden constant [85 x i8] c"toString_adhoc_W1N0cmluZyosaThd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8)*}** @toString_adhoc_W1N0cmluZyosaThd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2739 = load i8*, i8** %_impzPtr
%zone2740 = bitcast i8* %tzone2739 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosaThd
%dat_toString_adhoc_W1N0cmluZyosaThd = call i8* @llvm_zone_malloc(%mzone* %zone2740, i64 8)
%toString_adhoc_W1N0cmluZyosaThdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosaThd to { i8*, i8*, %String* (i8*, i8*, i8)*}***
%tzone2720 = load i8*, i8** %_impzPtr
%zone2721 = bitcast i8* %tzone2720 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2721)
; malloc closure structure
%clsptr2722 = call i8* @llvm_zone_malloc(%mzone* %zone2721, i64 24)
%closure2723 = bitcast i8* %clsptr2722 to { i8*, i8*, %String* (i8*, i8*, i8)*}*

; malloc environment structure
%envptr2724 = call i8* @llvm_zone_malloc(%mzone* %zone2721, i64 8)
%environment2725 = bitcast i8* %envptr2724 to {{i8*, i8*, %String* (i8*, i8*, i8)*}***}*

; malloc closure address table
%addytable2726 = call %clsvar* @new_address_table()
%var2727 = bitcast [32 x i8]* @gsxtmbase193 to i8*
%var2728 = bitcast [39 x i8]* @gsxtmbase170 to i8*
%addytable2729 = call %clsvar* @add_address_table(%mzone* %zone2721, i8* %var2727, i32 0, i8* %var2728, i32 3, %clsvar* %addytable2726)
%address-table2730 = bitcast %clsvar* %addytable2729 to i8*

; insert table, function and environment into closure struct
%closure.table2733 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8)*}, { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2723, i32 0, i32 0
store i8* %address-table2730, i8** %closure.table2733
%closure.env2734 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8)*}, { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2723, i32 0, i32 1
store i8* %envptr2724, i8** %closure.env2734
%closure.func2735 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8)*}, { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2723, i32 0, i32 2
store %String* (i8*, i8*, i8)* @toString_adhoc_W1N0cmluZyosaThd__2709, %String* (i8*, i8*, i8)** %closure.func2735
%closure_size2736 = call i64 @llvm_zone_mark_size(%mzone* %zone2721)
call void @llvm_zone_ptr_set_size(i8* %clsptr2722, i64 %closure_size2736)
%wrapper_ptr2737 = call i8* @llvm_zone_malloc(%mzone* %zone2721, i64 8)
%closure_wrapper2738 = bitcast i8* %wrapper_ptr2737 to { i8*, i8*, %String* (i8*, i8*, i8)*}**
store { i8*, i8*, %String* (i8*, i8*, i8)*}* %closure2723, { i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_wrapper2738

; let value assignment
%toString_adhoc_W1N0cmluZyosaThd = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_wrapper2738, { i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_wrapper2738
store { i8*, i8*, %String* (i8*, i8*, i8)*}** %toString_adhoc_W1N0cmluZyosaThd, { i8*, i8*, %String* (i8*, i8*, i8)*}*** %toString_adhoc_W1N0cmluZyosaThdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosaThd
%tmp_envptr2732 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8)*}***}* %environment2725, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8)*}*** %toString_adhoc_W1N0cmluZyosaThdPtr, {i8*, i8*, %String* (i8*, i8*, i8)*}**** %tmp_envptr2732


%val2741 = load {i8*, i8*, %String* (i8*, i8*, i8)*}**, {i8*, i8*, %String* (i8*, i8*, i8)*}*** %toString_adhoc_W1N0cmluZyosaThdPtr
ret {i8*, i8*, %String* (i8*, i8*, i8)*}** %val2741
}


@toString_adhoc_W1N0cmluZyosaThd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosaThd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosaThd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8)*}** @toString_adhoc_W1N0cmluZyosaThd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosaThd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaThd(i8 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosaThd_native(i8 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosaThd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2742 = bitcast [85 x i8]* @gsxtmbase194 to i8*
call i32 (i8*, ...) @printf(i8* %var2742)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8  @i8value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosaThd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8}*
%arg_p_0 = getelementptr {i8}, {i8}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaThd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8)*}*, {i8*, i8*, %String* (i8*, i8*, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8)*}, {i8*, i8*, %String* (i8*, i8*, i8)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8)*,  %String* (i8*, i8*, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase195 = hidden constant [34 x i8] c"toString_adhoc_W1N0cmluZyosaTE2XQ\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTE2XQ__2743(i8* %_impz,i8* %_impenv, i16 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2744 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i16)*}***}*
%toString_adhoc_W1N0cmluZyosaTE2XQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i16)*}***}, {{i8*, i8*, %String* (i8*, i8*, i16)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosaTE2XQPtr = load {i8*, i8*, %String* (i8*, i8*, i16)*}***, {i8*, i8*, %String* (i8*, i8*, i16)*}**** %toString_adhoc_W1N0cmluZyosaTE2XQPtr_

; setup arguments
%xPtr = alloca i16
store i16 %x, i16* %xPtr


%tzone2746 = load i8*, i8** %_impzPtr
%zone2747 = bitcast i8* %tzone2746 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat2745 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat2745, i8* %dat2745
store i8* %s, i8** %sPtr

%val2748 = load i8*, i8** %sPtr
%var2749 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2750 = load i16, i16* %xPtr

%val2751 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2748, i8* %var2749, i16 %val2750)
%val2752 = load i8*, i8** %sPtr
%res2753 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2752)
ret %String* %res2753
}
@gsxtmbase196 = hidden constant [87 x i8] c"toString_adhoc_W1N0cmluZyosaTE2XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i16)*}** @toString_adhoc_W1N0cmluZyosaTE2XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2773 = load i8*, i8** %_impzPtr
%zone2774 = bitcast i8* %tzone2773 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosaTE2XQ
%dat_toString_adhoc_W1N0cmluZyosaTE2XQ = call i8* @llvm_zone_malloc(%mzone* %zone2774, i64 8)
%toString_adhoc_W1N0cmluZyosaTE2XQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosaTE2XQ to { i8*, i8*, %String* (i8*, i8*, i16)*}***
%tzone2754 = load i8*, i8** %_impzPtr
%zone2755 = bitcast i8* %tzone2754 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2755)
; malloc closure structure
%clsptr2756 = call i8* @llvm_zone_malloc(%mzone* %zone2755, i64 24)
%closure2757 = bitcast i8* %clsptr2756 to { i8*, i8*, %String* (i8*, i8*, i16)*}*

; malloc environment structure
%envptr2758 = call i8* @llvm_zone_malloc(%mzone* %zone2755, i64 8)
%environment2759 = bitcast i8* %envptr2758 to {{i8*, i8*, %String* (i8*, i8*, i16)*}***}*

; malloc closure address table
%addytable2760 = call %clsvar* @new_address_table()
%var2761 = bitcast [34 x i8]* @gsxtmbase195 to i8*
%var2762 = bitcast [40 x i8]* @gsxtmbase173 to i8*
%addytable2763 = call %clsvar* @add_address_table(%mzone* %zone2755, i8* %var2761, i32 0, i8* %var2762, i32 3, %clsvar* %addytable2760)
%address-table2764 = bitcast %clsvar* %addytable2763 to i8*

; insert table, function and environment into closure struct
%closure.table2767 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16)*}, { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2757, i32 0, i32 0
store i8* %address-table2764, i8** %closure.table2767
%closure.env2768 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16)*}, { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2757, i32 0, i32 1
store i8* %envptr2758, i8** %closure.env2768
%closure.func2769 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16)*}, { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2757, i32 0, i32 2
store %String* (i8*, i8*, i16)* @toString_adhoc_W1N0cmluZyosaTE2XQ__2743, %String* (i8*, i8*, i16)** %closure.func2769
%closure_size2770 = call i64 @llvm_zone_mark_size(%mzone* %zone2755)
call void @llvm_zone_ptr_set_size(i8* %clsptr2756, i64 %closure_size2770)
%wrapper_ptr2771 = call i8* @llvm_zone_malloc(%mzone* %zone2755, i64 8)
%closure_wrapper2772 = bitcast i8* %wrapper_ptr2771 to { i8*, i8*, %String* (i8*, i8*, i16)*}**
store { i8*, i8*, %String* (i8*, i8*, i16)*}* %closure2757, { i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_wrapper2772

; let value assignment
%toString_adhoc_W1N0cmluZyosaTE2XQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_wrapper2772, { i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_wrapper2772
store { i8*, i8*, %String* (i8*, i8*, i16)*}** %toString_adhoc_W1N0cmluZyosaTE2XQ, { i8*, i8*, %String* (i8*, i8*, i16)*}*** %toString_adhoc_W1N0cmluZyosaTE2XQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosaTE2XQ
%tmp_envptr2766 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i16)*}***}, {{i8*, i8*, %String* (i8*, i8*, i16)*}***}* %environment2759, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i16)*}*** %toString_adhoc_W1N0cmluZyosaTE2XQPtr, {i8*, i8*, %String* (i8*, i8*, i16)*}**** %tmp_envptr2766


%val2775 = load {i8*, i8*, %String* (i8*, i8*, i16)*}**, {i8*, i8*, %String* (i8*, i8*, i16)*}*** %toString_adhoc_W1N0cmluZyosaTE2XQPtr
ret {i8*, i8*, %String* (i8*, i8*, i16)*}** %val2775
}


@toString_adhoc_W1N0cmluZyosaTE2XQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosaTE2XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTE2XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i16)*}** @toString_adhoc_W1N0cmluZyosaTE2XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosaTE2XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTE2XQ(i16 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosaTE2XQ_native(i16 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosaTE2XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2776 = bitcast [87 x i8]* @gsxtmbase196 to i8*
call i32 (i8*, ...) @printf(i8* %var2776)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i16  @i16value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTE2XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16}*
%arg_p_0 = getelementptr {i16}, {i16}* %fstruct, i32 0, i32 0
%arg_0 = load i16, i16* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTE2XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16)*}*, {i8*, i8*, %String* (i8*, i8*, i16)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16)*}, {i8*, i8*, %String* (i8*, i8*, i16)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16)*,  %String* (i8*, i8*, i16)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase197 = hidden constant [34 x i8] c"toString_adhoc_W1N0cmluZyosaTMyXQ\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ__2777(i8* %_impz,i8* %_impenv, i32 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2778 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i32)*}***}*
%toString_adhoc_W1N0cmluZyosaTMyXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i32)*}***}, {{i8*, i8*, %String* (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosaTMyXQPtr = load {i8*, i8*, %String* (i8*, i8*, i32)*}***, {i8*, i8*, %String* (i8*, i8*, i32)*}**** %toString_adhoc_W1N0cmluZyosaTMyXQPtr_

; setup arguments
%xPtr = alloca i32
store i32 %x, i32* %xPtr


%tzone2780 = load i8*, i8** %_impzPtr
%zone2781 = bitcast i8* %tzone2780 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat2779 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat2779, i8* %dat2779
store i8* %s, i8** %sPtr

%val2782 = load i8*, i8** %sPtr
%var2783 = bitcast [3 x i8]* @gsxtmbase6 to i8*
%val2784 = load i32, i32* %xPtr

%val2785 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2782, i8* %var2783, i32 %val2784)
%val2786 = load i8*, i8** %sPtr
%res2787 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2786)
ret %String* %res2787
}
@gsxtmbase198 = hidden constant [87 x i8] c"toString_adhoc_W1N0cmluZyosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i32)*}** @toString_adhoc_W1N0cmluZyosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2807 = load i8*, i8** %_impzPtr
%zone2808 = bitcast i8* %tzone2807 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosaTMyXQ
%dat_toString_adhoc_W1N0cmluZyosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone2808, i64 8)
%toString_adhoc_W1N0cmluZyosaTMyXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosaTMyXQ to { i8*, i8*, %String* (i8*, i8*, i32)*}***
%tzone2788 = load i8*, i8** %_impzPtr
%zone2789 = bitcast i8* %tzone2788 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2789)
; malloc closure structure
%clsptr2790 = call i8* @llvm_zone_malloc(%mzone* %zone2789, i64 24)
%closure2791 = bitcast i8* %clsptr2790 to { i8*, i8*, %String* (i8*, i8*, i32)*}*

; malloc environment structure
%envptr2792 = call i8* @llvm_zone_malloc(%mzone* %zone2789, i64 8)
%environment2793 = bitcast i8* %envptr2792 to {{i8*, i8*, %String* (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable2794 = call %clsvar* @new_address_table()
%var2795 = bitcast [34 x i8]* @gsxtmbase197 to i8*
%var2796 = bitcast [40 x i8]* @gsxtmbase176 to i8*
%addytable2797 = call %clsvar* @add_address_table(%mzone* %zone2789, i8* %var2795, i32 0, i8* %var2796, i32 3, %clsvar* %addytable2794)
%address-table2798 = bitcast %clsvar* %addytable2797 to i8*

; insert table, function and environment into closure struct
%closure.table2801 = getelementptr { i8*, i8*, %String* (i8*, i8*, i32)*}, { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2791, i32 0, i32 0
store i8* %address-table2798, i8** %closure.table2801
%closure.env2802 = getelementptr { i8*, i8*, %String* (i8*, i8*, i32)*}, { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2791, i32 0, i32 1
store i8* %envptr2792, i8** %closure.env2802
%closure.func2803 = getelementptr { i8*, i8*, %String* (i8*, i8*, i32)*}, { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2791, i32 0, i32 2
store %String* (i8*, i8*, i32)* @toString_adhoc_W1N0cmluZyosaTMyXQ__2777, %String* (i8*, i8*, i32)** %closure.func2803
%closure_size2804 = call i64 @llvm_zone_mark_size(%mzone* %zone2789)
call void @llvm_zone_ptr_set_size(i8* %clsptr2790, i64 %closure_size2804)
%wrapper_ptr2805 = call i8* @llvm_zone_malloc(%mzone* %zone2789, i64 8)
%closure_wrapper2806 = bitcast i8* %wrapper_ptr2805 to { i8*, i8*, %String* (i8*, i8*, i32)*}**
store { i8*, i8*, %String* (i8*, i8*, i32)*}* %closure2791, { i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_wrapper2806

; let value assignment
%toString_adhoc_W1N0cmluZyosaTMyXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_wrapper2806, { i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_wrapper2806
store { i8*, i8*, %String* (i8*, i8*, i32)*}** %toString_adhoc_W1N0cmluZyosaTMyXQ, { i8*, i8*, %String* (i8*, i8*, i32)*}*** %toString_adhoc_W1N0cmluZyosaTMyXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosaTMyXQ
%tmp_envptr2800 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i32)*}***}, {{i8*, i8*, %String* (i8*, i8*, i32)*}***}* %environment2793, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i32)*}*** %toString_adhoc_W1N0cmluZyosaTMyXQPtr, {i8*, i8*, %String* (i8*, i8*, i32)*}**** %tmp_envptr2800


%val2809 = load {i8*, i8*, %String* (i8*, i8*, i32)*}**, {i8*, i8*, %String* (i8*, i8*, i32)*}*** %toString_adhoc_W1N0cmluZyosaTMyXQPtr
ret {i8*, i8*, %String* (i8*, i8*, i32)*}** %val2809
}


@toString_adhoc_W1N0cmluZyosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i32)*}** @toString_adhoc_W1N0cmluZyosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2810 = bitcast [87 x i8]* @gsxtmbase198 to i8*
call i32 (i8*, ...) @printf(i8* %var2810)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i32)*}*, {i8*, i8*, %String* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i32)*}, {i8*, i8*, %String* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i32)*,  %String* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase199 = hidden constant [34 x i8] c"toString_adhoc_W1N0cmluZyosaTY0XQ\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTY0XQ__2811(i8* %_impz,i8* %_impenv, i64 %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2812 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i64)*}***}*
%toString_adhoc_W1N0cmluZyosaTY0XQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosaTY0XQPtr = load {i8*, i8*, %String* (i8*, i8*, i64)*}***, {i8*, i8*, %String* (i8*, i8*, i64)*}**** %toString_adhoc_W1N0cmluZyosaTY0XQPtr_

; setup arguments
%xPtr = alloca i64
store i64 %x, i64* %xPtr


%tzone2814 = load i8*, i8** %_impzPtr
%zone2815 = bitcast i8* %tzone2814 to %mzone*

; let assign value to symbol st
%stPtr = alloca i8*
%dat2813 = alloca i8, i64 256, align 16

; let value assignment
%st = select i1 true, i8* %dat2813, i8* %dat2813
store i8* %st, i8** %stPtr

%val2816 = load i8*, i8** %stPtr
%var2817 = bitcast [5 x i8]* @gsxtmbase19 to i8*
%val2818 = load i64, i64* %xPtr

%val2819 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2816, i8* %var2817, i64 %val2818)
%val2820 = load i8*, i8** %stPtr
%res2821 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2820)
ret %String* %res2821
}
@gsxtmbase200 = hidden constant [87 x i8] c"toString_adhoc_W1N0cmluZyosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i64)*}** @toString_adhoc_W1N0cmluZyosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2841 = load i8*, i8** %_impzPtr
%zone2842 = bitcast i8* %tzone2841 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosaTY0XQ
%dat_toString_adhoc_W1N0cmluZyosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone2842, i64 8)
%toString_adhoc_W1N0cmluZyosaTY0XQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosaTY0XQ to { i8*, i8*, %String* (i8*, i8*, i64)*}***
%tzone2822 = load i8*, i8** %_impzPtr
%zone2823 = bitcast i8* %tzone2822 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2823)
; malloc closure structure
%clsptr2824 = call i8* @llvm_zone_malloc(%mzone* %zone2823, i64 24)
%closure2825 = bitcast i8* %clsptr2824 to { i8*, i8*, %String* (i8*, i8*, i64)*}*

; malloc environment structure
%envptr2826 = call i8* @llvm_zone_malloc(%mzone* %zone2823, i64 8)
%environment2827 = bitcast i8* %envptr2826 to {{i8*, i8*, %String* (i8*, i8*, i64)*}***}*

; malloc closure address table
%addytable2828 = call %clsvar* @new_address_table()
%var2829 = bitcast [34 x i8]* @gsxtmbase199 to i8*
%var2830 = bitcast [40 x i8]* @gsxtmbase179 to i8*
%addytable2831 = call %clsvar* @add_address_table(%mzone* %zone2823, i8* %var2829, i32 0, i8* %var2830, i32 3, %clsvar* %addytable2828)
%address-table2832 = bitcast %clsvar* %addytable2831 to i8*

; insert table, function and environment into closure struct
%closure.table2835 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64)*}, { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2825, i32 0, i32 0
store i8* %address-table2832, i8** %closure.table2835
%closure.env2836 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64)*}, { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2825, i32 0, i32 1
store i8* %envptr2826, i8** %closure.env2836
%closure.func2837 = getelementptr { i8*, i8*, %String* (i8*, i8*, i64)*}, { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2825, i32 0, i32 2
store %String* (i8*, i8*, i64)* @toString_adhoc_W1N0cmluZyosaTY0XQ__2811, %String* (i8*, i8*, i64)** %closure.func2837
%closure_size2838 = call i64 @llvm_zone_mark_size(%mzone* %zone2823)
call void @llvm_zone_ptr_set_size(i8* %clsptr2824, i64 %closure_size2838)
%wrapper_ptr2839 = call i8* @llvm_zone_malloc(%mzone* %zone2823, i64 8)
%closure_wrapper2840 = bitcast i8* %wrapper_ptr2839 to { i8*, i8*, %String* (i8*, i8*, i64)*}**
store { i8*, i8*, %String* (i8*, i8*, i64)*}* %closure2825, { i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_wrapper2840

; let value assignment
%toString_adhoc_W1N0cmluZyosaTY0XQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_wrapper2840, { i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_wrapper2840
store { i8*, i8*, %String* (i8*, i8*, i64)*}** %toString_adhoc_W1N0cmluZyosaTY0XQ, { i8*, i8*, %String* (i8*, i8*, i64)*}*** %toString_adhoc_W1N0cmluZyosaTY0XQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosaTY0XQ
%tmp_envptr2834 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i64)*}***}, {{i8*, i8*, %String* (i8*, i8*, i64)*}***}* %environment2827, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i64)*}*** %toString_adhoc_W1N0cmluZyosaTY0XQPtr, {i8*, i8*, %String* (i8*, i8*, i64)*}**** %tmp_envptr2834


%val2843 = load {i8*, i8*, %String* (i8*, i8*, i64)*}**, {i8*, i8*, %String* (i8*, i8*, i64)*}*** %toString_adhoc_W1N0cmluZyosaTY0XQPtr
ret {i8*, i8*, %String* (i8*, i8*, i64)*}** %val2843
}


@toString_adhoc_W1N0cmluZyosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i64)*}** @toString_adhoc_W1N0cmluZyosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTY0XQ(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosaTY0XQ_native(i64 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2844 = bitcast [87 x i8]* @gsxtmbase200 to i8*
call i32 (i8*, ...) @printf(i8* %var2844)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64}*
%arg_p_0 = getelementptr {i64}, {i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i64)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i64)*}*, {i8*, i8*, %String* (i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i64)*}, {i8*, i8*, %String* (i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i64)*,  %String* (i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i64 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase201 = hidden constant [36 x i8] c"toString_adhoc_W1N0cmluZyosZmxvYXRd\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd__2845(i8* %_impz,i8* %_impenv, float %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2846 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, float)*}***}*
%toString_adhoc_W1N0cmluZyosZmxvYXRdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, float)*}***}, {{i8*, i8*, %String* (i8*, i8*, float)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosZmxvYXRdPtr = load {i8*, i8*, %String* (i8*, i8*, float)*}***, {i8*, i8*, %String* (i8*, i8*, float)*}**** %toString_adhoc_W1N0cmluZyosZmxvYXRdPtr_

; setup arguments
%xPtr = alloca float
store float %x, float* %xPtr


%tzone2848 = load i8*, i8** %_impzPtr
%zone2849 = bitcast i8* %tzone2848 to %mzone*

; let assign value to symbol st
%stPtr = alloca i8*
%dat2847 = alloca i8, i64 256, align 16

; let value assignment
%st = select i1 true, i8* %dat2847, i8* %dat2847
store i8* %st, i8** %stPtr

%val2850 = load i8*, i8** %stPtr
%var2851 = bitcast [3 x i8]* @gsxtmbase23 to i8*
%val2852 = load float, float* %xPtr
%res2853 = call ccc double @ftod(float %val2852)

%val2854 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2850, i8* %var2851, double %res2853)
%val2855 = load i8*, i8** %stPtr
%res2856 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2855)
ret %String* %res2856
}
@gsxtmbase202 = hidden constant [89 x i8] c"toString_adhoc_W1N0cmluZyosZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, float)*}** @toString_adhoc_W1N0cmluZyosZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2876 = load i8*, i8** %_impzPtr
%zone2877 = bitcast i8* %tzone2876 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosZmxvYXRd
%dat_toString_adhoc_W1N0cmluZyosZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone2877, i64 8)
%toString_adhoc_W1N0cmluZyosZmxvYXRdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosZmxvYXRd to { i8*, i8*, %String* (i8*, i8*, float)*}***
%tzone2857 = load i8*, i8** %_impzPtr
%zone2858 = bitcast i8* %tzone2857 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2858)
; malloc closure structure
%clsptr2859 = call i8* @llvm_zone_malloc(%mzone* %zone2858, i64 24)
%closure2860 = bitcast i8* %clsptr2859 to { i8*, i8*, %String* (i8*, i8*, float)*}*

; malloc environment structure
%envptr2861 = call i8* @llvm_zone_malloc(%mzone* %zone2858, i64 8)
%environment2862 = bitcast i8* %envptr2861 to {{i8*, i8*, %String* (i8*, i8*, float)*}***}*

; malloc closure address table
%addytable2863 = call %clsvar* @new_address_table()
%var2864 = bitcast [36 x i8]* @gsxtmbase201 to i8*
%var2865 = bitcast [42 x i8]* @gsxtmbase182 to i8*
%addytable2866 = call %clsvar* @add_address_table(%mzone* %zone2858, i8* %var2864, i32 0, i8* %var2865, i32 3, %clsvar* %addytable2863)
%address-table2867 = bitcast %clsvar* %addytable2866 to i8*

; insert table, function and environment into closure struct
%closure.table2870 = getelementptr { i8*, i8*, %String* (i8*, i8*, float)*}, { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2860, i32 0, i32 0
store i8* %address-table2867, i8** %closure.table2870
%closure.env2871 = getelementptr { i8*, i8*, %String* (i8*, i8*, float)*}, { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2860, i32 0, i32 1
store i8* %envptr2861, i8** %closure.env2871
%closure.func2872 = getelementptr { i8*, i8*, %String* (i8*, i8*, float)*}, { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2860, i32 0, i32 2
store %String* (i8*, i8*, float)* @toString_adhoc_W1N0cmluZyosZmxvYXRd__2845, %String* (i8*, i8*, float)** %closure.func2872
%closure_size2873 = call i64 @llvm_zone_mark_size(%mzone* %zone2858)
call void @llvm_zone_ptr_set_size(i8* %clsptr2859, i64 %closure_size2873)
%wrapper_ptr2874 = call i8* @llvm_zone_malloc(%mzone* %zone2858, i64 8)
%closure_wrapper2875 = bitcast i8* %wrapper_ptr2874 to { i8*, i8*, %String* (i8*, i8*, float)*}**
store { i8*, i8*, %String* (i8*, i8*, float)*}* %closure2860, { i8*, i8*, %String* (i8*, i8*, float)*}** %closure_wrapper2875

; let value assignment
%toString_adhoc_W1N0cmluZyosZmxvYXRd = select i1 true, { i8*, i8*, %String* (i8*, i8*, float)*}** %closure_wrapper2875, { i8*, i8*, %String* (i8*, i8*, float)*}** %closure_wrapper2875
store { i8*, i8*, %String* (i8*, i8*, float)*}** %toString_adhoc_W1N0cmluZyosZmxvYXRd, { i8*, i8*, %String* (i8*, i8*, float)*}*** %toString_adhoc_W1N0cmluZyosZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosZmxvYXRd
%tmp_envptr2869 = getelementptr {{i8*, i8*, %String* (i8*, i8*, float)*}***}, {{i8*, i8*, %String* (i8*, i8*, float)*}***}* %environment2862, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, float)*}*** %toString_adhoc_W1N0cmluZyosZmxvYXRdPtr, {i8*, i8*, %String* (i8*, i8*, float)*}**** %tmp_envptr2869


%val2878 = load {i8*, i8*, %String* (i8*, i8*, float)*}**, {i8*, i8*, %String* (i8*, i8*, float)*}*** %toString_adhoc_W1N0cmluZyosZmxvYXRdPtr
ret {i8*, i8*, %String* (i8*, i8*, float)*}** %val2878
}


@toString_adhoc_W1N0cmluZyosZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, float)*}** @toString_adhoc_W1N0cmluZyosZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd_native(float %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2879 = bitcast [89 x i8]* @gsxtmbase202 to i8*
call i32 (i8*, ...) @printf(i8* %var2879)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float}*
%arg_p_0 = getelementptr {float}, {float}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, float)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, float)*}*, {i8*, i8*, %String* (i8*, i8*, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, float)*}, {i8*, i8*, %String* (i8*, i8*, float)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, float)*,  %String* (i8*, i8*, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, float %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase203 = hidden constant [38 x i8] c"toString_adhoc_W1N0cmluZyosZG91YmxlXQ\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ__2880(i8* %_impz,i8* %_impenv, double %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2881 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, double)*}***}*
%toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, double)*}***}, {{i8*, i8*, %String* (i8*, i8*, double)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr = load {i8*, i8*, %String* (i8*, i8*, double)*}***, {i8*, i8*, %String* (i8*, i8*, double)*}**** %toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr_

; setup arguments
%xPtr = alloca double
store double %x, double* %xPtr


%tzone2883 = load i8*, i8** %_impzPtr
%zone2884 = bitcast i8* %tzone2883 to %mzone*

; let assign value to symbol st
%stPtr = alloca i8*
%dat2882 = alloca i8, i64 256, align 16

; let value assignment
%st = select i1 true, i8* %dat2882, i8* %dat2882
store i8* %st, i8** %stPtr

%val2885 = load i8*, i8** %stPtr
%var2886 = bitcast [3 x i8]* @gsxtmbase23 to i8*
%val2887 = load double, double* %xPtr

%val2888 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2885, i8* %var2886, double %val2887)
%val2889 = load i8*, i8** %stPtr
%res2890 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2889)
ret %String* %res2890
}
@gsxtmbase204 = hidden constant [91 x i8] c"toString_adhoc_W1N0cmluZyosZG91YmxlXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, double)*}** @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2910 = load i8*, i8** %_impzPtr
%zone2911 = bitcast i8* %tzone2910 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosZG91YmxlXQ
%dat_toString_adhoc_W1N0cmluZyosZG91YmxlXQ = call i8* @llvm_zone_malloc(%mzone* %zone2911, i64 8)
%toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosZG91YmxlXQ to { i8*, i8*, %String* (i8*, i8*, double)*}***
%tzone2891 = load i8*, i8** %_impzPtr
%zone2892 = bitcast i8* %tzone2891 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2892)
; malloc closure structure
%clsptr2893 = call i8* @llvm_zone_malloc(%mzone* %zone2892, i64 24)
%closure2894 = bitcast i8* %clsptr2893 to { i8*, i8*, %String* (i8*, i8*, double)*}*

; malloc environment structure
%envptr2895 = call i8* @llvm_zone_malloc(%mzone* %zone2892, i64 8)
%environment2896 = bitcast i8* %envptr2895 to {{i8*, i8*, %String* (i8*, i8*, double)*}***}*

; malloc closure address table
%addytable2897 = call %clsvar* @new_address_table()
%var2898 = bitcast [38 x i8]* @gsxtmbase203 to i8*
%var2899 = bitcast [43 x i8]* @gsxtmbase185 to i8*
%addytable2900 = call %clsvar* @add_address_table(%mzone* %zone2892, i8* %var2898, i32 0, i8* %var2899, i32 3, %clsvar* %addytable2897)
%address-table2901 = bitcast %clsvar* %addytable2900 to i8*

; insert table, function and environment into closure struct
%closure.table2904 = getelementptr { i8*, i8*, %String* (i8*, i8*, double)*}, { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2894, i32 0, i32 0
store i8* %address-table2901, i8** %closure.table2904
%closure.env2905 = getelementptr { i8*, i8*, %String* (i8*, i8*, double)*}, { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2894, i32 0, i32 1
store i8* %envptr2895, i8** %closure.env2905
%closure.func2906 = getelementptr { i8*, i8*, %String* (i8*, i8*, double)*}, { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2894, i32 0, i32 2
store %String* (i8*, i8*, double)* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ__2880, %String* (i8*, i8*, double)** %closure.func2906
%closure_size2907 = call i64 @llvm_zone_mark_size(%mzone* %zone2892)
call void @llvm_zone_ptr_set_size(i8* %clsptr2893, i64 %closure_size2907)
%wrapper_ptr2908 = call i8* @llvm_zone_malloc(%mzone* %zone2892, i64 8)
%closure_wrapper2909 = bitcast i8* %wrapper_ptr2908 to { i8*, i8*, %String* (i8*, i8*, double)*}**
store { i8*, i8*, %String* (i8*, i8*, double)*}* %closure2894, { i8*, i8*, %String* (i8*, i8*, double)*}** %closure_wrapper2909

; let value assignment
%toString_adhoc_W1N0cmluZyosZG91YmxlXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, double)*}** %closure_wrapper2909, { i8*, i8*, %String* (i8*, i8*, double)*}** %closure_wrapper2909
store { i8*, i8*, %String* (i8*, i8*, double)*}** %toString_adhoc_W1N0cmluZyosZG91YmxlXQ, { i8*, i8*, %String* (i8*, i8*, double)*}*** %toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosZG91YmxlXQ
%tmp_envptr2903 = getelementptr {{i8*, i8*, %String* (i8*, i8*, double)*}***}, {{i8*, i8*, %String* (i8*, i8*, double)*}***}* %environment2896, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, double)*}*** %toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr, {i8*, i8*, %String* (i8*, i8*, double)*}**** %tmp_envptr2903


%val2912 = load {i8*, i8*, %String* (i8*, i8*, double)*}**, {i8*, i8*, %String* (i8*, i8*, double)*}*** %toString_adhoc_W1N0cmluZyosZG91YmxlXQPtr
ret {i8*, i8*, %String* (i8*, i8*, double)*}** %val2912
}


@toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, double)*}** @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_native(double %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2913 = bitcast [91 x i8]* @gsxtmbase204 to i8*
call i32 (i8*, ...) @printf(i8* %var2913)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc double @r64value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double}*
%arg_p_0 = getelementptr {double}, {double}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, double)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, double)*}*, {i8*, i8*, %String* (i8*, i8*, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, double)*}, {i8*, i8*, %String* (i8*, i8*, double)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, double)*,  %String* (i8*, i8*, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, double %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase205 = hidden constant [3 x i8] c"%p\00"
@gsxtmbase206 = hidden constant [27 x i8] c"print_adhoc_W3ZvaWQsaTgqXQ\00"
@gsxtmbase207 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i8*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsaTgqXQ__2914(i8* %_impz,i8* %_impenv, i8* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2915 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*
%print_adhoc_W3ZvaWQsaTgqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsaTgqXQPtr = load {i8*, i8*, void (i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*)*}**** %print_adhoc_W3ZvaWQsaTgqXQPtr_

; setup arguments
%xPtr = alloca i8*
store i8* %x, i8** %xPtr


%var2916 = bitcast [3 x i8]* @gsxtmbase205 to i8*
%val2917 = load i8*, i8** %xPtr

%val2918 = call i32 (i8*, ...) @printf(i8* %var2916, i8* %val2917)
ret void
}
@gsxtmbase208 = hidden constant [80 x i8] c"print_adhoc_W3ZvaWQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @print_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2939 = load i8*, i8** %_impzPtr
%zone2940 = bitcast i8* %tzone2939 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsaTgqXQ
%dat_print_adhoc_W3ZvaWQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2940, i64 8)
%print_adhoc_W3ZvaWQsaTgqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsaTgqXQ to { i8*, i8*, void (i8*, i8*, i8*)*}***
%tzone2920 = load i8*, i8** %_impzPtr
%zone2921 = bitcast i8* %tzone2920 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2921)
; malloc closure structure
%clsptr2922 = call i8* @llvm_zone_malloc(%mzone* %zone2921, i64 24)
%closure2923 = bitcast i8* %clsptr2922 to { i8*, i8*, void (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2924 = call i8* @llvm_zone_malloc(%mzone* %zone2921, i64 8)
%environment2925 = bitcast i8* %envptr2924 to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2926 = call %clsvar* @new_address_table()
%var2927 = bitcast [27 x i8]* @gsxtmbase206 to i8*
%var2928 = bitcast [36 x i8]* @gsxtmbase207 to i8*
%addytable2929 = call %clsvar* @add_address_table(%mzone* %zone2921, i8* %var2927, i32 0, i8* %var2928, i32 3, %clsvar* %addytable2926)
%address-table2930 = bitcast %clsvar* %addytable2929 to i8*

; insert table, function and environment into closure struct
%closure.table2933 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2923, i32 0, i32 0
store i8* %address-table2930, i8** %closure.table2933
%closure.env2934 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2923, i32 0, i32 1
store i8* %envptr2924, i8** %closure.env2934
%closure.func2935 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2923, i32 0, i32 2
store void (i8*, i8*, i8*)* @print_adhoc_W3ZvaWQsaTgqXQ__2914, void (i8*, i8*, i8*)** %closure.func2935
%closure_size2936 = call i64 @llvm_zone_mark_size(%mzone* %zone2921)
call void @llvm_zone_ptr_set_size(i8* %clsptr2922, i64 %closure_size2936)
%wrapper_ptr2937 = call i8* @llvm_zone_malloc(%mzone* %zone2921, i64 8)
%closure_wrapper2938 = bitcast i8* %wrapper_ptr2937 to { i8*, i8*, void (i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2923, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2938

; let value assignment
%print_adhoc_W3ZvaWQsaTgqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2938, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2938
store { i8*, i8*, void (i8*, i8*, i8*)*}** %print_adhoc_W3ZvaWQsaTgqXQ, { i8*, i8*, void (i8*, i8*, i8*)*}*** %print_adhoc_W3ZvaWQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsaTgqXQ
%tmp_envptr2932 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %environment2925, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*)*}*** %print_adhoc_W3ZvaWQsaTgqXQPtr, {i8*, i8*, void (i8*, i8*, i8*)*}**** %tmp_envptr2932


%val2941 = load {i8*, i8*, void (i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*)*}*** %print_adhoc_W3ZvaWQsaTgqXQPtr
ret {i8*, i8*, void (i8*, i8*, i8*)*}** %val2941
}


@print_adhoc_W3ZvaWQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @print_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2942 = bitcast [80 x i8]* @gsxtmbase208 to i8*
call i32 (i8*, ...) @printf(i8* %var2942)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase209 = hidden constant [34 x i8] c"toString_adhoc_W1N0cmluZyosaTgqXQ\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ__2943(i8* %_impz,i8* %_impenv, i8* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2944 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*
%toString_adhoc_W1N0cmluZyosaTgqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosaTgqXQPtr = load {i8*, i8*, %String* (i8*, i8*, i8*)*}***, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %toString_adhoc_W1N0cmluZyosaTgqXQPtr_

; setup arguments
%xPtr = alloca i8*
store i8* %x, i8** %xPtr


%tzone2946 = load i8*, i8** %_impzPtr
%zone2947 = bitcast i8* %tzone2946 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat2945 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat2945, i8* %dat2945
store i8* %s, i8** %sPtr

%val2948 = load i8*, i8** %sPtr
%var2949 = bitcast [3 x i8]* @gsxtmbase205 to i8*
%val2950 = load i8*, i8** %xPtr

%val2951 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2948, i8* %var2949, i8* %val2950)
%val2952 = load i8*, i8** %sPtr
%res2953 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2952)
ret %String* %res2953
}
@gsxtmbase210 = hidden constant [87 x i8] c"toString_adhoc_W1N0cmluZyosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @toString_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2973 = load i8*, i8** %_impzPtr
%zone2974 = bitcast i8* %tzone2973 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosaTgqXQ
%dat_toString_adhoc_W1N0cmluZyosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2974, i64 8)
%toString_adhoc_W1N0cmluZyosaTgqXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosaTgqXQ to { i8*, i8*, %String* (i8*, i8*, i8*)*}***
%tzone2954 = load i8*, i8** %_impzPtr
%zone2955 = bitcast i8* %tzone2954 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2955)
; malloc closure structure
%clsptr2956 = call i8* @llvm_zone_malloc(%mzone* %zone2955, i64 24)
%closure2957 = bitcast i8* %clsptr2956 to { i8*, i8*, %String* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2958 = call i8* @llvm_zone_malloc(%mzone* %zone2955, i64 8)
%environment2959 = bitcast i8* %envptr2958 to {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2960 = call %clsvar* @new_address_table()
%var2961 = bitcast [34 x i8]* @gsxtmbase209 to i8*
%var2962 = bitcast [40 x i8]* @gsxtmbase81 to i8*
%addytable2963 = call %clsvar* @add_address_table(%mzone* %zone2955, i8* %var2961, i32 0, i8* %var2962, i32 3, %clsvar* %addytable2960)
%address-table2964 = bitcast %clsvar* %addytable2963 to i8*

; insert table, function and environment into closure struct
%closure.table2967 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure2957, i32 0, i32 0
store i8* %address-table2964, i8** %closure.table2967
%closure.env2968 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure2957, i32 0, i32 1
store i8* %envptr2958, i8** %closure.env2968
%closure.func2969 = getelementptr { i8*, i8*, %String* (i8*, i8*, i8*)*}, { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure2957, i32 0, i32 2
store %String* (i8*, i8*, i8*)* @toString_adhoc_W1N0cmluZyosaTgqXQ__2943, %String* (i8*, i8*, i8*)** %closure.func2969
%closure_size2970 = call i64 @llvm_zone_mark_size(%mzone* %zone2955)
call void @llvm_zone_ptr_set_size(i8* %clsptr2956, i64 %closure_size2970)
%wrapper_ptr2971 = call i8* @llvm_zone_malloc(%mzone* %zone2955, i64 8)
%closure_wrapper2972 = bitcast i8* %wrapper_ptr2971 to { i8*, i8*, %String* (i8*, i8*, i8*)*}**
store { i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure2957, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper2972

; let value assignment
%toString_adhoc_W1N0cmluZyosaTgqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper2972, { i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_wrapper2972
store { i8*, i8*, %String* (i8*, i8*, i8*)*}** %toString_adhoc_W1N0cmluZyosaTgqXQ, { i8*, i8*, %String* (i8*, i8*, i8*)*}*** %toString_adhoc_W1N0cmluZyosaTgqXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosaTgqXQ
%tmp_envptr2966 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i8*)*}***}* %environment2959, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %toString_adhoc_W1N0cmluZyosaTgqXQPtr, {i8*, i8*, %String* (i8*, i8*, i8*)*}**** %tmp_envptr2966


%val2975 = load {i8*, i8*, %String* (i8*, i8*, i8*)*}**, {i8*, i8*, %String* (i8*, i8*, i8*)*}*** %toString_adhoc_W1N0cmluZyosaTgqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, i8*)*}** %val2975
}


@toString_adhoc_W1N0cmluZyosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i8*)*}** @toString_adhoc_W1N0cmluZyosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2976 = bitcast [87 x i8]* @gsxtmbase210 to i8*
call i32 (i8*, ...) @printf(i8* %var2976)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i8*)*}*, {i8*, i8*, %String* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i8*)*}, {i8*, i8*, %String* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i8*)*,  %String* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%Symbol = type {i64,i8*}
@gsxtmbase211 = hidden constant [37 x i8] c"Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0\00"
@gsxtmbase212 = hidden constant [45 x i8] c"{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**\00"
define dllexport fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0__2977(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2978 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}*
%Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**** %Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone2983 = load i8*, i8** %_impzPtr
%zone2984 = bitcast i8* %tzone2983 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Symbol*
%tzone2979 = load i8*, i8** %_impzPtr
%zone2980 = bitcast i8* %tzone2979 to %mzone*
%dat2981 = call i8* @llvm_zone_malloc(%mzone* %zone2980, i64 16)
call i8* @memset(i8* %dat2981, i32 0, i64 16)
%val2982 = bitcast i8* %dat2981 to %Symbol*

; let value assignment
%obj = select i1 true, %Symbol* %val2982, %Symbol* %val2982
store %Symbol* %obj, %Symbol** %objPtr

%val2985 = load %Symbol*, %Symbol** %objPtr
%val2986 = load i64, i64* %arg_0Ptr
; set tuple
%val2987 = getelementptr %Symbol, %Symbol* %val2985, i64 0, i32 0
store i64 %val2986, i64* %val2987
%val2988 = load %Symbol*, %Symbol** %objPtr
%val2989 = load i8*, i8** %arg_1Ptr
; set tuple
%val2990 = getelementptr %Symbol, %Symbol* %val2988, i64 0, i32 1
store i8* %val2989, i8** %val2990
%val2991 = load %Symbol*, %Symbol** %objPtr
ret %Symbol* %val2991
}
@gsxtmbase213 = hidden constant [90 x i8] c"Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3011 = load i8*, i8** %_impzPtr
%zone3012 = bitcast i8* %tzone3011 to %mzone*

; let assign value to symbol Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0
%dat_Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3012, i64 8)
%Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr = bitcast i8* %dat_Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***
%tzone2992 = load i8*, i8** %_impzPtr
%zone2993 = bitcast i8* %tzone2992 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2993)
; malloc closure structure
%clsptr2994 = call i8* @llvm_zone_malloc(%mzone* %zone2993, i64 24)
%closure2995 = bitcast i8* %clsptr2994 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr2996 = call i8* @llvm_zone_malloc(%mzone* %zone2993, i64 8)
%environment2997 = bitcast i8* %envptr2996 to {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable2998 = call %clsvar* @new_address_table()
%var2999 = bitcast [37 x i8]* @gsxtmbase211 to i8*
%var3000 = bitcast [45 x i8]* @gsxtmbase212 to i8*
%addytable3001 = call %clsvar* @add_address_table(%mzone* %zone2993, i8* %var2999, i32 0, i8* %var3000, i32 3, %clsvar* %addytable2998)
%address-table3002 = bitcast %clsvar* %addytable3001 to i8*

; insert table, function and environment into closure struct
%closure.table3005 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure2995, i32 0, i32 0
store i8* %address-table3002, i8** %closure.table3005
%closure.env3006 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure2995, i32 0, i32 1
store i8* %envptr2996, i8** %closure.env3006
%closure.func3007 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure2995, i32 0, i32 2
store %Symbol* (i8*, i8*, i64, i8*)* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0__2977, %Symbol* (i8*, i8*, i64, i8*)** %closure.func3007
%closure_size3008 = call i64 @llvm_zone_mark_size(%mzone* %zone2993)
call void @llvm_zone_ptr_set_size(i8* %clsptr2994, i64 %closure_size3008)
%wrapper_ptr3009 = call i8* @llvm_zone_malloc(%mzone* %zone2993, i64 8)
%closure_wrapper3010 = bitcast i8* %wrapper_ptr3009 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure2995, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3010

; let value assignment
%Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3010, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3010
store { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0
%tmp_envptr3004 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}* %environment2997, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**** %tmp_envptr3004


%val3013 = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr
ret {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %val3013
}


@Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol* %result
}


define dllexport ccc i8*  @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3014 = bitcast [90 x i8]* @gsxtmbase213 to i8*
call i32 (i8*, ...) @printf(i8* %var3014)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3015 = bitcast [90 x i8]* @gsxtmbase213 to i8*
call i32 (i8*, ...) @printf(i8* %var3015)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase214 = hidden constant [39 x i8] c"Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0\00"
define dllexport fastcc %Symbol* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0__3016(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3017 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}*
%Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**** %Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone3022 = load i8*, i8** %_impzPtr
%zone3023 = bitcast i8* %tzone3022 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Symbol*
%tzone3018 = load i8*, i8** %_impzPtr
%zone3019 = bitcast i8* %tzone3018 to %mzone*
%dat3020 = call i8* @llvm_zone_malloc(%mzone* %zone3019, i64 16)
call i8* @memset(i8* %dat3020, i32 0, i64 16)
%val3021 = bitcast i8* %dat3020 to %Symbol*

; let value assignment
%obj = select i1 true, %Symbol* %val3021, %Symbol* %val3021
store %Symbol* %obj, %Symbol** %objPtr

%val3024 = load %Symbol*, %Symbol** %objPtr
%val3025 = load i64, i64* %arg_0Ptr
; set tuple
%val3026 = getelementptr %Symbol, %Symbol* %val3024, i64 0, i32 0
store i64 %val3025, i64* %val3026
%val3027 = load %Symbol*, %Symbol** %objPtr
%val3028 = load i8*, i8** %arg_1Ptr
; set tuple
%val3029 = getelementptr %Symbol, %Symbol* %val3027, i64 0, i32 1
store i8* %val3028, i8** %val3029
%val3030 = load %Symbol*, %Symbol** %objPtr
ret %Symbol* %val3030
}
@gsxtmbase215 = hidden constant [92 x i8] c"Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3050 = load i8*, i8** %_impzPtr
%zone3051 = bitcast i8* %tzone3050 to %mzone*

; let assign value to symbol Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0
%dat_Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3051, i64 8)
%Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr = bitcast i8* %dat_Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***
%tzone3031 = load i8*, i8** %_impzPtr
%zone3032 = bitcast i8* %tzone3031 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3032)
; malloc closure structure
%clsptr3033 = call i8* @llvm_zone_malloc(%mzone* %zone3032, i64 24)
%closure3034 = bitcast i8* %clsptr3033 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr3035 = call i8* @llvm_zone_malloc(%mzone* %zone3032, i64 8)
%environment3036 = bitcast i8* %envptr3035 to {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable3037 = call %clsvar* @new_address_table()
%var3038 = bitcast [39 x i8]* @gsxtmbase214 to i8*
%var3039 = bitcast [45 x i8]* @gsxtmbase212 to i8*
%addytable3040 = call %clsvar* @add_address_table(%mzone* %zone3032, i8* %var3038, i32 0, i8* %var3039, i32 3, %clsvar* %addytable3037)
%address-table3041 = bitcast %clsvar* %addytable3040 to i8*

; insert table, function and environment into closure struct
%closure.table3044 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3034, i32 0, i32 0
store i8* %address-table3041, i8** %closure.table3044
%closure.env3045 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3034, i32 0, i32 1
store i8* %envptr3035, i8** %closure.env3045
%closure.func3046 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3034, i32 0, i32 2
store %Symbol* (i8*, i8*, i64, i8*)* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0__3016, %Symbol* (i8*, i8*, i64, i8*)** %closure.func3046
%closure_size3047 = call i64 @llvm_zone_mark_size(%mzone* %zone3032)
call void @llvm_zone_ptr_set_size(i8* %clsptr3033, i64 %closure_size3047)
%wrapper_ptr3048 = call i8* @llvm_zone_malloc(%mzone* %zone3032, i64 8)
%closure_wrapper3049 = bitcast i8* %wrapper_ptr3048 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3034, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3049

; let value assignment
%Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3049, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3049
store { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0
%tmp_envptr3043 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}* %environment3036, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**** %tmp_envptr3043


%val3052 = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr
ret {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %val3052
}


@Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol* %result
}


define dllexport ccc i8*  @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3053 = bitcast [92 x i8]* @gsxtmbase215 to i8*
call i32 (i8*, ...) @printf(i8* %var3053)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3054 = bitcast [92 x i8]* @gsxtmbase215 to i8*
call i32 (i8*, ...) @printf(i8* %var3054)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase216 = hidden constant [39 x i8] c"Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0\00"
define dllexport fastcc %Symbol* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0__3055(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3056 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}*
%Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**** %Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone3059 = load i8*, i8** %_impzPtr
%zone3060 = bitcast i8* %tzone3059 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Symbol*
%dat3057 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat3057, i32 0, i64 16)
%val3058 = bitcast i8* %dat3057 to %Symbol*

; let value assignment
%obj = select i1 true, %Symbol* %val3058, %Symbol* %val3058
store %Symbol* %obj, %Symbol** %objPtr

%val3061 = load %Symbol*, %Symbol** %objPtr
%val3062 = load i64, i64* %arg_0Ptr
; set tuple
%val3063 = getelementptr %Symbol, %Symbol* %val3061, i64 0, i32 0
store i64 %val3062, i64* %val3063
%val3064 = load %Symbol*, %Symbol** %objPtr
%val3065 = load i8*, i8** %arg_1Ptr
; set tuple
%val3066 = getelementptr %Symbol, %Symbol* %val3064, i64 0, i32 1
store i8* %val3065, i8** %val3066
%val3067 = load %Symbol*, %Symbol** %objPtr
ret %Symbol* %val3067
}
@gsxtmbase217 = hidden constant [92 x i8] c"Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3087 = load i8*, i8** %_impzPtr
%zone3088 = bitcast i8* %tzone3087 to %mzone*

; let assign value to symbol Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0
%dat_Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3088, i64 8)
%Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr = bitcast i8* %dat_Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***
%tzone3068 = load i8*, i8** %_impzPtr
%zone3069 = bitcast i8* %tzone3068 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3069)
; malloc closure structure
%clsptr3070 = call i8* @llvm_zone_malloc(%mzone* %zone3069, i64 24)
%closure3071 = bitcast i8* %clsptr3070 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr3072 = call i8* @llvm_zone_malloc(%mzone* %zone3069, i64 8)
%environment3073 = bitcast i8* %envptr3072 to {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable3074 = call %clsvar* @new_address_table()
%var3075 = bitcast [39 x i8]* @gsxtmbase216 to i8*
%var3076 = bitcast [45 x i8]* @gsxtmbase212 to i8*
%addytable3077 = call %clsvar* @add_address_table(%mzone* %zone3069, i8* %var3075, i32 0, i8* %var3076, i32 3, %clsvar* %addytable3074)
%address-table3078 = bitcast %clsvar* %addytable3077 to i8*

; insert table, function and environment into closure struct
%closure.table3081 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3071, i32 0, i32 0
store i8* %address-table3078, i8** %closure.table3081
%closure.env3082 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3071, i32 0, i32 1
store i8* %envptr3072, i8** %closure.env3082
%closure.func3083 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3071, i32 0, i32 2
store %Symbol* (i8*, i8*, i64, i8*)* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0__3055, %Symbol* (i8*, i8*, i64, i8*)** %closure.func3083
%closure_size3084 = call i64 @llvm_zone_mark_size(%mzone* %zone3069)
call void @llvm_zone_ptr_set_size(i8* %clsptr3070, i64 %closure_size3084)
%wrapper_ptr3085 = call i8* @llvm_zone_malloc(%mzone* %zone3069, i64 8)
%closure_wrapper3086 = bitcast i8* %wrapper_ptr3085 to { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure3071, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3086

; let value assignment
%Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0 = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3086, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_wrapper3086
store { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0, { i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0
%tmp_envptr3080 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}***}* %environment3073, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**** %tmp_envptr3080


%val3089 = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*** %Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0Ptr
ret {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %val3089
}


@Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol* %result
}


define dllexport ccc i8*  @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3090 = bitcast [92 x i8]* @gsxtmbase217 to i8*
call i32 (i8*, ...) @printf(i8* %var3090)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3091 = bitcast [92 x i8]* @gsxtmbase217 to i8*
call i32 (i8*, ...) @printf(i8* %var3091)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_h_adhoc_W1N5bWJvbCosaTY0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i64, i8*)*,  %Symbol* (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase218 = hidden constant [40 x i8] c"Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ\00"
@gsxtmbase219 = hidden constant [44 x i8] c"{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**\00"
define dllexport fastcc %Symbol @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ__3092(i8* %_impz,i8* %_impenv, i64 %arg_0, i8* %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3093 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***}*
%Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr_ = getelementptr {{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***}* %impenv, i32 0, i32 0
%Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr = load {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**** %Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr


%tzone3095 = load i8*, i8** %_impzPtr
%zone3096 = bitcast i8* %tzone3095 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Symbol*
%dat3094 = alloca %Symbol, align 16

; let value assignment
%obj = select i1 true, %Symbol* %dat3094, %Symbol* %dat3094
store %Symbol* %obj, %Symbol** %objPtr

%val3097 = load %Symbol*, %Symbol** %objPtr
%val3098 = load i64, i64* %arg_0Ptr
; set tuple
%val3099 = getelementptr %Symbol, %Symbol* %val3097, i64 0, i32 0
store i64 %val3098, i64* %val3099
%val3100 = load %Symbol*, %Symbol** %objPtr
%val3101 = load i8*, i8** %arg_1Ptr
; set tuple
%val3102 = getelementptr %Symbol, %Symbol* %val3100, i64 0, i32 1
store i8* %val3101, i8** %val3102
%val3103 = load %Symbol*, %Symbol** %objPtr
; pointer ref
%val3104 = getelementptr %Symbol, %Symbol* %val3103, i64 0
%val3105 = load %Symbol, %Symbol* %val3104
ret %Symbol %val3105
}
@gsxtmbase220 = hidden constant [93 x i8] c"Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3125 = load i8*, i8** %_impzPtr
%zone3126 = bitcast i8* %tzone3125 to %mzone*

; let assign value to symbol Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ
%dat_Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3126, i64 8)
%Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr = bitcast i8* %dat_Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ to { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***
%tzone3106 = load i8*, i8** %_impzPtr
%zone3107 = bitcast i8* %tzone3106 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3107)
; malloc closure structure
%clsptr3108 = call i8* @llvm_zone_malloc(%mzone* %zone3107, i64 24)
%closure3109 = bitcast i8* %clsptr3108 to { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*

; malloc environment structure
%envptr3110 = call i8* @llvm_zone_malloc(%mzone* %zone3107, i64 8)
%environment3111 = bitcast i8* %envptr3110 to {{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***}*

; malloc closure address table
%addytable3112 = call %clsvar* @new_address_table()
%var3113 = bitcast [40 x i8]* @gsxtmbase218 to i8*
%var3114 = bitcast [44 x i8]* @gsxtmbase219 to i8*
%addytable3115 = call %clsvar* @add_address_table(%mzone* %zone3107, i8* %var3113, i32 0, i8* %var3114, i32 3, %clsvar* %addytable3112)
%address-table3116 = bitcast %clsvar* %addytable3115 to i8*

; insert table, function and environment into closure struct
%closure.table3119 = getelementptr { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure3109, i32 0, i32 0
store i8* %address-table3116, i8** %closure.table3119
%closure.env3120 = getelementptr { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure3109, i32 0, i32 1
store i8* %envptr3110, i8** %closure.env3120
%closure.func3121 = getelementptr { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure3109, i32 0, i32 2
store %Symbol (i8*, i8*, i64, i8*)* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ__3092, %Symbol (i8*, i8*, i64, i8*)** %closure.func3121
%closure_size3122 = call i64 @llvm_zone_mark_size(%mzone* %zone3107)
call void @llvm_zone_ptr_set_size(i8* %clsptr3108, i64 %closure_size3122)
%wrapper_ptr3123 = call i8* @llvm_zone_malloc(%mzone* %zone3107, i64 8)
%closure_wrapper3124 = bitcast i8* %wrapper_ptr3123 to { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**
store { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure3109, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure_wrapper3124

; let value assignment
%Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ = select i1 true, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure_wrapper3124, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure_wrapper3124
store { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ, { i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*** %Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ
%tmp_envptr3118 = getelementptr {{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***}, {{i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}***}* %environment3111, i32 0, i32 0
store {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*** %Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**** %tmp_envptr3118


%val3127 = load {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*** %Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQPtr
ret {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %val3127
}


@Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol (i8*, i8*, i64, i8*)*,  %Symbol (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol %result
}


define dllexport ccc %Symbol @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_native(i64 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol (i8*, i8*, i64, i8*)*,  %Symbol (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
ret %Symbol %result
}


define dllexport ccc void @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i8*}*
%arg_p_0 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i8*}, {i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_val_adhoc_W1N5bWJvbCxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}**
%closure = load {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}*, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}, {i8*, i8*, %Symbol (i8*, i8*, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol (i8*, i8*, i64, i8*)*,  %Symbol (i8*, i8*, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol %ff(i8* %_impz, i8* %ee, i64 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase221 = hidden constant [36 x i8] c"hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0\00"
@gsxtmbase222 = hidden constant [45 x i8] c"{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**\00"
define dllexport fastcc %Symbol* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0__3130(i8* %_impz,i8* %_impenv, %Symbol* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3131 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}*
%hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**** %hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr_

; setup arguments
%xPtr = alloca %Symbol*
store %Symbol* %x, %Symbol** %xPtr


%tzone3134 = load i8*, i8** %_impzPtr
%zone3135 = bitcast i8* %tzone3134 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Symbol*
%dat3132 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat3132, i32 0, i64 16)
%val3133 = bitcast i8* %dat3132 to %Symbol*

; let value assignment
%obj = select i1 true, %Symbol* %val3133, %Symbol* %val3133
store %Symbol* %obj, %Symbol** %objPtr

%val3136 = load %Symbol*, %Symbol** %objPtr
%val3137 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3138 = getelementptr %Symbol, %Symbol* %val3137, i64 0, i32 0
%val3139 = load i64, i64* %val3138
; set tuple
%val3140 = getelementptr %Symbol, %Symbol* %val3136, i64 0, i32 0
store i64 %val3139, i64* %val3140
%val3141 = load %Symbol*, %Symbol** %objPtr
%val3142 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3143 = getelementptr %Symbol, %Symbol* %val3142, i64 0, i32 1
%val3144 = load i8*, i8** %val3143
; set tuple
%val3145 = getelementptr %Symbol, %Symbol* %val3141, i64 0, i32 1
store i8* %val3144, i8** %val3145
%val3146 = load %Symbol*, %Symbol** %objPtr
ret %Symbol* %val3146
}
@gsxtmbase223 = hidden constant [89 x i8] c"hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3166 = load i8*, i8** %_impzPtr
%zone3167 = bitcast i8* %tzone3166 to %mzone*

; let assign value to symbol hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0
%dat_hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3167, i64 8)
%hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***
%tzone3147 = load i8*, i8** %_impzPtr
%zone3148 = bitcast i8* %tzone3147 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3148)
; malloc closure structure
%clsptr3149 = call i8* @llvm_zone_malloc(%mzone* %zone3148, i64 24)
%closure3150 = bitcast i8* %clsptr3149 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3151 = call i8* @llvm_zone_malloc(%mzone* %zone3148, i64 8)
%environment3152 = bitcast i8* %envptr3151 to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3153 = call %clsvar* @new_address_table()
%var3154 = bitcast [36 x i8]* @gsxtmbase221 to i8*
%var3155 = bitcast [45 x i8]* @gsxtmbase222 to i8*
%addytable3156 = call %clsvar* @add_address_table(%mzone* %zone3148, i8* %var3154, i32 0, i8* %var3155, i32 3, %clsvar* %addytable3153)
%address-table3157 = bitcast %clsvar* %addytable3156 to i8*

; insert table, function and environment into closure struct
%closure.table3160 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3150, i32 0, i32 0
store i8* %address-table3157, i8** %closure.table3160
%closure.env3161 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3150, i32 0, i32 1
store i8* %envptr3151, i8** %closure.env3161
%closure.func3162 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3150, i32 0, i32 2
store %Symbol* (i8*, i8*, %Symbol*)* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0__3130, %Symbol* (i8*, i8*, %Symbol*)** %closure.func3162
%closure_size3163 = call i64 @llvm_zone_mark_size(%mzone* %zone3148)
call void @llvm_zone_ptr_set_size(i8* %clsptr3149, i64 %closure_size3163)
%wrapper_ptr3164 = call i8* @llvm_zone_malloc(%mzone* %zone3148, i64 8)
%closure_wrapper3165 = bitcast i8* %wrapper_ptr3164 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3150, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_wrapper3165

; let value assignment
%hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0 = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_wrapper3165, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_wrapper3165
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*** %hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0
%tmp_envptr3159 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}* %environment3152, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*** %hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**** %tmp_envptr3159


%val3168 = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*** %hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr
ret {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %val3168
}


@hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret %Symbol* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3169 = bitcast [89 x i8]* @gsxtmbase223 to i8*
call i32 (i8*, ...) @printf(i8* %var3169)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase224 = hidden constant [32 x i8] c"hfree_adhoc_W3ZvaWQsU3ltYm9sKl0\00"
@gsxtmbase225 = hidden constant [41 x i8] c"{i8*, i8*, void (i8*, i8*, %Symbol*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0__3170(i8* %_impz,i8* %_impenv, %Symbol* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3171 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}*
%hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}***, {i8*, i8*, void (i8*, i8*, %Symbol*)*}**** %hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr_

; setup arguments
%xPtr = alloca %Symbol*
store %Symbol* %x, %Symbol** %xPtr


%val3172 = load %Symbol*, %Symbol** %xPtr
%val3173 = bitcast %Symbol* %val3172 to i8*
call ccc void @free(i8* %val3173)
ret void
}
@gsxtmbase226 = hidden constant [85 x i8] c"hfree_adhoc_W3ZvaWQsU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Symbol*)*}** @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3195 = load i8*, i8** %_impzPtr
%zone3196 = bitcast i8* %tzone3195 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU3ltYm9sKl0
%dat_hfree_adhoc_W3ZvaWQsU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3196, i64 8)
%hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU3ltYm9sKl0 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}***
%tzone3176 = load i8*, i8** %_impzPtr
%zone3177 = bitcast i8* %tzone3176 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3177)
; malloc closure structure
%clsptr3178 = call i8* @llvm_zone_malloc(%mzone* %zone3177, i64 24)
%closure3179 = bitcast i8* %clsptr3178 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3180 = call i8* @llvm_zone_malloc(%mzone* %zone3177, i64 8)
%environment3181 = bitcast i8* %envptr3180 to {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3182 = call %clsvar* @new_address_table()
%var3183 = bitcast [32 x i8]* @gsxtmbase224 to i8*
%var3184 = bitcast [41 x i8]* @gsxtmbase225 to i8*
%addytable3185 = call %clsvar* @add_address_table(%mzone* %zone3177, i8* %var3183, i32 0, i8* %var3184, i32 3, %clsvar* %addytable3182)
%address-table3186 = bitcast %clsvar* %addytable3185 to i8*

; insert table, function and environment into closure struct
%closure.table3189 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3179, i32 0, i32 0
store i8* %address-table3186, i8** %closure.table3189
%closure.env3190 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3179, i32 0, i32 1
store i8* %envptr3180, i8** %closure.env3190
%closure.func3191 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3179, i32 0, i32 2
store void (i8*, i8*, %Symbol*)* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0__3170, void (i8*, i8*, %Symbol*)** %closure.func3191
%closure_size3192 = call i64 @llvm_zone_mark_size(%mzone* %zone3177)
call void @llvm_zone_ptr_set_size(i8* %clsptr3178, i64 %closure_size3192)
%wrapper_ptr3193 = call i8* @llvm_zone_malloc(%mzone* %zone3177, i64 8)
%closure_wrapper3194 = bitcast i8* %wrapper_ptr3193 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3179, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3194

; let value assignment
%hfree_adhoc_W3ZvaWQsU3ltYm9sKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3194, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3194
store { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %hfree_adhoc_W3ZvaWQsU3ltYm9sKl0, { i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU3ltYm9sKl0
%tmp_envptr3188 = getelementptr {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}* %environment3181, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr, {i8*, i8*, void (i8*, i8*, %Symbol*)*}**** %tmp_envptr3188


%val3197 = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}**, {i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %hfree_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %val3197
}


@hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Symbol*)*}** @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3198 = bitcast [85 x i8]* @gsxtmbase226 to i8*
call i32 (i8*, ...) @printf(i8* %var3198)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase227 = hidden constant [55 x i8] c"zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmbase228 = hidden constant [63 x i8] c"{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %Symbol* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ__3199(i8* %_impz,i8* %_impenv, %Symbol* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3200 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %Symbol*
store %Symbol* %x, %Symbol** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val3202 = load %mzone*, %mzone** %fromzPtr
%val3203 = load %Symbol*, %Symbol** %xPtr
%val3204 = bitcast %Symbol* %val3203 to i8*
%res3205 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3202, i8* %val3204)
br i1 %res3205, label %then3201, label %else3201

then3201:
%val3206 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val3206)
%zone_ptr3207 = bitcast %mzone* %val3206 to i8*
store i8* %zone_ptr3207, i8** %_impzPtr
%tzone3213 = load i8*, i8** %_impzPtr
%zone3214 = bitcast i8* %tzone3213 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Symbol*
%tzone3209 = load i8*, i8** %_impzPtr
%zone3210 = bitcast i8* %tzone3209 to %mzone*
%dat3211 = call i8* @llvm_zone_malloc(%mzone* %zone3210, i64 16)
call i8* @memset(i8* %dat3211, i32 0, i64 16)
%val3212 = bitcast i8* %dat3211 to %Symbol*

; let value assignment
%obj = select i1 true, %Symbol* %val3212, %Symbol* %val3212
store %Symbol* %obj, %Symbol** %objPtr

; promote local stack var allocations
%tzone3253 = load i8*, i8** %_impzPtr
%zone3254 = bitcast i8* %tzone3253 to %mzone*
%ifptr3220 = alloca i8*
%val3215 = load %Symbol*, %Symbol** %objPtr
%val3216 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3217 = getelementptr %Symbol, %Symbol* %val3216, i64 0, i32 0
%val3218 = load i64, i64* %val3217
; set tuple
%val3219 = getelementptr %Symbol, %Symbol* %val3215, i64 0, i32 0
store i64 %val3218, i64* %val3219
%val3221 = load %mzone*, %mzone** %fromzPtr
%val3222 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3223 = getelementptr %Symbol, %Symbol* %val3222, i64 0, i32 1
%val3224 = load i8*, i8** %val3223
%val3225 = bitcast i8* %val3224 to i8*
%res3226 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3221, i8* %val3225)
br i1 %res3226, label %then3220, label %else3220

then3220:
%tzone3231 = load i8*, i8** %_impzPtr
%zone3232 = bitcast i8* %tzone3231 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i8*
%tzone3227 = load i8*, i8** %_impzPtr
%zone3228 = bitcast i8* %tzone3227 to %mzone*
%dat3229 = call i8* @llvm_zone_malloc(%mzone* %zone3228, i64 1)
call i8* @memset(i8* %dat3229, i32 0, i64 1)
%val3230 = bitcast i8* %dat3229 to i8*

; let value assignment
%newptr = select i1 true, i8* %val3230, i8* %val3230
store i8* %newptr, i8** %newptrPtr

%val3233 = load i8*, i8** %newptrPtr
%val3234 = bitcast i8* %val3233 to i8*
%val3235 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3236 = getelementptr %Symbol, %Symbol* %val3235, i64 0, i32 1
%val3237 = load i8*, i8** %val3236
%val3238 = bitcast i8* %val3237 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val3234, i8* %val3238, i64 1, i32 1, i1 0)
%val3240 = load %Symbol*, %Symbol** %objPtr
%val3241 = load i8*, i8** %newptrPtr
; set tuple
%val3242 = getelementptr %Symbol, %Symbol* %val3240, i64 0, i32 1
store i8* %val3241, i8** %val3242
store i8* %val3241, i8** %ifptr3220
br label %ifcont3220

else3220:
%val3243 = load %Symbol*, %Symbol** %objPtr
%val3244 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3245 = getelementptr %Symbol, %Symbol* %val3244, i64 0, i32 1
%val3246 = load i8*, i8** %val3245
; set tuple
%val3247 = getelementptr %Symbol, %Symbol* %val3243, i64 0, i32 1
store i8* %val3246, i8** %val3247
store i8* %val3246, i8** %ifptr3220
br label %ifcont3220

ifcont3220:
%ifres3248 = load i8*, i8** %ifptr3220

%oldzone3249 = call %mzone* @llvm_pop_zone_stack()
%newzone3250 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3251 = bitcast %mzone* %newzone3250 to i8*
store i8* %zone_ptr3251, i8** %_impzPtr
%val3252 = load %Symbol*, %Symbol** %objPtr
ret %Symbol* %val3252

else3201:
%val3255 = load %Symbol*, %Symbol** %xPtr
ret %Symbol* %val3255
}
@gsxtmbase229 = hidden constant [108 x i8] c"zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3275 = load i8*, i8** %_impzPtr
%zone3276 = bitcast i8* %tzone3275 to %mzone*

; let assign value to symbol zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3276, i64 8)
%zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***
%tzone3256 = load i8*, i8** %_impzPtr
%zone3257 = bitcast i8* %tzone3256 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3257)
; malloc closure structure
%clsptr3258 = call i8* @llvm_zone_malloc(%mzone* %zone3257, i64 24)
%closure3259 = bitcast i8* %clsptr3258 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr3260 = call i8* @llvm_zone_malloc(%mzone* %zone3257, i64 8)
%environment3261 = bitcast i8* %envptr3260 to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable3262 = call %clsvar* @new_address_table()
%var3263 = bitcast [55 x i8]* @gsxtmbase227 to i8*
%var3264 = bitcast [63 x i8]* @gsxtmbase228 to i8*
%addytable3265 = call %clsvar* @add_address_table(%mzone* %zone3257, i8* %var3263, i32 0, i8* %var3264, i32 3, %clsvar* %addytable3262)
%address-table3266 = bitcast %clsvar* %addytable3265 to i8*

; insert table, function and environment into closure struct
%closure.table3269 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure3259, i32 0, i32 0
store i8* %address-table3266, i8** %closure.table3269
%closure.env3270 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure3259, i32 0, i32 1
store i8* %envptr3260, i8** %closure.env3270
%closure.func3271 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure3259, i32 0, i32 2
store %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ__3199, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)** %closure.func3271
%closure_size3272 = call i64 @llvm_zone_mark_size(%mzone* %zone3257)
call void @llvm_zone_ptr_set_size(i8* %clsptr3258, i64 %closure_size3272)
%wrapper_ptr3273 = call i8* @llvm_zone_malloc(%mzone* %zone3257, i64 8)
%closure_wrapper3274 = bitcast i8* %wrapper_ptr3273 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure3259, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_wrapper3274

; let value assignment
%zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_wrapper3274, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_wrapper3274
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ
%tmp_envptr3268 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}***}* %environment3261, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**** %tmp_envptr3268


%val3277 = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %val3277
}


@zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ(%Symbol* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*,  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_native(%Symbol* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*,  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Symbol* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3278 = bitcast [108 x i8]* @gsxtmbase229 to i8*
call i32 (i8*, ...) @printf(i8* %var3278)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3279 = bitcast [108 x i8]* @gsxtmbase229 to i8*
call i32 (i8*, ...) @printf(i8* %var3279)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3280 = bitcast [108 x i8]* @gsxtmbase229 to i8*
call i32 (i8*, ...) @printf(i8* %var3280)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*,  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%Symbol*, %mzone*, %mzone*}, {%Symbol*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
%arg_p_1 = getelementptr {%Symbol*, %mzone*, %mzone*}, {%Symbol*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%Symbol*, %mzone*, %mzone*}, {%Symbol*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1N5bWJvbCosU3ltYm9sKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)*,  %Symbol* (i8*, i8*, %Symbol*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase230 = hidden constant [38 x i8] c"Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0\00"
define dllexport fastcc void @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0__3281(i8* %_impz,i8* %_impenv, %Symbol* %sym) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3282 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}*
%Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}***, {i8*, i8*, void (i8*, i8*, %Symbol*)*}**** %Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr_

; setup arguments
%symPtr = alloca %Symbol*
store %Symbol* %sym, %Symbol** %symPtr


%val3283 = load %Symbol*, %Symbol** %symPtr
; tuple ref
%val3284 = getelementptr %Symbol, %Symbol* %val3283, i64 0, i32 1
%val3285 = load i8*, i8** %val3284
%val3286 = bitcast i8* %val3285 to i8*
call ccc void @free(i8* %val3286)
%val3288 = load %Symbol*, %Symbol** %symPtr
%val3289 = bitcast %Symbol* %val3288 to i8*
call ccc void @free(i8* %val3289)
ret void
}
@gsxtmbase231 = hidden constant [91 x i8] c"Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Symbol*)*}** @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3311 = load i8*, i8** %_impzPtr
%zone3312 = bitcast i8* %tzone3311 to %mzone*

; let assign value to symbol Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0
%dat_Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3312, i64 8)
%Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr = bitcast i8* %dat_Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}***
%tzone3292 = load i8*, i8** %_impzPtr
%zone3293 = bitcast i8* %tzone3292 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3293)
; malloc closure structure
%clsptr3294 = call i8* @llvm_zone_malloc(%mzone* %zone3293, i64 24)
%closure3295 = bitcast i8* %clsptr3294 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3296 = call i8* @llvm_zone_malloc(%mzone* %zone3293, i64 8)
%environment3297 = bitcast i8* %envptr3296 to {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3298 = call %clsvar* @new_address_table()
%var3299 = bitcast [38 x i8]* @gsxtmbase230 to i8*
%var3300 = bitcast [41 x i8]* @gsxtmbase225 to i8*
%addytable3301 = call %clsvar* @add_address_table(%mzone* %zone3293, i8* %var3299, i32 0, i8* %var3300, i32 3, %clsvar* %addytable3298)
%address-table3302 = bitcast %clsvar* %addytable3301 to i8*

; insert table, function and environment into closure struct
%closure.table3305 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3295, i32 0, i32 0
store i8* %address-table3302, i8** %closure.table3305
%closure.env3306 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3295, i32 0, i32 1
store i8* %envptr3296, i8** %closure.env3306
%closure.func3307 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3295, i32 0, i32 2
store void (i8*, i8*, %Symbol*)* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0__3281, void (i8*, i8*, %Symbol*)** %closure.func3307
%closure_size3308 = call i64 @llvm_zone_mark_size(%mzone* %zone3293)
call void @llvm_zone_ptr_set_size(i8* %clsptr3294, i64 %closure_size3308)
%wrapper_ptr3309 = call i8* @llvm_zone_malloc(%mzone* %zone3293, i64 8)
%closure_wrapper3310 = bitcast i8* %wrapper_ptr3309 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3295, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3310

; let value assignment
%Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3310, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3310
store { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0, { i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0
%tmp_envptr3304 = getelementptr {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}* %environment3297, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr, {i8*, i8*, void (i8*, i8*, %Symbol*)*}**** %tmp_envptr3304


%val3313 = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}**, {i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %val3313
}


@Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Symbol*)*}** @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret void
}


define dllexport ccc void @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret void
}


define dllexport ccc i8*  @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3314 = bitcast [91 x i8]* @gsxtmbase231 to i8*
call i32 (i8*, ...) @printf(i8* %var3314)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_free_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase232 = hidden constant [3 x i8] c"%s\00"
@gsxtmbase233 = hidden constant [32 x i8] c"print_adhoc_W3ZvaWQsU3ltYm9sKl0\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0__3315(i8* %_impz,i8* %_impenv, %Symbol* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3316 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}*
%print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}***, {i8*, i8*, void (i8*, i8*, %Symbol*)*}**** %print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr_

; setup arguments
%xPtr = alloca %Symbol*
store %Symbol* %x, %Symbol** %xPtr


%val3318 = load %Symbol*, %Symbol** %xPtr
%val3319 = icmp eq %Symbol* %val3318, null
br i1 %val3319, label %then3317, label %else3317

then3317:
%var3320 = bitcast [1 x i8]* @gsxtmbase89 to i8*

%val3321 = call i32 (i8*, ...) @printf(i8* %var3320)
ret void

else3317:
%var3323 = bitcast [3 x i8]* @gsxtmbase232 to i8*
%val3324 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3325 = getelementptr %Symbol, %Symbol* %val3324, i64 0, i32 1
%val3326 = load i8*, i8** %val3325

%val3327 = call i32 (i8*, ...) @printf(i8* %var3323, i8* %val3326)
ret void
}
@gsxtmbase234 = hidden constant [85 x i8] c"print_adhoc_W3ZvaWQsU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Symbol*)*}** @print_adhoc_W3ZvaWQsU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3348 = load i8*, i8** %_impzPtr
%zone3349 = bitcast i8* %tzone3348 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU3ltYm9sKl0
%dat_print_adhoc_W3ZvaWQsU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3349, i64 8)
%print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU3ltYm9sKl0 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}***
%tzone3329 = load i8*, i8** %_impzPtr
%zone3330 = bitcast i8* %tzone3329 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3330)
; malloc closure structure
%clsptr3331 = call i8* @llvm_zone_malloc(%mzone* %zone3330, i64 24)
%closure3332 = bitcast i8* %clsptr3331 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3333 = call i8* @llvm_zone_malloc(%mzone* %zone3330, i64 8)
%environment3334 = bitcast i8* %envptr3333 to {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3335 = call %clsvar* @new_address_table()
%var3336 = bitcast [32 x i8]* @gsxtmbase233 to i8*
%var3337 = bitcast [41 x i8]* @gsxtmbase225 to i8*
%addytable3338 = call %clsvar* @add_address_table(%mzone* %zone3330, i8* %var3336, i32 0, i8* %var3337, i32 3, %clsvar* %addytable3335)
%address-table3339 = bitcast %clsvar* %addytable3338 to i8*

; insert table, function and environment into closure struct
%closure.table3342 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3332, i32 0, i32 0
store i8* %address-table3339, i8** %closure.table3342
%closure.env3343 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3332, i32 0, i32 1
store i8* %envptr3333, i8** %closure.env3343
%closure.func3344 = getelementptr { i8*, i8*, void (i8*, i8*, %Symbol*)*}, { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3332, i32 0, i32 2
store void (i8*, i8*, %Symbol*)* @print_adhoc_W3ZvaWQsU3ltYm9sKl0__3315, void (i8*, i8*, %Symbol*)** %closure.func3344
%closure_size3345 = call i64 @llvm_zone_mark_size(%mzone* %zone3330)
call void @llvm_zone_ptr_set_size(i8* %clsptr3331, i64 %closure_size3345)
%wrapper_ptr3346 = call i8* @llvm_zone_malloc(%mzone* %zone3330, i64 8)
%closure_wrapper3347 = bitcast i8* %wrapper_ptr3346 to { i8*, i8*, void (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure3332, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3347

; let value assignment
%print_adhoc_W3ZvaWQsU3ltYm9sKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3347, { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_wrapper3347
store { i8*, i8*, void (i8*, i8*, %Symbol*)*}** %print_adhoc_W3ZvaWQsU3ltYm9sKl0, { i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU3ltYm9sKl0
%tmp_envptr3341 = getelementptr {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, void (i8*, i8*, %Symbol*)*}***}* %environment3334, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr, {i8*, i8*, void (i8*, i8*, %Symbol*)*}**** %tmp_envptr3341


%val3350 = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}**, {i8*, i8*, void (i8*, i8*, %Symbol*)*}*** %print_adhoc_W3ZvaWQsU3ltYm9sKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %val3350
}


@print_adhoc_W3ZvaWQsU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Symbol*)*}** @print_adhoc_W3ZvaWQsU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3351 = bitcast [85 x i8]* @gsxtmbase234 to i8*
call i32 (i8*, ...) @printf(i8* %var3351)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Symbol*)*}*, {i8*, i8*, void (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Symbol*)*}, {i8*, i8*, void (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Symbol*)*,  void (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase235 = hidden constant [39 x i8] c"toString_adhoc_W1N0cmluZyosU3ltYm9sKl0\00"
@gsxtmbase236 = hidden constant [45 x i8] c"{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0__3352(i8* %_impz,i8* %_impenv, %Symbol* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3353 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***}*
%toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**** %toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr_

; setup arguments
%xPtr = alloca %Symbol*
store %Symbol* %x, %Symbol** %xPtr


%val3354 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3355 = getelementptr %Symbol, %Symbol* %val3354, i64 0, i32 0
%val3356 = load i64, i64* %val3355
%val3357 = load %Symbol*, %Symbol** %xPtr
; tuple ref
%val3358 = getelementptr %Symbol, %Symbol* %val3357, i64 0, i32 1
%val3359 = load i8*, i8** %val3358
%res3360 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTY0LGk4Kl0(i64 %val3356, i8* %val3359)
ret %String* %res3360
}
@gsxtmbase237 = hidden constant [92 x i8] c"toString_adhoc_W1N0cmluZyosU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3380 = load i8*, i8** %_impzPtr
%zone3381 = bitcast i8* %tzone3380 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosU3ltYm9sKl0
%dat_toString_adhoc_W1N0cmluZyosU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3381, i64 8)
%toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosU3ltYm9sKl0 to { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***
%tzone3361 = load i8*, i8** %_impzPtr
%zone3362 = bitcast i8* %tzone3361 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3362)
; malloc closure structure
%clsptr3363 = call i8* @llvm_zone_malloc(%mzone* %zone3362, i64 24)
%closure3364 = bitcast i8* %clsptr3363 to { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3365 = call i8* @llvm_zone_malloc(%mzone* %zone3362, i64 8)
%environment3366 = bitcast i8* %envptr3365 to {{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3367 = call %clsvar* @new_address_table()
%var3368 = bitcast [39 x i8]* @gsxtmbase235 to i8*
%var3369 = bitcast [45 x i8]* @gsxtmbase236 to i8*
%addytable3370 = call %clsvar* @add_address_table(%mzone* %zone3362, i8* %var3368, i32 0, i8* %var3369, i32 3, %clsvar* %addytable3367)
%address-table3371 = bitcast %clsvar* %addytable3370 to i8*

; insert table, function and environment into closure struct
%closure.table3374 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure3364, i32 0, i32 0
store i8* %address-table3371, i8** %closure.table3374
%closure.env3375 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure3364, i32 0, i32 1
store i8* %envptr3365, i8** %closure.env3375
%closure.func3376 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure3364, i32 0, i32 2
store %String* (i8*, i8*, %Symbol*)* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0__3352, %String* (i8*, i8*, %Symbol*)** %closure.func3376
%closure_size3377 = call i64 @llvm_zone_mark_size(%mzone* %zone3362)
call void @llvm_zone_ptr_set_size(i8* %clsptr3363, i64 %closure_size3377)
%wrapper_ptr3378 = call i8* @llvm_zone_malloc(%mzone* %zone3362, i64 8)
%closure_wrapper3379 = bitcast i8* %wrapper_ptr3378 to { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure3364, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_wrapper3379

; let value assignment
%toString_adhoc_W1N0cmluZyosU3ltYm9sKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_wrapper3379, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_wrapper3379
store { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %toString_adhoc_W1N0cmluZyosU3ltYm9sKl0, { i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*** %toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosU3ltYm9sKl0
%tmp_envptr3373 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Symbol*)*}***}* %environment3366, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*** %toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**** %tmp_envptr3373


%val3382 = load {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*** %toString_adhoc_W1N0cmluZyosU3ltYm9sKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %val3382
}


@toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Symbol*)*,  %String* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Symbol*)*,  %String* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3383 = bitcast [92 x i8]* @gsxtmbase237 to i8*
call i32 (i8*, ...) @printf(i8* %var3383)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Symbol*)*,  %String* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %String* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Symbol*)*,  %String* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase238 = hidden constant [32 x i8] c"length_adhoc_W2k2NCxTeW1ib2wqXQ\00"
@gsxtmbase239 = hidden constant [40 x i8] c"{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**\00"
define dllexport fastcc i64 @length_adhoc_W2k2NCxTeW1ib2wqXQ__3384(i8* %_impz,i8* %_impenv, %Symbol* %sym) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3385 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}*
%length_adhoc_W2k2NCxTeW1ib2wqXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%length_adhoc_W2k2NCxTeW1ib2wqXQPtr = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**** %length_adhoc_W2k2NCxTeW1ib2wqXQPtr_

; setup arguments
%symPtr = alloca %Symbol*
store %Symbol* %sym, %Symbol** %symPtr


%val3386 = load %Symbol*, %Symbol** %symPtr
; tuple ref
%val3387 = getelementptr %Symbol, %Symbol* %val3386, i64 0, i32 1
%val3388 = load i8*, i8** %val3387
%res3389 = call ccc i64 @strlen(i8* %val3388)
ret i64 %res3389
}
@gsxtmbase240 = hidden constant [85 x i8] c"length_adhoc_W2k2NCxTeW1ib2wqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** @length_adhoc_W2k2NCxTeW1ib2wqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3409 = load i8*, i8** %_impzPtr
%zone3410 = bitcast i8* %tzone3409 to %mzone*

; let assign value to symbol length_adhoc_W2k2NCxTeW1ib2wqXQ
%dat_length_adhoc_W2k2NCxTeW1ib2wqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3410, i64 8)
%length_adhoc_W2k2NCxTeW1ib2wqXQPtr = bitcast i8* %dat_length_adhoc_W2k2NCxTeW1ib2wqXQ to { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***
%tzone3390 = load i8*, i8** %_impzPtr
%zone3391 = bitcast i8* %tzone3390 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3391)
; malloc closure structure
%clsptr3392 = call i8* @llvm_zone_malloc(%mzone* %zone3391, i64 24)
%closure3393 = bitcast i8* %clsptr3392 to { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3394 = call i8* @llvm_zone_malloc(%mzone* %zone3391, i64 8)
%environment3395 = bitcast i8* %envptr3394 to {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3396 = call %clsvar* @new_address_table()
%var3397 = bitcast [32 x i8]* @gsxtmbase238 to i8*
%var3398 = bitcast [40 x i8]* @gsxtmbase239 to i8*
%addytable3399 = call %clsvar* @add_address_table(%mzone* %zone3391, i8* %var3397, i32 0, i8* %var3398, i32 3, %clsvar* %addytable3396)
%address-table3400 = bitcast %clsvar* %addytable3399 to i8*

; insert table, function and environment into closure struct
%closure.table3403 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3393, i32 0, i32 0
store i8* %address-table3400, i8** %closure.table3403
%closure.env3404 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3393, i32 0, i32 1
store i8* %envptr3394, i8** %closure.env3404
%closure.func3405 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3393, i32 0, i32 2
store i64 (i8*, i8*, %Symbol*)* @length_adhoc_W2k2NCxTeW1ib2wqXQ__3384, i64 (i8*, i8*, %Symbol*)** %closure.func3405
%closure_size3406 = call i64 @llvm_zone_mark_size(%mzone* %zone3391)
call void @llvm_zone_ptr_set_size(i8* %clsptr3392, i64 %closure_size3406)
%wrapper_ptr3407 = call i8* @llvm_zone_malloc(%mzone* %zone3391, i64 8)
%closure_wrapper3408 = bitcast i8* %wrapper_ptr3407 to { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3393, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_wrapper3408

; let value assignment
%length_adhoc_W2k2NCxTeW1ib2wqXQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_wrapper3408, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_wrapper3408
store { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %length_adhoc_W2k2NCxTeW1ib2wqXQ, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*** %length_adhoc_W2k2NCxTeW1ib2wqXQPtr

; add data to environment
; don't need to alloc for env var length_adhoc_W2k2NCxTeW1ib2wqXQ
%tmp_envptr3402 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}* %environment3395, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*** %length_adhoc_W2k2NCxTeW1ib2wqXQPtr, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**** %tmp_envptr3402


%val3411 = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*** %length_adhoc_W2k2NCxTeW1ib2wqXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %val3411
}


@length_adhoc_W2k2NCxTeW1ib2wqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@length_adhoc_W2k2NCxTeW1ib2wqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @length_adhoc_W2k2NCxTeW1ib2wqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** @length_adhoc_W2k2NCxTeW1ib2wqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @length_adhoc_W2k2NCxTeW1ib2wqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @length_adhoc_W2k2NCxTeW1ib2wqXQ(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @length_adhoc_W2k2NCxTeW1ib2wqXQ_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @length_adhoc_W2k2NCxTeW1ib2wqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3412 = bitcast [85 x i8]* @gsxtmbase240 to i8*
call i32 (i8*, ...) @printf(i8* %var3412)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @length_adhoc_W2k2NCxTeW1ib2wqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @length_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase241 = hidden constant [30 x i8] c"size_adhoc_W2k2NCxTeW1ib2wqXQ\00"
define dllexport fastcc i64 @size_adhoc_W2k2NCxTeW1ib2wqXQ__3413(i8* %_impz,i8* %_impenv, %Symbol* %sym) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3414 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}*
%size_adhoc_W2k2NCxTeW1ib2wqXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%size_adhoc_W2k2NCxTeW1ib2wqXQPtr = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**** %size_adhoc_W2k2NCxTeW1ib2wqXQPtr_

; setup arguments
%symPtr = alloca %Symbol*
store %Symbol* %sym, %Symbol** %symPtr


%val3415 = load %Symbol*, %Symbol** %symPtr
; tuple ref
%val3416 = getelementptr %Symbol, %Symbol* %val3415, i64 0, i32 0
%val3417 = load i64, i64* %val3416
ret i64 %val3417
}
@gsxtmbase242 = hidden constant [83 x i8] c"size_adhoc_W2k2NCxTeW1ib2wqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** @size_adhoc_W2k2NCxTeW1ib2wqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3437 = load i8*, i8** %_impzPtr
%zone3438 = bitcast i8* %tzone3437 to %mzone*

; let assign value to symbol size_adhoc_W2k2NCxTeW1ib2wqXQ
%dat_size_adhoc_W2k2NCxTeW1ib2wqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3438, i64 8)
%size_adhoc_W2k2NCxTeW1ib2wqXQPtr = bitcast i8* %dat_size_adhoc_W2k2NCxTeW1ib2wqXQ to { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***
%tzone3418 = load i8*, i8** %_impzPtr
%zone3419 = bitcast i8* %tzone3418 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3419)
; malloc closure structure
%clsptr3420 = call i8* @llvm_zone_malloc(%mzone* %zone3419, i64 24)
%closure3421 = bitcast i8* %clsptr3420 to { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3422 = call i8* @llvm_zone_malloc(%mzone* %zone3419, i64 8)
%environment3423 = bitcast i8* %envptr3422 to {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3424 = call %clsvar* @new_address_table()
%var3425 = bitcast [30 x i8]* @gsxtmbase241 to i8*
%var3426 = bitcast [40 x i8]* @gsxtmbase239 to i8*
%addytable3427 = call %clsvar* @add_address_table(%mzone* %zone3419, i8* %var3425, i32 0, i8* %var3426, i32 3, %clsvar* %addytable3424)
%address-table3428 = bitcast %clsvar* %addytable3427 to i8*

; insert table, function and environment into closure struct
%closure.table3431 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3421, i32 0, i32 0
store i8* %address-table3428, i8** %closure.table3431
%closure.env3432 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3421, i32 0, i32 1
store i8* %envptr3422, i8** %closure.env3432
%closure.func3433 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3421, i32 0, i32 2
store i64 (i8*, i8*, %Symbol*)* @size_adhoc_W2k2NCxTeW1ib2wqXQ__3413, i64 (i8*, i8*, %Symbol*)** %closure.func3433
%closure_size3434 = call i64 @llvm_zone_mark_size(%mzone* %zone3419)
call void @llvm_zone_ptr_set_size(i8* %clsptr3420, i64 %closure_size3434)
%wrapper_ptr3435 = call i8* @llvm_zone_malloc(%mzone* %zone3419, i64 8)
%closure_wrapper3436 = bitcast i8* %wrapper_ptr3435 to { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure3421, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_wrapper3436

; let value assignment
%size_adhoc_W2k2NCxTeW1ib2wqXQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_wrapper3436, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_wrapper3436
store { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %size_adhoc_W2k2NCxTeW1ib2wqXQ, { i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*** %size_adhoc_W2k2NCxTeW1ib2wqXQPtr

; add data to environment
; don't need to alloc for env var size_adhoc_W2k2NCxTeW1ib2wqXQ
%tmp_envptr3430 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Symbol*)*}***}* %environment3423, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*** %size_adhoc_W2k2NCxTeW1ib2wqXQPtr, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**** %tmp_envptr3430


%val3439 = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*** %size_adhoc_W2k2NCxTeW1ib2wqXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %val3439
}


@size_adhoc_W2k2NCxTeW1ib2wqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@size_adhoc_W2k2NCxTeW1ib2wqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @size_adhoc_W2k2NCxTeW1ib2wqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** @size_adhoc_W2k2NCxTeW1ib2wqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @size_adhoc_W2k2NCxTeW1ib2wqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @size_adhoc_W2k2NCxTeW1ib2wqXQ(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @size_adhoc_W2k2NCxTeW1ib2wqXQ_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @size_adhoc_W2k2NCxTeW1ib2wqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3440 = bitcast [83 x i8]* @gsxtmbase242 to i8*
call i32 (i8*, ...) @printf(i8* %var3440)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @size_adhoc_W2k2NCxTeW1ib2wqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}, {i8*, i8*, i64 (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Symbol*)*,  i64 (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase243 = hidden constant [33 x i8] c"cstring_adhoc_W2k4KixTeW1ib2wqXQ\00"
@gsxtmbase244 = hidden constant [40 x i8] c"{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**\00"
define dllexport fastcc i8* @cstring_adhoc_W2k4KixTeW1ib2wqXQ__3441(i8* %_impz,i8* %_impenv, %Symbol* %sym) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3442 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***}*
%cstring_adhoc_W2k4KixTeW1ib2wqXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%cstring_adhoc_W2k4KixTeW1ib2wqXQPtr = load {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**** %cstring_adhoc_W2k4KixTeW1ib2wqXQPtr_

; setup arguments
%symPtr = alloca %Symbol*
store %Symbol* %sym, %Symbol** %symPtr


%val3443 = load %Symbol*, %Symbol** %symPtr
; tuple ref
%val3444 = getelementptr %Symbol, %Symbol* %val3443, i64 0, i32 1
%val3445 = load i8*, i8** %val3444
ret i8* %val3445
}
@gsxtmbase245 = hidden constant [86 x i8] c"cstring_adhoc_W2k4KixTeW1ib2wqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** @cstring_adhoc_W2k4KixTeW1ib2wqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3465 = load i8*, i8** %_impzPtr
%zone3466 = bitcast i8* %tzone3465 to %mzone*

; let assign value to symbol cstring_adhoc_W2k4KixTeW1ib2wqXQ
%dat_cstring_adhoc_W2k4KixTeW1ib2wqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3466, i64 8)
%cstring_adhoc_W2k4KixTeW1ib2wqXQPtr = bitcast i8* %dat_cstring_adhoc_W2k4KixTeW1ib2wqXQ to { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***
%tzone3446 = load i8*, i8** %_impzPtr
%zone3447 = bitcast i8* %tzone3446 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3447)
; malloc closure structure
%clsptr3448 = call i8* @llvm_zone_malloc(%mzone* %zone3447, i64 24)
%closure3449 = bitcast i8* %clsptr3448 to { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3450 = call i8* @llvm_zone_malloc(%mzone* %zone3447, i64 8)
%environment3451 = bitcast i8* %envptr3450 to {{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3452 = call %clsvar* @new_address_table()
%var3453 = bitcast [33 x i8]* @gsxtmbase243 to i8*
%var3454 = bitcast [40 x i8]* @gsxtmbase244 to i8*
%addytable3455 = call %clsvar* @add_address_table(%mzone* %zone3447, i8* %var3453, i32 0, i8* %var3454, i32 3, %clsvar* %addytable3452)
%address-table3456 = bitcast %clsvar* %addytable3455 to i8*

; insert table, function and environment into closure struct
%closure.table3459 = getelementptr { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure3449, i32 0, i32 0
store i8* %address-table3456, i8** %closure.table3459
%closure.env3460 = getelementptr { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure3449, i32 0, i32 1
store i8* %envptr3450, i8** %closure.env3460
%closure.func3461 = getelementptr { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure3449, i32 0, i32 2
store i8* (i8*, i8*, %Symbol*)* @cstring_adhoc_W2k4KixTeW1ib2wqXQ__3441, i8* (i8*, i8*, %Symbol*)** %closure.func3461
%closure_size3462 = call i64 @llvm_zone_mark_size(%mzone* %zone3447)
call void @llvm_zone_ptr_set_size(i8* %clsptr3448, i64 %closure_size3462)
%wrapper_ptr3463 = call i8* @llvm_zone_malloc(%mzone* %zone3447, i64 8)
%closure_wrapper3464 = bitcast i8* %wrapper_ptr3463 to { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure3449, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_wrapper3464

; let value assignment
%cstring_adhoc_W2k4KixTeW1ib2wqXQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_wrapper3464, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_wrapper3464
store { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %cstring_adhoc_W2k4KixTeW1ib2wqXQ, { i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*** %cstring_adhoc_W2k4KixTeW1ib2wqXQPtr

; add data to environment
; don't need to alloc for env var cstring_adhoc_W2k4KixTeW1ib2wqXQ
%tmp_envptr3458 = getelementptr {{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %Symbol*)*}***}* %environment3451, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*** %cstring_adhoc_W2k4KixTeW1ib2wqXQPtr, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**** %tmp_envptr3458


%val3467 = load {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*** %cstring_adhoc_W2k4KixTeW1ib2wqXQPtr
ret {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %val3467
}


@cstring_adhoc_W2k4KixTeW1ib2wqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@cstring_adhoc_W2k4KixTeW1ib2wqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @cstring_adhoc_W2k4KixTeW1ib2wqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** @cstring_adhoc_W2k4KixTeW1ib2wqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @cstring_adhoc_W2k4KixTeW1ib2wqXQ(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %Symbol*)*,  i8* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret i8* %result
}


define dllexport ccc i8* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %Symbol*)*,  i8* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @cstring_adhoc_W2k4KixTeW1ib2wqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3468 = bitcast [86 x i8]* @gsxtmbase245 to i8*
call i32 (i8*, ...) @printf(i8* %var3468)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %Symbol*)*,  i8* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @cstring_adhoc_W2k4KixTeW1ib2wqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cstring_adhoc_W2k4KixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}, {i8*, i8*, i8* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %Symbol*)*,  i8* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase246 = hidden constant [32 x i8] c"Symbol_adhoc_W1N5bWJvbCosaTgqXQ\00"
@gsxtmbase247 = hidden constant [40 x i8] c"{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**\00"
define dllexport fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ__3469(i8* %_impz,i8* %_impenv, i8* %s) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3470 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***}*
%Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr = load {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**** %Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr_

; setup arguments
%sPtr = alloca i8*
store i8* %s, i8** %sPtr


%tzone3473 = load i8*, i8** %_impzPtr
%zone3474 = bitcast i8* %tzone3473 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%tzone3478 = load i8*, i8** %_impzPtr
%zone3479 = bitcast i8* %tzone3478 to %mzone*

; let assign value to symbol str
%strPtr = alloca %Symbol*
%val3471 = load i8*, i8** %sPtr
%res3472 = call ccc i64 @strlen(i8* %val3471)

; let value assignment
%len = select i1 true, i64 %res3472, i64 %res3472
store i64 %len, i64* %lenPtr

%val3475 = load i64, i64* %lenPtr
%val3476 = load i8*, i8** %sPtr
%res3477 = call fastcc %Symbol* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0(i64 %val3475, i8* %val3476)

; let value assignment
%str = select i1 true, %Symbol* %res3477, %Symbol* %res3477
store %Symbol* %str, %Symbol** %strPtr

%val3480 = load %Symbol*, %Symbol** %strPtr
ret %Symbol* %val3480
}
@gsxtmbase248 = hidden constant [85 x i8] c"Symbol_adhoc_W1N5bWJvbCosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3500 = load i8*, i8** %_impzPtr
%zone3501 = bitcast i8* %tzone3500 to %mzone*

; let assign value to symbol Symbol_adhoc_W1N5bWJvbCosaTgqXQ
%dat_Symbol_adhoc_W1N5bWJvbCosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3501, i64 8)
%Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr = bitcast i8* %dat_Symbol_adhoc_W1N5bWJvbCosaTgqXQ to { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***
%tzone3481 = load i8*, i8** %_impzPtr
%zone3482 = bitcast i8* %tzone3481 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3482)
; malloc closure structure
%clsptr3483 = call i8* @llvm_zone_malloc(%mzone* %zone3482, i64 24)
%closure3484 = bitcast i8* %clsptr3483 to { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3485 = call i8* @llvm_zone_malloc(%mzone* %zone3482, i64 8)
%environment3486 = bitcast i8* %envptr3485 to {{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3487 = call %clsvar* @new_address_table()
%var3488 = bitcast [32 x i8]* @gsxtmbase246 to i8*
%var3489 = bitcast [40 x i8]* @gsxtmbase247 to i8*
%addytable3490 = call %clsvar* @add_address_table(%mzone* %zone3482, i8* %var3488, i32 0, i8* %var3489, i32 3, %clsvar* %addytable3487)
%address-table3491 = bitcast %clsvar* %addytable3490 to i8*

; insert table, function and environment into closure struct
%closure.table3494 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure3484, i32 0, i32 0
store i8* %address-table3491, i8** %closure.table3494
%closure.env3495 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure3484, i32 0, i32 1
store i8* %envptr3485, i8** %closure.env3495
%closure.func3496 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure3484, i32 0, i32 2
store %Symbol* (i8*, i8*, i8*)* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ__3469, %Symbol* (i8*, i8*, i8*)** %closure.func3496
%closure_size3497 = call i64 @llvm_zone_mark_size(%mzone* %zone3482)
call void @llvm_zone_ptr_set_size(i8* %clsptr3483, i64 %closure_size3497)
%wrapper_ptr3498 = call i8* @llvm_zone_malloc(%mzone* %zone3482, i64 8)
%closure_wrapper3499 = bitcast i8* %wrapper_ptr3498 to { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure3484, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_wrapper3499

; let value assignment
%Symbol_adhoc_W1N5bWJvbCosaTgqXQ = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_wrapper3499, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_wrapper3499
store { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %Symbol_adhoc_W1N5bWJvbCosaTgqXQ, { i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*** %Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr

; add data to environment
; don't need to alloc for env var Symbol_adhoc_W1N5bWJvbCosaTgqXQ
%tmp_envptr3493 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, i8*)*}***}* %environment3486, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*** %Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**** %tmp_envptr3493


%val3502 = load {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*** %Symbol_adhoc_W1N5bWJvbCosaTgqXQPtr
ret {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %val3502
}


@Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i8*)*,  %Symbol* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i8*)*,  %Symbol* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %Symbol* %result
}


define dllexport ccc i8*  @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3503 = bitcast [85 x i8]* @gsxtmbase248 to i8*
call i32 (i8*, ...) @printf(i8* %var3503)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i8*)*,  %Symbol* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}, {i8*, i8*, %Symbol* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, i8*)*,  %Symbol* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase249 = hidden constant [37 x i8] c"Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0\00"
define dllexport fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0__3504(i8* %_impz,i8* %_impenv, %Symbol* %str) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3505 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}*
%Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**** %Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr_

; setup arguments
%strPtr = alloca %Symbol*
store %Symbol* %str, %Symbol** %strPtr


%tzone3508 = load i8*, i8** %_impzPtr
%zone3509 = bitcast i8* %tzone3508 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%tzone3514 = load i8*, i8** %_impzPtr
%zone3515 = bitcast i8* %tzone3514 to %mzone*

; let assign value to symbol new_str
%new_strPtr = alloca %Symbol*
%val3506 = load %Symbol*, %Symbol** %strPtr
%res3507 = call fastcc i64 @length_adhoc_W2k2NCxTeW1ib2wqXQ(%Symbol* %val3506)

; let value assignment
%len = select i1 true, i64 %res3507, i64 %res3507
store i64 %len, i64* %lenPtr

%val3510 = load i64, i64* %lenPtr
%val3511 = load %Symbol*, %Symbol** %strPtr
%res3512 = call fastcc i8* @cstring_adhoc_W2k4KixTeW1ib2wqXQ(%Symbol* %val3511)
%res3513 = call fastcc %Symbol* @Symbol_z_adhoc_W1N5bWJvbCosaTY0LGk4Kl0(i64 %val3510, i8* %res3512)

; let value assignment
%new_str = select i1 true, %Symbol* %res3513, %Symbol* %res3513
store %Symbol* %new_str, %Symbol** %new_strPtr

%val3516 = load %Symbol*, %Symbol** %new_strPtr
ret %Symbol* %val3516
}
@gsxtmbase250 = hidden constant [90 x i8] c"Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3536 = load i8*, i8** %_impzPtr
%zone3537 = bitcast i8* %tzone3536 to %mzone*

; let assign value to symbol Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0
%dat_Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3537, i64 8)
%Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr = bitcast i8* %dat_Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***
%tzone3517 = load i8*, i8** %_impzPtr
%zone3518 = bitcast i8* %tzone3517 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3518)
; malloc closure structure
%clsptr3519 = call i8* @llvm_zone_malloc(%mzone* %zone3518, i64 24)
%closure3520 = bitcast i8* %clsptr3519 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*

; malloc environment structure
%envptr3521 = call i8* @llvm_zone_malloc(%mzone* %zone3518, i64 8)
%environment3522 = bitcast i8* %envptr3521 to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}*

; malloc closure address table
%addytable3523 = call %clsvar* @new_address_table()
%var3524 = bitcast [37 x i8]* @gsxtmbase249 to i8*
%var3525 = bitcast [45 x i8]* @gsxtmbase222 to i8*
%addytable3526 = call %clsvar* @add_address_table(%mzone* %zone3518, i8* %var3524, i32 0, i8* %var3525, i32 3, %clsvar* %addytable3523)
%address-table3527 = bitcast %clsvar* %addytable3526 to i8*

; insert table, function and environment into closure struct
%closure.table3530 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3520, i32 0, i32 0
store i8* %address-table3527, i8** %closure.table3530
%closure.env3531 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3520, i32 0, i32 1
store i8* %envptr3521, i8** %closure.env3531
%closure.func3532 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3520, i32 0, i32 2
store %Symbol* (i8*, i8*, %Symbol*)* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0__3504, %Symbol* (i8*, i8*, %Symbol*)** %closure.func3532
%closure_size3533 = call i64 @llvm_zone_mark_size(%mzone* %zone3518)
call void @llvm_zone_ptr_set_size(i8* %clsptr3519, i64 %closure_size3533)
%wrapper_ptr3534 = call i8* @llvm_zone_malloc(%mzone* %zone3518, i64 8)
%closure_wrapper3535 = bitcast i8* %wrapper_ptr3534 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure3520, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_wrapper3535

; let value assignment
%Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0 = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_wrapper3535, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_wrapper3535
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*** %Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0
%tmp_envptr3529 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}***}* %environment3522, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*** %Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**** %tmp_envptr3529


%val3538 = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*** %Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0Ptr
ret {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %val3538
}


@Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_native(%Symbol* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
ret %Symbol* %result
}


define dllexport ccc i8*  @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3539 = bitcast [90 x i8]* @gsxtmbase250 to i8*
call i32 (i8*, ...) @printf(i8* %var3539)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*}*
%arg_p_0 = getelementptr {%Symbol*}, {%Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase251 = hidden constant [40 x i8] c"equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0\00"
@gsxtmbase252 = hidden constant [49 x i8] c"{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**\00"
define dllexport fastcc i1 @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0__3540(i8* %_impz,i8* %_impenv, %Symbol* %s1, %Symbol* %s2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3541 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***}*
%equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr = load {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**** %equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr_

; setup arguments
%s1Ptr = alloca %Symbol*
store %Symbol* %s1, %Symbol** %s1Ptr
%s2Ptr = alloca %Symbol*
store %Symbol* %s2, %Symbol** %s2Ptr


%val3543 = load %Symbol*, %Symbol** %s1Ptr
; tuple ref
%val3544 = getelementptr %Symbol, %Symbol* %val3543, i64 0, i32 1
%val3545 = load i8*, i8** %val3544
%val3546 = load %Symbol*, %Symbol** %s2Ptr
; tuple ref
%val3547 = getelementptr %Symbol, %Symbol* %val3546, i64 0, i32 1
%val3548 = load i8*, i8** %val3547
%res3549 = call ccc i32 @strcmp(i8* %val3545, i8* %val3548)
%cmp3550 = icmp eq i32 %res3549, 0
br i1 %cmp3550, label %then3542, label %else3542

then3542:
%val3551 = trunc i64 1 to i1
ret i1 %val3551

else3542:
%val3552 = trunc i64 0 to i1
ret i1 %val3552
}
@gsxtmbase253 = hidden constant [93 x i8] c"equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3572 = load i8*, i8** %_impzPtr
%zone3573 = bitcast i8* %tzone3572 to %mzone*

; let assign value to symbol equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0
%dat_equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3573, i64 8)
%equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr = bitcast i8* %dat_equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0 to { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***
%tzone3553 = load i8*, i8** %_impzPtr
%zone3554 = bitcast i8* %tzone3553 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3554)
; malloc closure structure
%clsptr3555 = call i8* @llvm_zone_malloc(%mzone* %zone3554, i64 24)
%closure3556 = bitcast i8* %clsptr3555 to { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*

; malloc environment structure
%envptr3557 = call i8* @llvm_zone_malloc(%mzone* %zone3554, i64 8)
%environment3558 = bitcast i8* %envptr3557 to {{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***}*

; malloc closure address table
%addytable3559 = call %clsvar* @new_address_table()
%var3560 = bitcast [40 x i8]* @gsxtmbase251 to i8*
%var3561 = bitcast [49 x i8]* @gsxtmbase252 to i8*
%addytable3562 = call %clsvar* @add_address_table(%mzone* %zone3554, i8* %var3560, i32 0, i8* %var3561, i32 3, %clsvar* %addytable3559)
%address-table3563 = bitcast %clsvar* %addytable3562 to i8*

; insert table, function and environment into closure struct
%closure.table3566 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3556, i32 0, i32 0
store i8* %address-table3563, i8** %closure.table3566
%closure.env3567 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3556, i32 0, i32 1
store i8* %envptr3557, i8** %closure.env3567
%closure.func3568 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3556, i32 0, i32 2
store i1 (i8*, i8*, %Symbol*, %Symbol*)* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0__3540, i1 (i8*, i8*, %Symbol*, %Symbol*)** %closure.func3568
%closure_size3569 = call i64 @llvm_zone_mark_size(%mzone* %zone3554)
call void @llvm_zone_ptr_set_size(i8* %clsptr3555, i64 %closure_size3569)
%wrapper_ptr3570 = call i8* @llvm_zone_malloc(%mzone* %zone3554, i64 8)
%closure_wrapper3571 = bitcast i8* %wrapper_ptr3570 to { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**
store { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3556, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_wrapper3571

; let value assignment
%equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_wrapper3571, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_wrapper3571
store { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0, { i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*** %equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr

; add data to environment
; don't need to alloc for env var equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0
%tmp_envptr3565 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}***}* %environment3558, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*** %equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**** %tmp_envptr3565


%val3574 = load {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*** %equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %val3574
}


@equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var = dllexport global [1 x i8*] [ i8* null ]

@equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0(%Symbol* %arg_0,%Symbol* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Symbol*, %Symbol*)*,  i1 (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
ret i1 %result
}


define dllexport ccc i1 @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_native(%Symbol* %arg_0,%Symbol* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Symbol*, %Symbol*)*,  i1 (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
ret i1 %result
}


define dllexport ccc i8*  @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3575 = bitcast [93 x i8]* @gsxtmbase253 to i8*
call i32 (i8*, ...) @printf(i8* %var3575)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3576 = bitcast [93 x i8]* @gsxtmbase253 to i8*
call i32 (i8*, ...) @printf(i8* %var3576)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Symbol*, %Symbol*)*,  i1 (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*, %Symbol*}*
%arg_p_0 = getelementptr {%Symbol*, %Symbol*}, {%Symbol*, %Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
%arg_p_1 = getelementptr {%Symbol*, %Symbol*}, {%Symbol*, %Symbol*}* %fstruct, i32 0, i32 1
%arg_1 = load %Symbol*, %Symbol** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @equal_adhoc_W2kxLFN5bWJvbCosU3ltYm9sKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, i1 (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Symbol*, %Symbol*)*,  i1 (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmbase254 = hidden constant [46 x i8] c"cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ\00"
@gsxtmbase255 = hidden constant [55 x i8] c"{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**\00"
define dllexport fastcc %Symbol* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ__3577(i8* %_impz,i8* %_impenv, %Symbol* %s1, %Symbol* %s2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3578 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***}*
%cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr_ = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***}* %impenv, i32 0, i32 0
%cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**** %cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr_

; setup arguments
%s1Ptr = alloca %Symbol*
store %Symbol* %s1, %Symbol** %s1Ptr
%s2Ptr = alloca %Symbol*
store %Symbol* %s2, %Symbol** %s2Ptr


%val3580 = load %Symbol*, %Symbol** %s2Ptr
%val3581 = icmp eq %Symbol* %val3580, null
br i1 %val3581, label %then3579, label %else3579

then3579:
%val3582 = load %Symbol*, %Symbol** %s1Ptr
%res3583 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0(%Symbol* %val3582)
ret %Symbol* %res3583

else3579:
%val3585 = load %Symbol*, %Symbol** %s1Ptr
%val3586 = icmp eq %Symbol* %val3585, null
br i1 %val3586, label %then3584, label %else3584

then3584:
%val3587 = load %Symbol*, %Symbol** %s2Ptr
%res3588 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosU3ltYm9sKl0(%Symbol* %val3587)
ret %Symbol* %res3588

else3584:
%tzone3596 = load i8*, i8** %_impzPtr
%zone3597 = bitcast i8* %tzone3596 to %mzone*

; let assign value to symbol size_s_1
%size_s_1Ptr = alloca i64
%tzone3606 = load i8*, i8** %_impzPtr
%zone3607 = bitcast i8* %tzone3606 to %mzone*

; let assign value to symbol news
%newsPtr = alloca i8*
%val3589 = load %Symbol*, %Symbol** %s1Ptr
; tuple ref
%val3590 = getelementptr %Symbol, %Symbol* %val3589, i64 0, i32 0
%val3591 = load i64, i64* %val3590
%val3592 = load %Symbol*, %Symbol** %s2Ptr
; tuple ref
%val3593 = getelementptr %Symbol, %Symbol* %val3592, i64 0, i32 0
%val3594 = load i64, i64* %val3593
%val3595 = add i64 %val3591, %val3594

; let value assignment
%size_s_1 = select i1 true, i64 %val3595, i64 %val3595
store i64 %size_s_1, i64* %size_s_1Ptr

%val3598 = load i64, i64* %size_s_1Ptr
%val3599 = add i64 1, %val3598
%val3600 = getelementptr i64, i64* null, i32 1
%zonesize3601 = mul i64 1, %val3599
%tzone3602 = load i8*, i8** %_impzPtr
%zone3603 = bitcast i8* %tzone3602 to %mzone*
%dat3604 = call i8* @llvm_zone_malloc(%mzone* %zone3603, i64 %zonesize3601)
call i8* @memset(i8* %dat3604, i32 0, i64 %zonesize3601)
%val3605 = bitcast i8* %dat3604 to i8*

; let value assignment
%news = select i1 true, i8* %val3605, i8* %val3605
store i8* %news, i8** %newsPtr

%val3608 = load i8*, i8** %newsPtr
%val3609 = load %Symbol*, %Symbol** %s1Ptr
; tuple ref
%val3610 = getelementptr %Symbol, %Symbol* %val3609, i64 0, i32 1
%val3611 = load i8*, i8** %val3610
%res3612 = call ccc i8* @strcpy(i8* %val3608, i8* %val3611)
%val3613 = load i8*, i8** %newsPtr
%val3614 = load %Symbol*, %Symbol** %s2Ptr
; tuple ref
%val3615 = getelementptr %Symbol, %Symbol* %val3614, i64 0, i32 1
%val3616 = load i8*, i8** %val3615
%val3617 = load i64, i64* %size_s_1Ptr
%res3618 = call ccc i8* @strncat(i8* %val3613, i8* %val3616, i64 %val3617)
%val3619 = load i8*, i8** %newsPtr
%res3620 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %val3619)
ret %Symbol* %res3620
}
@gsxtmbase256 = hidden constant [99 x i8] c"cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3640 = load i8*, i8** %_impzPtr
%zone3641 = bitcast i8* %tzone3640 to %mzone*

; let assign value to symbol cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ
%dat_cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3641, i64 8)
%cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr = bitcast i8* %dat_cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***
%tzone3621 = load i8*, i8** %_impzPtr
%zone3622 = bitcast i8* %tzone3621 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3622)
; malloc closure structure
%clsptr3623 = call i8* @llvm_zone_malloc(%mzone* %zone3622, i64 24)
%closure3624 = bitcast i8* %clsptr3623 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*

; malloc environment structure
%envptr3625 = call i8* @llvm_zone_malloc(%mzone* %zone3622, i64 8)
%environment3626 = bitcast i8* %envptr3625 to {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***}*

; malloc closure address table
%addytable3627 = call %clsvar* @new_address_table()
%var3628 = bitcast [46 x i8]* @gsxtmbase254 to i8*
%var3629 = bitcast [55 x i8]* @gsxtmbase255 to i8*
%addytable3630 = call %clsvar* @add_address_table(%mzone* %zone3622, i8* %var3628, i32 0, i8* %var3629, i32 3, %clsvar* %addytable3627)
%address-table3631 = bitcast %clsvar* %addytable3630 to i8*

; insert table, function and environment into closure struct
%closure.table3634 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3624, i32 0, i32 0
store i8* %address-table3631, i8** %closure.table3634
%closure.env3635 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3624, i32 0, i32 1
store i8* %envptr3625, i8** %closure.env3635
%closure.func3636 = getelementptr { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3624, i32 0, i32 2
store %Symbol* (i8*, i8*, %Symbol*, %Symbol*)* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ__3577, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)** %closure.func3636
%closure_size3637 = call i64 @llvm_zone_mark_size(%mzone* %zone3622)
call void @llvm_zone_ptr_set_size(i8* %clsptr3623, i64 %closure_size3637)
%wrapper_ptr3638 = call i8* @llvm_zone_malloc(%mzone* %zone3622, i64 8)
%closure_wrapper3639 = bitcast i8* %wrapper_ptr3638 to { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure3624, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_wrapper3639

; let value assignment
%cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ = select i1 true, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_wrapper3639, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_wrapper3639
store { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ, { i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*** %cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr

; add data to environment
; don't need to alloc for env var cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ
%tmp_envptr3633 = getelementptr {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***}, {{i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}***}* %environment3626, i32 0, i32 0
store {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*** %cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**** %tmp_envptr3633


%val3642 = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*** %cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQPtr
ret {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %val3642
}


@cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Symbol* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ(%Symbol* %arg_0,%Symbol* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
ret %Symbol* %result
}


define dllexport ccc %Symbol* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_native(%Symbol* %arg_0,%Symbol* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
ret %Symbol* %result
}


define dllexport ccc i8*  @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3643 = bitcast [99 x i8]* @gsxtmbase256 to i8*
call i32 (i8*, ...) @printf(i8* %var3643)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Symbol*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3644 = bitcast [99 x i8]* @gsxtmbase256 to i8*
call i32 (i8*, ...) @printf(i8* %var3644)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Symbol*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
%tmpres = bitcast %Symbol* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Symbol*, %Symbol*}*
%arg_p_0 = getelementptr {%Symbol*, %Symbol*}, {%Symbol*, %Symbol*}* %fstruct, i32 0, i32 0
%arg_0 = load %Symbol*, %Symbol** %arg_p_0
%arg_p_1 = getelementptr {%Symbol*, %Symbol*}, {%Symbol*, %Symbol*}* %fstruct, i32 0, i32 1
%arg_1 = load %Symbol*, %Symbol** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @cat2_adhoc_W1N5bWJvbCosU3ltYm9sKixTeW1ib2wqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}**
%closure = load {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}*, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}, {i8*, i8*, %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*}* %closure, i32 0, i32 1
%ff = load  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)*,  %Symbol* (i8*, i8*, %Symbol*, %Symbol*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Symbol* %ff(i8* %_impz, i8* %ee, %Symbol* %arg_0, %Symbol* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


