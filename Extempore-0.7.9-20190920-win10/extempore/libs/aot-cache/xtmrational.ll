%Rational = type {i64,i64}
@gsxtmrational0 = hidden constant [42 x i8] c"Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ\00"
@gsxtmrational1 = hidden constant [47 x i8] c"{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**\00"
define dllexport fastcc %Rational* @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ__1(i8* %_impz,i8* %_impenv, i64 %arg_0, i64 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}*
%Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**** %Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i64
store i64 %arg_1, i64* %arg_1Ptr


%tzone7 = load i8*, i8** %_impzPtr
%zone8 = bitcast i8* %tzone7 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Rational*
%tzone3 = load i8*, i8** %_impzPtr
%zone4 = bitcast i8* %tzone3 to %mzone*
%dat5 = call i8* @llvm_zone_malloc(%mzone* %zone4, i64 16)
call i8* @memset(i8* %dat5, i32 0, i64 16)
%val6 = bitcast i8* %dat5 to %Rational*

; let value assignment
%obj = select i1 true, %Rational* %val6, %Rational* %val6
store %Rational* %obj, %Rational** %objPtr

%val9 = load %Rational*, %Rational** %objPtr
%val10 = load i64, i64* %arg_0Ptr
; set tuple
%val11 = getelementptr %Rational, %Rational* %val9, i64 0, i32 0
store i64 %val10, i64* %val11
%val12 = load %Rational*, %Rational** %objPtr
%val13 = load i64, i64* %arg_1Ptr
; set tuple
%val14 = getelementptr %Rational, %Rational* %val12, i64 0, i32 1
store i64 %val13, i64* %val14
%val15 = load %Rational*, %Rational** %objPtr
ret %Rational* %val15
}
@gsxtmrational2 = hidden constant [95 x i8] c"Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone35 = load i8*, i8** %_impzPtr
%zone36 = bitcast i8* %tzone35 to %mzone*

; let assign value to symbol Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ
%dat_Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone36, i64 8)
%Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr = bitcast i8* %dat_Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ to { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***
%tzone16 = load i8*, i8** %_impzPtr
%zone17 = bitcast i8* %tzone16 to %mzone*
call void @llvm_zone_mark(%mzone* %zone17)
; malloc closure structure
%clsptr18 = call i8* @llvm_zone_malloc(%mzone* %zone17, i64 24)
%closure19 = bitcast i8* %clsptr18 to { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr20 = call i8* @llvm_zone_malloc(%mzone* %zone17, i64 8)
%environment21 = bitcast i8* %envptr20 to {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable22 = call %clsvar* @new_address_table()
%var23 = bitcast [42 x i8]* @gsxtmrational0 to i8*
%var24 = bitcast [47 x i8]* @gsxtmrational1 to i8*
%addytable25 = call %clsvar* @add_address_table(%mzone* %zone17, i8* %var23, i32 0, i8* %var24, i32 3, %clsvar* %addytable22)
%address-table26 = bitcast %clsvar* %addytable25 to i8*

; insert table, function and environment into closure struct
%closure.table29 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure19, i32 0, i32 0
store i8* %address-table26, i8** %closure.table29
%closure.env30 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure19, i32 0, i32 1
store i8* %envptr20, i8** %closure.env30
%closure.func31 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure19, i32 0, i32 2
store %Rational* (i8*, i8*, i64, i64)* @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ__1, %Rational* (i8*, i8*, i64, i64)** %closure.func31
%closure_size32 = call i64 @llvm_zone_mark_size(%mzone* %zone17)
call void @llvm_zone_ptr_set_size(i8* %clsptr18, i64 %closure_size32)
%wrapper_ptr33 = call i8* @llvm_zone_malloc(%mzone* %zone17, i64 8)
%closure_wrapper34 = bitcast i8* %wrapper_ptr33 to { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
store { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure19, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_wrapper34

; let value assignment
%Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_wrapper34, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_wrapper34
store { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*** %Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ
%tmp_envptr28 = getelementptr {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}* %environment21, i32 0, i32 0
store {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*** %Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**** %tmp_envptr28


%val37 = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*** %Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr
ret {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %val37
}


@Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational* @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, i64, i64)*,  %Rational* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %Rational* %result
}


define dllexport ccc %Rational* @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_native(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, i64, i64)*,  %Rational* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %Rational* %result
}


define dllexport ccc i8*  @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var38 = bitcast [95 x i8]* @gsxtmrational2 to i8*
call i32 (i8*, ...) @printf(i8* %var38)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var39 = bitcast [95 x i8]* @gsxtmrational2 to i8*
call i32 (i8*, ...) @printf(i8* %var39)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, i64, i64)*,  %Rational* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%tmpres = bitcast %Rational* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64}*
%arg_p_0 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, i64, i64)*,  %Rational* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational3 = hidden constant [44 x i8] c"Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ\00"
define dllexport fastcc %Rational* @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ__40(i8* %_impz,i8* %_impenv, i64 %arg_0, i64 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone41 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}*
%Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**** %Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i64
store i64 %arg_1, i64* %arg_1Ptr


%tzone46 = load i8*, i8** %_impzPtr
%zone47 = bitcast i8* %tzone46 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Rational*
%tzone42 = load i8*, i8** %_impzPtr
%zone43 = bitcast i8* %tzone42 to %mzone*
%dat44 = call i8* @llvm_zone_malloc(%mzone* %zone43, i64 16)
call i8* @memset(i8* %dat44, i32 0, i64 16)
%val45 = bitcast i8* %dat44 to %Rational*

; let value assignment
%obj = select i1 true, %Rational* %val45, %Rational* %val45
store %Rational* %obj, %Rational** %objPtr

%val48 = load %Rational*, %Rational** %objPtr
%val49 = load i64, i64* %arg_0Ptr
; set tuple
%val50 = getelementptr %Rational, %Rational* %val48, i64 0, i32 0
store i64 %val49, i64* %val50
%val51 = load %Rational*, %Rational** %objPtr
%val52 = load i64, i64* %arg_1Ptr
; set tuple
%val53 = getelementptr %Rational, %Rational* %val51, i64 0, i32 1
store i64 %val52, i64* %val53
%val54 = load %Rational*, %Rational** %objPtr
ret %Rational* %val54
}
@gsxtmrational4 = hidden constant [97 x i8] c"Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone74 = load i8*, i8** %_impzPtr
%zone75 = bitcast i8* %tzone74 to %mzone*

; let assign value to symbol Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ
%dat_Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone75, i64 8)
%Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr = bitcast i8* %dat_Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ to { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***
%tzone55 = load i8*, i8** %_impzPtr
%zone56 = bitcast i8* %tzone55 to %mzone*
call void @llvm_zone_mark(%mzone* %zone56)
; malloc closure structure
%clsptr57 = call i8* @llvm_zone_malloc(%mzone* %zone56, i64 24)
%closure58 = bitcast i8* %clsptr57 to { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr59 = call i8* @llvm_zone_malloc(%mzone* %zone56, i64 8)
%environment60 = bitcast i8* %envptr59 to {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable61 = call %clsvar* @new_address_table()
%var62 = bitcast [44 x i8]* @gsxtmrational3 to i8*
%var63 = bitcast [47 x i8]* @gsxtmrational1 to i8*
%addytable64 = call %clsvar* @add_address_table(%mzone* %zone56, i8* %var62, i32 0, i8* %var63, i32 3, %clsvar* %addytable61)
%address-table65 = bitcast %clsvar* %addytable64 to i8*

; insert table, function and environment into closure struct
%closure.table68 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure58, i32 0, i32 0
store i8* %address-table65, i8** %closure.table68
%closure.env69 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure58, i32 0, i32 1
store i8* %envptr59, i8** %closure.env69
%closure.func70 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure58, i32 0, i32 2
store %Rational* (i8*, i8*, i64, i64)* @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ__40, %Rational* (i8*, i8*, i64, i64)** %closure.func70
%closure_size71 = call i64 @llvm_zone_mark_size(%mzone* %zone56)
call void @llvm_zone_ptr_set_size(i8* %clsptr57, i64 %closure_size71)
%wrapper_ptr72 = call i8* @llvm_zone_malloc(%mzone* %zone56, i64 8)
%closure_wrapper73 = bitcast i8* %wrapper_ptr72 to { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
store { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure58, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_wrapper73

; let value assignment
%Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_wrapper73, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_wrapper73
store { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*** %Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ
%tmp_envptr67 = getelementptr {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}* %environment60, i32 0, i32 0
store {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*** %Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**** %tmp_envptr67


%val76 = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*** %Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr
ret {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %val76
}


@Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational* @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, i64, i64)*,  %Rational* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %Rational* %result
}


define dllexport ccc %Rational* @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_native(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, i64, i64)*,  %Rational* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %Rational* %result
}


define dllexport ccc i8*  @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var77 = bitcast [97 x i8]* @gsxtmrational4 to i8*
call i32 (i8*, ...) @printf(i8* %var77)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var78 = bitcast [97 x i8]* @gsxtmrational4 to i8*
call i32 (i8*, ...) @printf(i8* %var78)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, i64, i64)*,  %Rational* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%tmpres = bitcast %Rational* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64}*
%arg_p_0 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_z_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, i64, i64)*,  %Rational* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational5 = hidden constant [44 x i8] c"Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ\00"
define dllexport fastcc %Rational* @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ__79(i8* %_impz,i8* %_impenv, i64 %arg_0, i64 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone80 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}*
%Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**** %Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i64
store i64 %arg_1, i64* %arg_1Ptr


%tzone83 = load i8*, i8** %_impzPtr
%zone84 = bitcast i8* %tzone83 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Rational*
%dat81 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat81, i32 0, i64 16)
%val82 = bitcast i8* %dat81 to %Rational*

; let value assignment
%obj = select i1 true, %Rational* %val82, %Rational* %val82
store %Rational* %obj, %Rational** %objPtr

%val85 = load %Rational*, %Rational** %objPtr
%val86 = load i64, i64* %arg_0Ptr
; set tuple
%val87 = getelementptr %Rational, %Rational* %val85, i64 0, i32 0
store i64 %val86, i64* %val87
%val88 = load %Rational*, %Rational** %objPtr
%val89 = load i64, i64* %arg_1Ptr
; set tuple
%val90 = getelementptr %Rational, %Rational* %val88, i64 0, i32 1
store i64 %val89, i64* %val90
%val91 = load %Rational*, %Rational** %objPtr
ret %Rational* %val91
}
@gsxtmrational6 = hidden constant [97 x i8] c"Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone111 = load i8*, i8** %_impzPtr
%zone112 = bitcast i8* %tzone111 to %mzone*

; let assign value to symbol Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ
%dat_Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone112, i64 8)
%Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr = bitcast i8* %dat_Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ to { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***
%tzone92 = load i8*, i8** %_impzPtr
%zone93 = bitcast i8* %tzone92 to %mzone*
call void @llvm_zone_mark(%mzone* %zone93)
; malloc closure structure
%clsptr94 = call i8* @llvm_zone_malloc(%mzone* %zone93, i64 24)
%closure95 = bitcast i8* %clsptr94 to { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr96 = call i8* @llvm_zone_malloc(%mzone* %zone93, i64 8)
%environment97 = bitcast i8* %envptr96 to {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable98 = call %clsvar* @new_address_table()
%var99 = bitcast [44 x i8]* @gsxtmrational5 to i8*
%var100 = bitcast [47 x i8]* @gsxtmrational1 to i8*
%addytable101 = call %clsvar* @add_address_table(%mzone* %zone93, i8* %var99, i32 0, i8* %var100, i32 3, %clsvar* %addytable98)
%address-table102 = bitcast %clsvar* %addytable101 to i8*

; insert table, function and environment into closure struct
%closure.table105 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure95, i32 0, i32 0
store i8* %address-table102, i8** %closure.table105
%closure.env106 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure95, i32 0, i32 1
store i8* %envptr96, i8** %closure.env106
%closure.func107 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure95, i32 0, i32 2
store %Rational* (i8*, i8*, i64, i64)* @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ__79, %Rational* (i8*, i8*, i64, i64)** %closure.func107
%closure_size108 = call i64 @llvm_zone_mark_size(%mzone* %zone93)
call void @llvm_zone_ptr_set_size(i8* %clsptr94, i64 %closure_size108)
%wrapper_ptr109 = call i8* @llvm_zone_malloc(%mzone* %zone93, i64 8)
%closure_wrapper110 = bitcast i8* %wrapper_ptr109 to { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
store { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure95, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_wrapper110

; let value assignment
%Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_wrapper110, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_wrapper110
store { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ, { i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*** %Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ
%tmp_envptr104 = getelementptr {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}***}* %environment97, i32 0, i32 0
store {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*** %Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**** %tmp_envptr104


%val113 = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*** %Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQPtr
ret {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %val113
}


@Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational* @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, i64, i64)*,  %Rational* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %Rational* %result
}


define dllexport ccc %Rational* @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_native(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, i64, i64)*,  %Rational* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %Rational* %result
}


define dllexport ccc i8*  @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var114 = bitcast [97 x i8]* @gsxtmrational6 to i8*
call i32 (i8*, ...) @printf(i8* %var114)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var115 = bitcast [97 x i8]* @gsxtmrational6 to i8*
call i32 (i8*, ...) @printf(i8* %var115)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, i64, i64)*,  %Rational* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%tmpres = bitcast %Rational* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64}*
%arg_p_0 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_h_adhoc_W1JhdGlvbmFsKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, i64, i64)*,  %Rational* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational7 = hidden constant [44 x i8] c"Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd\00"
@gsxtmrational8 = hidden constant [46 x i8] c"{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**\00"
define dllexport fastcc %Rational @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd__116(i8* %_impz,i8* %_impenv, i64 %arg_0, i64 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone117 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***}*
%Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr = load {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**** %Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i64
store i64 %arg_1, i64* %arg_1Ptr


%tzone119 = load i8*, i8** %_impzPtr
%zone120 = bitcast i8* %tzone119 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Rational*
%dat118 = alloca %Rational, align 16

; let value assignment
%obj = select i1 true, %Rational* %dat118, %Rational* %dat118
store %Rational* %obj, %Rational** %objPtr

%val121 = load %Rational*, %Rational** %objPtr
%val122 = load i64, i64* %arg_0Ptr
; set tuple
%val123 = getelementptr %Rational, %Rational* %val121, i64 0, i32 0
store i64 %val122, i64* %val123
%val124 = load %Rational*, %Rational** %objPtr
%val125 = load i64, i64* %arg_1Ptr
; set tuple
%val126 = getelementptr %Rational, %Rational* %val124, i64 0, i32 1
store i64 %val125, i64* %val126
%val127 = load %Rational*, %Rational** %objPtr
; pointer ref
%val128 = getelementptr %Rational, %Rational* %val127, i64 0
%val129 = load %Rational, %Rational* %val128
ret %Rational %val129
}
@gsxtmrational9 = hidden constant [97 x i8] c"Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone149 = load i8*, i8** %_impzPtr
%zone150 = bitcast i8* %tzone149 to %mzone*

; let assign value to symbol Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd
%dat_Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone150, i64 8)
%Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr = bitcast i8* %dat_Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd to { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***
%tzone130 = load i8*, i8** %_impzPtr
%zone131 = bitcast i8* %tzone130 to %mzone*
call void @llvm_zone_mark(%mzone* %zone131)
; malloc closure structure
%clsptr132 = call i8* @llvm_zone_malloc(%mzone* %zone131, i64 24)
%closure133 = bitcast i8* %clsptr132 to { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr134 = call i8* @llvm_zone_malloc(%mzone* %zone131, i64 8)
%environment135 = bitcast i8* %envptr134 to {{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable136 = call %clsvar* @new_address_table()
%var137 = bitcast [44 x i8]* @gsxtmrational7 to i8*
%var138 = bitcast [46 x i8]* @gsxtmrational8 to i8*
%addytable139 = call %clsvar* @add_address_table(%mzone* %zone131, i8* %var137, i32 0, i8* %var138, i32 3, %clsvar* %addytable136)
%address-table140 = bitcast %clsvar* %addytable139 to i8*

; insert table, function and environment into closure struct
%closure.table143 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure133, i32 0, i32 0
store i8* %address-table140, i8** %closure.table143
%closure.env144 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure133, i32 0, i32 1
store i8* %envptr134, i8** %closure.env144
%closure.func145 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure133, i32 0, i32 2
store %Rational (i8*, i8*, i64, i64)* @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd__116, %Rational (i8*, i8*, i64, i64)** %closure.func145
%closure_size146 = call i64 @llvm_zone_mark_size(%mzone* %zone131)
call void @llvm_zone_ptr_set_size(i8* %clsptr132, i64 %closure_size146)
%wrapper_ptr147 = call i8* @llvm_zone_malloc(%mzone* %zone131, i64 8)
%closure_wrapper148 = bitcast i8* %wrapper_ptr147 to { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**
store { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure133, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure_wrapper148

; let value assignment
%Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure_wrapper148, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure_wrapper148
store { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*** %Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr

; add data to environment
; don't need to alloc for env var Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd
%tmp_envptr142 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***}* %environment135, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*** %Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**** %tmp_envptr142


%val151 = load {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*** %Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr
ret {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %val151
}


@Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, i64)*,  %Rational (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_native(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, i64)*,  %Rational (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc void @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64}*
%arg_p_0 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_val_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, i64)*,  %Rational (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational10 = hidden constant [41 x i8] c"hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd\00"
@gsxtmrational11 = hidden constant [49 x i8] c"{i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}**\00"
define dllexport fastcc %Rational* @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd__154(i8* %_impz,i8* %_impenv, %Rational* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone155 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}***}*
%hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpdPtr_ = getelementptr {{i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}***}, {{i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpdPtr = load {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}***, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}**** %hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpdPtr_

; setup arguments
%xPtr = alloca %Rational*
store %Rational* %x, %Rational** %xPtr


%tzone158 = load i8*, i8** %_impzPtr
%zone159 = bitcast i8* %tzone158 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Rational*
%dat156 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat156, i32 0, i64 16)
%val157 = bitcast i8* %dat156 to %Rational*

; let value assignment
%obj = select i1 true, %Rational* %val157, %Rational* %val157
store %Rational* %obj, %Rational** %objPtr

%val160 = load %Rational*, %Rational** %objPtr
%val161 = load %Rational*, %Rational** %xPtr
; tuple ref
%val162 = getelementptr %Rational, %Rational* %val161, i64 0, i32 0
%val163 = load i64, i64* %val162
; set tuple
%val164 = getelementptr %Rational, %Rational* %val160, i64 0, i32 0
store i64 %val163, i64* %val164
%val165 = load %Rational*, %Rational** %objPtr
%val166 = load %Rational*, %Rational** %xPtr
; tuple ref
%val167 = getelementptr %Rational, %Rational* %val166, i64 0, i32 1
%val168 = load i64, i64* %val167
; set tuple
%val169 = getelementptr %Rational, %Rational* %val165, i64 0, i32 1
store i64 %val168, i64* %val169
%val170 = load %Rational*, %Rational** %objPtr
ret %Rational* %val170
}
@gsxtmrational12 = hidden constant [94 x i8] c"hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}** @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone190 = load i8*, i8** %_impzPtr
%zone191 = bitcast i8* %tzone190 to %mzone*

; let assign value to symbol hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd
%dat_hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd = call i8* @llvm_zone_malloc(%mzone* %zone191, i64 8)
%hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpdPtr = bitcast i8* %dat_hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd to { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}***
%tzone171 = load i8*, i8** %_impzPtr
%zone172 = bitcast i8* %tzone171 to %mzone*
call void @llvm_zone_mark(%mzone* %zone172)
; malloc closure structure
%clsptr173 = call i8* @llvm_zone_malloc(%mzone* %zone172, i64 24)
%closure174 = bitcast i8* %clsptr173 to { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}*

; malloc environment structure
%envptr175 = call i8* @llvm_zone_malloc(%mzone* %zone172, i64 8)
%environment176 = bitcast i8* %envptr175 to {{i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}***}*

; malloc closure address table
%addytable177 = call %clsvar* @new_address_table()
%var178 = bitcast [41 x i8]* @gsxtmrational10 to i8*
%var179 = bitcast [49 x i8]* @gsxtmrational11 to i8*
%addytable180 = call %clsvar* @add_address_table(%mzone* %zone172, i8* %var178, i32 0, i8* %var179, i32 3, %clsvar* %addytable177)
%address-table181 = bitcast %clsvar* %addytable180 to i8*

; insert table, function and environment into closure struct
%closure.table184 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}, { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}* %closure174, i32 0, i32 0
store i8* %address-table181, i8** %closure.table184
%closure.env185 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}, { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}* %closure174, i32 0, i32 1
store i8* %envptr175, i8** %closure.env185
%closure.func186 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}, { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}* %closure174, i32 0, i32 2
store %Rational* (i8*, i8*, %Rational*)* @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd__154, %Rational* (i8*, i8*, %Rational*)** %closure.func186
%closure_size187 = call i64 @llvm_zone_mark_size(%mzone* %zone172)
call void @llvm_zone_ptr_set_size(i8* %clsptr173, i64 %closure_size187)
%wrapper_ptr188 = call i8* @llvm_zone_malloc(%mzone* %zone172, i64 8)
%closure_wrapper189 = bitcast i8* %wrapper_ptr188 to { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}**
store { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}* %closure174, { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}** %closure_wrapper189

; let value assignment
%hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd = select i1 true, { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}** %closure_wrapper189, { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}** %closure_wrapper189
store { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}** %hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd, { i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}*** %hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpdPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd
%tmp_envptr183 = getelementptr {{i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}***}, {{i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}***}* %environment176, i32 0, i32 0
store {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}*** %hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpdPtr, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}**** %tmp_envptr183


%val192 = load {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}**, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}*** %hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpdPtr
ret {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}** %val192
}


@hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}** @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational* @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd(%Rational* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}*, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, %Rational*)*,  %Rational* (i8*, i8*, %Rational*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, %Rational* %arg_0)
ret %Rational* %result
}


define dllexport ccc %Rational* @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_native(%Rational* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}*, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, %Rational*)*,  %Rational* (i8*, i8*, %Rational*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, %Rational* %arg_0)
ret %Rational* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var193 = bitcast [94 x i8]* @gsxtmrational12 to i8*
call i32 (i8*, ...) @printf(i8* %var193)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Rational*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}*, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, %Rational*)*,  %Rational* (i8*, i8*, %Rational*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, %Rational* %arg_0)
%tmpres = bitcast %Rational* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational*}*
%arg_p_0 = getelementptr {%Rational*}, {%Rational*}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational*, %Rational** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}*, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, %Rational*)*,  %Rational* (i8*, i8*, %Rational*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, %Rational* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational13 = hidden constant [35 x i8] c"hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ\00"
@gsxtmrational14 = hidden constant [43 x i8] c"{i8*, i8*, void (i8*, i8*, %Rational*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ__194(i8* %_impz,i8* %_impenv, %Rational* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone195 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Rational*)*}***}*
%hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Rational*)*}***}, {{i8*, i8*, void (i8*, i8*, %Rational*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQPtr = load {i8*, i8*, void (i8*, i8*, %Rational*)*}***, {i8*, i8*, void (i8*, i8*, %Rational*)*}**** %hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQPtr_

; setup arguments
%xPtr = alloca %Rational*
store %Rational* %x, %Rational** %xPtr


%val196 = load %Rational*, %Rational** %xPtr
%val197 = bitcast %Rational* %val196 to i8*
call ccc void @free(i8* %val197)
ret void
}
@gsxtmrational15 = hidden constant [88 x i8] c"hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Rational*)*}** @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone219 = load i8*, i8** %_impzPtr
%zone220 = bitcast i8* %tzone219 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ
%dat_hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ = call i8* @llvm_zone_malloc(%mzone* %zone220, i64 8)
%hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ to { i8*, i8*, void (i8*, i8*, %Rational*)*}***
%tzone200 = load i8*, i8** %_impzPtr
%zone201 = bitcast i8* %tzone200 to %mzone*
call void @llvm_zone_mark(%mzone* %zone201)
; malloc closure structure
%clsptr202 = call i8* @llvm_zone_malloc(%mzone* %zone201, i64 24)
%closure203 = bitcast i8* %clsptr202 to { i8*, i8*, void (i8*, i8*, %Rational*)*}*

; malloc environment structure
%envptr204 = call i8* @llvm_zone_malloc(%mzone* %zone201, i64 8)
%environment205 = bitcast i8* %envptr204 to {{i8*, i8*, void (i8*, i8*, %Rational*)*}***}*

; malloc closure address table
%addytable206 = call %clsvar* @new_address_table()
%var207 = bitcast [35 x i8]* @gsxtmrational13 to i8*
%var208 = bitcast [43 x i8]* @gsxtmrational14 to i8*
%addytable209 = call %clsvar* @add_address_table(%mzone* %zone201, i8* %var207, i32 0, i8* %var208, i32 3, %clsvar* %addytable206)
%address-table210 = bitcast %clsvar* %addytable209 to i8*

; insert table, function and environment into closure struct
%closure.table213 = getelementptr { i8*, i8*, void (i8*, i8*, %Rational*)*}, { i8*, i8*, void (i8*, i8*, %Rational*)*}* %closure203, i32 0, i32 0
store i8* %address-table210, i8** %closure.table213
%closure.env214 = getelementptr { i8*, i8*, void (i8*, i8*, %Rational*)*}, { i8*, i8*, void (i8*, i8*, %Rational*)*}* %closure203, i32 0, i32 1
store i8* %envptr204, i8** %closure.env214
%closure.func215 = getelementptr { i8*, i8*, void (i8*, i8*, %Rational*)*}, { i8*, i8*, void (i8*, i8*, %Rational*)*}* %closure203, i32 0, i32 2
store void (i8*, i8*, %Rational*)* @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ__194, void (i8*, i8*, %Rational*)** %closure.func215
%closure_size216 = call i64 @llvm_zone_mark_size(%mzone* %zone201)
call void @llvm_zone_ptr_set_size(i8* %clsptr202, i64 %closure_size216)
%wrapper_ptr217 = call i8* @llvm_zone_malloc(%mzone* %zone201, i64 8)
%closure_wrapper218 = bitcast i8* %wrapper_ptr217 to { i8*, i8*, void (i8*, i8*, %Rational*)*}**
store { i8*, i8*, void (i8*, i8*, %Rational*)*}* %closure203, { i8*, i8*, void (i8*, i8*, %Rational*)*}** %closure_wrapper218

; let value assignment
%hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Rational*)*}** %closure_wrapper218, { i8*, i8*, void (i8*, i8*, %Rational*)*}** %closure_wrapper218
store { i8*, i8*, void (i8*, i8*, %Rational*)*}** %hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ, { i8*, i8*, void (i8*, i8*, %Rational*)*}*** %hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ
%tmp_envptr212 = getelementptr {{i8*, i8*, void (i8*, i8*, %Rational*)*}***}, {{i8*, i8*, void (i8*, i8*, %Rational*)*}***}* %environment205, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Rational*)*}*** %hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQPtr, {i8*, i8*, void (i8*, i8*, %Rational*)*}**** %tmp_envptr212


%val221 = load {i8*, i8*, void (i8*, i8*, %Rational*)*}**, {i8*, i8*, void (i8*, i8*, %Rational*)*}*** %hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQPtr
ret {i8*, i8*, void (i8*, i8*, %Rational*)*}** %val221
}


@hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Rational*)*}** @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Rational*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ(%Rational* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rational*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rational*)*}*, {i8*, i8*, void (i8*, i8*, %Rational*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational*)*}, {i8*, i8*, void (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational*)*}, {i8*, i8*, void (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rational*)*,  void (i8*, i8*, %Rational*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rational* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_native(%Rational* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rational*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rational*)*}*, {i8*, i8*, void (i8*, i8*, %Rational*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational*)*}, {i8*, i8*, void (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational*)*}, {i8*, i8*, void (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rational*)*,  void (i8*, i8*, %Rational*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rational* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var222 = bitcast [88 x i8]* @gsxtmrational15 to i8*
call i32 (i8*, ...) @printf(i8* %var222)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Rational*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rational*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rational*)*}*, {i8*, i8*, void (i8*, i8*, %Rational*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational*)*}, {i8*, i8*, void (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational*)*}, {i8*, i8*, void (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rational*)*,  void (i8*, i8*, %Rational*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rational* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational*}*
%arg_p_0 = getelementptr {%Rational*}, {%Rational*}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational*, %Rational** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsUmF0aW9uYWwqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rational*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rational*)*}*, {i8*, i8*, void (i8*, i8*, %Rational*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational*)*}, {i8*, i8*, void (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational*)*}, {i8*, i8*, void (i8*, i8*, %Rational*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rational*)*,  void (i8*, i8*, %Rational*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rational* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational16 = hidden constant [60 x i8] c"zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0\00"
@gsxtmrational17 = hidden constant [67 x i8] c"{i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %Rational* @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0__223(i8* %_impz,i8* %_impenv, %Rational* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone224 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}***, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca %Rational*
store %Rational* %x, %Rational** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val226 = load %mzone*, %mzone** %fromzPtr
%val227 = load %Rational*, %Rational** %xPtr
%val228 = bitcast %Rational* %val227 to i8*
%res229 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val226, i8* %val228)
br i1 %res229, label %then225, label %else225

then225:
%val230 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val230)
%zone_ptr231 = bitcast %mzone* %val230 to i8*
store i8* %zone_ptr231, i8** %_impzPtr
%tzone237 = load i8*, i8** %_impzPtr
%zone238 = bitcast i8* %tzone237 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Rational*
%tzone233 = load i8*, i8** %_impzPtr
%zone234 = bitcast i8* %tzone233 to %mzone*
%dat235 = call i8* @llvm_zone_malloc(%mzone* %zone234, i64 16)
call i8* @memset(i8* %dat235, i32 0, i64 16)
%val236 = bitcast i8* %dat235 to %Rational*

; let value assignment
%obj = select i1 true, %Rational* %val236, %Rational* %val236
store %Rational* %obj, %Rational** %objPtr

%val239 = load %Rational*, %Rational** %objPtr
%val240 = load %Rational*, %Rational** %xPtr
; tuple ref
%val241 = getelementptr %Rational, %Rational* %val240, i64 0, i32 0
%val242 = load i64, i64* %val241
; set tuple
%val243 = getelementptr %Rational, %Rational* %val239, i64 0, i32 0
store i64 %val242, i64* %val243
%val244 = load %Rational*, %Rational** %objPtr
%val245 = load %Rational*, %Rational** %xPtr
; tuple ref
%val246 = getelementptr %Rational, %Rational* %val245, i64 0, i32 1
%val247 = load i64, i64* %val246
; set tuple
%val248 = getelementptr %Rational, %Rational* %val244, i64 0, i32 1
store i64 %val247, i64* %val248
%oldzone249 = call %mzone* @llvm_pop_zone_stack()
%newzone250 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr251 = bitcast %mzone* %newzone250 to i8*
store i8* %zone_ptr251, i8** %_impzPtr
%val252 = load %Rational*, %Rational** %objPtr
ret %Rational* %val252

else225:
%val253 = load %Rational*, %Rational** %xPtr
ret %Rational* %val253
}
@gsxtmrational18 = hidden constant [113 x i8] c"zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone273 = load i8*, i8** %_impzPtr
%zone274 = bitcast i8* %tzone273 to %mzone*

; let assign value to symbol zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone274, i64 8)
%zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0 to { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}***
%tzone254 = load i8*, i8** %_impzPtr
%zone255 = bitcast i8* %tzone254 to %mzone*
call void @llvm_zone_mark(%mzone* %zone255)
; malloc closure structure
%clsptr256 = call i8* @llvm_zone_malloc(%mzone* %zone255, i64 24)
%closure257 = bitcast i8* %clsptr256 to { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr258 = call i8* @llvm_zone_malloc(%mzone* %zone255, i64 8)
%environment259 = bitcast i8* %envptr258 to {{i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable260 = call %clsvar* @new_address_table()
%var261 = bitcast [60 x i8]* @gsxtmrational16 to i8*
%var262 = bitcast [67 x i8]* @gsxtmrational17 to i8*
%addytable263 = call %clsvar* @add_address_table(%mzone* %zone255, i8* %var261, i32 0, i8* %var262, i32 3, %clsvar* %addytable260)
%address-table264 = bitcast %clsvar* %addytable263 to i8*

; insert table, function and environment into closure struct
%closure.table267 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}, { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}* %closure257, i32 0, i32 0
store i8* %address-table264, i8** %closure.table267
%closure.env268 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}, { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}* %closure257, i32 0, i32 1
store i8* %envptr258, i8** %closure.env268
%closure.func269 = getelementptr { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}, { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}* %closure257, i32 0, i32 2
store %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)* @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0__223, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)** %closure.func269
%closure_size270 = call i64 @llvm_zone_mark_size(%mzone* %zone255)
call void @llvm_zone_ptr_set_size(i8* %clsptr256, i64 %closure_size270)
%wrapper_ptr271 = call i8* @llvm_zone_malloc(%mzone* %zone255, i64 8)
%closure_wrapper272 = bitcast i8* %wrapper_ptr271 to { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}**
store { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}* %closure257, { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}** %closure_wrapper272

; let value assignment
%zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}** %closure_wrapper272, { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}** %closure_wrapper272
store { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0, { i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0
%tmp_envptr266 = getelementptr {{i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}***}* %environment259, i32 0, i32 0
store {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}**** %tmp_envptr266


%val275 = load {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}**, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}** %val275
}


@zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational* @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0(%Rational* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}*, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*,  %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, %Rational* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Rational* %result
}


define dllexport ccc %Rational* @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_native(%Rational* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}*, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*,  %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, %Rational* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Rational* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var276 = bitcast [113 x i8]* @gsxtmrational18 to i8*
call i32 (i8*, ...) @printf(i8* %var276)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Rational*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var277 = bitcast [113 x i8]* @gsxtmrational18 to i8*
call i32 (i8*, ...) @printf(i8* %var277)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var278 = bitcast [113 x i8]* @gsxtmrational18 to i8*
call i32 (i8*, ...) @printf(i8* %var278)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}*, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*,  %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, %Rational* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %Rational* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%Rational*, %mzone*, %mzone*}, {%Rational*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational*, %Rational** %arg_p_0
%arg_p_1 = getelementptr {%Rational*, %mzone*, %mzone*}, {%Rational*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%Rational*, %mzone*, %mzone*}, {%Rational*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1JhdGlvbmFsKixSYXRpb25hbCosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}*, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}, {i8*, i8*, %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)*,  %Rational* (i8*, i8*, %Rational*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational* %ff(i8* %_impz, i8* %ee, %Rational* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational19 = hidden constant [35 x i8] c"Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd\00"
define dllexport fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd__279(i8* %_impz,i8* %_impenv, i64 %a, i64 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone280 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***}*
%Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr = load {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**** %Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr_

; setup arguments
%aPtr = alloca i64
store i64 %a, i64* %aPtr
%bPtr = alloca i64
store i64 %b, i64* %bPtr

; promote local stack var allocations
%tzone301 = load i8*, i8** %_impzPtr
%zone302 = bitcast i8* %tzone301 to %mzone*
%ifptr281 = alloca i64

%val282 = load i64, i64* %bPtr
%cmp283 = icmp slt i64 %val282, 0
br i1 %cmp283, label %then281, label %else281

then281:
; do set!
%val284 = load i64, i64* %aPtr
%val285 = mul i64 -1, %val284
store i64 %val285, i64* %aPtr
; do set!
%val286 = load i64, i64* %bPtr
%val287 = mul i64 -1, %val286
store i64 %val287, i64* %bPtr
store i64 %val287, i64* %ifptr281
br label %ifcont281

else281:
br label %ifcont281

ifcont281:
%ifres288 = load i64, i64* %ifptr281

%tzone290 = load i8*, i8** %_impzPtr
%zone291 = bitcast i8* %tzone290 to %mzone*

; let assign value to symbol r
%rPtr = alloca %Rational*
%dat289 = alloca %Rational, align 16

; let value assignment
%r = select i1 true, %Rational* %dat289, %Rational* %dat289
store %Rational* %r, %Rational** %rPtr

%val292 = load %Rational*, %Rational** %rPtr
%val293 = load i64, i64* %aPtr
; set tuple
%val294 = getelementptr %Rational, %Rational* %val292, i64 0, i32 0
store i64 %val293, i64* %val294
%val295 = load %Rational*, %Rational** %rPtr
%val296 = load i64, i64* %bPtr
; set tuple
%val297 = getelementptr %Rational, %Rational* %val295, i64 0, i32 1
store i64 %val296, i64* %val297
%val298 = load %Rational*, %Rational** %rPtr
; pointer ref
%val299 = getelementptr %Rational, %Rational* %val298, i64 0
%val300 = load %Rational, %Rational* %val299
ret %Rational %val300
}
@gsxtmrational20 = hidden constant [88 x i8] c"Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone322 = load i8*, i8** %_impzPtr
%zone323 = bitcast i8* %tzone322 to %mzone*

; let assign value to symbol Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd
%dat_Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone323, i64 8)
%Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr = bitcast i8* %dat_Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd to { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***
%tzone303 = load i8*, i8** %_impzPtr
%zone304 = bitcast i8* %tzone303 to %mzone*
call void @llvm_zone_mark(%mzone* %zone304)
; malloc closure structure
%clsptr305 = call i8* @llvm_zone_malloc(%mzone* %zone304, i64 24)
%closure306 = bitcast i8* %clsptr305 to { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr307 = call i8* @llvm_zone_malloc(%mzone* %zone304, i64 8)
%environment308 = bitcast i8* %envptr307 to {{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable309 = call %clsvar* @new_address_table()
%var310 = bitcast [35 x i8]* @gsxtmrational19 to i8*
%var311 = bitcast [46 x i8]* @gsxtmrational8 to i8*
%addytable312 = call %clsvar* @add_address_table(%mzone* %zone304, i8* %var310, i32 0, i8* %var311, i32 3, %clsvar* %addytable309)
%address-table313 = bitcast %clsvar* %addytable312 to i8*

; insert table, function and environment into closure struct
%closure.table316 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure306, i32 0, i32 0
store i8* %address-table313, i8** %closure.table316
%closure.env317 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure306, i32 0, i32 1
store i8* %envptr307, i8** %closure.env317
%closure.func318 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure306, i32 0, i32 2
store %Rational (i8*, i8*, i64, i64)* @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd__279, %Rational (i8*, i8*, i64, i64)** %closure.func318
%closure_size319 = call i64 @llvm_zone_mark_size(%mzone* %zone304)
call void @llvm_zone_ptr_set_size(i8* %clsptr305, i64 %closure_size319)
%wrapper_ptr320 = call i8* @llvm_zone_malloc(%mzone* %zone304, i64 8)
%closure_wrapper321 = bitcast i8* %wrapper_ptr320 to { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**
store { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure306, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure_wrapper321

; let value assignment
%Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure_wrapper321, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure_wrapper321
store { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd, { i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*** %Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr

; add data to environment
; don't need to alloc for env var Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd
%tmp_envptr315 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, i64)*}***}* %environment308, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*** %Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**** %tmp_envptr315


%val324 = load {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*** %Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRdPtr
ret {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %val324
}


@Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, i64)*,  %Rational (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_native(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, i64)*,  %Rational (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc void @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64}*
%arg_p_0 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}, {i8*, i8*, %Rational (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, i64)*,  %Rational (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational21 = hidden constant [58 x i8] c"Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ\00"
@gsxtmrational22 = hidden constant [40 x i8] c"{i8*, i8*, i64 (i8*, i8*, i64, i64)*}**\00"
define dllexport fastcc i64 @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ__327(i8* %_impz,i8* %_impenv, i64 %m, i64 %n) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone328 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, i64, i64)*}***}*
%Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, i64 (i8*, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQPtr = load {i8*, i8*, i64 (i8*, i8*, i64, i64)*}***, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}**** %Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQPtr_

; setup arguments
%mPtr = alloca i64
store i64 %m, i64* %mPtr
%nPtr = alloca i64
store i64 %n, i64* %nPtr

; promote local stack var allocations
%tzone378 = load i8*, i8** %_impzPtr
%zone379 = bitcast i8* %tzone378 to %mzone*
%ifptr330 = alloca i1
%ifptr333 = alloca i1

%val331 = load i64, i64* %mPtr
%cmp332 = icmp eq i64 %val331, 0
br i1 %cmp332, label %then330, label %else330

then330:
%val334 = load i64, i64* %nPtr
%cmp335 = icmp eq i64 %val334, 0
br i1 %cmp335, label %then333, label %else333

then333:
%val336 = load i64, i64* %nPtr
%cmp337 = icmp eq i64 %val336, 0
store i1 %cmp337, i1* %ifptr333
br label %ifcont333

else333:
%res338 = call ccc i1 @impc_false()
store i1 %res338, i1* %ifptr333
br label %ifcont333

ifcont333:
%ifres339 = load i1, i1* %ifptr333

store i1 %ifres339, i1* %ifptr330
br label %ifcont330

else330:
%res340 = call ccc i1 @impc_false()
store i1 %res340, i1* %ifptr330
br label %ifcont330

ifcont330:
%ifres341 = load i1, i1* %ifptr330

br i1 %ifres341, label %then329, label %else329

then329:
ret i64 -1

else329:
%tzone342 = load i8*, i8** %_impzPtr
%zone343 = bitcast i8* %tzone342 to %mzone*

; let assign value to symbol r
%rPtr = alloca i64

; let value assignment
%r = select i1 true, i64 0, i64 0
store i64 %r, i64* %rPtr

; promote local stack var allocations
%tzone376 = load i8*, i8** %_impzPtr
%zone377 = bitcast i8* %tzone376 to %mzone*
%ifptr368 = alloca i1
%ifptr357 = alloca i1
%ifptr350 = alloca i64
%ifptr344 = alloca i64
%val345 = load i64, i64* %mPtr
%cmp346 = icmp slt i64 %val345, 0
br i1 %cmp346, label %then344, label %else344

then344:
; do set!
%val347 = load i64, i64* %mPtr
%val348 = mul i64 %val347, -1
store i64 %val348, i64* %mPtr
store i64 %val348, i64* %ifptr344
br label %ifcont344

else344:
br label %ifcont344

ifcont344:
%ifres349 = load i64, i64* %ifptr344

%val351 = load i64, i64* %nPtr
%cmp352 = icmp slt i64 %val351, 0
br i1 %cmp352, label %then350, label %else350

then350:
; do set!
%val353 = load i64, i64* %nPtr
%val354 = mul i64 %val353, -1
store i64 %val354, i64* %nPtr
store i64 %val354, i64* %ifptr350
br label %ifcont350

else350:
br label %ifcont350

ifcont350:
%ifres355 = load i64, i64* %ifptr350

; while loop
%val358 = load i64, i64* %nPtr
%cmp359 = icmp eq i64 %val358, 0
br i1 %cmp359, label %then357, label %else357

then357:
%res360 = call ccc i1 @impc_false()
store i1 %res360, i1* %ifptr357
br label %ifcont357

else357:
%res361 = call ccc i1 @impc_true()
store i1 %res361, i1* %ifptr357
br label %ifcont357

ifcont357:
%ifres362 = load i1, i1* %ifptr357

br i1 %ifres362, label %loop356, label %after356

loop356:
; do set!
%val363 = load i64, i64* %mPtr
%val364 = load i64, i64* %nPtr
%val365 = srem i64 %val363, %val364
store i64 %val365, i64* %rPtr
; do set!
%val366 = load i64, i64* %nPtr
store i64 %val366, i64* %mPtr
; do set!
%val367 = load i64, i64* %rPtr
store i64 %val367, i64* %nPtr
%val369 = load i64, i64* %nPtr
%cmp370 = icmp eq i64 %val369, 0
br i1 %cmp370, label %then368, label %else368

then368:
%res371 = call ccc i1 @impc_false()
store i1 %res371, i1* %ifptr368
br label %ifcont368

else368:
%res372 = call ccc i1 @impc_true()
store i1 %res372, i1* %ifptr368
br label %ifcont368

ifcont368:
%ifres373 = load i1, i1* %ifptr368

br i1 %ifres373, label %loop356, label %after356

after356:
%val375 = load i64, i64* %mPtr
ret i64 %val375
}
@gsxtmrational23 = hidden constant [111 x i8] c"Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, i64, i64)*}** @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone399 = load i8*, i8** %_impzPtr
%zone400 = bitcast i8* %tzone399 to %mzone*

; let assign value to symbol Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ
%dat_Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone400, i64 8)
%Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQPtr = bitcast i8* %dat_Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ to { i8*, i8*, i64 (i8*, i8*, i64, i64)*}***
%tzone380 = load i8*, i8** %_impzPtr
%zone381 = bitcast i8* %tzone380 to %mzone*
call void @llvm_zone_mark(%mzone* %zone381)
; malloc closure structure
%clsptr382 = call i8* @llvm_zone_malloc(%mzone* %zone381, i64 24)
%closure383 = bitcast i8* %clsptr382 to { i8*, i8*, i64 (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr384 = call i8* @llvm_zone_malloc(%mzone* %zone381, i64 8)
%environment385 = bitcast i8* %envptr384 to {{i8*, i8*, i64 (i8*, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable386 = call %clsvar* @new_address_table()
%var387 = bitcast [58 x i8]* @gsxtmrational21 to i8*
%var388 = bitcast [40 x i8]* @gsxtmrational22 to i8*
%addytable389 = call %clsvar* @add_address_table(%mzone* %zone381, i8* %var387, i32 0, i8* %var388, i32 3, %clsvar* %addytable386)
%address-table390 = bitcast %clsvar* %addytable389 to i8*

; insert table, function and environment into closure struct
%closure.table393 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure383, i32 0, i32 0
store i8* %address-table390, i8** %closure.table393
%closure.env394 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure383, i32 0, i32 1
store i8* %envptr384, i8** %closure.env394
%closure.func395 = getelementptr { i8*, i8*, i64 (i8*, i8*, i64, i64)*}, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure383, i32 0, i32 2
store i64 (i8*, i8*, i64, i64)* @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ__327, i64 (i8*, i8*, i64, i64)** %closure.func395
%closure_size396 = call i64 @llvm_zone_mark_size(%mzone* %zone381)
call void @llvm_zone_ptr_set_size(i8* %clsptr382, i64 %closure_size396)
%wrapper_ptr397 = call i8* @llvm_zone_malloc(%mzone* %zone381, i64 8)
%closure_wrapper398 = bitcast i8* %wrapper_ptr397 to { i8*, i8*, i64 (i8*, i8*, i64, i64)*}**
store { i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure383, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %closure_wrapper398

; let value assignment
%Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %closure_wrapper398, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %closure_wrapper398
store { i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ, { i8*, i8*, i64 (i8*, i8*, i64, i64)*}*** %Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ
%tmp_envptr392 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, i64 (i8*, i8*, i64, i64)*}***}* %environment385, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, i64, i64)*}*** %Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQPtr, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}**** %tmp_envptr392


%val401 = load {i8*, i8*, i64 (i8*, i8*, i64, i64)*}**, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}*** %Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQPtr
ret {i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %val401
}


@Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, i64, i64)*}** @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64, i64)*,  i64 (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret i64 %result
}


define dllexport ccc i64 @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_native(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64, i64)*,  i64 (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret i64 %result
}


define dllexport ccc i8*  @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var402 = bitcast [111 x i8]* @gsxtmrational23 to i8*
call i32 (i8*, ...) @printf(i8* %var402)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var403 = bitcast [111 x i8]* @gsxtmrational23 to i8*
call i32 (i8*, ...) @printf(i8* %var403)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64, i64)*,  i64 (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64}*
%arg_p_0 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i64, i64)*}*, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i64, i64)*}, {i8*, i8*, i64 (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i64, i64)*,  i64 (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational24 = hidden constant [49 x i8] c"Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ\00"
@gsxtmrational25 = hidden constant [47 x i8] c"{i8*, i8*, %Rational (i8*, i8*, %Rational)*}**\00"
define dllexport fastcc %Rational @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ__404(i8* %_impz,i8* %_impenv, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone405 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational)*}***}*
%Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational)*}***}* %impenv, i32 0, i32 0
%Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational)*}**** %Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%tzone411 = load i8*, i8** %_impzPtr
%zone412 = bitcast i8* %tzone411 to %mzone*

; let assign value to symbol gcd
%gcdPtr = alloca i64
%val406 = load %Rational, %Rational* %aPtr
; tuple ref
%val407 = extractvalue %Rational %val406, 0
%val408 = load %Rational, %Rational* %aPtr
; tuple ref
%val409 = extractvalue %Rational %val408, 1
%res410 = call fastcc i64 @Rational_greatest_common_divisor_adhoc_W2k2NCxpNjQsaTY0XQ(i64 %val407, i64 %val409)

; let value assignment
%gcd = select i1 true, i64 %res410, i64 %res410
store i64 %gcd, i64* %gcdPtr

%val413 = load %Rational, %Rational* %aPtr
; tuple ref
%val414 = extractvalue %Rational %val413, 0
%val415 = load i64, i64* %gcdPtr
%val416 = sdiv i64 %val414, %val415
%val417 = load %Rational, %Rational* %aPtr
; tuple ref
%val418 = extractvalue %Rational %val417, 1
%val419 = load i64, i64* %gcdPtr
%val420 = sdiv i64 %val418, %val419
%res421 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val416, i64 %val420)
ret %Rational %res421
}
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational)*}** @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone441 = load i8*, i8** %_impzPtr
%zone442 = bitcast i8* %tzone441 to %mzone*

; let assign value to symbol Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ
%dat_Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone442, i64 8)
%Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQPtr = bitcast i8* %dat_Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, %Rational)*}***
%tzone422 = load i8*, i8** %_impzPtr
%zone423 = bitcast i8* %tzone422 to %mzone*
call void @llvm_zone_mark(%mzone* %zone423)
; malloc closure structure
%clsptr424 = call i8* @llvm_zone_malloc(%mzone* %zone423, i64 24)
%closure425 = bitcast i8* %clsptr424 to { i8*, i8*, %Rational (i8*, i8*, %Rational)*}*

; malloc environment structure
%envptr426 = call i8* @llvm_zone_malloc(%mzone* %zone423, i64 8)
%environment427 = bitcast i8* %envptr426 to {{i8*, i8*, %Rational (i8*, i8*, %Rational)*}***}*

; malloc closure address table
%addytable428 = call %clsvar* @new_address_table()
%var429 = bitcast [49 x i8]* @gsxtmrational24 to i8*
%var430 = bitcast [47 x i8]* @gsxtmrational25 to i8*
%addytable431 = call %clsvar* @add_address_table(%mzone* %zone423, i8* %var429, i32 0, i8* %var430, i32 3, %clsvar* %addytable428)
%address-table432 = bitcast %clsvar* %addytable431 to i8*

; insert table, function and environment into closure struct
%closure.table435 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational)*}* %closure425, i32 0, i32 0
store i8* %address-table432, i8** %closure.table435
%closure.env436 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational)*}* %closure425, i32 0, i32 1
store i8* %envptr426, i8** %closure.env436
%closure.func437 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational)*}* %closure425, i32 0, i32 2
store %Rational (i8*, i8*, %Rational)* @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ__404, %Rational (i8*, i8*, %Rational)** %closure.func437
%closure_size438 = call i64 @llvm_zone_mark_size(%mzone* %zone423)
call void @llvm_zone_ptr_set_size(i8* %clsptr424, i64 %closure_size438)
%wrapper_ptr439 = call i8* @llvm_zone_malloc(%mzone* %zone423, i64 8)
%closure_wrapper440 = bitcast i8* %wrapper_ptr439 to { i8*, i8*, %Rational (i8*, i8*, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational)*}* %closure425, { i8*, i8*, %Rational (i8*, i8*, %Rational)*}** %closure_wrapper440

; let value assignment
%Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational)*}** %closure_wrapper440, { i8*, i8*, %Rational (i8*, i8*, %Rational)*}** %closure_wrapper440
store { i8*, i8*, %Rational (i8*, i8*, %Rational)*}** %Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, %Rational)*}*** %Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ
%tmp_envptr434 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational)*}***}* %environment427, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational)*}*** %Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational)*}**** %tmp_envptr434


%val443 = load {i8*, i8*, %Rational (i8*, i8*, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational)*}*** %Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational)*}** %val443
}


@Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational)*}** @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational)*,  %Rational (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret %Rational %result
}


define dllexport ccc %Rational @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_native(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational)*,  %Rational (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret %Rational %result
}


define dllexport ccc void @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational}*
%arg_p_0 = getelementptr {%Rational}, {%Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational)*,  %Rational (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational26 = hidden constant [10 x i8] c"%lld/%lld\00"
@gsxtmrational27 = hidden constant [33 x i8] c"print_adhoc_W3ZvaWQsUmF0aW9uYWxd\00"
@gsxtmrational28 = hidden constant [42 x i8] c"{i8*, i8*, void (i8*, i8*, %Rational)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsUmF0aW9uYWxd__444(i8* %_impz,i8* %_impenv, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone445 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Rational)*}***}*
%print_adhoc_W3ZvaWQsUmF0aW9uYWxdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Rational)*}***}, {{i8*, i8*, void (i8*, i8*, %Rational)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsUmF0aW9uYWxdPtr = load {i8*, i8*, void (i8*, i8*, %Rational)*}***, {i8*, i8*, void (i8*, i8*, %Rational)*}**** %print_adhoc_W3ZvaWQsUmF0aW9uYWxdPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%tzone448 = load i8*, i8** %_impzPtr
%zone449 = bitcast i8* %tzone448 to %mzone*

; let assign value to symbol reduced
%reducedPtr = alloca %Rational
%val446 = load %Rational, %Rational* %aPtr
%res447 = call fastcc %Rational @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val446)

; let value assignment
%reduced = select i1 true, %Rational %res447, %Rational %res447
store %Rational %reduced, %Rational* %reducedPtr

%var450 = bitcast [10 x i8]* @gsxtmrational26 to i8*
%val451 = load %Rational, %Rational* %reducedPtr
; tuple ref
%val452 = extractvalue %Rational %val451, 0
%val453 = load %Rational, %Rational* %reducedPtr
; tuple ref
%val454 = extractvalue %Rational %val453, 1

%val455 = call i32 (i8*, ...) @printf(i8* %var450, i64 %val452, i64 %val454)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Rational)*}** @print_adhoc_W3ZvaWQsUmF0aW9uYWxd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone476 = load i8*, i8** %_impzPtr
%zone477 = bitcast i8* %tzone476 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsUmF0aW9uYWxd
%dat_print_adhoc_W3ZvaWQsUmF0aW9uYWxd = call i8* @llvm_zone_malloc(%mzone* %zone477, i64 8)
%print_adhoc_W3ZvaWQsUmF0aW9uYWxdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsUmF0aW9uYWxd to { i8*, i8*, void (i8*, i8*, %Rational)*}***
%tzone457 = load i8*, i8** %_impzPtr
%zone458 = bitcast i8* %tzone457 to %mzone*
call void @llvm_zone_mark(%mzone* %zone458)
; malloc closure structure
%clsptr459 = call i8* @llvm_zone_malloc(%mzone* %zone458, i64 24)
%closure460 = bitcast i8* %clsptr459 to { i8*, i8*, void (i8*, i8*, %Rational)*}*

; malloc environment structure
%envptr461 = call i8* @llvm_zone_malloc(%mzone* %zone458, i64 8)
%environment462 = bitcast i8* %envptr461 to {{i8*, i8*, void (i8*, i8*, %Rational)*}***}*

; malloc closure address table
%addytable463 = call %clsvar* @new_address_table()
%var464 = bitcast [33 x i8]* @gsxtmrational27 to i8*
%var465 = bitcast [42 x i8]* @gsxtmrational28 to i8*
%addytable466 = call %clsvar* @add_address_table(%mzone* %zone458, i8* %var464, i32 0, i8* %var465, i32 3, %clsvar* %addytable463)
%address-table467 = bitcast %clsvar* %addytable466 to i8*

; insert table, function and environment into closure struct
%closure.table470 = getelementptr { i8*, i8*, void (i8*, i8*, %Rational)*}, { i8*, i8*, void (i8*, i8*, %Rational)*}* %closure460, i32 0, i32 0
store i8* %address-table467, i8** %closure.table470
%closure.env471 = getelementptr { i8*, i8*, void (i8*, i8*, %Rational)*}, { i8*, i8*, void (i8*, i8*, %Rational)*}* %closure460, i32 0, i32 1
store i8* %envptr461, i8** %closure.env471
%closure.func472 = getelementptr { i8*, i8*, void (i8*, i8*, %Rational)*}, { i8*, i8*, void (i8*, i8*, %Rational)*}* %closure460, i32 0, i32 2
store void (i8*, i8*, %Rational)* @print_adhoc_W3ZvaWQsUmF0aW9uYWxd__444, void (i8*, i8*, %Rational)** %closure.func472
%closure_size473 = call i64 @llvm_zone_mark_size(%mzone* %zone458)
call void @llvm_zone_ptr_set_size(i8* %clsptr459, i64 %closure_size473)
%wrapper_ptr474 = call i8* @llvm_zone_malloc(%mzone* %zone458, i64 8)
%closure_wrapper475 = bitcast i8* %wrapper_ptr474 to { i8*, i8*, void (i8*, i8*, %Rational)*}**
store { i8*, i8*, void (i8*, i8*, %Rational)*}* %closure460, { i8*, i8*, void (i8*, i8*, %Rational)*}** %closure_wrapper475

; let value assignment
%print_adhoc_W3ZvaWQsUmF0aW9uYWxd = select i1 true, { i8*, i8*, void (i8*, i8*, %Rational)*}** %closure_wrapper475, { i8*, i8*, void (i8*, i8*, %Rational)*}** %closure_wrapper475
store { i8*, i8*, void (i8*, i8*, %Rational)*}** %print_adhoc_W3ZvaWQsUmF0aW9uYWxd, { i8*, i8*, void (i8*, i8*, %Rational)*}*** %print_adhoc_W3ZvaWQsUmF0aW9uYWxdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsUmF0aW9uYWxd
%tmp_envptr469 = getelementptr {{i8*, i8*, void (i8*, i8*, %Rational)*}***}, {{i8*, i8*, void (i8*, i8*, %Rational)*}***}* %environment462, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Rational)*}*** %print_adhoc_W3ZvaWQsUmF0aW9uYWxdPtr, {i8*, i8*, void (i8*, i8*, %Rational)*}**** %tmp_envptr469


%val478 = load {i8*, i8*, void (i8*, i8*, %Rational)*}**, {i8*, i8*, void (i8*, i8*, %Rational)*}*** %print_adhoc_W3ZvaWQsUmF0aW9uYWxdPtr
ret {i8*, i8*, void (i8*, i8*, %Rational)*}** %val478
}


@print_adhoc_W3ZvaWQsUmF0aW9uYWxd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsUmF0aW9uYWxd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsUmF0aW9uYWxd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsUmF0aW9uYWxd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Rational)*}** @print_adhoc_W3ZvaWQsUmF0aW9uYWxd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsUmF0aW9uYWxd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsUmF0aW9uYWxd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsUmF0aW9uYWxd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsUmF0aW9uYWxd(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rational)*}*, {i8*, i8*, void (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational)*}, {i8*, i8*, void (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational)*}, {i8*, i8*, void (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rational)*,  void (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsUmF0aW9uYWxd_native(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rational)*}*, {i8*, i8*, void (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational)*}, {i8*, i8*, void (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational)*}, {i8*, i8*, void (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rational)*,  void (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsUmF0aW9uYWxd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational}*
%arg_p_0 = getelementptr {%Rational}, {%Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Rational)*}*, {i8*, i8*, void (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational)*}, {i8*, i8*, void (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Rational)*}, {i8*, i8*, void (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Rational)*,  void (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational29 = hidden constant [35 x i8] c"rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0\00"
@gsxtmrational30 = hidden constant [44 x i8] c"{i8*, i8*, double (i8*, i8*, %Rational)*}**\00"
define dllexport fastcc double @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0__479(i8* %_impz,i8* %_impenv, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone480 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, %Rational)*}***}*
%rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, double (i8*, i8*, %Rational)*}***}, {{i8*, i8*, double (i8*, i8*, %Rational)*}***}* %impenv, i32 0, i32 0
%rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0Ptr = load {i8*, i8*, double (i8*, i8*, %Rational)*}***, {i8*, i8*, double (i8*, i8*, %Rational)*}**** %rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val481 = load %Rational, %Rational* %aPtr
; tuple ref
%val482 = extractvalue %Rational %val481, 0
%res483 = call ccc double @i64tod(i64 %val482)
%val484 = load %Rational, %Rational* %aPtr
; tuple ref
%val485 = extractvalue %Rational %val484, 1
%res486 = call ccc double @i64tod(i64 %val485)
%val487 = fdiv double %res483, %res486
ret double %val487
}
define dllexport ccc {i8*, i8*, double (i8*, i8*, %Rational)*}** @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone507 = load i8*, i8** %_impzPtr
%zone508 = bitcast i8* %tzone507 to %mzone*

; let assign value to symbol rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0
%dat_rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone508, i64 8)
%rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0Ptr = bitcast i8* %dat_rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0 to { i8*, i8*, double (i8*, i8*, %Rational)*}***
%tzone488 = load i8*, i8** %_impzPtr
%zone489 = bitcast i8* %tzone488 to %mzone*
call void @llvm_zone_mark(%mzone* %zone489)
; malloc closure structure
%clsptr490 = call i8* @llvm_zone_malloc(%mzone* %zone489, i64 24)
%closure491 = bitcast i8* %clsptr490 to { i8*, i8*, double (i8*, i8*, %Rational)*}*

; malloc environment structure
%envptr492 = call i8* @llvm_zone_malloc(%mzone* %zone489, i64 8)
%environment493 = bitcast i8* %envptr492 to {{i8*, i8*, double (i8*, i8*, %Rational)*}***}*

; malloc closure address table
%addytable494 = call %clsvar* @new_address_table()
%var495 = bitcast [35 x i8]* @gsxtmrational29 to i8*
%var496 = bitcast [44 x i8]* @gsxtmrational30 to i8*
%addytable497 = call %clsvar* @add_address_table(%mzone* %zone489, i8* %var495, i32 0, i8* %var496, i32 3, %clsvar* %addytable494)
%address-table498 = bitcast %clsvar* %addytable497 to i8*

; insert table, function and environment into closure struct
%closure.table501 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational)*}, { i8*, i8*, double (i8*, i8*, %Rational)*}* %closure491, i32 0, i32 0
store i8* %address-table498, i8** %closure.table501
%closure.env502 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational)*}, { i8*, i8*, double (i8*, i8*, %Rational)*}* %closure491, i32 0, i32 1
store i8* %envptr492, i8** %closure.env502
%closure.func503 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational)*}, { i8*, i8*, double (i8*, i8*, %Rational)*}* %closure491, i32 0, i32 2
store double (i8*, i8*, %Rational)* @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0__479, double (i8*, i8*, %Rational)** %closure.func503
%closure_size504 = call i64 @llvm_zone_mark_size(%mzone* %zone489)
call void @llvm_zone_ptr_set_size(i8* %clsptr490, i64 %closure_size504)
%wrapper_ptr505 = call i8* @llvm_zone_malloc(%mzone* %zone489, i64 8)
%closure_wrapper506 = bitcast i8* %wrapper_ptr505 to { i8*, i8*, double (i8*, i8*, %Rational)*}**
store { i8*, i8*, double (i8*, i8*, %Rational)*}* %closure491, { i8*, i8*, double (i8*, i8*, %Rational)*}** %closure_wrapper506

; let value assignment
%rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0 = select i1 true, { i8*, i8*, double (i8*, i8*, %Rational)*}** %closure_wrapper506, { i8*, i8*, double (i8*, i8*, %Rational)*}** %closure_wrapper506
store { i8*, i8*, double (i8*, i8*, %Rational)*}** %rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0, { i8*, i8*, double (i8*, i8*, %Rational)*}*** %rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0
%tmp_envptr500 = getelementptr {{i8*, i8*, double (i8*, i8*, %Rational)*}***}, {{i8*, i8*, double (i8*, i8*, %Rational)*}***}* %environment493, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, %Rational)*}*** %rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0Ptr, {i8*, i8*, double (i8*, i8*, %Rational)*}**** %tmp_envptr500


%val509 = load {i8*, i8*, double (i8*, i8*, %Rational)*}**, {i8*, i8*, double (i8*, i8*, %Rational)*}*** %rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0Ptr
ret {i8*, i8*, double (i8*, i8*, %Rational)*}** %val509
}


@rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, %Rational)*}** @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational)*}*, {i8*, i8*, double (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational)*}, {i8*, i8*, double (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational)*}, {i8*, i8*, double (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational)*,  double (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret double %result
}


define dllexport ccc double @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_native(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational)*}*, {i8*, i8*, double (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational)*}, {i8*, i8*, double (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational)*}, {i8*, i8*, double (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational)*,  double (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret double %result
}


define dllexport ccc void @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational}*
%arg_p_0 = getelementptr {%Rational}, {%Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational)*}*, {i8*, i8*, double (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational)*}, {i8*, i8*, double (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational)*}, {i8*, i8*, double (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational)*,  double (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational31 = hidden constant [34 x i8] c"rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ\00"
@gsxtmrational32 = hidden constant [43 x i8] c"{i8*, i8*, float (i8*, i8*, %Rational)*}**\00"
define dllexport fastcc float @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ__510(i8* %_impz,i8* %_impenv, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone511 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %Rational)*}***}*
%rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %Rational)*}***}, {{i8*, i8*, float (i8*, i8*, %Rational)*}***}* %impenv, i32 0, i32 0
%rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQPtr = load {i8*, i8*, float (i8*, i8*, %Rational)*}***, {i8*, i8*, float (i8*, i8*, %Rational)*}**** %rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val512 = load %Rational, %Rational* %aPtr
; tuple ref
%val513 = extractvalue %Rational %val512, 0
%res514 = call ccc float @i64tof(i64 %val513)
%val515 = load %Rational, %Rational* %aPtr
; tuple ref
%val516 = extractvalue %Rational %val515, 1
%res517 = call ccc float @i64tof(i64 %val516)
%val518 = fdiv float %res514, %res517
ret float %val518
}
define dllexport ccc {i8*, i8*, float (i8*, i8*, %Rational)*}** @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone538 = load i8*, i8** %_impzPtr
%zone539 = bitcast i8* %tzone538 to %mzone*

; let assign value to symbol rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ
%dat_rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone539, i64 8)
%rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQPtr = bitcast i8* %dat_rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ to { i8*, i8*, float (i8*, i8*, %Rational)*}***
%tzone519 = load i8*, i8** %_impzPtr
%zone520 = bitcast i8* %tzone519 to %mzone*
call void @llvm_zone_mark(%mzone* %zone520)
; malloc closure structure
%clsptr521 = call i8* @llvm_zone_malloc(%mzone* %zone520, i64 24)
%closure522 = bitcast i8* %clsptr521 to { i8*, i8*, float (i8*, i8*, %Rational)*}*

; malloc environment structure
%envptr523 = call i8* @llvm_zone_malloc(%mzone* %zone520, i64 8)
%environment524 = bitcast i8* %envptr523 to {{i8*, i8*, float (i8*, i8*, %Rational)*}***}*

; malloc closure address table
%addytable525 = call %clsvar* @new_address_table()
%var526 = bitcast [34 x i8]* @gsxtmrational31 to i8*
%var527 = bitcast [43 x i8]* @gsxtmrational32 to i8*
%addytable528 = call %clsvar* @add_address_table(%mzone* %zone520, i8* %var526, i32 0, i8* %var527, i32 3, %clsvar* %addytable525)
%address-table529 = bitcast %clsvar* %addytable528 to i8*

; insert table, function and environment into closure struct
%closure.table532 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational)*}, { i8*, i8*, float (i8*, i8*, %Rational)*}* %closure522, i32 0, i32 0
store i8* %address-table529, i8** %closure.table532
%closure.env533 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational)*}, { i8*, i8*, float (i8*, i8*, %Rational)*}* %closure522, i32 0, i32 1
store i8* %envptr523, i8** %closure.env533
%closure.func534 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational)*}, { i8*, i8*, float (i8*, i8*, %Rational)*}* %closure522, i32 0, i32 2
store float (i8*, i8*, %Rational)* @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ__510, float (i8*, i8*, %Rational)** %closure.func534
%closure_size535 = call i64 @llvm_zone_mark_size(%mzone* %zone520)
call void @llvm_zone_ptr_set_size(i8* %clsptr521, i64 %closure_size535)
%wrapper_ptr536 = call i8* @llvm_zone_malloc(%mzone* %zone520, i64 8)
%closure_wrapper537 = bitcast i8* %wrapper_ptr536 to { i8*, i8*, float (i8*, i8*, %Rational)*}**
store { i8*, i8*, float (i8*, i8*, %Rational)*}* %closure522, { i8*, i8*, float (i8*, i8*, %Rational)*}** %closure_wrapper537

; let value assignment
%rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, float (i8*, i8*, %Rational)*}** %closure_wrapper537, { i8*, i8*, float (i8*, i8*, %Rational)*}** %closure_wrapper537
store { i8*, i8*, float (i8*, i8*, %Rational)*}** %rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ, { i8*, i8*, float (i8*, i8*, %Rational)*}*** %rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ
%tmp_envptr531 = getelementptr {{i8*, i8*, float (i8*, i8*, %Rational)*}***}, {{i8*, i8*, float (i8*, i8*, %Rational)*}***}* %environment524, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %Rational)*}*** %rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQPtr, {i8*, i8*, float (i8*, i8*, %Rational)*}**** %tmp_envptr531


%val540 = load {i8*, i8*, float (i8*, i8*, %Rational)*}**, {i8*, i8*, float (i8*, i8*, %Rational)*}*** %rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQPtr
ret {i8*, i8*, float (i8*, i8*, %Rational)*}** %val540
}


@rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %Rational)*}** @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational)*}*, {i8*, i8*, float (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational)*}, {i8*, i8*, float (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational)*}, {i8*, i8*, float (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational)*,  float (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret float %result
}


define dllexport ccc float @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_native(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational)*}*, {i8*, i8*, float (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational)*}, {i8*, i8*, float (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational)*}, {i8*, i8*, float (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational)*,  float (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret float %result
}


define dllexport ccc void @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational}*
%arg_p_0 = getelementptr {%Rational}, {%Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtof_adhoc_W2Zsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational)*}*, {i8*, i8*, float (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational)*}, {i8*, i8*, float (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational)*}, {i8*, i8*, float (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational)*,  float (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational33 = hidden constant [33 x i8] c"rtoi64_adhoc_W2k2NCxSYXRpb25hbF0\00"
@gsxtmrational34 = hidden constant [41 x i8] c"{i8*, i8*, i64 (i8*, i8*, %Rational)*}**\00"
define dllexport fastcc i64 @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0__541(i8* %_impz,i8* %_impenv, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone542 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %Rational)*}***}*
%rtoi64_adhoc_W2k2NCxSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Rational)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Rational)*}***}* %impenv, i32 0, i32 0
%rtoi64_adhoc_W2k2NCxSYXRpb25hbF0Ptr = load {i8*, i8*, i64 (i8*, i8*, %Rational)*}***, {i8*, i8*, i64 (i8*, i8*, %Rational)*}**** %rtoi64_adhoc_W2k2NCxSYXRpb25hbF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val543 = load %Rational, %Rational* %aPtr
%res544 = call fastcc double @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0(%Rational %val543)
%res545 = call ccc i64 @dtoi64(double %res544)
ret i64 %res545
}
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %Rational)*}** @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone565 = load i8*, i8** %_impzPtr
%zone566 = bitcast i8* %tzone565 to %mzone*

; let assign value to symbol rtoi64_adhoc_W2k2NCxSYXRpb25hbF0
%dat_rtoi64_adhoc_W2k2NCxSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone566, i64 8)
%rtoi64_adhoc_W2k2NCxSYXRpb25hbF0Ptr = bitcast i8* %dat_rtoi64_adhoc_W2k2NCxSYXRpb25hbF0 to { i8*, i8*, i64 (i8*, i8*, %Rational)*}***
%tzone546 = load i8*, i8** %_impzPtr
%zone547 = bitcast i8* %tzone546 to %mzone*
call void @llvm_zone_mark(%mzone* %zone547)
; malloc closure structure
%clsptr548 = call i8* @llvm_zone_malloc(%mzone* %zone547, i64 24)
%closure549 = bitcast i8* %clsptr548 to { i8*, i8*, i64 (i8*, i8*, %Rational)*}*

; malloc environment structure
%envptr550 = call i8* @llvm_zone_malloc(%mzone* %zone547, i64 8)
%environment551 = bitcast i8* %envptr550 to {{i8*, i8*, i64 (i8*, i8*, %Rational)*}***}*

; malloc closure address table
%addytable552 = call %clsvar* @new_address_table()
%var553 = bitcast [33 x i8]* @gsxtmrational33 to i8*
%var554 = bitcast [41 x i8]* @gsxtmrational34 to i8*
%addytable555 = call %clsvar* @add_address_table(%mzone* %zone547, i8* %var553, i32 0, i8* %var554, i32 3, %clsvar* %addytable552)
%address-table556 = bitcast %clsvar* %addytable555 to i8*

; insert table, function and environment into closure struct
%closure.table559 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Rational)*}, { i8*, i8*, i64 (i8*, i8*, %Rational)*}* %closure549, i32 0, i32 0
store i8* %address-table556, i8** %closure.table559
%closure.env560 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Rational)*}, { i8*, i8*, i64 (i8*, i8*, %Rational)*}* %closure549, i32 0, i32 1
store i8* %envptr550, i8** %closure.env560
%closure.func561 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Rational)*}, { i8*, i8*, i64 (i8*, i8*, %Rational)*}* %closure549, i32 0, i32 2
store i64 (i8*, i8*, %Rational)* @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0__541, i64 (i8*, i8*, %Rational)** %closure.func561
%closure_size562 = call i64 @llvm_zone_mark_size(%mzone* %zone547)
call void @llvm_zone_ptr_set_size(i8* %clsptr548, i64 %closure_size562)
%wrapper_ptr563 = call i8* @llvm_zone_malloc(%mzone* %zone547, i64 8)
%closure_wrapper564 = bitcast i8* %wrapper_ptr563 to { i8*, i8*, i64 (i8*, i8*, %Rational)*}**
store { i8*, i8*, i64 (i8*, i8*, %Rational)*}* %closure549, { i8*, i8*, i64 (i8*, i8*, %Rational)*}** %closure_wrapper564

; let value assignment
%rtoi64_adhoc_W2k2NCxSYXRpb25hbF0 = select i1 true, { i8*, i8*, i64 (i8*, i8*, %Rational)*}** %closure_wrapper564, { i8*, i8*, i64 (i8*, i8*, %Rational)*}** %closure_wrapper564
store { i8*, i8*, i64 (i8*, i8*, %Rational)*}** %rtoi64_adhoc_W2k2NCxSYXRpb25hbF0, { i8*, i8*, i64 (i8*, i8*, %Rational)*}*** %rtoi64_adhoc_W2k2NCxSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var rtoi64_adhoc_W2k2NCxSYXRpb25hbF0
%tmp_envptr558 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Rational)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Rational)*}***}* %environment551, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %Rational)*}*** %rtoi64_adhoc_W2k2NCxSYXRpb25hbF0Ptr, {i8*, i8*, i64 (i8*, i8*, %Rational)*}**** %tmp_envptr558


%val567 = load {i8*, i8*, i64 (i8*, i8*, %Rational)*}**, {i8*, i8*, i64 (i8*, i8*, %Rational)*}*** %rtoi64_adhoc_W2k2NCxSYXRpb25hbF0Ptr
ret {i8*, i8*, i64 (i8*, i8*, %Rational)*}** %val567
}


@rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %Rational)*}** @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Rational)*}*, {i8*, i8*, i64 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Rational)*}, {i8*, i8*, i64 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Rational)*}, {i8*, i8*, i64 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Rational)*,  i64 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret i64 %result
}


define dllexport ccc i64 @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_native(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Rational)*}*, {i8*, i8*, i64 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Rational)*}, {i8*, i8*, i64 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Rational)*}, {i8*, i8*, i64 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Rational)*,  i64 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret i64 %result
}


define dllexport ccc void @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational}*
%arg_p_0 = getelementptr {%Rational}, {%Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi64_adhoc_W2k2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Rational)*}*, {i8*, i8*, i64 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Rational)*}, {i8*, i8*, i64 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Rational)*}, {i8*, i8*, i64 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Rational)*,  i64 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational35 = hidden constant [33 x i8] c"rtoi32_adhoc_W2kzMixSYXRpb25hbF0\00"
@gsxtmrational36 = hidden constant [41 x i8] c"{i8*, i8*, i32 (i8*, i8*, %Rational)*}**\00"
define dllexport fastcc i32 @rtoi32_adhoc_W2kzMixSYXRpb25hbF0__568(i8* %_impz,i8* %_impenv, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone569 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Rational)*}***}*
%rtoi32_adhoc_W2kzMixSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Rational)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Rational)*}***}* %impenv, i32 0, i32 0
%rtoi32_adhoc_W2kzMixSYXRpb25hbF0Ptr = load {i8*, i8*, i32 (i8*, i8*, %Rational)*}***, {i8*, i8*, i32 (i8*, i8*, %Rational)*}**** %rtoi32_adhoc_W2kzMixSYXRpb25hbF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val570 = load %Rational, %Rational* %aPtr
%res571 = call fastcc double @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0(%Rational %val570)
%res572 = call ccc i32 @dtoi32(double %res571)
ret i32 %res572
}
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Rational)*}** @rtoi32_adhoc_W2kzMixSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone592 = load i8*, i8** %_impzPtr
%zone593 = bitcast i8* %tzone592 to %mzone*

; let assign value to symbol rtoi32_adhoc_W2kzMixSYXRpb25hbF0
%dat_rtoi32_adhoc_W2kzMixSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone593, i64 8)
%rtoi32_adhoc_W2kzMixSYXRpb25hbF0Ptr = bitcast i8* %dat_rtoi32_adhoc_W2kzMixSYXRpb25hbF0 to { i8*, i8*, i32 (i8*, i8*, %Rational)*}***
%tzone573 = load i8*, i8** %_impzPtr
%zone574 = bitcast i8* %tzone573 to %mzone*
call void @llvm_zone_mark(%mzone* %zone574)
; malloc closure structure
%clsptr575 = call i8* @llvm_zone_malloc(%mzone* %zone574, i64 24)
%closure576 = bitcast i8* %clsptr575 to { i8*, i8*, i32 (i8*, i8*, %Rational)*}*

; malloc environment structure
%envptr577 = call i8* @llvm_zone_malloc(%mzone* %zone574, i64 8)
%environment578 = bitcast i8* %envptr577 to {{i8*, i8*, i32 (i8*, i8*, %Rational)*}***}*

; malloc closure address table
%addytable579 = call %clsvar* @new_address_table()
%var580 = bitcast [33 x i8]* @gsxtmrational35 to i8*
%var581 = bitcast [41 x i8]* @gsxtmrational36 to i8*
%addytable582 = call %clsvar* @add_address_table(%mzone* %zone574, i8* %var580, i32 0, i8* %var581, i32 3, %clsvar* %addytable579)
%address-table583 = bitcast %clsvar* %addytable582 to i8*

; insert table, function and environment into closure struct
%closure.table586 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Rational)*}, { i8*, i8*, i32 (i8*, i8*, %Rational)*}* %closure576, i32 0, i32 0
store i8* %address-table583, i8** %closure.table586
%closure.env587 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Rational)*}, { i8*, i8*, i32 (i8*, i8*, %Rational)*}* %closure576, i32 0, i32 1
store i8* %envptr577, i8** %closure.env587
%closure.func588 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Rational)*}, { i8*, i8*, i32 (i8*, i8*, %Rational)*}* %closure576, i32 0, i32 2
store i32 (i8*, i8*, %Rational)* @rtoi32_adhoc_W2kzMixSYXRpb25hbF0__568, i32 (i8*, i8*, %Rational)** %closure.func588
%closure_size589 = call i64 @llvm_zone_mark_size(%mzone* %zone574)
call void @llvm_zone_ptr_set_size(i8* %clsptr575, i64 %closure_size589)
%wrapper_ptr590 = call i8* @llvm_zone_malloc(%mzone* %zone574, i64 8)
%closure_wrapper591 = bitcast i8* %wrapper_ptr590 to { i8*, i8*, i32 (i8*, i8*, %Rational)*}**
store { i8*, i8*, i32 (i8*, i8*, %Rational)*}* %closure576, { i8*, i8*, i32 (i8*, i8*, %Rational)*}** %closure_wrapper591

; let value assignment
%rtoi32_adhoc_W2kzMixSYXRpb25hbF0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Rational)*}** %closure_wrapper591, { i8*, i8*, i32 (i8*, i8*, %Rational)*}** %closure_wrapper591
store { i8*, i8*, i32 (i8*, i8*, %Rational)*}** %rtoi32_adhoc_W2kzMixSYXRpb25hbF0, { i8*, i8*, i32 (i8*, i8*, %Rational)*}*** %rtoi32_adhoc_W2kzMixSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var rtoi32_adhoc_W2kzMixSYXRpb25hbF0
%tmp_envptr585 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Rational)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Rational)*}***}* %environment578, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Rational)*}*** %rtoi32_adhoc_W2kzMixSYXRpb25hbF0Ptr, {i8*, i8*, i32 (i8*, i8*, %Rational)*}**** %tmp_envptr585


%val594 = load {i8*, i8*, i32 (i8*, i8*, %Rational)*}**, {i8*, i8*, i32 (i8*, i8*, %Rational)*}*** %rtoi32_adhoc_W2kzMixSYXRpb25hbF0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %Rational)*}** %val594
}


@rtoi32_adhoc_W2kzMixSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@rtoi32_adhoc_W2kzMixSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @rtoi32_adhoc_W2kzMixSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @rtoi32_adhoc_W2kzMixSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Rational)*}** @rtoi32_adhoc_W2kzMixSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @rtoi32_adhoc_W2kzMixSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @rtoi32_adhoc_W2kzMixSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi32_adhoc_W2kzMixSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @rtoi32_adhoc_W2kzMixSYXRpb25hbF0(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi32_adhoc_W2kzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Rational)*}*, {i8*, i8*, i32 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Rational)*}, {i8*, i8*, i32 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Rational)*}, {i8*, i8*, i32 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Rational)*,  i32 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret i32 %result
}


define dllexport ccc i32 @rtoi32_adhoc_W2kzMixSYXRpb25hbF0_native(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi32_adhoc_W2kzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Rational)*}*, {i8*, i8*, i32 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Rational)*}, {i8*, i8*, i32 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Rational)*}, {i8*, i8*, i32 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Rational)*,  i32 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret i32 %result
}


define dllexport ccc void @rtoi32_adhoc_W2kzMixSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational}*
%arg_p_0 = getelementptr {%Rational}, {%Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi32_adhoc_W2kzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Rational)*}*, {i8*, i8*, i32 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Rational)*}, {i8*, i8*, i32 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Rational)*}, {i8*, i8*, i32 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Rational)*,  i32 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational37 = hidden constant [33 x i8] c"rtoi16_adhoc_W2kxNixSYXRpb25hbF0\00"
@gsxtmrational38 = hidden constant [41 x i8] c"{i8*, i8*, i16 (i8*, i8*, %Rational)*}**\00"
define dllexport fastcc i16 @rtoi16_adhoc_W2kxNixSYXRpb25hbF0__595(i8* %_impz,i8* %_impenv, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone596 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i16 (i8*, i8*, %Rational)*}***}*
%rtoi16_adhoc_W2kxNixSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, i16 (i8*, i8*, %Rational)*}***}, {{i8*, i8*, i16 (i8*, i8*, %Rational)*}***}* %impenv, i32 0, i32 0
%rtoi16_adhoc_W2kxNixSYXRpb25hbF0Ptr = load {i8*, i8*, i16 (i8*, i8*, %Rational)*}***, {i8*, i8*, i16 (i8*, i8*, %Rational)*}**** %rtoi16_adhoc_W2kxNixSYXRpb25hbF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val597 = load %Rational, %Rational* %aPtr
%res598 = call fastcc double @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0(%Rational %val597)
%res599 = call ccc i16 @dtoi16(double %res598)
ret i16 %res599
}
define dllexport ccc {i8*, i8*, i16 (i8*, i8*, %Rational)*}** @rtoi16_adhoc_W2kxNixSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone619 = load i8*, i8** %_impzPtr
%zone620 = bitcast i8* %tzone619 to %mzone*

; let assign value to symbol rtoi16_adhoc_W2kxNixSYXRpb25hbF0
%dat_rtoi16_adhoc_W2kxNixSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone620, i64 8)
%rtoi16_adhoc_W2kxNixSYXRpb25hbF0Ptr = bitcast i8* %dat_rtoi16_adhoc_W2kxNixSYXRpb25hbF0 to { i8*, i8*, i16 (i8*, i8*, %Rational)*}***
%tzone600 = load i8*, i8** %_impzPtr
%zone601 = bitcast i8* %tzone600 to %mzone*
call void @llvm_zone_mark(%mzone* %zone601)
; malloc closure structure
%clsptr602 = call i8* @llvm_zone_malloc(%mzone* %zone601, i64 24)
%closure603 = bitcast i8* %clsptr602 to { i8*, i8*, i16 (i8*, i8*, %Rational)*}*

; malloc environment structure
%envptr604 = call i8* @llvm_zone_malloc(%mzone* %zone601, i64 8)
%environment605 = bitcast i8* %envptr604 to {{i8*, i8*, i16 (i8*, i8*, %Rational)*}***}*

; malloc closure address table
%addytable606 = call %clsvar* @new_address_table()
%var607 = bitcast [33 x i8]* @gsxtmrational37 to i8*
%var608 = bitcast [41 x i8]* @gsxtmrational38 to i8*
%addytable609 = call %clsvar* @add_address_table(%mzone* %zone601, i8* %var607, i32 0, i8* %var608, i32 3, %clsvar* %addytable606)
%address-table610 = bitcast %clsvar* %addytable609 to i8*

; insert table, function and environment into closure struct
%closure.table613 = getelementptr { i8*, i8*, i16 (i8*, i8*, %Rational)*}, { i8*, i8*, i16 (i8*, i8*, %Rational)*}* %closure603, i32 0, i32 0
store i8* %address-table610, i8** %closure.table613
%closure.env614 = getelementptr { i8*, i8*, i16 (i8*, i8*, %Rational)*}, { i8*, i8*, i16 (i8*, i8*, %Rational)*}* %closure603, i32 0, i32 1
store i8* %envptr604, i8** %closure.env614
%closure.func615 = getelementptr { i8*, i8*, i16 (i8*, i8*, %Rational)*}, { i8*, i8*, i16 (i8*, i8*, %Rational)*}* %closure603, i32 0, i32 2
store i16 (i8*, i8*, %Rational)* @rtoi16_adhoc_W2kxNixSYXRpb25hbF0__595, i16 (i8*, i8*, %Rational)** %closure.func615
%closure_size616 = call i64 @llvm_zone_mark_size(%mzone* %zone601)
call void @llvm_zone_ptr_set_size(i8* %clsptr602, i64 %closure_size616)
%wrapper_ptr617 = call i8* @llvm_zone_malloc(%mzone* %zone601, i64 8)
%closure_wrapper618 = bitcast i8* %wrapper_ptr617 to { i8*, i8*, i16 (i8*, i8*, %Rational)*}**
store { i8*, i8*, i16 (i8*, i8*, %Rational)*}* %closure603, { i8*, i8*, i16 (i8*, i8*, %Rational)*}** %closure_wrapper618

; let value assignment
%rtoi16_adhoc_W2kxNixSYXRpb25hbF0 = select i1 true, { i8*, i8*, i16 (i8*, i8*, %Rational)*}** %closure_wrapper618, { i8*, i8*, i16 (i8*, i8*, %Rational)*}** %closure_wrapper618
store { i8*, i8*, i16 (i8*, i8*, %Rational)*}** %rtoi16_adhoc_W2kxNixSYXRpb25hbF0, { i8*, i8*, i16 (i8*, i8*, %Rational)*}*** %rtoi16_adhoc_W2kxNixSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var rtoi16_adhoc_W2kxNixSYXRpb25hbF0
%tmp_envptr612 = getelementptr {{i8*, i8*, i16 (i8*, i8*, %Rational)*}***}, {{i8*, i8*, i16 (i8*, i8*, %Rational)*}***}* %environment605, i32 0, i32 0
store {i8*, i8*, i16 (i8*, i8*, %Rational)*}*** %rtoi16_adhoc_W2kxNixSYXRpb25hbF0Ptr, {i8*, i8*, i16 (i8*, i8*, %Rational)*}**** %tmp_envptr612


%val621 = load {i8*, i8*, i16 (i8*, i8*, %Rational)*}**, {i8*, i8*, i16 (i8*, i8*, %Rational)*}*** %rtoi16_adhoc_W2kxNixSYXRpb25hbF0Ptr
ret {i8*, i8*, i16 (i8*, i8*, %Rational)*}** %val621
}


@rtoi16_adhoc_W2kxNixSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@rtoi16_adhoc_W2kxNixSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @rtoi16_adhoc_W2kxNixSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @rtoi16_adhoc_W2kxNixSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i16 (i8*, i8*, %Rational)*}** @rtoi16_adhoc_W2kxNixSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i16 (i8*, i8*, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @rtoi16_adhoc_W2kxNixSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @rtoi16_adhoc_W2kxNixSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi16_adhoc_W2kxNixSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i16 @rtoi16_adhoc_W2kxNixSYXRpb25hbF0(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi16_adhoc_W2kxNixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i16 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i16 (i8*, i8*, %Rational)*}*, {i8*, i8*, i16 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i16 (i8*, i8*, %Rational)*}, {i8*, i8*, i16 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i16 (i8*, i8*, %Rational)*}, {i8*, i8*, i16 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i16 (i8*, i8*, %Rational)*,  i16 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i16 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret i16 %result
}


define dllexport ccc i16 @rtoi16_adhoc_W2kxNixSYXRpb25hbF0_native(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi16_adhoc_W2kxNixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i16 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i16 (i8*, i8*, %Rational)*}*, {i8*, i8*, i16 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i16 (i8*, i8*, %Rational)*}, {i8*, i8*, i16 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i16 (i8*, i8*, %Rational)*}, {i8*, i8*, i16 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i16 (i8*, i8*, %Rational)*,  i16 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i16 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret i16 %result
}


define dllexport ccc void @rtoi16_adhoc_W2kxNixSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational}*
%arg_p_0 = getelementptr {%Rational}, {%Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi16_adhoc_W2kxNixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i16 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i16 (i8*, i8*, %Rational)*}*, {i8*, i8*, i16 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i16 (i8*, i8*, %Rational)*}, {i8*, i8*, i16 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i16 (i8*, i8*, %Rational)*}, {i8*, i8*, i16 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i16 (i8*, i8*, %Rational)*,  i16 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i16 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational39 = hidden constant [31 x i8] c"rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ\00"
@gsxtmrational40 = hidden constant [40 x i8] c"{i8*, i8*, i8 (i8*, i8*, %Rational)*}**\00"
define dllexport fastcc i8 @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ__622(i8* %_impz,i8* %_impenv, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone623 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8 (i8*, i8*, %Rational)*}***}*
%rtoi8_adhoc_W2k4LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i8 (i8*, i8*, %Rational)*}***}, {{i8*, i8*, i8 (i8*, i8*, %Rational)*}***}* %impenv, i32 0, i32 0
%rtoi8_adhoc_W2k4LFJhdGlvbmFsXQPtr = load {i8*, i8*, i8 (i8*, i8*, %Rational)*}***, {i8*, i8*, i8 (i8*, i8*, %Rational)*}**** %rtoi8_adhoc_W2k4LFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val624 = load %Rational, %Rational* %aPtr
%res625 = call fastcc double @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0(%Rational %val624)
%res626 = call ccc i8 @dtoi8(double %res625)
ret i8 %res626
}
define dllexport ccc {i8*, i8*, i8 (i8*, i8*, %Rational)*}** @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone646 = load i8*, i8** %_impzPtr
%zone647 = bitcast i8* %tzone646 to %mzone*

; let assign value to symbol rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ
%dat_rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone647, i64 8)
%rtoi8_adhoc_W2k4LFJhdGlvbmFsXQPtr = bitcast i8* %dat_rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ to { i8*, i8*, i8 (i8*, i8*, %Rational)*}***
%tzone627 = load i8*, i8** %_impzPtr
%zone628 = bitcast i8* %tzone627 to %mzone*
call void @llvm_zone_mark(%mzone* %zone628)
; malloc closure structure
%clsptr629 = call i8* @llvm_zone_malloc(%mzone* %zone628, i64 24)
%closure630 = bitcast i8* %clsptr629 to { i8*, i8*, i8 (i8*, i8*, %Rational)*}*

; malloc environment structure
%envptr631 = call i8* @llvm_zone_malloc(%mzone* %zone628, i64 8)
%environment632 = bitcast i8* %envptr631 to {{i8*, i8*, i8 (i8*, i8*, %Rational)*}***}*

; malloc closure address table
%addytable633 = call %clsvar* @new_address_table()
%var634 = bitcast [31 x i8]* @gsxtmrational39 to i8*
%var635 = bitcast [40 x i8]* @gsxtmrational40 to i8*
%addytable636 = call %clsvar* @add_address_table(%mzone* %zone628, i8* %var634, i32 0, i8* %var635, i32 3, %clsvar* %addytable633)
%address-table637 = bitcast %clsvar* %addytable636 to i8*

; insert table, function and environment into closure struct
%closure.table640 = getelementptr { i8*, i8*, i8 (i8*, i8*, %Rational)*}, { i8*, i8*, i8 (i8*, i8*, %Rational)*}* %closure630, i32 0, i32 0
store i8* %address-table637, i8** %closure.table640
%closure.env641 = getelementptr { i8*, i8*, i8 (i8*, i8*, %Rational)*}, { i8*, i8*, i8 (i8*, i8*, %Rational)*}* %closure630, i32 0, i32 1
store i8* %envptr631, i8** %closure.env641
%closure.func642 = getelementptr { i8*, i8*, i8 (i8*, i8*, %Rational)*}, { i8*, i8*, i8 (i8*, i8*, %Rational)*}* %closure630, i32 0, i32 2
store i8 (i8*, i8*, %Rational)* @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ__622, i8 (i8*, i8*, %Rational)** %closure.func642
%closure_size643 = call i64 @llvm_zone_mark_size(%mzone* %zone628)
call void @llvm_zone_ptr_set_size(i8* %clsptr629, i64 %closure_size643)
%wrapper_ptr644 = call i8* @llvm_zone_malloc(%mzone* %zone628, i64 8)
%closure_wrapper645 = bitcast i8* %wrapper_ptr644 to { i8*, i8*, i8 (i8*, i8*, %Rational)*}**
store { i8*, i8*, i8 (i8*, i8*, %Rational)*}* %closure630, { i8*, i8*, i8 (i8*, i8*, %Rational)*}** %closure_wrapper645

; let value assignment
%rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i8 (i8*, i8*, %Rational)*}** %closure_wrapper645, { i8*, i8*, i8 (i8*, i8*, %Rational)*}** %closure_wrapper645
store { i8*, i8*, i8 (i8*, i8*, %Rational)*}** %rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ, { i8*, i8*, i8 (i8*, i8*, %Rational)*}*** %rtoi8_adhoc_W2k4LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ
%tmp_envptr639 = getelementptr {{i8*, i8*, i8 (i8*, i8*, %Rational)*}***}, {{i8*, i8*, i8 (i8*, i8*, %Rational)*}***}* %environment632, i32 0, i32 0
store {i8*, i8*, i8 (i8*, i8*, %Rational)*}*** %rtoi8_adhoc_W2k4LFJhdGlvbmFsXQPtr, {i8*, i8*, i8 (i8*, i8*, %Rational)*}**** %tmp_envptr639


%val648 = load {i8*, i8*, i8 (i8*, i8*, %Rational)*}**, {i8*, i8*, i8 (i8*, i8*, %Rational)*}*** %rtoi8_adhoc_W2k4LFJhdGlvbmFsXQPtr
ret {i8*, i8*, i8 (i8*, i8*, %Rational)*}** %val648
}


@rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8 (i8*, i8*, %Rational)*}** @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8 (i8*, i8*, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8 @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i8 (i8*, i8*, %Rational)*}*, {i8*, i8*, i8 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8 (i8*, i8*, %Rational)*}, {i8*, i8*, i8 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8 (i8*, i8*, %Rational)*}, {i8*, i8*, i8 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i8 (i8*, i8*, %Rational)*,  i8 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret i8 %result
}


define dllexport ccc i8 @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_native(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i8 (i8*, i8*, %Rational)*}*, {i8*, i8*, i8 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8 (i8*, i8*, %Rational)*}, {i8*, i8*, i8 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8 (i8*, i8*, %Rational)*}, {i8*, i8*, i8 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i8 (i8*, i8*, %Rational)*,  i8 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret i8 %result
}


define dllexport ccc void @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational}*
%arg_p_0 = getelementptr {%Rational}, {%Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi8_adhoc_W2k4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i8 (i8*, i8*, %Rational)*}*, {i8*, i8*, i8 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8 (i8*, i8*, %Rational)*}, {i8*, i8*, i8 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8 (i8*, i8*, %Rational)*}, {i8*, i8*, i8 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i8 (i8*, i8*, %Rational)*,  i8 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational41 = hidden constant [31 x i8] c"rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ\00"
@gsxtmrational42 = hidden constant [40 x i8] c"{i8*, i8*, i1 (i8*, i8*, %Rational)*}**\00"
define dllexport fastcc i1 @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ__649(i8* %_impz,i8* %_impenv, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone650 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational)*}***}*
%rtoi1_adhoc_W2kxLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational)*}***}* %impenv, i32 0, i32 0
%rtoi1_adhoc_W2kxLFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational)*}**** %rtoi1_adhoc_W2kxLFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val651 = load %Rational, %Rational* %aPtr
%res652 = call fastcc double @rtod_adhoc_W2RvdWJsZSxSYXRpb25hbF0(%Rational %val651)
%res653 = call ccc i1 @dtoi1(double %res652)
ret i1 %res653
}
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational)*}** @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone673 = load i8*, i8** %_impzPtr
%zone674 = bitcast i8* %tzone673 to %mzone*

; let assign value to symbol rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ
%dat_rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone674, i64 8)
%rtoi1_adhoc_W2kxLFJhdGlvbmFsXQPtr = bitcast i8* %dat_rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, %Rational)*}***
%tzone654 = load i8*, i8** %_impzPtr
%zone655 = bitcast i8* %tzone654 to %mzone*
call void @llvm_zone_mark(%mzone* %zone655)
; malloc closure structure
%clsptr656 = call i8* @llvm_zone_malloc(%mzone* %zone655, i64 24)
%closure657 = bitcast i8* %clsptr656 to { i8*, i8*, i1 (i8*, i8*, %Rational)*}*

; malloc environment structure
%envptr658 = call i8* @llvm_zone_malloc(%mzone* %zone655, i64 8)
%environment659 = bitcast i8* %envptr658 to {{i8*, i8*, i1 (i8*, i8*, %Rational)*}***}*

; malloc closure address table
%addytable660 = call %clsvar* @new_address_table()
%var661 = bitcast [31 x i8]* @gsxtmrational41 to i8*
%var662 = bitcast [40 x i8]* @gsxtmrational42 to i8*
%addytable663 = call %clsvar* @add_address_table(%mzone* %zone655, i8* %var661, i32 0, i8* %var662, i32 3, %clsvar* %addytable660)
%address-table664 = bitcast %clsvar* %addytable663 to i8*

; insert table, function and environment into closure struct
%closure.table667 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational)*}* %closure657, i32 0, i32 0
store i8* %address-table664, i8** %closure.table667
%closure.env668 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational)*}* %closure657, i32 0, i32 1
store i8* %envptr658, i8** %closure.env668
%closure.func669 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational)*}* %closure657, i32 0, i32 2
store i1 (i8*, i8*, %Rational)* @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ__649, i1 (i8*, i8*, %Rational)** %closure.func669
%closure_size670 = call i64 @llvm_zone_mark_size(%mzone* %zone655)
call void @llvm_zone_ptr_set_size(i8* %clsptr656, i64 %closure_size670)
%wrapper_ptr671 = call i8* @llvm_zone_malloc(%mzone* %zone655, i64 8)
%closure_wrapper672 = bitcast i8* %wrapper_ptr671 to { i8*, i8*, i1 (i8*, i8*, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational)*}* %closure657, { i8*, i8*, i1 (i8*, i8*, %Rational)*}** %closure_wrapper672

; let value assignment
%rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational)*}** %closure_wrapper672, { i8*, i8*, i1 (i8*, i8*, %Rational)*}** %closure_wrapper672
store { i8*, i8*, i1 (i8*, i8*, %Rational)*}** %rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, %Rational)*}*** %rtoi1_adhoc_W2kxLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ
%tmp_envptr666 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational)*}***}* %environment659, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational)*}*** %rtoi1_adhoc_W2kxLFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational)*}**** %tmp_envptr666


%val675 = load {i8*, i8*, i1 (i8*, i8*, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational)*}*** %rtoi1_adhoc_W2kxLFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational)*}** %val675
}


@rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational)*}** @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational)*,  i1 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret i1 %result
}


define dllexport ccc i1 @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_native(%Rational %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational)*,  i1 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
ret i1 %result
}


define dllexport ccc void @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational}*
%arg_p_0 = getelementptr {%Rational}, {%Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @rtoi1_adhoc_W2kxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational)*,  i1 (i8*, i8*, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational43 = hidden constant [64 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ\00"
@gsxtmrational44 = hidden constant [58 x i8] c"{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**\00"
define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ__676(i8* %_impz,i8* %_impenv, %Rational %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone677 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}*
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%val678 = load %Rational, %Rational* %aPtr
; tuple ref
%val679 = extractvalue %Rational %val678, 0
%val680 = load %Rational, %Rational* %bPtr
; tuple ref
%val681 = extractvalue %Rational %val680, 0
%val682 = mul i64 %val679, %val681
%val683 = load %Rational, %Rational* %aPtr
; tuple ref
%val684 = extractvalue %Rational %val683, 1
%val685 = load %Rational, %Rational* %bPtr
; tuple ref
%val686 = extractvalue %Rational %val685, 1
%val687 = mul i64 %val684, %val686
%res688 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val682, i64 %val687)
%res689 = call fastcc %Rational @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res688)
ret %Rational %res689
}
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone709 = load i8*, i8** %_impzPtr
%zone710 = bitcast i8* %tzone709 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ
%dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone710, i64 8)
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***
%tzone690 = load i8*, i8** %_impzPtr
%zone691 = bitcast i8* %tzone690 to %mzone*
call void @llvm_zone_mark(%mzone* %zone691)
; malloc closure structure
%clsptr692 = call i8* @llvm_zone_malloc(%mzone* %zone691, i64 24)
%closure693 = bitcast i8* %clsptr692 to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*

; malloc environment structure
%envptr694 = call i8* @llvm_zone_malloc(%mzone* %zone691, i64 8)
%environment695 = bitcast i8* %envptr694 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}*

; malloc closure address table
%addytable696 = call %clsvar* @new_address_table()
%var697 = bitcast [64 x i8]* @gsxtmrational43 to i8*
%var698 = bitcast [58 x i8]* @gsxtmrational44 to i8*
%addytable699 = call %clsvar* @add_address_table(%mzone* %zone691, i8* %var697, i32 0, i8* %var698, i32 3, %clsvar* %addytable696)
%address-table700 = bitcast %clsvar* %addytable699 to i8*

; insert table, function and environment into closure struct
%closure.table703 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure693, i32 0, i32 0
store i8* %address-table700, i8** %closure.table703
%closure.env704 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure693, i32 0, i32 1
store i8* %envptr694, i8** %closure.env704
%closure.func705 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure693, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, %Rational)* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ__676, %Rational (i8*, i8*, %Rational, %Rational)** %closure.func705
%closure_size706 = call i64 @llvm_zone_mark_size(%mzone* %zone691)
call void @llvm_zone_ptr_set_size(i8* %clsptr692, i64 %closure_size706)
%wrapper_ptr707 = call i8* @llvm_zone_malloc(%mzone* %zone691, i64 8)
%closure_wrapper708 = bitcast i8* %wrapper_ptr707 to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure693, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper708

; let value assignment
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper708, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper708
store { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ
%tmp_envptr702 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}* %environment695, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**** %tmp_envptr702


%val711 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %val711
}


@xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_native(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, %Rational}*
%arg_p_0 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational45 = hidden constant [57 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0\00"
@gsxtmrational46 = hidden constant [52 x i8] c"{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**\00"
define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0__712(i8* %_impz,i8* %_impenv, %Rational %a, i64 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone713 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}*
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i64
store i64 %b, i64* %bPtr


%val714 = load %Rational, %Rational* %aPtr
; tuple ref
%val715 = extractvalue %Rational %val714, 0
%val716 = load i64, i64* %bPtr
%val717 = mul i64 %val715, %val716
%val718 = load %Rational, %Rational* %aPtr
; tuple ref
%val719 = extractvalue %Rational %val718, 1
%val720 = mul i64 %val719, 1
%res721 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val717, i64 %val720)
ret %Rational %res721
}
@gsxtmrational47 = hidden constant [110 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone741 = load i8*, i8** %_impzPtr
%zone742 = bitcast i8* %tzone741 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0
%dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone742, i64 8)
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr = bitcast i8* %dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***
%tzone722 = load i8*, i8** %_impzPtr
%zone723 = bitcast i8* %tzone722 to %mzone*
call void @llvm_zone_mark(%mzone* %zone723)
; malloc closure structure
%clsptr724 = call i8* @llvm_zone_malloc(%mzone* %zone723, i64 24)
%closure725 = bitcast i8* %clsptr724 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*

; malloc environment structure
%envptr726 = call i8* @llvm_zone_malloc(%mzone* %zone723, i64 8)
%environment727 = bitcast i8* %envptr726 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}*

; malloc closure address table
%addytable728 = call %clsvar* @new_address_table()
%var729 = bitcast [57 x i8]* @gsxtmrational45 to i8*
%var730 = bitcast [52 x i8]* @gsxtmrational46 to i8*
%addytable731 = call %clsvar* @add_address_table(%mzone* %zone723, i8* %var729, i32 0, i8* %var730, i32 3, %clsvar* %addytable728)
%address-table732 = bitcast %clsvar* %addytable731 to i8*

; insert table, function and environment into closure struct
%closure.table735 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure725, i32 0, i32 0
store i8* %address-table732, i8** %closure.table735
%closure.env736 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure725, i32 0, i32 1
store i8* %envptr726, i8** %closure.env736
%closure.func737 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure725, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i64)* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0__712, %Rational (i8*, i8*, %Rational, i64)** %closure.func737
%closure_size738 = call i64 @llvm_zone_mark_size(%mzone* %zone723)
call void @llvm_zone_ptr_set_size(i8* %clsptr724, i64 %closure_size738)
%wrapper_ptr739 = call i8* @llvm_zone_malloc(%mzone* %zone723, i64 8)
%closure_wrapper740 = bitcast i8* %wrapper_ptr739 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure725, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper740

; let value assignment
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper740, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper740
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0
%tmp_envptr734 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}* %environment727, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**** %tmp_envptr734


%val743 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %val743
}


@xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_native(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i64}*
%arg_p_0 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational48 = hidden constant [57 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0\00"
@gsxtmrational49 = hidden constant [52 x i8] c"{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**\00"
define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0__745(i8* %_impz,i8* %_impenv, i64 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone746 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}*
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i64
store i64 %b, i64* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val747 = load %Rational, %Rational* %aPtr
; tuple ref
%val748 = extractvalue %Rational %val747, 0
%val749 = load i64, i64* %bPtr
%val750 = mul i64 %val748, %val749
%val751 = load %Rational, %Rational* %aPtr
; tuple ref
%val752 = extractvalue %Rational %val751, 1
%val753 = mul i64 %val752, 1
%res754 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val750, i64 %val753)
ret %Rational %res754
}
@gsxtmrational50 = hidden constant [110 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone774 = load i8*, i8** %_impzPtr
%zone775 = bitcast i8* %tzone774 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0
%dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone775, i64 8)
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***
%tzone755 = load i8*, i8** %_impzPtr
%zone756 = bitcast i8* %tzone755 to %mzone*
call void @llvm_zone_mark(%mzone* %zone756)
; malloc closure structure
%clsptr757 = call i8* @llvm_zone_malloc(%mzone* %zone756, i64 24)
%closure758 = bitcast i8* %clsptr757 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*

; malloc environment structure
%envptr759 = call i8* @llvm_zone_malloc(%mzone* %zone756, i64 8)
%environment760 = bitcast i8* %envptr759 to {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}*

; malloc closure address table
%addytable761 = call %clsvar* @new_address_table()
%var762 = bitcast [57 x i8]* @gsxtmrational48 to i8*
%var763 = bitcast [52 x i8]* @gsxtmrational49 to i8*
%addytable764 = call %clsvar* @add_address_table(%mzone* %zone756, i8* %var762, i32 0, i8* %var763, i32 3, %clsvar* %addytable761)
%address-table765 = bitcast %clsvar* %addytable764 to i8*

; insert table, function and environment into closure struct
%closure.table768 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure758, i32 0, i32 0
store i8* %address-table765, i8** %closure.table768
%closure.env769 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure758, i32 0, i32 1
store i8* %envptr759, i8** %closure.env769
%closure.func770 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure758, i32 0, i32 2
store %Rational (i8*, i8*, i64, %Rational)* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0__745, %Rational (i8*, i8*, i64, %Rational)** %closure.func770
%closure_size771 = call i64 @llvm_zone_mark_size(%mzone* %zone756)
call void @llvm_zone_ptr_set_size(i8* %clsptr757, i64 %closure_size771)
%wrapper_ptr772 = call i8* @llvm_zone_malloc(%mzone* %zone756, i64 8)
%closure_wrapper773 = bitcast i8* %wrapper_ptr772 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure758, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper773

; let value assignment
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper773, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper773
store { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0
%tmp_envptr767 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}* %environment760, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**** %tmp_envptr767


%val776 = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %val776
}


@xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_native(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, %Rational}*
%arg_p_0 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational51 = hidden constant [57 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0\00"
@gsxtmrational52 = hidden constant [52 x i8] c"{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**\00"
define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0__778(i8* %_impz,i8* %_impenv, %Rational %a, i32 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone779 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}*
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i32
store i32 %b, i32* %bPtr


%val780 = load %Rational, %Rational* %aPtr
; tuple ref
%val781 = extractvalue %Rational %val780, 0
%val782 = load i32, i32* %bPtr
%res783 = call ccc i64 @i32toi64(i32 %val782)
%val784 = mul i64 %val781, %res783
%val785 = load %Rational, %Rational* %aPtr
; tuple ref
%val786 = extractvalue %Rational %val785, 1
%val787 = mul i64 %val786, 1
%res788 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val784, i64 %val787)
ret %Rational %res788
}
@gsxtmrational53 = hidden constant [110 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone808 = load i8*, i8** %_impzPtr
%zone809 = bitcast i8* %tzone808 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0
%dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone809, i64 8)
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr = bitcast i8* %dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***
%tzone789 = load i8*, i8** %_impzPtr
%zone790 = bitcast i8* %tzone789 to %mzone*
call void @llvm_zone_mark(%mzone* %zone790)
; malloc closure structure
%clsptr791 = call i8* @llvm_zone_malloc(%mzone* %zone790, i64 24)
%closure792 = bitcast i8* %clsptr791 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*

; malloc environment structure
%envptr793 = call i8* @llvm_zone_malloc(%mzone* %zone790, i64 8)
%environment794 = bitcast i8* %envptr793 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}*

; malloc closure address table
%addytable795 = call %clsvar* @new_address_table()
%var796 = bitcast [57 x i8]* @gsxtmrational51 to i8*
%var797 = bitcast [52 x i8]* @gsxtmrational52 to i8*
%addytable798 = call %clsvar* @add_address_table(%mzone* %zone790, i8* %var796, i32 0, i8* %var797, i32 3, %clsvar* %addytable795)
%address-table799 = bitcast %clsvar* %addytable798 to i8*

; insert table, function and environment into closure struct
%closure.table802 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure792, i32 0, i32 0
store i8* %address-table799, i8** %closure.table802
%closure.env803 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure792, i32 0, i32 1
store i8* %envptr793, i8** %closure.env803
%closure.func804 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure792, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i32)* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0__778, %Rational (i8*, i8*, %Rational, i32)** %closure.func804
%closure_size805 = call i64 @llvm_zone_mark_size(%mzone* %zone790)
call void @llvm_zone_ptr_set_size(i8* %clsptr791, i64 %closure_size805)
%wrapper_ptr806 = call i8* @llvm_zone_malloc(%mzone* %zone790, i64 8)
%closure_wrapper807 = bitcast i8* %wrapper_ptr806 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure792, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper807

; let value assignment
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper807, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper807
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0
%tmp_envptr801 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}* %environment794, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**** %tmp_envptr801


%val810 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %val810
}


@xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_native(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i32}*
%arg_p_0 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational54 = hidden constant [57 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0\00"
@gsxtmrational55 = hidden constant [52 x i8] c"{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**\00"
define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0__812(i8* %_impz,i8* %_impenv, i32 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone813 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}*
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i32
store i32 %b, i32* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val814 = load %Rational, %Rational* %aPtr
; tuple ref
%val815 = extractvalue %Rational %val814, 0
%val816 = load i32, i32* %bPtr
%res817 = call ccc i64 @i32toi64(i32 %val816)
%val818 = mul i64 %val815, %res817
%val819 = load %Rational, %Rational* %aPtr
; tuple ref
%val820 = extractvalue %Rational %val819, 1
%val821 = mul i64 %val820, 1
%res822 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val818, i64 %val821)
ret %Rational %res822
}
@gsxtmrational56 = hidden constant [110 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone842 = load i8*, i8** %_impzPtr
%zone843 = bitcast i8* %tzone842 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0
%dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone843, i64 8)
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***
%tzone823 = load i8*, i8** %_impzPtr
%zone824 = bitcast i8* %tzone823 to %mzone*
call void @llvm_zone_mark(%mzone* %zone824)
; malloc closure structure
%clsptr825 = call i8* @llvm_zone_malloc(%mzone* %zone824, i64 24)
%closure826 = bitcast i8* %clsptr825 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*

; malloc environment structure
%envptr827 = call i8* @llvm_zone_malloc(%mzone* %zone824, i64 8)
%environment828 = bitcast i8* %envptr827 to {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}*

; malloc closure address table
%addytable829 = call %clsvar* @new_address_table()
%var830 = bitcast [57 x i8]* @gsxtmrational54 to i8*
%var831 = bitcast [52 x i8]* @gsxtmrational55 to i8*
%addytable832 = call %clsvar* @add_address_table(%mzone* %zone824, i8* %var830, i32 0, i8* %var831, i32 3, %clsvar* %addytable829)
%address-table833 = bitcast %clsvar* %addytable832 to i8*

; insert table, function and environment into closure struct
%closure.table836 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure826, i32 0, i32 0
store i8* %address-table833, i8** %closure.table836
%closure.env837 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure826, i32 0, i32 1
store i8* %envptr827, i8** %closure.env837
%closure.func838 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure826, i32 0, i32 2
store %Rational (i8*, i8*, i32, %Rational)* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0__812, %Rational (i8*, i8*, i32, %Rational)** %closure.func838
%closure_size839 = call i64 @llvm_zone_mark_size(%mzone* %zone824)
call void @llvm_zone_ptr_set_size(i8* %clsptr825, i64 %closure_size839)
%wrapper_ptr840 = call i8* @llvm_zone_malloc(%mzone* %zone824, i64 8)
%closure_wrapper841 = bitcast i8* %wrapper_ptr840 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure826, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper841

; let value assignment
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper841, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper841
store { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0
%tmp_envptr835 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}* %environment828, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**** %tmp_envptr835


%val844 = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %val844
}


@xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_native(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Rational}*
%arg_p_0 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational57 = hidden constant [56 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ\00"
@gsxtmrational58 = hidden constant [51 x i8] c"{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**\00"
define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ__846(i8* %_impz,i8* %_impenv, %Rational %a, i8 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone847 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}*
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i8
store i8 %b, i8* %bPtr


%val848 = load %Rational, %Rational* %aPtr
; tuple ref
%val849 = extractvalue %Rational %val848, 0
%val850 = load i8, i8* %bPtr
%res851 = call ccc i64 @i8toi64(i8 %val850)
%val852 = mul i64 %val849, %res851
%val853 = load %Rational, %Rational* %aPtr
; tuple ref
%val854 = extractvalue %Rational %val853, 1
%val855 = mul i64 %val854, 1
%res856 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val852, i64 %val855)
ret %Rational %res856
}
@gsxtmrational59 = hidden constant [109 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone876 = load i8*, i8** %_impzPtr
%zone877 = bitcast i8* %tzone876 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ
%dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ = call i8* @llvm_zone_malloc(%mzone* %zone877, i64 8)
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***
%tzone857 = load i8*, i8** %_impzPtr
%zone858 = bitcast i8* %tzone857 to %mzone*
call void @llvm_zone_mark(%mzone* %zone858)
; malloc closure structure
%clsptr859 = call i8* @llvm_zone_malloc(%mzone* %zone858, i64 24)
%closure860 = bitcast i8* %clsptr859 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*

; malloc environment structure
%envptr861 = call i8* @llvm_zone_malloc(%mzone* %zone858, i64 8)
%environment862 = bitcast i8* %envptr861 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}*

; malloc closure address table
%addytable863 = call %clsvar* @new_address_table()
%var864 = bitcast [56 x i8]* @gsxtmrational57 to i8*
%var865 = bitcast [51 x i8]* @gsxtmrational58 to i8*
%addytable866 = call %clsvar* @add_address_table(%mzone* %zone858, i8* %var864, i32 0, i8* %var865, i32 3, %clsvar* %addytable863)
%address-table867 = bitcast %clsvar* %addytable866 to i8*

; insert table, function and environment into closure struct
%closure.table870 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure860, i32 0, i32 0
store i8* %address-table867, i8** %closure.table870
%closure.env871 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure860, i32 0, i32 1
store i8* %envptr861, i8** %closure.env871
%closure.func872 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure860, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i8)* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ__846, %Rational (i8*, i8*, %Rational, i8)** %closure.func872
%closure_size873 = call i64 @llvm_zone_mark_size(%mzone* %zone858)
call void @llvm_zone_ptr_set_size(i8* %clsptr859, i64 %closure_size873)
%wrapper_ptr874 = call i8* @llvm_zone_malloc(%mzone* %zone858, i64 8)
%closure_wrapper875 = bitcast i8* %wrapper_ptr874 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure860, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper875

; let value assignment
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper875, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper875
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ
%tmp_envptr869 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}* %environment862, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**** %tmp_envptr869


%val878 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %val878
}


@xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_native(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i8}*
%arg_p_0 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational60 = hidden constant [56 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ\00"
@gsxtmrational61 = hidden constant [51 x i8] c"{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**\00"
define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ__880(i8* %_impz,i8* %_impenv, i8 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone881 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}*
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i8
store i8 %b, i8* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val882 = load %Rational, %Rational* %aPtr
; tuple ref
%val883 = extractvalue %Rational %val882, 0
%val884 = load i8, i8* %bPtr
%res885 = call ccc i64 @i8toi64(i8 %val884)
%val886 = mul i64 %val883, %res885
%val887 = load %Rational, %Rational* %aPtr
; tuple ref
%val888 = extractvalue %Rational %val887, 1
%val889 = mul i64 %val888, 1
%res890 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val886, i64 %val889)
ret %Rational %res890
}
@gsxtmrational62 = hidden constant [109 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone910 = load i8*, i8** %_impzPtr
%zone911 = bitcast i8* %tzone910 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ
%dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone911, i64 8)
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***
%tzone891 = load i8*, i8** %_impzPtr
%zone892 = bitcast i8* %tzone891 to %mzone*
call void @llvm_zone_mark(%mzone* %zone892)
; malloc closure structure
%clsptr893 = call i8* @llvm_zone_malloc(%mzone* %zone892, i64 24)
%closure894 = bitcast i8* %clsptr893 to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*

; malloc environment structure
%envptr895 = call i8* @llvm_zone_malloc(%mzone* %zone892, i64 8)
%environment896 = bitcast i8* %envptr895 to {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}*

; malloc closure address table
%addytable897 = call %clsvar* @new_address_table()
%var898 = bitcast [56 x i8]* @gsxtmrational60 to i8*
%var899 = bitcast [51 x i8]* @gsxtmrational61 to i8*
%addytable900 = call %clsvar* @add_address_table(%mzone* %zone892, i8* %var898, i32 0, i8* %var899, i32 3, %clsvar* %addytable897)
%address-table901 = bitcast %clsvar* %addytable900 to i8*

; insert table, function and environment into closure struct
%closure.table904 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure894, i32 0, i32 0
store i8* %address-table901, i8** %closure.table904
%closure.env905 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure894, i32 0, i32 1
store i8* %envptr895, i8** %closure.env905
%closure.func906 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure894, i32 0, i32 2
store %Rational (i8*, i8*, i8, %Rational)* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ__880, %Rational (i8*, i8*, i8, %Rational)** %closure.func906
%closure_size907 = call i64 @llvm_zone_mark_size(%mzone* %zone892)
call void @llvm_zone_ptr_set_size(i8* %clsptr893, i64 %closure_size907)
%wrapper_ptr908 = call i8* @llvm_zone_malloc(%mzone* %zone892, i64 8)
%closure_wrapper909 = bitcast i8* %wrapper_ptr908 to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure894, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper909

; let value assignment
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper909, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper909
store { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ
%tmp_envptr903 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}* %environment896, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**** %tmp_envptr903


%val912 = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %val912
}


@xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_native(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8, %Rational}*
%arg_p_0 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
%arg_p_1 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational63 = hidden constant [56 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ\00"
@gsxtmrational64 = hidden constant [51 x i8] c"{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**\00"
define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ__914(i8* %_impz,i8* %_impenv, %Rational %a, i1 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone915 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}*
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i1
store i1 %b, i1* %bPtr


%val916 = load %Rational, %Rational* %aPtr
; tuple ref
%val917 = extractvalue %Rational %val916, 0
%val918 = load i1, i1* %bPtr
%res919 = call ccc i64 @i1toi64(i1 %val918)
%val920 = mul i64 %val917, %res919
%val921 = load %Rational, %Rational* %aPtr
; tuple ref
%val922 = extractvalue %Rational %val921, 1
%val923 = mul i64 %val922, 1
%res924 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val920, i64 %val923)
ret %Rational %res924
}
@gsxtmrational65 = hidden constant [109 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone944 = load i8*, i8** %_impzPtr
%zone945 = bitcast i8* %tzone944 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ
%dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ = call i8* @llvm_zone_malloc(%mzone* %zone945, i64 8)
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***
%tzone925 = load i8*, i8** %_impzPtr
%zone926 = bitcast i8* %tzone925 to %mzone*
call void @llvm_zone_mark(%mzone* %zone926)
; malloc closure structure
%clsptr927 = call i8* @llvm_zone_malloc(%mzone* %zone926, i64 24)
%closure928 = bitcast i8* %clsptr927 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*

; malloc environment structure
%envptr929 = call i8* @llvm_zone_malloc(%mzone* %zone926, i64 8)
%environment930 = bitcast i8* %envptr929 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}*

; malloc closure address table
%addytable931 = call %clsvar* @new_address_table()
%var932 = bitcast [56 x i8]* @gsxtmrational63 to i8*
%var933 = bitcast [51 x i8]* @gsxtmrational64 to i8*
%addytable934 = call %clsvar* @add_address_table(%mzone* %zone926, i8* %var932, i32 0, i8* %var933, i32 3, %clsvar* %addytable931)
%address-table935 = bitcast %clsvar* %addytable934 to i8*

; insert table, function and environment into closure struct
%closure.table938 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure928, i32 0, i32 0
store i8* %address-table935, i8** %closure.table938
%closure.env939 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure928, i32 0, i32 1
store i8* %envptr929, i8** %closure.env939
%closure.func940 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure928, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i1)* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ__914, %Rational (i8*, i8*, %Rational, i1)** %closure.func940
%closure_size941 = call i64 @llvm_zone_mark_size(%mzone* %zone926)
call void @llvm_zone_ptr_set_size(i8* %clsptr927, i64 %closure_size941)
%wrapper_ptr942 = call i8* @llvm_zone_malloc(%mzone* %zone926, i64 8)
%closure_wrapper943 = bitcast i8* %wrapper_ptr942 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure928, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_wrapper943

; let value assignment
%xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_wrapper943, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_wrapper943
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ
%tmp_envptr937 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}* %environment930, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**** %tmp_envptr937


%val946 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %val946
}


@xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i1)*,  %Rational (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_native(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i1)*,  %Rational (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i1}*
%arg_p_0 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 1
%arg_1 = load i1, i1* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i1)*,  %Rational (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational66 = hidden constant [56 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ\00"
@gsxtmrational67 = hidden constant [51 x i8] c"{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**\00"
define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ__948(i8* %_impz,i8* %_impenv, i1 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone949 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}*
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i1
store i1 %b, i1* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val950 = load %Rational, %Rational* %aPtr
; tuple ref
%val951 = extractvalue %Rational %val950, 0
%val952 = load i1, i1* %bPtr
%res953 = call ccc i64 @i1toi64(i1 %val952)
%val954 = mul i64 %val951, %res953
%val955 = load %Rational, %Rational* %aPtr
; tuple ref
%val956 = extractvalue %Rational %val955, 1
%val957 = mul i64 %val956, 1
%res958 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val954, i64 %val957)
ret %Rational %res958
}
@gsxtmrational68 = hidden constant [109 x i8] c"xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone978 = load i8*, i8** %_impzPtr
%zone979 = bitcast i8* %tzone978 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ
%dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone979, i64 8)
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***
%tzone959 = load i8*, i8** %_impzPtr
%zone960 = bitcast i8* %tzone959 to %mzone*
call void @llvm_zone_mark(%mzone* %zone960)
; malloc closure structure
%clsptr961 = call i8* @llvm_zone_malloc(%mzone* %zone960, i64 24)
%closure962 = bitcast i8* %clsptr961 to { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*

; malloc environment structure
%envptr963 = call i8* @llvm_zone_malloc(%mzone* %zone960, i64 8)
%environment964 = bitcast i8* %envptr963 to {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}*

; malloc closure address table
%addytable965 = call %clsvar* @new_address_table()
%var966 = bitcast [56 x i8]* @gsxtmrational66 to i8*
%var967 = bitcast [51 x i8]* @gsxtmrational67 to i8*
%addytable968 = call %clsvar* @add_address_table(%mzone* %zone960, i8* %var966, i32 0, i8* %var967, i32 3, %clsvar* %addytable965)
%address-table969 = bitcast %clsvar* %addytable968 to i8*

; insert table, function and environment into closure struct
%closure.table972 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure962, i32 0, i32 0
store i8* %address-table969, i8** %closure.table972
%closure.env973 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure962, i32 0, i32 1
store i8* %envptr963, i8** %closure.env973
%closure.func974 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure962, i32 0, i32 2
store %Rational (i8*, i8*, i1, %Rational)* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ__948, %Rational (i8*, i8*, i1, %Rational)** %closure.func974
%closure_size975 = call i64 @llvm_zone_mark_size(%mzone* %zone960)
call void @llvm_zone_ptr_set_size(i8* %clsptr961, i64 %closure_size975)
%wrapper_ptr976 = call i8* @llvm_zone_malloc(%mzone* %zone960, i64 8)
%closure_wrapper977 = bitcast i8* %wrapper_ptr976 to { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure962, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_wrapper977

; let value assignment
%xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_wrapper977, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_wrapper977
store { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ
%tmp_envptr971 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}* %environment964, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**** %tmp_envptr971


%val980 = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*** %xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %val980
}


@xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i1, %Rational)*,  %Rational (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_native(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i1, %Rational)*,  %Rational (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1, %Rational}*
%arg_p_0 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
%arg_p_1 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i1, %Rational)*,  %Rational (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational69 = hidden constant [58 x i8] c"xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd\00"
@gsxtmrational70 = hidden constant [52 x i8] c"{i8*, i8*, double (i8*, i8*, %Rational, double)*}**\00"
define dllexport fastcc double @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd__982(i8* %_impz,i8* %_impenv, %Rational %a, double %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone983 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}*
%xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}, {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}***, {i8*, i8*, double (i8*, i8*, %Rational, double)*}**** %xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca double
store double %b, double* %bPtr


%val984 = load double, double* %bPtr
%val985 = load %Rational, %Rational* %aPtr
; tuple ref
%val986 = extractvalue %Rational %val985, 0
%val987 = sitofp i64 %val986 to double
%val988 = load %Rational, %Rational* %aPtr
; tuple ref
%val989 = extractvalue %Rational %val988, 1
%val990 = sitofp i64 %val989 to double
%val991 = fdiv double %val987, %val990
%val992 = fmul double %val984, %val991
ret double %val992
}
@gsxtmrational71 = hidden constant [111 x i8] c"xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, %Rational, double)*}** @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1012 = load i8*, i8** %_impzPtr
%zone1013 = bitcast i8* %tzone1012 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd
%dat_xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone1013, i64 8)
%xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd to { i8*, i8*, double (i8*, i8*, %Rational, double)*}***
%tzone993 = load i8*, i8** %_impzPtr
%zone994 = bitcast i8* %tzone993 to %mzone*
call void @llvm_zone_mark(%mzone* %zone994)
; malloc closure structure
%clsptr995 = call i8* @llvm_zone_malloc(%mzone* %zone994, i64 24)
%closure996 = bitcast i8* %clsptr995 to { i8*, i8*, double (i8*, i8*, %Rational, double)*}*

; malloc environment structure
%envptr997 = call i8* @llvm_zone_malloc(%mzone* %zone994, i64 8)
%environment998 = bitcast i8* %envptr997 to {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}*

; malloc closure address table
%addytable999 = call %clsvar* @new_address_table()
%var1000 = bitcast [58 x i8]* @gsxtmrational69 to i8*
%var1001 = bitcast [52 x i8]* @gsxtmrational70 to i8*
%addytable1002 = call %clsvar* @add_address_table(%mzone* %zone994, i8* %var1000, i32 0, i8* %var1001, i32 3, %clsvar* %addytable999)
%address-table1003 = bitcast %clsvar* %addytable1002 to i8*

; insert table, function and environment into closure struct
%closure.table1006 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational, double)*}, { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure996, i32 0, i32 0
store i8* %address-table1003, i8** %closure.table1006
%closure.env1007 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational, double)*}, { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure996, i32 0, i32 1
store i8* %envptr997, i8** %closure.env1007
%closure.func1008 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational, double)*}, { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure996, i32 0, i32 2
store double (i8*, i8*, %Rational, double)* @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd__982, double (i8*, i8*, %Rational, double)** %closure.func1008
%closure_size1009 = call i64 @llvm_zone_mark_size(%mzone* %zone994)
call void @llvm_zone_ptr_set_size(i8* %clsptr995, i64 %closure_size1009)
%wrapper_ptr1010 = call i8* @llvm_zone_malloc(%mzone* %zone994, i64 8)
%closure_wrapper1011 = bitcast i8* %wrapper_ptr1010 to { i8*, i8*, double (i8*, i8*, %Rational, double)*}**
store { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure996, { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_wrapper1011

; let value assignment
%xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd = select i1 true, { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_wrapper1011, { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_wrapper1011
store { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd, { i8*, i8*, double (i8*, i8*, %Rational, double)*}*** %xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd
%tmp_envptr1005 = getelementptr {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}, {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}* %environment998, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, %Rational, double)*}*** %xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr, {i8*, i8*, double (i8*, i8*, %Rational, double)*}**** %tmp_envptr1005


%val1014 = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}**, {i8*, i8*, double (i8*, i8*, %Rational, double)*}*** %xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr
ret {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %val1014
}


@xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, %Rational, double)*}** @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd(%Rational %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}*, {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational, double)*,  double (i8*, i8*, %Rational, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc double @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_native(%Rational %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}*, {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational, double)*,  double (i8*, i8*, %Rational, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, double}*
%arg_p_0 = getelementptr {%Rational, double}, {%Rational, double}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, double}, {%Rational, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}*, {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational, double)*,  double (i8*, i8*, %Rational, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational72 = hidden constant [58 x i8] c"xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd\00"
@gsxtmrational73 = hidden constant [52 x i8] c"{i8*, i8*, double (i8*, i8*, double, %Rational)*}**\00"
define dllexport fastcc double @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd__1016(i8* %_impz,i8* %_impenv, double %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1017 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}*
%xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}, {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}***, {i8*, i8*, double (i8*, i8*, double, %Rational)*}**** %xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr_

; setup arguments
%bPtr = alloca double
store double %b, double* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val1018 = load double, double* %bPtr
%val1019 = load %Rational, %Rational* %aPtr
; tuple ref
%val1020 = extractvalue %Rational %val1019, 0
%val1021 = sitofp i64 %val1020 to double
%val1022 = load %Rational, %Rational* %aPtr
; tuple ref
%val1023 = extractvalue %Rational %val1022, 1
%val1024 = sitofp i64 %val1023 to double
%val1025 = fdiv double %val1021, %val1024
%val1026 = fmul double %val1018, %val1025
ret double %val1026
}
@gsxtmrational74 = hidden constant [111 x i8] c"xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double, %Rational)*}** @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1046 = load i8*, i8** %_impzPtr
%zone1047 = bitcast i8* %tzone1046 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd
%dat_xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd = call i8* @llvm_zone_malloc(%mzone* %zone1047, i64 8)
%xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd to { i8*, i8*, double (i8*, i8*, double, %Rational)*}***
%tzone1027 = load i8*, i8** %_impzPtr
%zone1028 = bitcast i8* %tzone1027 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1028)
; malloc closure structure
%clsptr1029 = call i8* @llvm_zone_malloc(%mzone* %zone1028, i64 24)
%closure1030 = bitcast i8* %clsptr1029 to { i8*, i8*, double (i8*, i8*, double, %Rational)*}*

; malloc environment structure
%envptr1031 = call i8* @llvm_zone_malloc(%mzone* %zone1028, i64 8)
%environment1032 = bitcast i8* %envptr1031 to {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}*

; malloc closure address table
%addytable1033 = call %clsvar* @new_address_table()
%var1034 = bitcast [58 x i8]* @gsxtmrational72 to i8*
%var1035 = bitcast [52 x i8]* @gsxtmrational73 to i8*
%addytable1036 = call %clsvar* @add_address_table(%mzone* %zone1028, i8* %var1034, i32 0, i8* %var1035, i32 3, %clsvar* %addytable1033)
%address-table1037 = bitcast %clsvar* %addytable1036 to i8*

; insert table, function and environment into closure struct
%closure.table1040 = getelementptr { i8*, i8*, double (i8*, i8*, double, %Rational)*}, { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure1030, i32 0, i32 0
store i8* %address-table1037, i8** %closure.table1040
%closure.env1041 = getelementptr { i8*, i8*, double (i8*, i8*, double, %Rational)*}, { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure1030, i32 0, i32 1
store i8* %envptr1031, i8** %closure.env1041
%closure.func1042 = getelementptr { i8*, i8*, double (i8*, i8*, double, %Rational)*}, { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure1030, i32 0, i32 2
store double (i8*, i8*, double, %Rational)* @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd__1016, double (i8*, i8*, double, %Rational)** %closure.func1042
%closure_size1043 = call i64 @llvm_zone_mark_size(%mzone* %zone1028)
call void @llvm_zone_ptr_set_size(i8* %clsptr1029, i64 %closure_size1043)
%wrapper_ptr1044 = call i8* @llvm_zone_malloc(%mzone* %zone1028, i64 8)
%closure_wrapper1045 = bitcast i8* %wrapper_ptr1044 to { i8*, i8*, double (i8*, i8*, double, %Rational)*}**
store { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure1030, { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_wrapper1045

; let value assignment
%xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd = select i1 true, { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_wrapper1045, { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_wrapper1045
store { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd, { i8*, i8*, double (i8*, i8*, double, %Rational)*}*** %xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd
%tmp_envptr1039 = getelementptr {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}, {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}* %environment1032, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double, %Rational)*}*** %xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr, {i8*, i8*, double (i8*, i8*, double, %Rational)*}**** %tmp_envptr1039


%val1048 = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}**, {i8*, i8*, double (i8*, i8*, double, %Rational)*}*** %xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr
ret {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %val1048
}


@xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double, %Rational)*}** @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd(double %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}*, {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %Rational)*,  double (i8*, i8*, double, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %Rational %arg_1)
ret double %result
}


define dllexport ccc double @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_native(double %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}*, {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %Rational)*,  double (i8*, i8*, double, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %Rational %arg_1)
ret double %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, %Rational}*
%arg_p_0 = getelementptr {double, %Rational}, {double, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, %Rational}, {double, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}*, {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %Rational)*,  double (i8*, i8*, double, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational75 = hidden constant [56 x i8] c"xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ\00"
@gsxtmrational76 = hidden constant [50 x i8] c"{i8*, i8*, float (i8*, i8*, %Rational, float)*}**\00"
define dllexport fastcc float @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ__1050(i8* %_impz,i8* %_impenv, %Rational %a, float %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1051 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}*
%xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}, {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}***, {i8*, i8*, float (i8*, i8*, %Rational, float)*}**** %xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca float
store float %b, float* %bPtr


%val1052 = load float, float* %bPtr
%val1053 = load %Rational, %Rational* %aPtr
; tuple ref
%val1054 = extractvalue %Rational %val1053, 0
%val1055 = sitofp i64 %val1054 to float
%val1056 = load %Rational, %Rational* %aPtr
; tuple ref
%val1057 = extractvalue %Rational %val1056, 1
%val1058 = sitofp i64 %val1057 to float
%val1059 = fdiv float %val1055, %val1058
%val1060 = fmul float %val1052, %val1059
ret float %val1060
}
@gsxtmrational77 = hidden constant [109 x i8] c"xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %Rational, float)*}** @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1080 = load i8*, i8** %_impzPtr
%zone1081 = bitcast i8* %tzone1080 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ
%dat_xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1081, i64 8)
%xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ to { i8*, i8*, float (i8*, i8*, %Rational, float)*}***
%tzone1061 = load i8*, i8** %_impzPtr
%zone1062 = bitcast i8* %tzone1061 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1062)
; malloc closure structure
%clsptr1063 = call i8* @llvm_zone_malloc(%mzone* %zone1062, i64 24)
%closure1064 = bitcast i8* %clsptr1063 to { i8*, i8*, float (i8*, i8*, %Rational, float)*}*

; malloc environment structure
%envptr1065 = call i8* @llvm_zone_malloc(%mzone* %zone1062, i64 8)
%environment1066 = bitcast i8* %envptr1065 to {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}*

; malloc closure address table
%addytable1067 = call %clsvar* @new_address_table()
%var1068 = bitcast [56 x i8]* @gsxtmrational75 to i8*
%var1069 = bitcast [50 x i8]* @gsxtmrational76 to i8*
%addytable1070 = call %clsvar* @add_address_table(%mzone* %zone1062, i8* %var1068, i32 0, i8* %var1069, i32 3, %clsvar* %addytable1067)
%address-table1071 = bitcast %clsvar* %addytable1070 to i8*

; insert table, function and environment into closure struct
%closure.table1074 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational, float)*}, { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure1064, i32 0, i32 0
store i8* %address-table1071, i8** %closure.table1074
%closure.env1075 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational, float)*}, { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure1064, i32 0, i32 1
store i8* %envptr1065, i8** %closure.env1075
%closure.func1076 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational, float)*}, { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure1064, i32 0, i32 2
store float (i8*, i8*, %Rational, float)* @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ__1050, float (i8*, i8*, %Rational, float)** %closure.func1076
%closure_size1077 = call i64 @llvm_zone_mark_size(%mzone* %zone1062)
call void @llvm_zone_ptr_set_size(i8* %clsptr1063, i64 %closure_size1077)
%wrapper_ptr1078 = call i8* @llvm_zone_malloc(%mzone* %zone1062, i64 8)
%closure_wrapper1079 = bitcast i8* %wrapper_ptr1078 to { i8*, i8*, float (i8*, i8*, %Rational, float)*}**
store { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure1064, { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_wrapper1079

; let value assignment
%xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ = select i1 true, { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_wrapper1079, { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_wrapper1079
store { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ, { i8*, i8*, float (i8*, i8*, %Rational, float)*}*** %xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ
%tmp_envptr1073 = getelementptr {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}, {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}* %environment1066, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %Rational, float)*}*** %xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr, {i8*, i8*, float (i8*, i8*, %Rational, float)*}**** %tmp_envptr1073


%val1082 = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}**, {i8*, i8*, float (i8*, i8*, %Rational, float)*}*** %xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr
ret {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %val1082
}


@xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %Rational, float)*}** @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ(%Rational %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}*, {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational, float)*,  float (i8*, i8*, %Rational, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0, float %arg_1)
ret float %result
}


define dllexport ccc float @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_native(%Rational %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}*, {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational, float)*,  float (i8*, i8*, %Rational, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0, float %arg_1)
ret float %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, float}*
%arg_p_0 = getelementptr {%Rational, float}, {%Rational, float}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, float}, {%Rational, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}*, {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational, float)*,  float (i8*, i8*, %Rational, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational78 = hidden constant [56 x i8] c"xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ\00"
@gsxtmrational79 = hidden constant [50 x i8] c"{i8*, i8*, float (i8*, i8*, float, %Rational)*}**\00"
define dllexport fastcc float @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ__1084(i8* %_impz,i8* %_impenv, float %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1085 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}*
%xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}, {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}***, {i8*, i8*, float (i8*, i8*, float, %Rational)*}**** %xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val1086 = load float, float* %bPtr
%val1087 = load %Rational, %Rational* %aPtr
; tuple ref
%val1088 = extractvalue %Rational %val1087, 0
%val1089 = sitofp i64 %val1088 to float
%val1090 = load %Rational, %Rational* %aPtr
; tuple ref
%val1091 = extractvalue %Rational %val1090, 1
%val1092 = sitofp i64 %val1091 to float
%val1093 = fdiv float %val1089, %val1092
%val1094 = fmul float %val1086, %val1093
ret float %val1094
}
@gsxtmrational80 = hidden constant [109 x i8] c"xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float, %Rational)*}** @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1114 = load i8*, i8** %_impzPtr
%zone1115 = bitcast i8* %tzone1114 to %mzone*

; let assign value to symbol xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ
%dat_xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone1115, i64 8)
%xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ to { i8*, i8*, float (i8*, i8*, float, %Rational)*}***
%tzone1095 = load i8*, i8** %_impzPtr
%zone1096 = bitcast i8* %tzone1095 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1096)
; malloc closure structure
%clsptr1097 = call i8* @llvm_zone_malloc(%mzone* %zone1096, i64 24)
%closure1098 = bitcast i8* %clsptr1097 to { i8*, i8*, float (i8*, i8*, float, %Rational)*}*

; malloc environment structure
%envptr1099 = call i8* @llvm_zone_malloc(%mzone* %zone1096, i64 8)
%environment1100 = bitcast i8* %envptr1099 to {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}*

; malloc closure address table
%addytable1101 = call %clsvar* @new_address_table()
%var1102 = bitcast [56 x i8]* @gsxtmrational78 to i8*
%var1103 = bitcast [50 x i8]* @gsxtmrational79 to i8*
%addytable1104 = call %clsvar* @add_address_table(%mzone* %zone1096, i8* %var1102, i32 0, i8* %var1103, i32 3, %clsvar* %addytable1101)
%address-table1105 = bitcast %clsvar* %addytable1104 to i8*

; insert table, function and environment into closure struct
%closure.table1108 = getelementptr { i8*, i8*, float (i8*, i8*, float, %Rational)*}, { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure1098, i32 0, i32 0
store i8* %address-table1105, i8** %closure.table1108
%closure.env1109 = getelementptr { i8*, i8*, float (i8*, i8*, float, %Rational)*}, { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure1098, i32 0, i32 1
store i8* %envptr1099, i8** %closure.env1109
%closure.func1110 = getelementptr { i8*, i8*, float (i8*, i8*, float, %Rational)*}, { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure1098, i32 0, i32 2
store float (i8*, i8*, float, %Rational)* @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ__1084, float (i8*, i8*, float, %Rational)** %closure.func1110
%closure_size1111 = call i64 @llvm_zone_mark_size(%mzone* %zone1096)
call void @llvm_zone_ptr_set_size(i8* %clsptr1097, i64 %closure_size1111)
%wrapper_ptr1112 = call i8* @llvm_zone_malloc(%mzone* %zone1096, i64 8)
%closure_wrapper1113 = bitcast i8* %wrapper_ptr1112 to { i8*, i8*, float (i8*, i8*, float, %Rational)*}**
store { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure1098, { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_wrapper1113

; let value assignment
%xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_wrapper1113, { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_wrapper1113
store { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ, { i8*, i8*, float (i8*, i8*, float, %Rational)*}*** %xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ
%tmp_envptr1107 = getelementptr {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}, {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}* %environment1100, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float, %Rational)*}*** %xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr, {i8*, i8*, float (i8*, i8*, float, %Rational)*}**** %tmp_envptr1107


%val1116 = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}**, {i8*, i8*, float (i8*, i8*, float, %Rational)*}*** %xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr
ret {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %val1116
}


@xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float, %Rational)*}** @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ(float %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}*, {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %Rational)*,  float (i8*, i8*, float, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %Rational %arg_1)
ret float %result
}


define dllexport ccc float @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_native(float %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}*, {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %Rational)*,  float (i8*, i8*, float, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %Rational %arg_1)
ret float %result
}


define dllexport ccc void @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, %Rational}*
%arg_p_0 = getelementptr {float, %Rational}, {float, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, %Rational}, {float, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_multiplication_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}*, {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %Rational)*,  float (i8*, i8*, float, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational81 = hidden constant [58 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ\00"
define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ__1118(i8* %_impz,i8* %_impenv, %Rational %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1119 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}*
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%val1120 = load %Rational, %Rational* %aPtr
; tuple ref
%val1121 = extractvalue %Rational %val1120, 0
%val1122 = load %Rational, %Rational* %bPtr
; tuple ref
%val1123 = extractvalue %Rational %val1122, 1
%val1124 = mul i64 %val1121, %val1123
%val1125 = load %Rational, %Rational* %aPtr
; tuple ref
%val1126 = extractvalue %Rational %val1125, 1
%val1127 = load %Rational, %Rational* %bPtr
; tuple ref
%val1128 = extractvalue %Rational %val1127, 0
%val1129 = mul i64 %val1126, %val1128
%res1130 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1124, i64 %val1129)
%res1131 = call fastcc %Rational @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res1130)
ret %Rational %res1131
}
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1151 = load i8*, i8** %_impzPtr
%zone1152 = bitcast i8* %tzone1151 to %mzone*

; let assign value to symbol xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ
%dat_xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone1152, i64 8)
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***
%tzone1132 = load i8*, i8** %_impzPtr
%zone1133 = bitcast i8* %tzone1132 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1133)
; malloc closure structure
%clsptr1134 = call i8* @llvm_zone_malloc(%mzone* %zone1133, i64 24)
%closure1135 = bitcast i8* %clsptr1134 to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*

; malloc environment structure
%envptr1136 = call i8* @llvm_zone_malloc(%mzone* %zone1133, i64 8)
%environment1137 = bitcast i8* %envptr1136 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}*

; malloc closure address table
%addytable1138 = call %clsvar* @new_address_table()
%var1139 = bitcast [58 x i8]* @gsxtmrational81 to i8*
%var1140 = bitcast [58 x i8]* @gsxtmrational44 to i8*
%addytable1141 = call %clsvar* @add_address_table(%mzone* %zone1133, i8* %var1139, i32 0, i8* %var1140, i32 3, %clsvar* %addytable1138)
%address-table1142 = bitcast %clsvar* %addytable1141 to i8*

; insert table, function and environment into closure struct
%closure.table1145 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure1135, i32 0, i32 0
store i8* %address-table1142, i8** %closure.table1145
%closure.env1146 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure1135, i32 0, i32 1
store i8* %envptr1136, i8** %closure.env1146
%closure.func1147 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure1135, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, %Rational)* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ__1118, %Rational (i8*, i8*, %Rational, %Rational)** %closure.func1147
%closure_size1148 = call i64 @llvm_zone_mark_size(%mzone* %zone1133)
call void @llvm_zone_ptr_set_size(i8* %clsptr1134, i64 %closure_size1148)
%wrapper_ptr1149 = call i8* @llvm_zone_malloc(%mzone* %zone1133, i64 8)
%closure_wrapper1150 = bitcast i8* %wrapper_ptr1149 to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure1135, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper1150

; let value assignment
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper1150, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper1150
store { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ
%tmp_envptr1144 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}* %environment1137, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**** %tmp_envptr1144


%val1153 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %val1153
}


@xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_native(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, %Rational}*
%arg_p_0 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational82 = hidden constant [51 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0\00"
define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0__1154(i8* %_impz,i8* %_impenv, %Rational %a, i64 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1155 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}*
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i64
store i64 %b, i64* %bPtr


%val1156 = load %Rational, %Rational* %aPtr
; tuple ref
%val1157 = extractvalue %Rational %val1156, 0
%val1158 = load i64, i64* %bPtr
%val1159 = mul i64 %val1157, %val1158
%val1160 = load %Rational, %Rational* %aPtr
; tuple ref
%val1161 = extractvalue %Rational %val1160, 1
%val1162 = mul i64 %val1161, 1
%res1163 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1159, i64 %val1162)
ret %Rational %res1163
}
@gsxtmrational83 = hidden constant [104 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1183 = load i8*, i8** %_impzPtr
%zone1184 = bitcast i8* %tzone1183 to %mzone*

; let assign value to symbol xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0
%dat_xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone1184, i64 8)
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr = bitcast i8* %dat_xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***
%tzone1164 = load i8*, i8** %_impzPtr
%zone1165 = bitcast i8* %tzone1164 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1165)
; malloc closure structure
%clsptr1166 = call i8* @llvm_zone_malloc(%mzone* %zone1165, i64 24)
%closure1167 = bitcast i8* %clsptr1166 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*

; malloc environment structure
%envptr1168 = call i8* @llvm_zone_malloc(%mzone* %zone1165, i64 8)
%environment1169 = bitcast i8* %envptr1168 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}*

; malloc closure address table
%addytable1170 = call %clsvar* @new_address_table()
%var1171 = bitcast [51 x i8]* @gsxtmrational82 to i8*
%var1172 = bitcast [52 x i8]* @gsxtmrational46 to i8*
%addytable1173 = call %clsvar* @add_address_table(%mzone* %zone1165, i8* %var1171, i32 0, i8* %var1172, i32 3, %clsvar* %addytable1170)
%address-table1174 = bitcast %clsvar* %addytable1173 to i8*

; insert table, function and environment into closure struct
%closure.table1177 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure1167, i32 0, i32 0
store i8* %address-table1174, i8** %closure.table1177
%closure.env1178 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure1167, i32 0, i32 1
store i8* %envptr1168, i8** %closure.env1178
%closure.func1179 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure1167, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i64)* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0__1154, %Rational (i8*, i8*, %Rational, i64)** %closure.func1179
%closure_size1180 = call i64 @llvm_zone_mark_size(%mzone* %zone1165)
call void @llvm_zone_ptr_set_size(i8* %clsptr1166, i64 %closure_size1180)
%wrapper_ptr1181 = call i8* @llvm_zone_malloc(%mzone* %zone1165, i64 8)
%closure_wrapper1182 = bitcast i8* %wrapper_ptr1181 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure1167, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper1182

; let value assignment
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper1182, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper1182
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0
%tmp_envptr1176 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}* %environment1169, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**** %tmp_envptr1176


%val1185 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %val1185
}


@xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_native(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i64}*
%arg_p_0 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational84 = hidden constant [51 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0\00"
define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0__1187(i8* %_impz,i8* %_impenv, i64 %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1188 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}*
%xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**** %xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr_

; setup arguments
%aPtr = alloca i64
store i64 %a, i64* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%val1189 = load %Rational, %Rational* %bPtr
; tuple ref
%val1190 = extractvalue %Rational %val1189, 1
%val1191 = load i64, i64* %aPtr
%val1192 = mul i64 %val1190, %val1191
%val1193 = load %Rational, %Rational* %bPtr
; tuple ref
%val1194 = extractvalue %Rational %val1193, 0
%val1195 = mul i64 %val1194, 1
%res1196 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1192, i64 %val1195)
ret %Rational %res1196
}
@gsxtmrational85 = hidden constant [104 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1216 = load i8*, i8** %_impzPtr
%zone1217 = bitcast i8* %tzone1216 to %mzone*

; let assign value to symbol xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0
%dat_xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone1217, i64 8)
%xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***
%tzone1197 = load i8*, i8** %_impzPtr
%zone1198 = bitcast i8* %tzone1197 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1198)
; malloc closure structure
%clsptr1199 = call i8* @llvm_zone_malloc(%mzone* %zone1198, i64 24)
%closure1200 = bitcast i8* %clsptr1199 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*

; malloc environment structure
%envptr1201 = call i8* @llvm_zone_malloc(%mzone* %zone1198, i64 8)
%environment1202 = bitcast i8* %envptr1201 to {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}*

; malloc closure address table
%addytable1203 = call %clsvar* @new_address_table()
%var1204 = bitcast [51 x i8]* @gsxtmrational84 to i8*
%var1205 = bitcast [52 x i8]* @gsxtmrational49 to i8*
%addytable1206 = call %clsvar* @add_address_table(%mzone* %zone1198, i8* %var1204, i32 0, i8* %var1205, i32 3, %clsvar* %addytable1203)
%address-table1207 = bitcast %clsvar* %addytable1206 to i8*

; insert table, function and environment into closure struct
%closure.table1210 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure1200, i32 0, i32 0
store i8* %address-table1207, i8** %closure.table1210
%closure.env1211 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure1200, i32 0, i32 1
store i8* %envptr1201, i8** %closure.env1211
%closure.func1212 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure1200, i32 0, i32 2
store %Rational (i8*, i8*, i64, %Rational)* @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0__1187, %Rational (i8*, i8*, i64, %Rational)** %closure.func1212
%closure_size1213 = call i64 @llvm_zone_mark_size(%mzone* %zone1198)
call void @llvm_zone_ptr_set_size(i8* %clsptr1199, i64 %closure_size1213)
%wrapper_ptr1214 = call i8* @llvm_zone_malloc(%mzone* %zone1198, i64 8)
%closure_wrapper1215 = bitcast i8* %wrapper_ptr1214 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure1200, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper1215

; let value assignment
%xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper1215, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper1215
store { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0
%tmp_envptr1209 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}* %environment1202, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**** %tmp_envptr1209


%val1218 = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %val1218
}


@xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_native(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, %Rational}*
%arg_p_0 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational86 = hidden constant [51 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0\00"
define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0__1220(i8* %_impz,i8* %_impenv, %Rational %a, i32 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1221 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}*
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i32
store i32 %b, i32* %bPtr


%val1222 = load %Rational, %Rational* %aPtr
; tuple ref
%val1223 = extractvalue %Rational %val1222, 0
%val1224 = load i32, i32* %bPtr
%res1225 = call ccc i64 @i32toi64(i32 %val1224)
%val1226 = mul i64 %val1223, %res1225
%val1227 = load %Rational, %Rational* %aPtr
; tuple ref
%val1228 = extractvalue %Rational %val1227, 1
%val1229 = mul i64 %val1228, 1
%res1230 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1226, i64 %val1229)
ret %Rational %res1230
}
@gsxtmrational87 = hidden constant [104 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1250 = load i8*, i8** %_impzPtr
%zone1251 = bitcast i8* %tzone1250 to %mzone*

; let assign value to symbol xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0
%dat_xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone1251, i64 8)
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr = bitcast i8* %dat_xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***
%tzone1231 = load i8*, i8** %_impzPtr
%zone1232 = bitcast i8* %tzone1231 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1232)
; malloc closure structure
%clsptr1233 = call i8* @llvm_zone_malloc(%mzone* %zone1232, i64 24)
%closure1234 = bitcast i8* %clsptr1233 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*

; malloc environment structure
%envptr1235 = call i8* @llvm_zone_malloc(%mzone* %zone1232, i64 8)
%environment1236 = bitcast i8* %envptr1235 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}*

; malloc closure address table
%addytable1237 = call %clsvar* @new_address_table()
%var1238 = bitcast [51 x i8]* @gsxtmrational86 to i8*
%var1239 = bitcast [52 x i8]* @gsxtmrational52 to i8*
%addytable1240 = call %clsvar* @add_address_table(%mzone* %zone1232, i8* %var1238, i32 0, i8* %var1239, i32 3, %clsvar* %addytable1237)
%address-table1241 = bitcast %clsvar* %addytable1240 to i8*

; insert table, function and environment into closure struct
%closure.table1244 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure1234, i32 0, i32 0
store i8* %address-table1241, i8** %closure.table1244
%closure.env1245 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure1234, i32 0, i32 1
store i8* %envptr1235, i8** %closure.env1245
%closure.func1246 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure1234, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i32)* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0__1220, %Rational (i8*, i8*, %Rational, i32)** %closure.func1246
%closure_size1247 = call i64 @llvm_zone_mark_size(%mzone* %zone1232)
call void @llvm_zone_ptr_set_size(i8* %clsptr1233, i64 %closure_size1247)
%wrapper_ptr1248 = call i8* @llvm_zone_malloc(%mzone* %zone1232, i64 8)
%closure_wrapper1249 = bitcast i8* %wrapper_ptr1248 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure1234, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper1249

; let value assignment
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper1249, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper1249
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0
%tmp_envptr1243 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}* %environment1236, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**** %tmp_envptr1243


%val1252 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %val1252
}


@xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_native(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i32}*
%arg_p_0 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational88 = hidden constant [51 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0\00"
define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0__1254(i8* %_impz,i8* %_impenv, i32 %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1255 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}*
%xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**** %xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr_

; setup arguments
%aPtr = alloca i32
store i32 %a, i32* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%val1256 = load %Rational, %Rational* %bPtr
; tuple ref
%val1257 = extractvalue %Rational %val1256, 1
%val1258 = load i32, i32* %aPtr
%res1259 = call ccc i64 @i32toi64(i32 %val1258)
%val1260 = mul i64 %val1257, %res1259
%val1261 = load %Rational, %Rational* %bPtr
; tuple ref
%val1262 = extractvalue %Rational %val1261, 0
%val1263 = mul i64 %val1262, 1
%res1264 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1260, i64 %val1263)
ret %Rational %res1264
}
@gsxtmrational89 = hidden constant [104 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1284 = load i8*, i8** %_impzPtr
%zone1285 = bitcast i8* %tzone1284 to %mzone*

; let assign value to symbol xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0
%dat_xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone1285, i64 8)
%xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***
%tzone1265 = load i8*, i8** %_impzPtr
%zone1266 = bitcast i8* %tzone1265 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1266)
; malloc closure structure
%clsptr1267 = call i8* @llvm_zone_malloc(%mzone* %zone1266, i64 24)
%closure1268 = bitcast i8* %clsptr1267 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*

; malloc environment structure
%envptr1269 = call i8* @llvm_zone_malloc(%mzone* %zone1266, i64 8)
%environment1270 = bitcast i8* %envptr1269 to {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}*

; malloc closure address table
%addytable1271 = call %clsvar* @new_address_table()
%var1272 = bitcast [51 x i8]* @gsxtmrational88 to i8*
%var1273 = bitcast [52 x i8]* @gsxtmrational55 to i8*
%addytable1274 = call %clsvar* @add_address_table(%mzone* %zone1266, i8* %var1272, i32 0, i8* %var1273, i32 3, %clsvar* %addytable1271)
%address-table1275 = bitcast %clsvar* %addytable1274 to i8*

; insert table, function and environment into closure struct
%closure.table1278 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure1268, i32 0, i32 0
store i8* %address-table1275, i8** %closure.table1278
%closure.env1279 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure1268, i32 0, i32 1
store i8* %envptr1269, i8** %closure.env1279
%closure.func1280 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure1268, i32 0, i32 2
store %Rational (i8*, i8*, i32, %Rational)* @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0__1254, %Rational (i8*, i8*, i32, %Rational)** %closure.func1280
%closure_size1281 = call i64 @llvm_zone_mark_size(%mzone* %zone1266)
call void @llvm_zone_ptr_set_size(i8* %clsptr1267, i64 %closure_size1281)
%wrapper_ptr1282 = call i8* @llvm_zone_malloc(%mzone* %zone1266, i64 8)
%closure_wrapper1283 = bitcast i8* %wrapper_ptr1282 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure1268, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper1283

; let value assignment
%xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper1283, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper1283
store { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0
%tmp_envptr1277 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}* %environment1270, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**** %tmp_envptr1277


%val1286 = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %val1286
}


@xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_native(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Rational}*
%arg_p_0 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational90 = hidden constant [50 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ\00"
define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ__1288(i8* %_impz,i8* %_impenv, %Rational %a, i8 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1289 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}*
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i8
store i8 %b, i8* %bPtr


%val1290 = load %Rational, %Rational* %aPtr
; tuple ref
%val1291 = extractvalue %Rational %val1290, 0
%val1292 = load i8, i8* %bPtr
%res1293 = call ccc i64 @i8toi64(i8 %val1292)
%val1294 = mul i64 %val1291, %res1293
%val1295 = load %Rational, %Rational* %aPtr
; tuple ref
%val1296 = extractvalue %Rational %val1295, 1
%val1297 = mul i64 %val1296, 1
%res1298 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1294, i64 %val1297)
ret %Rational %res1298
}
@gsxtmrational91 = hidden constant [103 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1318 = load i8*, i8** %_impzPtr
%zone1319 = bitcast i8* %tzone1318 to %mzone*

; let assign value to symbol xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ
%dat_xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ = call i8* @llvm_zone_malloc(%mzone* %zone1319, i64 8)
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr = bitcast i8* %dat_xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***
%tzone1299 = load i8*, i8** %_impzPtr
%zone1300 = bitcast i8* %tzone1299 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1300)
; malloc closure structure
%clsptr1301 = call i8* @llvm_zone_malloc(%mzone* %zone1300, i64 24)
%closure1302 = bitcast i8* %clsptr1301 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*

; malloc environment structure
%envptr1303 = call i8* @llvm_zone_malloc(%mzone* %zone1300, i64 8)
%environment1304 = bitcast i8* %envptr1303 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}*

; malloc closure address table
%addytable1305 = call %clsvar* @new_address_table()
%var1306 = bitcast [50 x i8]* @gsxtmrational90 to i8*
%var1307 = bitcast [51 x i8]* @gsxtmrational58 to i8*
%addytable1308 = call %clsvar* @add_address_table(%mzone* %zone1300, i8* %var1306, i32 0, i8* %var1307, i32 3, %clsvar* %addytable1305)
%address-table1309 = bitcast %clsvar* %addytable1308 to i8*

; insert table, function and environment into closure struct
%closure.table1312 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure1302, i32 0, i32 0
store i8* %address-table1309, i8** %closure.table1312
%closure.env1313 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure1302, i32 0, i32 1
store i8* %envptr1303, i8** %closure.env1313
%closure.func1314 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure1302, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i8)* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ__1288, %Rational (i8*, i8*, %Rational, i8)** %closure.func1314
%closure_size1315 = call i64 @llvm_zone_mark_size(%mzone* %zone1300)
call void @llvm_zone_ptr_set_size(i8* %clsptr1301, i64 %closure_size1315)
%wrapper_ptr1316 = call i8* @llvm_zone_malloc(%mzone* %zone1300, i64 8)
%closure_wrapper1317 = bitcast i8* %wrapper_ptr1316 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure1302, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper1317

; let value assignment
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper1317, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper1317
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ
%tmp_envptr1311 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}* %environment1304, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**** %tmp_envptr1311


%val1320 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %val1320
}


@xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_native(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i8}*
%arg_p_0 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational92 = hidden constant [50 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ\00"
define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ__1322(i8* %_impz,i8* %_impenv, i8 %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1323 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}*
%xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**** %xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca i8
store i8 %a, i8* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%val1324 = load %Rational, %Rational* %bPtr
; tuple ref
%val1325 = extractvalue %Rational %val1324, 1
%val1326 = load i8, i8* %aPtr
%res1327 = call ccc i64 @i8toi64(i8 %val1326)
%val1328 = mul i64 %val1325, %res1327
%val1329 = load %Rational, %Rational* %bPtr
; tuple ref
%val1330 = extractvalue %Rational %val1329, 0
%val1331 = mul i64 %val1330, 1
%res1332 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1328, i64 %val1331)
ret %Rational %res1332
}
@gsxtmrational93 = hidden constant [103 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1352 = load i8*, i8** %_impzPtr
%zone1353 = bitcast i8* %tzone1352 to %mzone*

; let assign value to symbol xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ
%dat_xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone1353, i64 8)
%xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***
%tzone1333 = load i8*, i8** %_impzPtr
%zone1334 = bitcast i8* %tzone1333 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1334)
; malloc closure structure
%clsptr1335 = call i8* @llvm_zone_malloc(%mzone* %zone1334, i64 24)
%closure1336 = bitcast i8* %clsptr1335 to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*

; malloc environment structure
%envptr1337 = call i8* @llvm_zone_malloc(%mzone* %zone1334, i64 8)
%environment1338 = bitcast i8* %envptr1337 to {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}*

; malloc closure address table
%addytable1339 = call %clsvar* @new_address_table()
%var1340 = bitcast [50 x i8]* @gsxtmrational92 to i8*
%var1341 = bitcast [51 x i8]* @gsxtmrational61 to i8*
%addytable1342 = call %clsvar* @add_address_table(%mzone* %zone1334, i8* %var1340, i32 0, i8* %var1341, i32 3, %clsvar* %addytable1339)
%address-table1343 = bitcast %clsvar* %addytable1342 to i8*

; insert table, function and environment into closure struct
%closure.table1346 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure1336, i32 0, i32 0
store i8* %address-table1343, i8** %closure.table1346
%closure.env1347 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure1336, i32 0, i32 1
store i8* %envptr1337, i8** %closure.env1347
%closure.func1348 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure1336, i32 0, i32 2
store %Rational (i8*, i8*, i8, %Rational)* @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ__1322, %Rational (i8*, i8*, i8, %Rational)** %closure.func1348
%closure_size1349 = call i64 @llvm_zone_mark_size(%mzone* %zone1334)
call void @llvm_zone_ptr_set_size(i8* %clsptr1335, i64 %closure_size1349)
%wrapper_ptr1350 = call i8* @llvm_zone_malloc(%mzone* %zone1334, i64 8)
%closure_wrapper1351 = bitcast i8* %wrapper_ptr1350 to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure1336, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper1351

; let value assignment
%xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper1351, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper1351
store { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ
%tmp_envptr1345 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}* %environment1338, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**** %tmp_envptr1345


%val1354 = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %val1354
}


@xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_native(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8, %Rational}*
%arg_p_0 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
%arg_p_1 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational94 = hidden constant [50 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ\00"
define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ__1356(i8* %_impz,i8* %_impenv, %Rational %a, i1 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1357 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}*
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i1
store i1 %b, i1* %bPtr


%val1358 = load %Rational, %Rational* %aPtr
; tuple ref
%val1359 = extractvalue %Rational %val1358, 0
%val1360 = load i1, i1* %bPtr
%res1361 = call ccc i64 @i1toi64(i1 %val1360)
%val1362 = mul i64 %val1359, %res1361
%val1363 = load %Rational, %Rational* %aPtr
; tuple ref
%val1364 = extractvalue %Rational %val1363, 1
%val1365 = mul i64 %val1364, 1
%res1366 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1362, i64 %val1365)
ret %Rational %res1366
}
@gsxtmrational95 = hidden constant [103 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1386 = load i8*, i8** %_impzPtr
%zone1387 = bitcast i8* %tzone1386 to %mzone*

; let assign value to symbol xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ
%dat_xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ = call i8* @llvm_zone_malloc(%mzone* %zone1387, i64 8)
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr = bitcast i8* %dat_xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***
%tzone1367 = load i8*, i8** %_impzPtr
%zone1368 = bitcast i8* %tzone1367 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1368)
; malloc closure structure
%clsptr1369 = call i8* @llvm_zone_malloc(%mzone* %zone1368, i64 24)
%closure1370 = bitcast i8* %clsptr1369 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*

; malloc environment structure
%envptr1371 = call i8* @llvm_zone_malloc(%mzone* %zone1368, i64 8)
%environment1372 = bitcast i8* %envptr1371 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}*

; malloc closure address table
%addytable1373 = call %clsvar* @new_address_table()
%var1374 = bitcast [50 x i8]* @gsxtmrational94 to i8*
%var1375 = bitcast [51 x i8]* @gsxtmrational64 to i8*
%addytable1376 = call %clsvar* @add_address_table(%mzone* %zone1368, i8* %var1374, i32 0, i8* %var1375, i32 3, %clsvar* %addytable1373)
%address-table1377 = bitcast %clsvar* %addytable1376 to i8*

; insert table, function and environment into closure struct
%closure.table1380 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure1370, i32 0, i32 0
store i8* %address-table1377, i8** %closure.table1380
%closure.env1381 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure1370, i32 0, i32 1
store i8* %envptr1371, i8** %closure.env1381
%closure.func1382 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure1370, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i1)* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ__1356, %Rational (i8*, i8*, %Rational, i1)** %closure.func1382
%closure_size1383 = call i64 @llvm_zone_mark_size(%mzone* %zone1368)
call void @llvm_zone_ptr_set_size(i8* %clsptr1369, i64 %closure_size1383)
%wrapper_ptr1384 = call i8* @llvm_zone_malloc(%mzone* %zone1368, i64 8)
%closure_wrapper1385 = bitcast i8* %wrapper_ptr1384 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure1370, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_wrapper1385

; let value assignment
%xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_wrapper1385, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_wrapper1385
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ
%tmp_envptr1379 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}* %environment1372, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**** %tmp_envptr1379


%val1388 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %val1388
}


@xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i1)*,  %Rational (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_native(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i1)*,  %Rational (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i1}*
%arg_p_0 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 1
%arg_1 = load i1, i1* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i1)*,  %Rational (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational96 = hidden constant [50 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ\00"
define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ__1390(i8* %_impz,i8* %_impenv, i1 %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1391 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}*
%xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**** %xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca i1
store i1 %a, i1* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%val1392 = load %Rational, %Rational* %bPtr
; tuple ref
%val1393 = extractvalue %Rational %val1392, 1
%val1394 = load i1, i1* %aPtr
%res1395 = call ccc i64 @i1toi64(i1 %val1394)
%val1396 = mul i64 %val1393, %res1395
%val1397 = load %Rational, %Rational* %bPtr
; tuple ref
%val1398 = extractvalue %Rational %val1397, 0
%val1399 = mul i64 %val1398, 1
%res1400 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1396, i64 %val1399)
ret %Rational %res1400
}
@gsxtmrational97 = hidden constant [103 x i8] c"xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1420 = load i8*, i8** %_impzPtr
%zone1421 = bitcast i8* %tzone1420 to %mzone*

; let assign value to symbol xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ
%dat_xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone1421, i64 8)
%xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***
%tzone1401 = load i8*, i8** %_impzPtr
%zone1402 = bitcast i8* %tzone1401 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1402)
; malloc closure structure
%clsptr1403 = call i8* @llvm_zone_malloc(%mzone* %zone1402, i64 24)
%closure1404 = bitcast i8* %clsptr1403 to { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*

; malloc environment structure
%envptr1405 = call i8* @llvm_zone_malloc(%mzone* %zone1402, i64 8)
%environment1406 = bitcast i8* %envptr1405 to {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}*

; malloc closure address table
%addytable1407 = call %clsvar* @new_address_table()
%var1408 = bitcast [50 x i8]* @gsxtmrational96 to i8*
%var1409 = bitcast [51 x i8]* @gsxtmrational67 to i8*
%addytable1410 = call %clsvar* @add_address_table(%mzone* %zone1402, i8* %var1408, i32 0, i8* %var1409, i32 3, %clsvar* %addytable1407)
%address-table1411 = bitcast %clsvar* %addytable1410 to i8*

; insert table, function and environment into closure struct
%closure.table1414 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure1404, i32 0, i32 0
store i8* %address-table1411, i8** %closure.table1414
%closure.env1415 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure1404, i32 0, i32 1
store i8* %envptr1405, i8** %closure.env1415
%closure.func1416 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure1404, i32 0, i32 2
store %Rational (i8*, i8*, i1, %Rational)* @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ__1390, %Rational (i8*, i8*, i1, %Rational)** %closure.func1416
%closure_size1417 = call i64 @llvm_zone_mark_size(%mzone* %zone1402)
call void @llvm_zone_ptr_set_size(i8* %clsptr1403, i64 %closure_size1417)
%wrapper_ptr1418 = call i8* @llvm_zone_malloc(%mzone* %zone1402, i64 8)
%closure_wrapper1419 = bitcast i8* %wrapper_ptr1418 to { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure1404, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_wrapper1419

; let value assignment
%xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_wrapper1419, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_wrapper1419
store { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ
%tmp_envptr1413 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}* %environment1406, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**** %tmp_envptr1413


%val1422 = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*** %xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %val1422
}


@xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i1, %Rational)*,  %Rational (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_native(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i1, %Rational)*,  %Rational (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1, %Rational}*
%arg_p_0 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
%arg_p_1 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i1, %Rational)*,  %Rational (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational98 = hidden constant [52 x i8] c"xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd\00"
define dllexport fastcc double @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd__1424(i8* %_impz,i8* %_impenv, %Rational %a, double %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1425 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}*
%xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}, {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}***, {i8*, i8*, double (i8*, i8*, %Rational, double)*}**** %xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca double
store double %b, double* %bPtr


%val1426 = load %Rational, %Rational* %aPtr
; tuple ref
%val1427 = extractvalue %Rational %val1426, 0
%val1428 = sitofp i64 %val1427 to double
%val1429 = load %Rational, %Rational* %aPtr
; tuple ref
%val1430 = extractvalue %Rational %val1429, 1
%val1431 = sitofp i64 %val1430 to double
%val1432 = fdiv double %val1428, %val1431
%val1433 = load double, double* %bPtr
%val1434 = fdiv double %val1432, %val1433
ret double %val1434
}
@gsxtmrational99 = hidden constant [105 x i8] c"xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, %Rational, double)*}** @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1454 = load i8*, i8** %_impzPtr
%zone1455 = bitcast i8* %tzone1454 to %mzone*

; let assign value to symbol xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd
%dat_xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone1455, i64 8)
%xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr = bitcast i8* %dat_xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd to { i8*, i8*, double (i8*, i8*, %Rational, double)*}***
%tzone1435 = load i8*, i8** %_impzPtr
%zone1436 = bitcast i8* %tzone1435 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1436)
; malloc closure structure
%clsptr1437 = call i8* @llvm_zone_malloc(%mzone* %zone1436, i64 24)
%closure1438 = bitcast i8* %clsptr1437 to { i8*, i8*, double (i8*, i8*, %Rational, double)*}*

; malloc environment structure
%envptr1439 = call i8* @llvm_zone_malloc(%mzone* %zone1436, i64 8)
%environment1440 = bitcast i8* %envptr1439 to {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}*

; malloc closure address table
%addytable1441 = call %clsvar* @new_address_table()
%var1442 = bitcast [52 x i8]* @gsxtmrational98 to i8*
%var1443 = bitcast [52 x i8]* @gsxtmrational70 to i8*
%addytable1444 = call %clsvar* @add_address_table(%mzone* %zone1436, i8* %var1442, i32 0, i8* %var1443, i32 3, %clsvar* %addytable1441)
%address-table1445 = bitcast %clsvar* %addytable1444 to i8*

; insert table, function and environment into closure struct
%closure.table1448 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational, double)*}, { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure1438, i32 0, i32 0
store i8* %address-table1445, i8** %closure.table1448
%closure.env1449 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational, double)*}, { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure1438, i32 0, i32 1
store i8* %envptr1439, i8** %closure.env1449
%closure.func1450 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational, double)*}, { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure1438, i32 0, i32 2
store double (i8*, i8*, %Rational, double)* @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd__1424, double (i8*, i8*, %Rational, double)** %closure.func1450
%closure_size1451 = call i64 @llvm_zone_mark_size(%mzone* %zone1436)
call void @llvm_zone_ptr_set_size(i8* %clsptr1437, i64 %closure_size1451)
%wrapper_ptr1452 = call i8* @llvm_zone_malloc(%mzone* %zone1436, i64 8)
%closure_wrapper1453 = bitcast i8* %wrapper_ptr1452 to { i8*, i8*, double (i8*, i8*, %Rational, double)*}**
store { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure1438, { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_wrapper1453

; let value assignment
%xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd = select i1 true, { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_wrapper1453, { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_wrapper1453
store { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd, { i8*, i8*, double (i8*, i8*, %Rational, double)*}*** %xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd
%tmp_envptr1447 = getelementptr {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}, {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}* %environment1440, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, %Rational, double)*}*** %xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr, {i8*, i8*, double (i8*, i8*, %Rational, double)*}**** %tmp_envptr1447


%val1456 = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}**, {i8*, i8*, double (i8*, i8*, %Rational, double)*}*** %xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr
ret {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %val1456
}


@xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, %Rational, double)*}** @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd(%Rational %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}*, {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational, double)*,  double (i8*, i8*, %Rational, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc double @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_native(%Rational %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}*, {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational, double)*,  double (i8*, i8*, %Rational, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc void @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, double}*
%arg_p_0 = getelementptr {%Rational, double}, {%Rational, double}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, double}, {%Rational, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}*, {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational, double)*,  double (i8*, i8*, %Rational, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational100 = hidden constant [52 x i8] c"xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd\00"
define dllexport fastcc double @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd__1458(i8* %_impz,i8* %_impenv, double %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1459 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}*
%xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}, {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}***, {i8*, i8*, double (i8*, i8*, double, %Rational)*}**** %xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr_

; setup arguments
%bPtr = alloca double
store double %b, double* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val1460 = load %Rational, %Rational* %aPtr
; tuple ref
%val1461 = extractvalue %Rational %val1460, 0
%val1462 = sitofp i64 %val1461 to double
%val1463 = load %Rational, %Rational* %aPtr
; tuple ref
%val1464 = extractvalue %Rational %val1463, 1
%val1465 = sitofp i64 %val1464 to double
%val1466 = fdiv double %val1462, %val1465
%val1467 = load double, double* %bPtr
%val1468 = fdiv double %val1466, %val1467
ret double %val1468
}
@gsxtmrational101 = hidden constant [105 x i8] c"xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double, %Rational)*}** @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1488 = load i8*, i8** %_impzPtr
%zone1489 = bitcast i8* %tzone1488 to %mzone*

; let assign value to symbol xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd
%dat_xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd = call i8* @llvm_zone_malloc(%mzone* %zone1489, i64 8)
%xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr = bitcast i8* %dat_xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd to { i8*, i8*, double (i8*, i8*, double, %Rational)*}***
%tzone1469 = load i8*, i8** %_impzPtr
%zone1470 = bitcast i8* %tzone1469 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1470)
; malloc closure structure
%clsptr1471 = call i8* @llvm_zone_malloc(%mzone* %zone1470, i64 24)
%closure1472 = bitcast i8* %clsptr1471 to { i8*, i8*, double (i8*, i8*, double, %Rational)*}*

; malloc environment structure
%envptr1473 = call i8* @llvm_zone_malloc(%mzone* %zone1470, i64 8)
%environment1474 = bitcast i8* %envptr1473 to {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}*

; malloc closure address table
%addytable1475 = call %clsvar* @new_address_table()
%var1476 = bitcast [52 x i8]* @gsxtmrational100 to i8*
%var1477 = bitcast [52 x i8]* @gsxtmrational73 to i8*
%addytable1478 = call %clsvar* @add_address_table(%mzone* %zone1470, i8* %var1476, i32 0, i8* %var1477, i32 3, %clsvar* %addytable1475)
%address-table1479 = bitcast %clsvar* %addytable1478 to i8*

; insert table, function and environment into closure struct
%closure.table1482 = getelementptr { i8*, i8*, double (i8*, i8*, double, %Rational)*}, { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure1472, i32 0, i32 0
store i8* %address-table1479, i8** %closure.table1482
%closure.env1483 = getelementptr { i8*, i8*, double (i8*, i8*, double, %Rational)*}, { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure1472, i32 0, i32 1
store i8* %envptr1473, i8** %closure.env1483
%closure.func1484 = getelementptr { i8*, i8*, double (i8*, i8*, double, %Rational)*}, { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure1472, i32 0, i32 2
store double (i8*, i8*, double, %Rational)* @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd__1458, double (i8*, i8*, double, %Rational)** %closure.func1484
%closure_size1485 = call i64 @llvm_zone_mark_size(%mzone* %zone1470)
call void @llvm_zone_ptr_set_size(i8* %clsptr1471, i64 %closure_size1485)
%wrapper_ptr1486 = call i8* @llvm_zone_malloc(%mzone* %zone1470, i64 8)
%closure_wrapper1487 = bitcast i8* %wrapper_ptr1486 to { i8*, i8*, double (i8*, i8*, double, %Rational)*}**
store { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure1472, { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_wrapper1487

; let value assignment
%xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd = select i1 true, { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_wrapper1487, { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_wrapper1487
store { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd, { i8*, i8*, double (i8*, i8*, double, %Rational)*}*** %xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd
%tmp_envptr1481 = getelementptr {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}, {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}* %environment1474, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double, %Rational)*}*** %xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr, {i8*, i8*, double (i8*, i8*, double, %Rational)*}**** %tmp_envptr1481


%val1490 = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}**, {i8*, i8*, double (i8*, i8*, double, %Rational)*}*** %xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr
ret {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %val1490
}


@xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double, %Rational)*}** @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd(double %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}*, {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %Rational)*,  double (i8*, i8*, double, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %Rational %arg_1)
ret double %result
}


define dllexport ccc double @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_native(double %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}*, {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %Rational)*,  double (i8*, i8*, double, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %Rational %arg_1)
ret double %result
}


define dllexport ccc void @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, %Rational}*
%arg_p_0 = getelementptr {double, %Rational}, {double, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, %Rational}, {double, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}*, {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %Rational)*,  double (i8*, i8*, double, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational102 = hidden constant [50 x i8] c"xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ\00"
define dllexport fastcc float @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ__1492(i8* %_impz,i8* %_impenv, %Rational %a, float %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1493 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}*
%xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}, {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}***, {i8*, i8*, float (i8*, i8*, %Rational, float)*}**** %xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca float
store float %b, float* %bPtr


%val1494 = load %Rational, %Rational* %aPtr
; tuple ref
%val1495 = extractvalue %Rational %val1494, 0
%val1496 = sitofp i64 %val1495 to float
%val1497 = load %Rational, %Rational* %aPtr
; tuple ref
%val1498 = extractvalue %Rational %val1497, 1
%val1499 = sitofp i64 %val1498 to float
%val1500 = fdiv float %val1496, %val1499
%val1501 = load float, float* %bPtr
%val1502 = fdiv float %val1500, %val1501
ret float %val1502
}
@gsxtmrational103 = hidden constant [103 x i8] c"xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %Rational, float)*}** @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1522 = load i8*, i8** %_impzPtr
%zone1523 = bitcast i8* %tzone1522 to %mzone*

; let assign value to symbol xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ
%dat_xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1523, i64 8)
%xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr = bitcast i8* %dat_xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ to { i8*, i8*, float (i8*, i8*, %Rational, float)*}***
%tzone1503 = load i8*, i8** %_impzPtr
%zone1504 = bitcast i8* %tzone1503 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1504)
; malloc closure structure
%clsptr1505 = call i8* @llvm_zone_malloc(%mzone* %zone1504, i64 24)
%closure1506 = bitcast i8* %clsptr1505 to { i8*, i8*, float (i8*, i8*, %Rational, float)*}*

; malloc environment structure
%envptr1507 = call i8* @llvm_zone_malloc(%mzone* %zone1504, i64 8)
%environment1508 = bitcast i8* %envptr1507 to {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}*

; malloc closure address table
%addytable1509 = call %clsvar* @new_address_table()
%var1510 = bitcast [50 x i8]* @gsxtmrational102 to i8*
%var1511 = bitcast [50 x i8]* @gsxtmrational76 to i8*
%addytable1512 = call %clsvar* @add_address_table(%mzone* %zone1504, i8* %var1510, i32 0, i8* %var1511, i32 3, %clsvar* %addytable1509)
%address-table1513 = bitcast %clsvar* %addytable1512 to i8*

; insert table, function and environment into closure struct
%closure.table1516 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational, float)*}, { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure1506, i32 0, i32 0
store i8* %address-table1513, i8** %closure.table1516
%closure.env1517 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational, float)*}, { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure1506, i32 0, i32 1
store i8* %envptr1507, i8** %closure.env1517
%closure.func1518 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational, float)*}, { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure1506, i32 0, i32 2
store float (i8*, i8*, %Rational, float)* @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ__1492, float (i8*, i8*, %Rational, float)** %closure.func1518
%closure_size1519 = call i64 @llvm_zone_mark_size(%mzone* %zone1504)
call void @llvm_zone_ptr_set_size(i8* %clsptr1505, i64 %closure_size1519)
%wrapper_ptr1520 = call i8* @llvm_zone_malloc(%mzone* %zone1504, i64 8)
%closure_wrapper1521 = bitcast i8* %wrapper_ptr1520 to { i8*, i8*, float (i8*, i8*, %Rational, float)*}**
store { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure1506, { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_wrapper1521

; let value assignment
%xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ = select i1 true, { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_wrapper1521, { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_wrapper1521
store { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ, { i8*, i8*, float (i8*, i8*, %Rational, float)*}*** %xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ
%tmp_envptr1515 = getelementptr {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}, {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}* %environment1508, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %Rational, float)*}*** %xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr, {i8*, i8*, float (i8*, i8*, %Rational, float)*}**** %tmp_envptr1515


%val1524 = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}**, {i8*, i8*, float (i8*, i8*, %Rational, float)*}*** %xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr
ret {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %val1524
}


@xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %Rational, float)*}** @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ(%Rational %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}*, {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational, float)*,  float (i8*, i8*, %Rational, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0, float %arg_1)
ret float %result
}


define dllexport ccc float @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_native(%Rational %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}*, {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational, float)*,  float (i8*, i8*, %Rational, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0, float %arg_1)
ret float %result
}


define dllexport ccc void @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, float}*
%arg_p_0 = getelementptr {%Rational, float}, {%Rational, float}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, float}, {%Rational, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}*, {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational, float)*,  float (i8*, i8*, %Rational, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational104 = hidden constant [50 x i8] c"xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ\00"
define dllexport fastcc float @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ__1526(i8* %_impz,i8* %_impenv, float %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1527 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}*
%xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}, {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}***, {i8*, i8*, float (i8*, i8*, float, %Rational)*}**** %xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val1528 = load %Rational, %Rational* %aPtr
; tuple ref
%val1529 = extractvalue %Rational %val1528, 0
%val1530 = sitofp i64 %val1529 to float
%val1531 = load %Rational, %Rational* %aPtr
; tuple ref
%val1532 = extractvalue %Rational %val1531, 1
%val1533 = sitofp i64 %val1532 to float
%val1534 = fdiv float %val1530, %val1533
%val1535 = load float, float* %bPtr
%val1536 = fdiv float %val1534, %val1535
ret float %val1536
}
@gsxtmrational105 = hidden constant [103 x i8] c"xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float, %Rational)*}** @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1556 = load i8*, i8** %_impzPtr
%zone1557 = bitcast i8* %tzone1556 to %mzone*

; let assign value to symbol xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ
%dat_xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone1557, i64 8)
%xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ to { i8*, i8*, float (i8*, i8*, float, %Rational)*}***
%tzone1537 = load i8*, i8** %_impzPtr
%zone1538 = bitcast i8* %tzone1537 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1538)
; malloc closure structure
%clsptr1539 = call i8* @llvm_zone_malloc(%mzone* %zone1538, i64 24)
%closure1540 = bitcast i8* %clsptr1539 to { i8*, i8*, float (i8*, i8*, float, %Rational)*}*

; malloc environment structure
%envptr1541 = call i8* @llvm_zone_malloc(%mzone* %zone1538, i64 8)
%environment1542 = bitcast i8* %envptr1541 to {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}*

; malloc closure address table
%addytable1543 = call %clsvar* @new_address_table()
%var1544 = bitcast [50 x i8]* @gsxtmrational104 to i8*
%var1545 = bitcast [50 x i8]* @gsxtmrational79 to i8*
%addytable1546 = call %clsvar* @add_address_table(%mzone* %zone1538, i8* %var1544, i32 0, i8* %var1545, i32 3, %clsvar* %addytable1543)
%address-table1547 = bitcast %clsvar* %addytable1546 to i8*

; insert table, function and environment into closure struct
%closure.table1550 = getelementptr { i8*, i8*, float (i8*, i8*, float, %Rational)*}, { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure1540, i32 0, i32 0
store i8* %address-table1547, i8** %closure.table1550
%closure.env1551 = getelementptr { i8*, i8*, float (i8*, i8*, float, %Rational)*}, { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure1540, i32 0, i32 1
store i8* %envptr1541, i8** %closure.env1551
%closure.func1552 = getelementptr { i8*, i8*, float (i8*, i8*, float, %Rational)*}, { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure1540, i32 0, i32 2
store float (i8*, i8*, float, %Rational)* @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ__1526, float (i8*, i8*, float, %Rational)** %closure.func1552
%closure_size1553 = call i64 @llvm_zone_mark_size(%mzone* %zone1538)
call void @llvm_zone_ptr_set_size(i8* %clsptr1539, i64 %closure_size1553)
%wrapper_ptr1554 = call i8* @llvm_zone_malloc(%mzone* %zone1538, i64 8)
%closure_wrapper1555 = bitcast i8* %wrapper_ptr1554 to { i8*, i8*, float (i8*, i8*, float, %Rational)*}**
store { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure1540, { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_wrapper1555

; let value assignment
%xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_wrapper1555, { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_wrapper1555
store { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ, { i8*, i8*, float (i8*, i8*, float, %Rational)*}*** %xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ
%tmp_envptr1549 = getelementptr {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}, {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}* %environment1542, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float, %Rational)*}*** %xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr, {i8*, i8*, float (i8*, i8*, float, %Rational)*}**** %tmp_envptr1549


%val1558 = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}**, {i8*, i8*, float (i8*, i8*, float, %Rational)*}*** %xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr
ret {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %val1558
}


@xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float, %Rational)*}** @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ(float %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}*, {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %Rational)*,  float (i8*, i8*, float, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %Rational %arg_1)
ret float %result
}


define dllexport ccc float @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_native(float %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}*, {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %Rational)*,  float (i8*, i8*, float, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %Rational %arg_1)
ret float %result
}


define dllexport ccc void @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, %Rational}*
%arg_p_0 = getelementptr {float, %Rational}, {float, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, %Rational}, {float, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_division_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}*, {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %Rational)*,  float (i8*, i8*, float, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational106 = hidden constant [58 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ\00"
define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ__1560(i8* %_impz,i8* %_impenv, %Rational %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1561 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}*
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%tzone1564 = load i8*, i8** %_impzPtr
%zone1565 = bitcast i8* %tzone1564 to %mzone*

; let assign value to symbol denom_a
%denom_aPtr = alloca i64
%tzone1568 = load i8*, i8** %_impzPtr
%zone1569 = bitcast i8* %tzone1568 to %mzone*

; let assign value to symbol denom_b
%denom_bPtr = alloca i64
%val1562 = load %Rational, %Rational* %aPtr
; tuple ref
%val1563 = extractvalue %Rational %val1562, 1

; let value assignment
%denom_a = select i1 true, i64 %val1563, i64 %val1563
store i64 %denom_a, i64* %denom_aPtr

%val1566 = load %Rational, %Rational* %bPtr
; tuple ref
%val1567 = extractvalue %Rational %val1566, 1

; let value assignment
%denom_b = select i1 true, i64 %val1567, i64 %val1567
store i64 %denom_b, i64* %denom_bPtr

%val1570 = load %Rational, %Rational* %aPtr
; tuple ref
%val1571 = extractvalue %Rational %val1570, 0
%val1572 = load i64, i64* %denom_bPtr
%val1573 = mul i64 %val1571, %val1572
%val1574 = load %Rational, %Rational* %bPtr
; tuple ref
%val1575 = extractvalue %Rational %val1574, 0
%val1576 = load i64, i64* %denom_aPtr
%val1577 = mul i64 %val1575, %val1576
%val1578 = add i64 %val1573, %val1577
%val1579 = load i64, i64* %denom_aPtr
%val1580 = load i64, i64* %denom_bPtr
%val1581 = mul i64 %val1579, %val1580
%res1582 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1578, i64 %val1581)
%res1583 = call fastcc %Rational @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res1582)
ret %Rational %res1583
}
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1603 = load i8*, i8** %_impzPtr
%zone1604 = bitcast i8* %tzone1603 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ
%dat_xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone1604, i64 8)
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***
%tzone1584 = load i8*, i8** %_impzPtr
%zone1585 = bitcast i8* %tzone1584 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1585)
; malloc closure structure
%clsptr1586 = call i8* @llvm_zone_malloc(%mzone* %zone1585, i64 24)
%closure1587 = bitcast i8* %clsptr1586 to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*

; malloc environment structure
%envptr1588 = call i8* @llvm_zone_malloc(%mzone* %zone1585, i64 8)
%environment1589 = bitcast i8* %envptr1588 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}*

; malloc closure address table
%addytable1590 = call %clsvar* @new_address_table()
%var1591 = bitcast [58 x i8]* @gsxtmrational106 to i8*
%var1592 = bitcast [58 x i8]* @gsxtmrational44 to i8*
%addytable1593 = call %clsvar* @add_address_table(%mzone* %zone1585, i8* %var1591, i32 0, i8* %var1592, i32 3, %clsvar* %addytable1590)
%address-table1594 = bitcast %clsvar* %addytable1593 to i8*

; insert table, function and environment into closure struct
%closure.table1597 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure1587, i32 0, i32 0
store i8* %address-table1594, i8** %closure.table1597
%closure.env1598 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure1587, i32 0, i32 1
store i8* %envptr1588, i8** %closure.env1598
%closure.func1599 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure1587, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, %Rational)* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ__1560, %Rational (i8*, i8*, %Rational, %Rational)** %closure.func1599
%closure_size1600 = call i64 @llvm_zone_mark_size(%mzone* %zone1585)
call void @llvm_zone_ptr_set_size(i8* %clsptr1586, i64 %closure_size1600)
%wrapper_ptr1601 = call i8* @llvm_zone_malloc(%mzone* %zone1585, i64 8)
%closure_wrapper1602 = bitcast i8* %wrapper_ptr1601 to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure1587, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper1602

; let value assignment
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper1602, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper1602
store { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ
%tmp_envptr1596 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}* %environment1589, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**** %tmp_envptr1596


%val1605 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %val1605
}


@xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_native(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, %Rational}*
%arg_p_0 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational107 = hidden constant [51 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0\00"
define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0__1606(i8* %_impz,i8* %_impenv, %Rational %a, i64 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1607 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}*
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i64
store i64 %b, i64* %bPtr


%val1608 = load %Rational, %Rational* %aPtr
; tuple ref
%val1609 = extractvalue %Rational %val1608, 0
%val1610 = load %Rational, %Rational* %aPtr
; tuple ref
%val1611 = extractvalue %Rational %val1610, 1
%val1612 = load i64, i64* %bPtr
%val1613 = mul i64 %val1611, %val1612
%val1614 = add i64 %val1609, %val1613
%val1615 = load %Rational, %Rational* %aPtr
; tuple ref
%val1616 = extractvalue %Rational %val1615, 1
%res1617 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1614, i64 %val1616)
ret %Rational %res1617
}
@gsxtmrational108 = hidden constant [104 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1637 = load i8*, i8** %_impzPtr
%zone1638 = bitcast i8* %tzone1637 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0
%dat_xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone1638, i64 8)
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr = bitcast i8* %dat_xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***
%tzone1618 = load i8*, i8** %_impzPtr
%zone1619 = bitcast i8* %tzone1618 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1619)
; malloc closure structure
%clsptr1620 = call i8* @llvm_zone_malloc(%mzone* %zone1619, i64 24)
%closure1621 = bitcast i8* %clsptr1620 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*

; malloc environment structure
%envptr1622 = call i8* @llvm_zone_malloc(%mzone* %zone1619, i64 8)
%environment1623 = bitcast i8* %envptr1622 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}*

; malloc closure address table
%addytable1624 = call %clsvar* @new_address_table()
%var1625 = bitcast [51 x i8]* @gsxtmrational107 to i8*
%var1626 = bitcast [52 x i8]* @gsxtmrational46 to i8*
%addytable1627 = call %clsvar* @add_address_table(%mzone* %zone1619, i8* %var1625, i32 0, i8* %var1626, i32 3, %clsvar* %addytable1624)
%address-table1628 = bitcast %clsvar* %addytable1627 to i8*

; insert table, function and environment into closure struct
%closure.table1631 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure1621, i32 0, i32 0
store i8* %address-table1628, i8** %closure.table1631
%closure.env1632 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure1621, i32 0, i32 1
store i8* %envptr1622, i8** %closure.env1632
%closure.func1633 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure1621, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i64)* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0__1606, %Rational (i8*, i8*, %Rational, i64)** %closure.func1633
%closure_size1634 = call i64 @llvm_zone_mark_size(%mzone* %zone1619)
call void @llvm_zone_ptr_set_size(i8* %clsptr1620, i64 %closure_size1634)
%wrapper_ptr1635 = call i8* @llvm_zone_malloc(%mzone* %zone1619, i64 8)
%closure_wrapper1636 = bitcast i8* %wrapper_ptr1635 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure1621, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper1636

; let value assignment
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper1636, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper1636
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0
%tmp_envptr1630 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}* %environment1623, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**** %tmp_envptr1630


%val1639 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %val1639
}


@xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_native(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i64}*
%arg_p_0 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational109 = hidden constant [51 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0\00"
define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0__1641(i8* %_impz,i8* %_impenv, i64 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1642 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}*
%xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**** %xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i64
store i64 %b, i64* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val1643 = load %Rational, %Rational* %aPtr
; tuple ref
%val1644 = extractvalue %Rational %val1643, 0
%val1645 = load %Rational, %Rational* %aPtr
; tuple ref
%val1646 = extractvalue %Rational %val1645, 1
%val1647 = load i64, i64* %bPtr
%val1648 = mul i64 %val1646, %val1647
%val1649 = add i64 %val1644, %val1648
%val1650 = load %Rational, %Rational* %aPtr
; tuple ref
%val1651 = extractvalue %Rational %val1650, 1
%res1652 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1649, i64 %val1651)
ret %Rational %res1652
}
@gsxtmrational110 = hidden constant [104 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1672 = load i8*, i8** %_impzPtr
%zone1673 = bitcast i8* %tzone1672 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0
%dat_xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone1673, i64 8)
%xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***
%tzone1653 = load i8*, i8** %_impzPtr
%zone1654 = bitcast i8* %tzone1653 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1654)
; malloc closure structure
%clsptr1655 = call i8* @llvm_zone_malloc(%mzone* %zone1654, i64 24)
%closure1656 = bitcast i8* %clsptr1655 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*

; malloc environment structure
%envptr1657 = call i8* @llvm_zone_malloc(%mzone* %zone1654, i64 8)
%environment1658 = bitcast i8* %envptr1657 to {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}*

; malloc closure address table
%addytable1659 = call %clsvar* @new_address_table()
%var1660 = bitcast [51 x i8]* @gsxtmrational109 to i8*
%var1661 = bitcast [52 x i8]* @gsxtmrational49 to i8*
%addytable1662 = call %clsvar* @add_address_table(%mzone* %zone1654, i8* %var1660, i32 0, i8* %var1661, i32 3, %clsvar* %addytable1659)
%address-table1663 = bitcast %clsvar* %addytable1662 to i8*

; insert table, function and environment into closure struct
%closure.table1666 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure1656, i32 0, i32 0
store i8* %address-table1663, i8** %closure.table1666
%closure.env1667 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure1656, i32 0, i32 1
store i8* %envptr1657, i8** %closure.env1667
%closure.func1668 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure1656, i32 0, i32 2
store %Rational (i8*, i8*, i64, %Rational)* @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0__1641, %Rational (i8*, i8*, i64, %Rational)** %closure.func1668
%closure_size1669 = call i64 @llvm_zone_mark_size(%mzone* %zone1654)
call void @llvm_zone_ptr_set_size(i8* %clsptr1655, i64 %closure_size1669)
%wrapper_ptr1670 = call i8* @llvm_zone_malloc(%mzone* %zone1654, i64 8)
%closure_wrapper1671 = bitcast i8* %wrapper_ptr1670 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure1656, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper1671

; let value assignment
%xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper1671, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper1671
store { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0
%tmp_envptr1665 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}* %environment1658, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**** %tmp_envptr1665


%val1674 = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %val1674
}


@xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_native(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, %Rational}*
%arg_p_0 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational111 = hidden constant [51 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0\00"
define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0__1676(i8* %_impz,i8* %_impenv, %Rational %a, i32 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1677 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}*
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i32
store i32 %b, i32* %bPtr


%val1678 = load %Rational, %Rational* %aPtr
; tuple ref
%val1679 = extractvalue %Rational %val1678, 0
%val1680 = load %Rational, %Rational* %aPtr
; tuple ref
%val1681 = extractvalue %Rational %val1680, 1
%val1682 = load i32, i32* %bPtr
%res1683 = call ccc i64 @i32toi64(i32 %val1682)
%val1684 = mul i64 %val1681, %res1683
%val1685 = add i64 %val1679, %val1684
%val1686 = load %Rational, %Rational* %aPtr
; tuple ref
%val1687 = extractvalue %Rational %val1686, 1
%res1688 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1685, i64 %val1687)
ret %Rational %res1688
}
@gsxtmrational112 = hidden constant [104 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1708 = load i8*, i8** %_impzPtr
%zone1709 = bitcast i8* %tzone1708 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0
%dat_xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone1709, i64 8)
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr = bitcast i8* %dat_xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***
%tzone1689 = load i8*, i8** %_impzPtr
%zone1690 = bitcast i8* %tzone1689 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1690)
; malloc closure structure
%clsptr1691 = call i8* @llvm_zone_malloc(%mzone* %zone1690, i64 24)
%closure1692 = bitcast i8* %clsptr1691 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*

; malloc environment structure
%envptr1693 = call i8* @llvm_zone_malloc(%mzone* %zone1690, i64 8)
%environment1694 = bitcast i8* %envptr1693 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}*

; malloc closure address table
%addytable1695 = call %clsvar* @new_address_table()
%var1696 = bitcast [51 x i8]* @gsxtmrational111 to i8*
%var1697 = bitcast [52 x i8]* @gsxtmrational52 to i8*
%addytable1698 = call %clsvar* @add_address_table(%mzone* %zone1690, i8* %var1696, i32 0, i8* %var1697, i32 3, %clsvar* %addytable1695)
%address-table1699 = bitcast %clsvar* %addytable1698 to i8*

; insert table, function and environment into closure struct
%closure.table1702 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure1692, i32 0, i32 0
store i8* %address-table1699, i8** %closure.table1702
%closure.env1703 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure1692, i32 0, i32 1
store i8* %envptr1693, i8** %closure.env1703
%closure.func1704 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure1692, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i32)* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0__1676, %Rational (i8*, i8*, %Rational, i32)** %closure.func1704
%closure_size1705 = call i64 @llvm_zone_mark_size(%mzone* %zone1690)
call void @llvm_zone_ptr_set_size(i8* %clsptr1691, i64 %closure_size1705)
%wrapper_ptr1706 = call i8* @llvm_zone_malloc(%mzone* %zone1690, i64 8)
%closure_wrapper1707 = bitcast i8* %wrapper_ptr1706 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure1692, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper1707

; let value assignment
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper1707, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper1707
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0
%tmp_envptr1701 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}* %environment1694, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**** %tmp_envptr1701


%val1710 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %val1710
}


@xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_native(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i32}*
%arg_p_0 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational113 = hidden constant [51 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0\00"
define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0__1712(i8* %_impz,i8* %_impenv, i32 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1713 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}*
%xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**** %xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i32
store i32 %b, i32* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val1714 = load %Rational, %Rational* %aPtr
; tuple ref
%val1715 = extractvalue %Rational %val1714, 0
%val1716 = load %Rational, %Rational* %aPtr
; tuple ref
%val1717 = extractvalue %Rational %val1716, 1
%val1718 = load i32, i32* %bPtr
%res1719 = call ccc i64 @i32toi64(i32 %val1718)
%val1720 = mul i64 %val1717, %res1719
%val1721 = add i64 %val1715, %val1720
%val1722 = load %Rational, %Rational* %aPtr
; tuple ref
%val1723 = extractvalue %Rational %val1722, 1
%res1724 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1721, i64 %val1723)
ret %Rational %res1724
}
@gsxtmrational114 = hidden constant [104 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1744 = load i8*, i8** %_impzPtr
%zone1745 = bitcast i8* %tzone1744 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0
%dat_xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone1745, i64 8)
%xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***
%tzone1725 = load i8*, i8** %_impzPtr
%zone1726 = bitcast i8* %tzone1725 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1726)
; malloc closure structure
%clsptr1727 = call i8* @llvm_zone_malloc(%mzone* %zone1726, i64 24)
%closure1728 = bitcast i8* %clsptr1727 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*

; malloc environment structure
%envptr1729 = call i8* @llvm_zone_malloc(%mzone* %zone1726, i64 8)
%environment1730 = bitcast i8* %envptr1729 to {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}*

; malloc closure address table
%addytable1731 = call %clsvar* @new_address_table()
%var1732 = bitcast [51 x i8]* @gsxtmrational113 to i8*
%var1733 = bitcast [52 x i8]* @gsxtmrational55 to i8*
%addytable1734 = call %clsvar* @add_address_table(%mzone* %zone1726, i8* %var1732, i32 0, i8* %var1733, i32 3, %clsvar* %addytable1731)
%address-table1735 = bitcast %clsvar* %addytable1734 to i8*

; insert table, function and environment into closure struct
%closure.table1738 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure1728, i32 0, i32 0
store i8* %address-table1735, i8** %closure.table1738
%closure.env1739 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure1728, i32 0, i32 1
store i8* %envptr1729, i8** %closure.env1739
%closure.func1740 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure1728, i32 0, i32 2
store %Rational (i8*, i8*, i32, %Rational)* @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0__1712, %Rational (i8*, i8*, i32, %Rational)** %closure.func1740
%closure_size1741 = call i64 @llvm_zone_mark_size(%mzone* %zone1726)
call void @llvm_zone_ptr_set_size(i8* %clsptr1727, i64 %closure_size1741)
%wrapper_ptr1742 = call i8* @llvm_zone_malloc(%mzone* %zone1726, i64 8)
%closure_wrapper1743 = bitcast i8* %wrapper_ptr1742 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure1728, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper1743

; let value assignment
%xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper1743, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper1743
store { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0
%tmp_envptr1737 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}* %environment1730, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**** %tmp_envptr1737


%val1746 = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %val1746
}


@xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_native(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Rational}*
%arg_p_0 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational115 = hidden constant [50 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ\00"
define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ__1748(i8* %_impz,i8* %_impenv, %Rational %a, i8 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1749 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}*
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i8
store i8 %b, i8* %bPtr


%val1750 = load %Rational, %Rational* %aPtr
; tuple ref
%val1751 = extractvalue %Rational %val1750, 0
%val1752 = load %Rational, %Rational* %aPtr
; tuple ref
%val1753 = extractvalue %Rational %val1752, 1
%val1754 = load i8, i8* %bPtr
%res1755 = call ccc i64 @i8toi64(i8 %val1754)
%val1756 = mul i64 %val1753, %res1755
%val1757 = add i64 %val1751, %val1756
%val1758 = load %Rational, %Rational* %aPtr
; tuple ref
%val1759 = extractvalue %Rational %val1758, 1
%res1760 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1757, i64 %val1759)
ret %Rational %res1760
}
@gsxtmrational116 = hidden constant [103 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1780 = load i8*, i8** %_impzPtr
%zone1781 = bitcast i8* %tzone1780 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ
%dat_xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ = call i8* @llvm_zone_malloc(%mzone* %zone1781, i64 8)
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr = bitcast i8* %dat_xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***
%tzone1761 = load i8*, i8** %_impzPtr
%zone1762 = bitcast i8* %tzone1761 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1762)
; malloc closure structure
%clsptr1763 = call i8* @llvm_zone_malloc(%mzone* %zone1762, i64 24)
%closure1764 = bitcast i8* %clsptr1763 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*

; malloc environment structure
%envptr1765 = call i8* @llvm_zone_malloc(%mzone* %zone1762, i64 8)
%environment1766 = bitcast i8* %envptr1765 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}*

; malloc closure address table
%addytable1767 = call %clsvar* @new_address_table()
%var1768 = bitcast [50 x i8]* @gsxtmrational115 to i8*
%var1769 = bitcast [51 x i8]* @gsxtmrational58 to i8*
%addytable1770 = call %clsvar* @add_address_table(%mzone* %zone1762, i8* %var1768, i32 0, i8* %var1769, i32 3, %clsvar* %addytable1767)
%address-table1771 = bitcast %clsvar* %addytable1770 to i8*

; insert table, function and environment into closure struct
%closure.table1774 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure1764, i32 0, i32 0
store i8* %address-table1771, i8** %closure.table1774
%closure.env1775 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure1764, i32 0, i32 1
store i8* %envptr1765, i8** %closure.env1775
%closure.func1776 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure1764, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i8)* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ__1748, %Rational (i8*, i8*, %Rational, i8)** %closure.func1776
%closure_size1777 = call i64 @llvm_zone_mark_size(%mzone* %zone1762)
call void @llvm_zone_ptr_set_size(i8* %clsptr1763, i64 %closure_size1777)
%wrapper_ptr1778 = call i8* @llvm_zone_malloc(%mzone* %zone1762, i64 8)
%closure_wrapper1779 = bitcast i8* %wrapper_ptr1778 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure1764, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper1779

; let value assignment
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper1779, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper1779
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ
%tmp_envptr1773 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}* %environment1766, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**** %tmp_envptr1773


%val1782 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %val1782
}


@xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_native(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i8}*
%arg_p_0 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational117 = hidden constant [50 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ\00"
define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ__1784(i8* %_impz,i8* %_impenv, i8 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1785 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}*
%xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**** %xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i8
store i8 %b, i8* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val1786 = load %Rational, %Rational* %aPtr
; tuple ref
%val1787 = extractvalue %Rational %val1786, 0
%val1788 = load %Rational, %Rational* %aPtr
; tuple ref
%val1789 = extractvalue %Rational %val1788, 1
%val1790 = load i8, i8* %bPtr
%res1791 = call ccc i64 @i8toi64(i8 %val1790)
%val1792 = mul i64 %val1789, %res1791
%val1793 = add i64 %val1787, %val1792
%val1794 = load %Rational, %Rational* %aPtr
; tuple ref
%val1795 = extractvalue %Rational %val1794, 1
%res1796 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1793, i64 %val1795)
ret %Rational %res1796
}
@gsxtmrational118 = hidden constant [103 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1816 = load i8*, i8** %_impzPtr
%zone1817 = bitcast i8* %tzone1816 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ
%dat_xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone1817, i64 8)
%xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***
%tzone1797 = load i8*, i8** %_impzPtr
%zone1798 = bitcast i8* %tzone1797 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1798)
; malloc closure structure
%clsptr1799 = call i8* @llvm_zone_malloc(%mzone* %zone1798, i64 24)
%closure1800 = bitcast i8* %clsptr1799 to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*

; malloc environment structure
%envptr1801 = call i8* @llvm_zone_malloc(%mzone* %zone1798, i64 8)
%environment1802 = bitcast i8* %envptr1801 to {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}*

; malloc closure address table
%addytable1803 = call %clsvar* @new_address_table()
%var1804 = bitcast [50 x i8]* @gsxtmrational117 to i8*
%var1805 = bitcast [51 x i8]* @gsxtmrational61 to i8*
%addytable1806 = call %clsvar* @add_address_table(%mzone* %zone1798, i8* %var1804, i32 0, i8* %var1805, i32 3, %clsvar* %addytable1803)
%address-table1807 = bitcast %clsvar* %addytable1806 to i8*

; insert table, function and environment into closure struct
%closure.table1810 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure1800, i32 0, i32 0
store i8* %address-table1807, i8** %closure.table1810
%closure.env1811 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure1800, i32 0, i32 1
store i8* %envptr1801, i8** %closure.env1811
%closure.func1812 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure1800, i32 0, i32 2
store %Rational (i8*, i8*, i8, %Rational)* @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ__1784, %Rational (i8*, i8*, i8, %Rational)** %closure.func1812
%closure_size1813 = call i64 @llvm_zone_mark_size(%mzone* %zone1798)
call void @llvm_zone_ptr_set_size(i8* %clsptr1799, i64 %closure_size1813)
%wrapper_ptr1814 = call i8* @llvm_zone_malloc(%mzone* %zone1798, i64 8)
%closure_wrapper1815 = bitcast i8* %wrapper_ptr1814 to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure1800, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper1815

; let value assignment
%xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper1815, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper1815
store { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ
%tmp_envptr1809 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}* %environment1802, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**** %tmp_envptr1809


%val1818 = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %val1818
}


@xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_native(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8, %Rational}*
%arg_p_0 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
%arg_p_1 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational119 = hidden constant [50 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ\00"
define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ__1820(i8* %_impz,i8* %_impenv, %Rational %a, i1 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1821 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}*
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i1
store i1 %b, i1* %bPtr


%val1822 = load %Rational, %Rational* %aPtr
; tuple ref
%val1823 = extractvalue %Rational %val1822, 0
%val1824 = load %Rational, %Rational* %aPtr
; tuple ref
%val1825 = extractvalue %Rational %val1824, 1
%val1826 = load i1, i1* %bPtr
%res1827 = call ccc i64 @i1toi64(i1 %val1826)
%val1828 = mul i64 %val1825, %res1827
%val1829 = add i64 %val1823, %val1828
%val1830 = load %Rational, %Rational* %aPtr
; tuple ref
%val1831 = extractvalue %Rational %val1830, 1
%res1832 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1829, i64 %val1831)
ret %Rational %res1832
}
@gsxtmrational120 = hidden constant [103 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1852 = load i8*, i8** %_impzPtr
%zone1853 = bitcast i8* %tzone1852 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ
%dat_xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ = call i8* @llvm_zone_malloc(%mzone* %zone1853, i64 8)
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr = bitcast i8* %dat_xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***
%tzone1833 = load i8*, i8** %_impzPtr
%zone1834 = bitcast i8* %tzone1833 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1834)
; malloc closure structure
%clsptr1835 = call i8* @llvm_zone_malloc(%mzone* %zone1834, i64 24)
%closure1836 = bitcast i8* %clsptr1835 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*

; malloc environment structure
%envptr1837 = call i8* @llvm_zone_malloc(%mzone* %zone1834, i64 8)
%environment1838 = bitcast i8* %envptr1837 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}*

; malloc closure address table
%addytable1839 = call %clsvar* @new_address_table()
%var1840 = bitcast [50 x i8]* @gsxtmrational119 to i8*
%var1841 = bitcast [51 x i8]* @gsxtmrational64 to i8*
%addytable1842 = call %clsvar* @add_address_table(%mzone* %zone1834, i8* %var1840, i32 0, i8* %var1841, i32 3, %clsvar* %addytable1839)
%address-table1843 = bitcast %clsvar* %addytable1842 to i8*

; insert table, function and environment into closure struct
%closure.table1846 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure1836, i32 0, i32 0
store i8* %address-table1843, i8** %closure.table1846
%closure.env1847 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure1836, i32 0, i32 1
store i8* %envptr1837, i8** %closure.env1847
%closure.func1848 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure1836, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i1)* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ__1820, %Rational (i8*, i8*, %Rational, i1)** %closure.func1848
%closure_size1849 = call i64 @llvm_zone_mark_size(%mzone* %zone1834)
call void @llvm_zone_ptr_set_size(i8* %clsptr1835, i64 %closure_size1849)
%wrapper_ptr1850 = call i8* @llvm_zone_malloc(%mzone* %zone1834, i64 8)
%closure_wrapper1851 = bitcast i8* %wrapper_ptr1850 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure1836, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_wrapper1851

; let value assignment
%xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_wrapper1851, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_wrapper1851
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ
%tmp_envptr1845 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}* %environment1838, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**** %tmp_envptr1845


%val1854 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %val1854
}


@xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i1)*,  %Rational (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_native(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i1)*,  %Rational (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i1}*
%arg_p_0 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 1
%arg_1 = load i1, i1* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i1)*,  %Rational (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational121 = hidden constant [50 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ\00"
define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ__1856(i8* %_impz,i8* %_impenv, i1 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1857 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}*
%xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**** %xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i1
store i1 %b, i1* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val1858 = load %Rational, %Rational* %aPtr
; tuple ref
%val1859 = extractvalue %Rational %val1858, 0
%val1860 = load %Rational, %Rational* %aPtr
; tuple ref
%val1861 = extractvalue %Rational %val1860, 1
%val1862 = load i1, i1* %bPtr
%res1863 = call ccc i64 @i1toi64(i1 %val1862)
%val1864 = mul i64 %val1861, %res1863
%val1865 = add i64 %val1859, %val1864
%val1866 = load %Rational, %Rational* %aPtr
; tuple ref
%val1867 = extractvalue %Rational %val1866, 1
%res1868 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val1865, i64 %val1867)
ret %Rational %res1868
}
@gsxtmrational122 = hidden constant [103 x i8] c"xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1888 = load i8*, i8** %_impzPtr
%zone1889 = bitcast i8* %tzone1888 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ
%dat_xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone1889, i64 8)
%xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***
%tzone1869 = load i8*, i8** %_impzPtr
%zone1870 = bitcast i8* %tzone1869 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1870)
; malloc closure structure
%clsptr1871 = call i8* @llvm_zone_malloc(%mzone* %zone1870, i64 24)
%closure1872 = bitcast i8* %clsptr1871 to { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*

; malloc environment structure
%envptr1873 = call i8* @llvm_zone_malloc(%mzone* %zone1870, i64 8)
%environment1874 = bitcast i8* %envptr1873 to {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}*

; malloc closure address table
%addytable1875 = call %clsvar* @new_address_table()
%var1876 = bitcast [50 x i8]* @gsxtmrational121 to i8*
%var1877 = bitcast [51 x i8]* @gsxtmrational67 to i8*
%addytable1878 = call %clsvar* @add_address_table(%mzone* %zone1870, i8* %var1876, i32 0, i8* %var1877, i32 3, %clsvar* %addytable1875)
%address-table1879 = bitcast %clsvar* %addytable1878 to i8*

; insert table, function and environment into closure struct
%closure.table1882 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure1872, i32 0, i32 0
store i8* %address-table1879, i8** %closure.table1882
%closure.env1883 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure1872, i32 0, i32 1
store i8* %envptr1873, i8** %closure.env1883
%closure.func1884 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure1872, i32 0, i32 2
store %Rational (i8*, i8*, i1, %Rational)* @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ__1856, %Rational (i8*, i8*, i1, %Rational)** %closure.func1884
%closure_size1885 = call i64 @llvm_zone_mark_size(%mzone* %zone1870)
call void @llvm_zone_ptr_set_size(i8* %clsptr1871, i64 %closure_size1885)
%wrapper_ptr1886 = call i8* @llvm_zone_malloc(%mzone* %zone1870, i64 8)
%closure_wrapper1887 = bitcast i8* %wrapper_ptr1886 to { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure1872, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_wrapper1887

; let value assignment
%xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_wrapper1887, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_wrapper1887
store { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ
%tmp_envptr1881 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}* %environment1874, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**** %tmp_envptr1881


%val1890 = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*** %xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %val1890
}


@xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i1, %Rational)*,  %Rational (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_native(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i1, %Rational)*,  %Rational (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1, %Rational}*
%arg_p_0 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
%arg_p_1 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i1, %Rational)*,  %Rational (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational123 = hidden constant [52 x i8] c"xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd\00"
define dllexport fastcc double @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd__1892(i8* %_impz,i8* %_impenv, %Rational %a, double %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1893 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}*
%xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}, {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}***, {i8*, i8*, double (i8*, i8*, %Rational, double)*}**** %xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca double
store double %b, double* %bPtr


%val1894 = load %Rational, %Rational* %aPtr
; tuple ref
%val1895 = extractvalue %Rational %val1894, 0
%val1896 = sitofp i64 %val1895 to double
%val1897 = load %Rational, %Rational* %aPtr
; tuple ref
%val1898 = extractvalue %Rational %val1897, 1
%val1899 = sitofp i64 %val1898 to double
%val1900 = fdiv double %val1896, %val1899
%val1901 = load double, double* %bPtr
%val1902 = fadd double %val1900, %val1901
ret double %val1902
}
@gsxtmrational124 = hidden constant [105 x i8] c"xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, %Rational, double)*}** @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1922 = load i8*, i8** %_impzPtr
%zone1923 = bitcast i8* %tzone1922 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd
%dat_xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone1923, i64 8)
%xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr = bitcast i8* %dat_xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd to { i8*, i8*, double (i8*, i8*, %Rational, double)*}***
%tzone1903 = load i8*, i8** %_impzPtr
%zone1904 = bitcast i8* %tzone1903 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1904)
; malloc closure structure
%clsptr1905 = call i8* @llvm_zone_malloc(%mzone* %zone1904, i64 24)
%closure1906 = bitcast i8* %clsptr1905 to { i8*, i8*, double (i8*, i8*, %Rational, double)*}*

; malloc environment structure
%envptr1907 = call i8* @llvm_zone_malloc(%mzone* %zone1904, i64 8)
%environment1908 = bitcast i8* %envptr1907 to {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}*

; malloc closure address table
%addytable1909 = call %clsvar* @new_address_table()
%var1910 = bitcast [52 x i8]* @gsxtmrational123 to i8*
%var1911 = bitcast [52 x i8]* @gsxtmrational70 to i8*
%addytable1912 = call %clsvar* @add_address_table(%mzone* %zone1904, i8* %var1910, i32 0, i8* %var1911, i32 3, %clsvar* %addytable1909)
%address-table1913 = bitcast %clsvar* %addytable1912 to i8*

; insert table, function and environment into closure struct
%closure.table1916 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational, double)*}, { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure1906, i32 0, i32 0
store i8* %address-table1913, i8** %closure.table1916
%closure.env1917 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational, double)*}, { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure1906, i32 0, i32 1
store i8* %envptr1907, i8** %closure.env1917
%closure.func1918 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational, double)*}, { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure1906, i32 0, i32 2
store double (i8*, i8*, %Rational, double)* @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd__1892, double (i8*, i8*, %Rational, double)** %closure.func1918
%closure_size1919 = call i64 @llvm_zone_mark_size(%mzone* %zone1904)
call void @llvm_zone_ptr_set_size(i8* %clsptr1905, i64 %closure_size1919)
%wrapper_ptr1920 = call i8* @llvm_zone_malloc(%mzone* %zone1904, i64 8)
%closure_wrapper1921 = bitcast i8* %wrapper_ptr1920 to { i8*, i8*, double (i8*, i8*, %Rational, double)*}**
store { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure1906, { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_wrapper1921

; let value assignment
%xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd = select i1 true, { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_wrapper1921, { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_wrapper1921
store { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd, { i8*, i8*, double (i8*, i8*, %Rational, double)*}*** %xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd
%tmp_envptr1915 = getelementptr {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}, {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}* %environment1908, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, %Rational, double)*}*** %xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr, {i8*, i8*, double (i8*, i8*, %Rational, double)*}**** %tmp_envptr1915


%val1924 = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}**, {i8*, i8*, double (i8*, i8*, %Rational, double)*}*** %xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr
ret {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %val1924
}


@xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, %Rational, double)*}** @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd(%Rational %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}*, {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational, double)*,  double (i8*, i8*, %Rational, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc double @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_native(%Rational %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}*, {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational, double)*,  double (i8*, i8*, %Rational, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc void @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, double}*
%arg_p_0 = getelementptr {%Rational, double}, {%Rational, double}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, double}, {%Rational, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}*, {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational, double)*,  double (i8*, i8*, %Rational, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational125 = hidden constant [52 x i8] c"xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd\00"
define dllexport fastcc double @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd__1926(i8* %_impz,i8* %_impenv, double %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1927 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}*
%xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}, {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}***, {i8*, i8*, double (i8*, i8*, double, %Rational)*}**** %xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr_

; setup arguments
%bPtr = alloca double
store double %b, double* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val1928 = load %Rational, %Rational* %aPtr
; tuple ref
%val1929 = extractvalue %Rational %val1928, 0
%val1930 = sitofp i64 %val1929 to double
%val1931 = load %Rational, %Rational* %aPtr
; tuple ref
%val1932 = extractvalue %Rational %val1931, 1
%val1933 = sitofp i64 %val1932 to double
%val1934 = fdiv double %val1930, %val1933
%val1935 = load double, double* %bPtr
%val1936 = fadd double %val1934, %val1935
ret double %val1936
}
@gsxtmrational126 = hidden constant [105 x i8] c"xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double, %Rational)*}** @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1956 = load i8*, i8** %_impzPtr
%zone1957 = bitcast i8* %tzone1956 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd
%dat_xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd = call i8* @llvm_zone_malloc(%mzone* %zone1957, i64 8)
%xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr = bitcast i8* %dat_xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd to { i8*, i8*, double (i8*, i8*, double, %Rational)*}***
%tzone1937 = load i8*, i8** %_impzPtr
%zone1938 = bitcast i8* %tzone1937 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1938)
; malloc closure structure
%clsptr1939 = call i8* @llvm_zone_malloc(%mzone* %zone1938, i64 24)
%closure1940 = bitcast i8* %clsptr1939 to { i8*, i8*, double (i8*, i8*, double, %Rational)*}*

; malloc environment structure
%envptr1941 = call i8* @llvm_zone_malloc(%mzone* %zone1938, i64 8)
%environment1942 = bitcast i8* %envptr1941 to {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}*

; malloc closure address table
%addytable1943 = call %clsvar* @new_address_table()
%var1944 = bitcast [52 x i8]* @gsxtmrational125 to i8*
%var1945 = bitcast [52 x i8]* @gsxtmrational73 to i8*
%addytable1946 = call %clsvar* @add_address_table(%mzone* %zone1938, i8* %var1944, i32 0, i8* %var1945, i32 3, %clsvar* %addytable1943)
%address-table1947 = bitcast %clsvar* %addytable1946 to i8*

; insert table, function and environment into closure struct
%closure.table1950 = getelementptr { i8*, i8*, double (i8*, i8*, double, %Rational)*}, { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure1940, i32 0, i32 0
store i8* %address-table1947, i8** %closure.table1950
%closure.env1951 = getelementptr { i8*, i8*, double (i8*, i8*, double, %Rational)*}, { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure1940, i32 0, i32 1
store i8* %envptr1941, i8** %closure.env1951
%closure.func1952 = getelementptr { i8*, i8*, double (i8*, i8*, double, %Rational)*}, { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure1940, i32 0, i32 2
store double (i8*, i8*, double, %Rational)* @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd__1926, double (i8*, i8*, double, %Rational)** %closure.func1952
%closure_size1953 = call i64 @llvm_zone_mark_size(%mzone* %zone1938)
call void @llvm_zone_ptr_set_size(i8* %clsptr1939, i64 %closure_size1953)
%wrapper_ptr1954 = call i8* @llvm_zone_malloc(%mzone* %zone1938, i64 8)
%closure_wrapper1955 = bitcast i8* %wrapper_ptr1954 to { i8*, i8*, double (i8*, i8*, double, %Rational)*}**
store { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure1940, { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_wrapper1955

; let value assignment
%xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd = select i1 true, { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_wrapper1955, { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_wrapper1955
store { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd, { i8*, i8*, double (i8*, i8*, double, %Rational)*}*** %xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd
%tmp_envptr1949 = getelementptr {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}, {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}* %environment1942, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double, %Rational)*}*** %xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr, {i8*, i8*, double (i8*, i8*, double, %Rational)*}**** %tmp_envptr1949


%val1958 = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}**, {i8*, i8*, double (i8*, i8*, double, %Rational)*}*** %xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr
ret {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %val1958
}


@xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double, %Rational)*}** @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd(double %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}*, {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %Rational)*,  double (i8*, i8*, double, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %Rational %arg_1)
ret double %result
}


define dllexport ccc double @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_native(double %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}*, {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %Rational)*,  double (i8*, i8*, double, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %Rational %arg_1)
ret double %result
}


define dllexport ccc void @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, %Rational}*
%arg_p_0 = getelementptr {double, %Rational}, {double, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, %Rational}, {double, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}*, {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %Rational)*,  double (i8*, i8*, double, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational127 = hidden constant [50 x i8] c"xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ\00"
define dllexport fastcc float @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ__1960(i8* %_impz,i8* %_impenv, %Rational %a, float %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1961 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}*
%xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}, {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}***, {i8*, i8*, float (i8*, i8*, %Rational, float)*}**** %xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca float
store float %b, float* %bPtr


%val1962 = load %Rational, %Rational* %aPtr
; tuple ref
%val1963 = extractvalue %Rational %val1962, 0
%val1964 = sitofp i64 %val1963 to float
%val1965 = load %Rational, %Rational* %aPtr
; tuple ref
%val1966 = extractvalue %Rational %val1965, 1
%val1967 = sitofp i64 %val1966 to float
%val1968 = fdiv float %val1964, %val1967
%val1969 = load float, float* %bPtr
%val1970 = fadd float %val1968, %val1969
ret float %val1970
}
@gsxtmrational128 = hidden constant [103 x i8] c"xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %Rational, float)*}** @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1990 = load i8*, i8** %_impzPtr
%zone1991 = bitcast i8* %tzone1990 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ
%dat_xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1991, i64 8)
%xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr = bitcast i8* %dat_xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ to { i8*, i8*, float (i8*, i8*, %Rational, float)*}***
%tzone1971 = load i8*, i8** %_impzPtr
%zone1972 = bitcast i8* %tzone1971 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1972)
; malloc closure structure
%clsptr1973 = call i8* @llvm_zone_malloc(%mzone* %zone1972, i64 24)
%closure1974 = bitcast i8* %clsptr1973 to { i8*, i8*, float (i8*, i8*, %Rational, float)*}*

; malloc environment structure
%envptr1975 = call i8* @llvm_zone_malloc(%mzone* %zone1972, i64 8)
%environment1976 = bitcast i8* %envptr1975 to {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}*

; malloc closure address table
%addytable1977 = call %clsvar* @new_address_table()
%var1978 = bitcast [50 x i8]* @gsxtmrational127 to i8*
%var1979 = bitcast [50 x i8]* @gsxtmrational76 to i8*
%addytable1980 = call %clsvar* @add_address_table(%mzone* %zone1972, i8* %var1978, i32 0, i8* %var1979, i32 3, %clsvar* %addytable1977)
%address-table1981 = bitcast %clsvar* %addytable1980 to i8*

; insert table, function and environment into closure struct
%closure.table1984 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational, float)*}, { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure1974, i32 0, i32 0
store i8* %address-table1981, i8** %closure.table1984
%closure.env1985 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational, float)*}, { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure1974, i32 0, i32 1
store i8* %envptr1975, i8** %closure.env1985
%closure.func1986 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational, float)*}, { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure1974, i32 0, i32 2
store float (i8*, i8*, %Rational, float)* @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ__1960, float (i8*, i8*, %Rational, float)** %closure.func1986
%closure_size1987 = call i64 @llvm_zone_mark_size(%mzone* %zone1972)
call void @llvm_zone_ptr_set_size(i8* %clsptr1973, i64 %closure_size1987)
%wrapper_ptr1988 = call i8* @llvm_zone_malloc(%mzone* %zone1972, i64 8)
%closure_wrapper1989 = bitcast i8* %wrapper_ptr1988 to { i8*, i8*, float (i8*, i8*, %Rational, float)*}**
store { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure1974, { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_wrapper1989

; let value assignment
%xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ = select i1 true, { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_wrapper1989, { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_wrapper1989
store { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ, { i8*, i8*, float (i8*, i8*, %Rational, float)*}*** %xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ
%tmp_envptr1983 = getelementptr {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}, {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}* %environment1976, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %Rational, float)*}*** %xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr, {i8*, i8*, float (i8*, i8*, %Rational, float)*}**** %tmp_envptr1983


%val1992 = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}**, {i8*, i8*, float (i8*, i8*, %Rational, float)*}*** %xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr
ret {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %val1992
}


@xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %Rational, float)*}** @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ(%Rational %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}*, {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational, float)*,  float (i8*, i8*, %Rational, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0, float %arg_1)
ret float %result
}


define dllexport ccc float @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_native(%Rational %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}*, {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational, float)*,  float (i8*, i8*, %Rational, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0, float %arg_1)
ret float %result
}


define dllexport ccc void @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, float}*
%arg_p_0 = getelementptr {%Rational, float}, {%Rational, float}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, float}, {%Rational, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}*, {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational, float)*,  float (i8*, i8*, %Rational, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational129 = hidden constant [50 x i8] c"xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ\00"
define dllexport fastcc float @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ__1994(i8* %_impz,i8* %_impenv, float %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1995 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}*
%xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}, {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}***, {i8*, i8*, float (i8*, i8*, float, %Rational)*}**** %xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val1996 = load %Rational, %Rational* %aPtr
; tuple ref
%val1997 = extractvalue %Rational %val1996, 0
%val1998 = sitofp i64 %val1997 to float
%val1999 = load %Rational, %Rational* %aPtr
; tuple ref
%val2000 = extractvalue %Rational %val1999, 1
%val2001 = sitofp i64 %val2000 to float
%val2002 = fdiv float %val1998, %val2001
%val2003 = load float, float* %bPtr
%val2004 = fadd float %val2002, %val2003
ret float %val2004
}
@gsxtmrational130 = hidden constant [103 x i8] c"xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float, %Rational)*}** @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2024 = load i8*, i8** %_impzPtr
%zone2025 = bitcast i8* %tzone2024 to %mzone*

; let assign value to symbol xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ
%dat_xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone2025, i64 8)
%xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ to { i8*, i8*, float (i8*, i8*, float, %Rational)*}***
%tzone2005 = load i8*, i8** %_impzPtr
%zone2006 = bitcast i8* %tzone2005 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2006)
; malloc closure structure
%clsptr2007 = call i8* @llvm_zone_malloc(%mzone* %zone2006, i64 24)
%closure2008 = bitcast i8* %clsptr2007 to { i8*, i8*, float (i8*, i8*, float, %Rational)*}*

; malloc environment structure
%envptr2009 = call i8* @llvm_zone_malloc(%mzone* %zone2006, i64 8)
%environment2010 = bitcast i8* %envptr2009 to {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}*

; malloc closure address table
%addytable2011 = call %clsvar* @new_address_table()
%var2012 = bitcast [50 x i8]* @gsxtmrational129 to i8*
%var2013 = bitcast [50 x i8]* @gsxtmrational79 to i8*
%addytable2014 = call %clsvar* @add_address_table(%mzone* %zone2006, i8* %var2012, i32 0, i8* %var2013, i32 3, %clsvar* %addytable2011)
%address-table2015 = bitcast %clsvar* %addytable2014 to i8*

; insert table, function and environment into closure struct
%closure.table2018 = getelementptr { i8*, i8*, float (i8*, i8*, float, %Rational)*}, { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure2008, i32 0, i32 0
store i8* %address-table2015, i8** %closure.table2018
%closure.env2019 = getelementptr { i8*, i8*, float (i8*, i8*, float, %Rational)*}, { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure2008, i32 0, i32 1
store i8* %envptr2009, i8** %closure.env2019
%closure.func2020 = getelementptr { i8*, i8*, float (i8*, i8*, float, %Rational)*}, { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure2008, i32 0, i32 2
store float (i8*, i8*, float, %Rational)* @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ__1994, float (i8*, i8*, float, %Rational)** %closure.func2020
%closure_size2021 = call i64 @llvm_zone_mark_size(%mzone* %zone2006)
call void @llvm_zone_ptr_set_size(i8* %clsptr2007, i64 %closure_size2021)
%wrapper_ptr2022 = call i8* @llvm_zone_malloc(%mzone* %zone2006, i64 8)
%closure_wrapper2023 = bitcast i8* %wrapper_ptr2022 to { i8*, i8*, float (i8*, i8*, float, %Rational)*}**
store { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure2008, { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_wrapper2023

; let value assignment
%xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_wrapper2023, { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_wrapper2023
store { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ, { i8*, i8*, float (i8*, i8*, float, %Rational)*}*** %xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ
%tmp_envptr2017 = getelementptr {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}, {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}* %environment2010, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float, %Rational)*}*** %xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr, {i8*, i8*, float (i8*, i8*, float, %Rational)*}**** %tmp_envptr2017


%val2026 = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}**, {i8*, i8*, float (i8*, i8*, float, %Rational)*}*** %xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr
ret {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %val2026
}


@xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float, %Rational)*}** @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ(float %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}*, {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %Rational)*,  float (i8*, i8*, float, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %Rational %arg_1)
ret float %result
}


define dllexport ccc float @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_native(float %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}*, {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %Rational)*,  float (i8*, i8*, float, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %Rational %arg_1)
ret float %result
}


define dllexport ccc void @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, %Rational}*
%arg_p_0 = getelementptr {float, %Rational}, {float, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, %Rational}, {float, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_addition_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}*, {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %Rational)*,  float (i8*, i8*, float, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational131 = hidden constant [61 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ\00"
define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ__2028(i8* %_impz,i8* %_impenv, %Rational %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2029 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}*
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%tzone2032 = load i8*, i8** %_impzPtr
%zone2033 = bitcast i8* %tzone2032 to %mzone*

; let assign value to symbol denom_a
%denom_aPtr = alloca i64
%tzone2036 = load i8*, i8** %_impzPtr
%zone2037 = bitcast i8* %tzone2036 to %mzone*

; let assign value to symbol denom_b
%denom_bPtr = alloca i64
%val2030 = load %Rational, %Rational* %aPtr
; tuple ref
%val2031 = extractvalue %Rational %val2030, 1

; let value assignment
%denom_a = select i1 true, i64 %val2031, i64 %val2031
store i64 %denom_a, i64* %denom_aPtr

%val2034 = load %Rational, %Rational* %bPtr
; tuple ref
%val2035 = extractvalue %Rational %val2034, 1

; let value assignment
%denom_b = select i1 true, i64 %val2035, i64 %val2035
store i64 %denom_b, i64* %denom_bPtr

%val2038 = load %Rational, %Rational* %aPtr
; tuple ref
%val2039 = extractvalue %Rational %val2038, 0
%val2040 = load i64, i64* %denom_bPtr
%val2041 = mul i64 %val2039, %val2040
%val2042 = load %Rational, %Rational* %bPtr
; tuple ref
%val2043 = extractvalue %Rational %val2042, 0
%val2044 = load i64, i64* %denom_aPtr
%val2045 = mul i64 %val2043, %val2044
%val2046 = sub i64 %val2041, %val2045
%val2047 = load i64, i64* %denom_aPtr
%val2048 = load i64, i64* %denom_bPtr
%val2049 = mul i64 %val2047, %val2048
%res2050 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2046, i64 %val2049)
%res2051 = call fastcc %Rational @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res2050)
ret %Rational %res2051
}
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2071 = load i8*, i8** %_impzPtr
%zone2072 = bitcast i8* %tzone2071 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ
%dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone2072, i64 8)
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***
%tzone2052 = load i8*, i8** %_impzPtr
%zone2053 = bitcast i8* %tzone2052 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2053)
; malloc closure structure
%clsptr2054 = call i8* @llvm_zone_malloc(%mzone* %zone2053, i64 24)
%closure2055 = bitcast i8* %clsptr2054 to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*

; malloc environment structure
%envptr2056 = call i8* @llvm_zone_malloc(%mzone* %zone2053, i64 8)
%environment2057 = bitcast i8* %envptr2056 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}*

; malloc closure address table
%addytable2058 = call %clsvar* @new_address_table()
%var2059 = bitcast [61 x i8]* @gsxtmrational131 to i8*
%var2060 = bitcast [58 x i8]* @gsxtmrational44 to i8*
%addytable2061 = call %clsvar* @add_address_table(%mzone* %zone2053, i8* %var2059, i32 0, i8* %var2060, i32 3, %clsvar* %addytable2058)
%address-table2062 = bitcast %clsvar* %addytable2061 to i8*

; insert table, function and environment into closure struct
%closure.table2065 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure2055, i32 0, i32 0
store i8* %address-table2062, i8** %closure.table2065
%closure.env2066 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure2055, i32 0, i32 1
store i8* %envptr2056, i8** %closure.env2066
%closure.func2067 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure2055, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, %Rational)* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ__2028, %Rational (i8*, i8*, %Rational, %Rational)** %closure.func2067
%closure_size2068 = call i64 @llvm_zone_mark_size(%mzone* %zone2053)
call void @llvm_zone_ptr_set_size(i8* %clsptr2054, i64 %closure_size2068)
%wrapper_ptr2069 = call i8* @llvm_zone_malloc(%mzone* %zone2053, i64 8)
%closure_wrapper2070 = bitcast i8* %wrapper_ptr2069 to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure2055, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper2070

; let value assignment
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper2070, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper2070
store { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ
%tmp_envptr2064 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}* %environment2057, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**** %tmp_envptr2064


%val2073 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %val2073
}


@xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_native(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, %Rational}*
%arg_p_0 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational132 = hidden constant [54 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0\00"
define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0__2074(i8* %_impz,i8* %_impenv, %Rational %a, i64 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2075 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}*
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i64
store i64 %b, i64* %bPtr


%val2076 = load %Rational, %Rational* %aPtr
; tuple ref
%val2077 = extractvalue %Rational %val2076, 0
%val2078 = load %Rational, %Rational* %aPtr
; tuple ref
%val2079 = extractvalue %Rational %val2078, 1
%val2080 = load i64, i64* %bPtr
%val2081 = mul i64 %val2079, %val2080
%val2082 = sub i64 %val2077, %val2081
%val2083 = load %Rational, %Rational* %aPtr
; tuple ref
%val2084 = extractvalue %Rational %val2083, 1
%res2085 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2082, i64 %val2084)
ret %Rational %res2085
}
@gsxtmrational133 = hidden constant [107 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2105 = load i8*, i8** %_impzPtr
%zone2106 = bitcast i8* %tzone2105 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0
%dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone2106, i64 8)
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr = bitcast i8* %dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***
%tzone2086 = load i8*, i8** %_impzPtr
%zone2087 = bitcast i8* %tzone2086 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2087)
; malloc closure structure
%clsptr2088 = call i8* @llvm_zone_malloc(%mzone* %zone2087, i64 24)
%closure2089 = bitcast i8* %clsptr2088 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*

; malloc environment structure
%envptr2090 = call i8* @llvm_zone_malloc(%mzone* %zone2087, i64 8)
%environment2091 = bitcast i8* %envptr2090 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}*

; malloc closure address table
%addytable2092 = call %clsvar* @new_address_table()
%var2093 = bitcast [54 x i8]* @gsxtmrational132 to i8*
%var2094 = bitcast [52 x i8]* @gsxtmrational46 to i8*
%addytable2095 = call %clsvar* @add_address_table(%mzone* %zone2087, i8* %var2093, i32 0, i8* %var2094, i32 3, %clsvar* %addytable2092)
%address-table2096 = bitcast %clsvar* %addytable2095 to i8*

; insert table, function and environment into closure struct
%closure.table2099 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure2089, i32 0, i32 0
store i8* %address-table2096, i8** %closure.table2099
%closure.env2100 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure2089, i32 0, i32 1
store i8* %envptr2090, i8** %closure.env2100
%closure.func2101 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure2089, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i64)* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0__2074, %Rational (i8*, i8*, %Rational, i64)** %closure.func2101
%closure_size2102 = call i64 @llvm_zone_mark_size(%mzone* %zone2087)
call void @llvm_zone_ptr_set_size(i8* %clsptr2088, i64 %closure_size2102)
%wrapper_ptr2103 = call i8* @llvm_zone_malloc(%mzone* %zone2087, i64 8)
%closure_wrapper2104 = bitcast i8* %wrapper_ptr2103 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure2089, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper2104

; let value assignment
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper2104, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper2104
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0
%tmp_envptr2098 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}* %environment2091, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**** %tmp_envptr2098


%val2107 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %val2107
}


@xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_native(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i64}*
%arg_p_0 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational134 = hidden constant [54 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0\00"
define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0__2109(i8* %_impz,i8* %_impenv, i64 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2110 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}*
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i64
store i64 %b, i64* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2111 = load %Rational, %Rational* %aPtr
; tuple ref
%val2112 = extractvalue %Rational %val2111, 0
%val2113 = load %Rational, %Rational* %aPtr
; tuple ref
%val2114 = extractvalue %Rational %val2113, 1
%val2115 = load i64, i64* %bPtr
%val2116 = mul i64 %val2114, %val2115
%val2117 = sub i64 %val2112, %val2116
%val2118 = load %Rational, %Rational* %aPtr
; tuple ref
%val2119 = extractvalue %Rational %val2118, 1
%res2120 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2117, i64 %val2119)
ret %Rational %res2120
}
@gsxtmrational135 = hidden constant [107 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2140 = load i8*, i8** %_impzPtr
%zone2141 = bitcast i8* %tzone2140 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0
%dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone2141, i64 8)
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***
%tzone2121 = load i8*, i8** %_impzPtr
%zone2122 = bitcast i8* %tzone2121 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2122)
; malloc closure structure
%clsptr2123 = call i8* @llvm_zone_malloc(%mzone* %zone2122, i64 24)
%closure2124 = bitcast i8* %clsptr2123 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*

; malloc environment structure
%envptr2125 = call i8* @llvm_zone_malloc(%mzone* %zone2122, i64 8)
%environment2126 = bitcast i8* %envptr2125 to {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}*

; malloc closure address table
%addytable2127 = call %clsvar* @new_address_table()
%var2128 = bitcast [54 x i8]* @gsxtmrational134 to i8*
%var2129 = bitcast [52 x i8]* @gsxtmrational49 to i8*
%addytable2130 = call %clsvar* @add_address_table(%mzone* %zone2122, i8* %var2128, i32 0, i8* %var2129, i32 3, %clsvar* %addytable2127)
%address-table2131 = bitcast %clsvar* %addytable2130 to i8*

; insert table, function and environment into closure struct
%closure.table2134 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure2124, i32 0, i32 0
store i8* %address-table2131, i8** %closure.table2134
%closure.env2135 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure2124, i32 0, i32 1
store i8* %envptr2125, i8** %closure.env2135
%closure.func2136 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure2124, i32 0, i32 2
store %Rational (i8*, i8*, i64, %Rational)* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0__2109, %Rational (i8*, i8*, i64, %Rational)** %closure.func2136
%closure_size2137 = call i64 @llvm_zone_mark_size(%mzone* %zone2122)
call void @llvm_zone_ptr_set_size(i8* %clsptr2123, i64 %closure_size2137)
%wrapper_ptr2138 = call i8* @llvm_zone_malloc(%mzone* %zone2122, i64 8)
%closure_wrapper2139 = bitcast i8* %wrapper_ptr2138 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure2124, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper2139

; let value assignment
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper2139, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper2139
store { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0
%tmp_envptr2133 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}* %environment2126, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**** %tmp_envptr2133


%val2142 = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %val2142
}


@xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_native(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, %Rational}*
%arg_p_0 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational136 = hidden constant [54 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0\00"
define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0__2144(i8* %_impz,i8* %_impenv, %Rational %a, i32 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2145 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}*
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i32
store i32 %b, i32* %bPtr


%val2146 = load %Rational, %Rational* %aPtr
; tuple ref
%val2147 = extractvalue %Rational %val2146, 0
%val2148 = load %Rational, %Rational* %aPtr
; tuple ref
%val2149 = extractvalue %Rational %val2148, 1
%val2150 = load i32, i32* %bPtr
%res2151 = call ccc i64 @i32toi64(i32 %val2150)
%val2152 = mul i64 %val2149, %res2151
%val2153 = sub i64 %val2147, %val2152
%val2154 = load %Rational, %Rational* %aPtr
; tuple ref
%val2155 = extractvalue %Rational %val2154, 1
%res2156 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2153, i64 %val2155)
ret %Rational %res2156
}
@gsxtmrational137 = hidden constant [107 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2176 = load i8*, i8** %_impzPtr
%zone2177 = bitcast i8* %tzone2176 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0
%dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2177, i64 8)
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr = bitcast i8* %dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***
%tzone2157 = load i8*, i8** %_impzPtr
%zone2158 = bitcast i8* %tzone2157 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2158)
; malloc closure structure
%clsptr2159 = call i8* @llvm_zone_malloc(%mzone* %zone2158, i64 24)
%closure2160 = bitcast i8* %clsptr2159 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*

; malloc environment structure
%envptr2161 = call i8* @llvm_zone_malloc(%mzone* %zone2158, i64 8)
%environment2162 = bitcast i8* %envptr2161 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}*

; malloc closure address table
%addytable2163 = call %clsvar* @new_address_table()
%var2164 = bitcast [54 x i8]* @gsxtmrational136 to i8*
%var2165 = bitcast [52 x i8]* @gsxtmrational52 to i8*
%addytable2166 = call %clsvar* @add_address_table(%mzone* %zone2158, i8* %var2164, i32 0, i8* %var2165, i32 3, %clsvar* %addytable2163)
%address-table2167 = bitcast %clsvar* %addytable2166 to i8*

; insert table, function and environment into closure struct
%closure.table2170 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure2160, i32 0, i32 0
store i8* %address-table2167, i8** %closure.table2170
%closure.env2171 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure2160, i32 0, i32 1
store i8* %envptr2161, i8** %closure.env2171
%closure.func2172 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure2160, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i32)* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0__2144, %Rational (i8*, i8*, %Rational, i32)** %closure.func2172
%closure_size2173 = call i64 @llvm_zone_mark_size(%mzone* %zone2158)
call void @llvm_zone_ptr_set_size(i8* %clsptr2159, i64 %closure_size2173)
%wrapper_ptr2174 = call i8* @llvm_zone_malloc(%mzone* %zone2158, i64 8)
%closure_wrapper2175 = bitcast i8* %wrapper_ptr2174 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure2160, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper2175

; let value assignment
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper2175, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper2175
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0
%tmp_envptr2169 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}* %environment2162, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**** %tmp_envptr2169


%val2178 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %val2178
}


@xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_native(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i32}*
%arg_p_0 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational138 = hidden constant [54 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0\00"
define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0__2180(i8* %_impz,i8* %_impenv, i32 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2181 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}*
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i32
store i32 %b, i32* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2182 = load %Rational, %Rational* %aPtr
; tuple ref
%val2183 = extractvalue %Rational %val2182, 0
%val2184 = load %Rational, %Rational* %aPtr
; tuple ref
%val2185 = extractvalue %Rational %val2184, 1
%val2186 = load i32, i32* %bPtr
%res2187 = call ccc i64 @i32toi64(i32 %val2186)
%val2188 = mul i64 %val2185, %res2187
%val2189 = sub i64 %val2183, %val2188
%val2190 = load %Rational, %Rational* %aPtr
; tuple ref
%val2191 = extractvalue %Rational %val2190, 1
%res2192 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2189, i64 %val2191)
ret %Rational %res2192
}
@gsxtmrational139 = hidden constant [107 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2212 = load i8*, i8** %_impzPtr
%zone2213 = bitcast i8* %tzone2212 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0
%dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone2213, i64 8)
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***
%tzone2193 = load i8*, i8** %_impzPtr
%zone2194 = bitcast i8* %tzone2193 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2194)
; malloc closure structure
%clsptr2195 = call i8* @llvm_zone_malloc(%mzone* %zone2194, i64 24)
%closure2196 = bitcast i8* %clsptr2195 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*

; malloc environment structure
%envptr2197 = call i8* @llvm_zone_malloc(%mzone* %zone2194, i64 8)
%environment2198 = bitcast i8* %envptr2197 to {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}*

; malloc closure address table
%addytable2199 = call %clsvar* @new_address_table()
%var2200 = bitcast [54 x i8]* @gsxtmrational138 to i8*
%var2201 = bitcast [52 x i8]* @gsxtmrational55 to i8*
%addytable2202 = call %clsvar* @add_address_table(%mzone* %zone2194, i8* %var2200, i32 0, i8* %var2201, i32 3, %clsvar* %addytable2199)
%address-table2203 = bitcast %clsvar* %addytable2202 to i8*

; insert table, function and environment into closure struct
%closure.table2206 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure2196, i32 0, i32 0
store i8* %address-table2203, i8** %closure.table2206
%closure.env2207 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure2196, i32 0, i32 1
store i8* %envptr2197, i8** %closure.env2207
%closure.func2208 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure2196, i32 0, i32 2
store %Rational (i8*, i8*, i32, %Rational)* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0__2180, %Rational (i8*, i8*, i32, %Rational)** %closure.func2208
%closure_size2209 = call i64 @llvm_zone_mark_size(%mzone* %zone2194)
call void @llvm_zone_ptr_set_size(i8* %clsptr2195, i64 %closure_size2209)
%wrapper_ptr2210 = call i8* @llvm_zone_malloc(%mzone* %zone2194, i64 8)
%closure_wrapper2211 = bitcast i8* %wrapper_ptr2210 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure2196, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper2211

; let value assignment
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper2211, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper2211
store { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0
%tmp_envptr2205 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}* %environment2198, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**** %tmp_envptr2205


%val2214 = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %val2214
}


@xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_native(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Rational}*
%arg_p_0 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational140 = hidden constant [53 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ\00"
define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ__2216(i8* %_impz,i8* %_impenv, %Rational %a, i8 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2217 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}*
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i8
store i8 %b, i8* %bPtr


%val2218 = load %Rational, %Rational* %aPtr
; tuple ref
%val2219 = extractvalue %Rational %val2218, 0
%val2220 = load %Rational, %Rational* %aPtr
; tuple ref
%val2221 = extractvalue %Rational %val2220, 1
%val2222 = load i8, i8* %bPtr
%res2223 = call ccc i64 @i8toi64(i8 %val2222)
%val2224 = mul i64 %val2221, %res2223
%val2225 = sub i64 %val2219, %val2224
%val2226 = load %Rational, %Rational* %aPtr
; tuple ref
%val2227 = extractvalue %Rational %val2226, 1
%res2228 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2225, i64 %val2227)
ret %Rational %res2228
}
@gsxtmrational141 = hidden constant [106 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2248 = load i8*, i8** %_impzPtr
%zone2249 = bitcast i8* %tzone2248 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ
%dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ = call i8* @llvm_zone_malloc(%mzone* %zone2249, i64 8)
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***
%tzone2229 = load i8*, i8** %_impzPtr
%zone2230 = bitcast i8* %tzone2229 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2230)
; malloc closure structure
%clsptr2231 = call i8* @llvm_zone_malloc(%mzone* %zone2230, i64 24)
%closure2232 = bitcast i8* %clsptr2231 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*

; malloc environment structure
%envptr2233 = call i8* @llvm_zone_malloc(%mzone* %zone2230, i64 8)
%environment2234 = bitcast i8* %envptr2233 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}*

; malloc closure address table
%addytable2235 = call %clsvar* @new_address_table()
%var2236 = bitcast [53 x i8]* @gsxtmrational140 to i8*
%var2237 = bitcast [51 x i8]* @gsxtmrational58 to i8*
%addytable2238 = call %clsvar* @add_address_table(%mzone* %zone2230, i8* %var2236, i32 0, i8* %var2237, i32 3, %clsvar* %addytable2235)
%address-table2239 = bitcast %clsvar* %addytable2238 to i8*

; insert table, function and environment into closure struct
%closure.table2242 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure2232, i32 0, i32 0
store i8* %address-table2239, i8** %closure.table2242
%closure.env2243 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure2232, i32 0, i32 1
store i8* %envptr2233, i8** %closure.env2243
%closure.func2244 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure2232, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i8)* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ__2216, %Rational (i8*, i8*, %Rational, i8)** %closure.func2244
%closure_size2245 = call i64 @llvm_zone_mark_size(%mzone* %zone2230)
call void @llvm_zone_ptr_set_size(i8* %clsptr2231, i64 %closure_size2245)
%wrapper_ptr2246 = call i8* @llvm_zone_malloc(%mzone* %zone2230, i64 8)
%closure_wrapper2247 = bitcast i8* %wrapper_ptr2246 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure2232, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper2247

; let value assignment
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper2247, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper2247
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ
%tmp_envptr2241 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}* %environment2234, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**** %tmp_envptr2241


%val2250 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %val2250
}


@xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_native(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i8}*
%arg_p_0 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational142 = hidden constant [53 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ\00"
define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ__2252(i8* %_impz,i8* %_impenv, i8 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2253 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}*
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i8
store i8 %b, i8* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2254 = load %Rational, %Rational* %aPtr
; tuple ref
%val2255 = extractvalue %Rational %val2254, 0
%val2256 = load %Rational, %Rational* %aPtr
; tuple ref
%val2257 = extractvalue %Rational %val2256, 1
%val2258 = load i8, i8* %bPtr
%res2259 = call ccc i64 @i8toi64(i8 %val2258)
%val2260 = mul i64 %val2257, %res2259
%val2261 = sub i64 %val2255, %val2260
%val2262 = load %Rational, %Rational* %aPtr
; tuple ref
%val2263 = extractvalue %Rational %val2262, 1
%res2264 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2261, i64 %val2263)
ret %Rational %res2264
}
@gsxtmrational143 = hidden constant [106 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2284 = load i8*, i8** %_impzPtr
%zone2285 = bitcast i8* %tzone2284 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ
%dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone2285, i64 8)
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***
%tzone2265 = load i8*, i8** %_impzPtr
%zone2266 = bitcast i8* %tzone2265 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2266)
; malloc closure structure
%clsptr2267 = call i8* @llvm_zone_malloc(%mzone* %zone2266, i64 24)
%closure2268 = bitcast i8* %clsptr2267 to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*

; malloc environment structure
%envptr2269 = call i8* @llvm_zone_malloc(%mzone* %zone2266, i64 8)
%environment2270 = bitcast i8* %envptr2269 to {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}*

; malloc closure address table
%addytable2271 = call %clsvar* @new_address_table()
%var2272 = bitcast [53 x i8]* @gsxtmrational142 to i8*
%var2273 = bitcast [51 x i8]* @gsxtmrational61 to i8*
%addytable2274 = call %clsvar* @add_address_table(%mzone* %zone2266, i8* %var2272, i32 0, i8* %var2273, i32 3, %clsvar* %addytable2271)
%address-table2275 = bitcast %clsvar* %addytable2274 to i8*

; insert table, function and environment into closure struct
%closure.table2278 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure2268, i32 0, i32 0
store i8* %address-table2275, i8** %closure.table2278
%closure.env2279 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure2268, i32 0, i32 1
store i8* %envptr2269, i8** %closure.env2279
%closure.func2280 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure2268, i32 0, i32 2
store %Rational (i8*, i8*, i8, %Rational)* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ__2252, %Rational (i8*, i8*, i8, %Rational)** %closure.func2280
%closure_size2281 = call i64 @llvm_zone_mark_size(%mzone* %zone2266)
call void @llvm_zone_ptr_set_size(i8* %clsptr2267, i64 %closure_size2281)
%wrapper_ptr2282 = call i8* @llvm_zone_malloc(%mzone* %zone2266, i64 8)
%closure_wrapper2283 = bitcast i8* %wrapper_ptr2282 to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure2268, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper2283

; let value assignment
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper2283, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper2283
store { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ
%tmp_envptr2277 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}* %environment2270, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**** %tmp_envptr2277


%val2286 = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %val2286
}


@xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_native(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8, %Rational}*
%arg_p_0 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
%arg_p_1 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational144 = hidden constant [53 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ\00"
define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ__2288(i8* %_impz,i8* %_impenv, %Rational %a, i1 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2289 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}*
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i1
store i1 %b, i1* %bPtr


%val2290 = load %Rational, %Rational* %aPtr
; tuple ref
%val2291 = extractvalue %Rational %val2290, 0
%val2292 = load %Rational, %Rational* %aPtr
; tuple ref
%val2293 = extractvalue %Rational %val2292, 1
%val2294 = load i1, i1* %bPtr
%res2295 = call ccc i64 @i1toi64(i1 %val2294)
%val2296 = mul i64 %val2293, %res2295
%val2297 = sub i64 %val2291, %val2296
%val2298 = load %Rational, %Rational* %aPtr
; tuple ref
%val2299 = extractvalue %Rational %val2298, 1
%res2300 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2297, i64 %val2299)
ret %Rational %res2300
}
@gsxtmrational145 = hidden constant [106 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2320 = load i8*, i8** %_impzPtr
%zone2321 = bitcast i8* %tzone2320 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ
%dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ = call i8* @llvm_zone_malloc(%mzone* %zone2321, i64 8)
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***
%tzone2301 = load i8*, i8** %_impzPtr
%zone2302 = bitcast i8* %tzone2301 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2302)
; malloc closure structure
%clsptr2303 = call i8* @llvm_zone_malloc(%mzone* %zone2302, i64 24)
%closure2304 = bitcast i8* %clsptr2303 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*

; malloc environment structure
%envptr2305 = call i8* @llvm_zone_malloc(%mzone* %zone2302, i64 8)
%environment2306 = bitcast i8* %envptr2305 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}*

; malloc closure address table
%addytable2307 = call %clsvar* @new_address_table()
%var2308 = bitcast [53 x i8]* @gsxtmrational144 to i8*
%var2309 = bitcast [51 x i8]* @gsxtmrational64 to i8*
%addytable2310 = call %clsvar* @add_address_table(%mzone* %zone2302, i8* %var2308, i32 0, i8* %var2309, i32 3, %clsvar* %addytable2307)
%address-table2311 = bitcast %clsvar* %addytable2310 to i8*

; insert table, function and environment into closure struct
%closure.table2314 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure2304, i32 0, i32 0
store i8* %address-table2311, i8** %closure.table2314
%closure.env2315 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure2304, i32 0, i32 1
store i8* %envptr2305, i8** %closure.env2315
%closure.func2316 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure2304, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i1)* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ__2288, %Rational (i8*, i8*, %Rational, i1)** %closure.func2316
%closure_size2317 = call i64 @llvm_zone_mark_size(%mzone* %zone2302)
call void @llvm_zone_ptr_set_size(i8* %clsptr2303, i64 %closure_size2317)
%wrapper_ptr2318 = call i8* @llvm_zone_malloc(%mzone* %zone2302, i64 8)
%closure_wrapper2319 = bitcast i8* %wrapper_ptr2318 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure2304, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_wrapper2319

; let value assignment
%xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_wrapper2319, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_wrapper2319
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ
%tmp_envptr2313 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}***}* %environment2306, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**** %tmp_envptr2313


%val2322 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %val2322
}


@xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i1)*,  %Rational (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_native(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i1)*,  %Rational (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i1}*
%arg_p_0 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 1
%arg_1 = load i1, i1* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i1)*,  %Rational (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational146 = hidden constant [53 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ\00"
define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ__2324(i8* %_impz,i8* %_impenv, i1 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2325 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}*
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i1
store i1 %b, i1* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2326 = load %Rational, %Rational* %aPtr
; tuple ref
%val2327 = extractvalue %Rational %val2326, 0
%val2328 = load %Rational, %Rational* %aPtr
; tuple ref
%val2329 = extractvalue %Rational %val2328, 1
%val2330 = load i1, i1* %bPtr
%res2331 = call ccc i64 @i1toi64(i1 %val2330)
%val2332 = mul i64 %val2329, %res2331
%val2333 = sub i64 %val2327, %val2332
%val2334 = load %Rational, %Rational* %aPtr
; tuple ref
%val2335 = extractvalue %Rational %val2334, 1
%res2336 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2333, i64 %val2335)
ret %Rational %res2336
}
@gsxtmrational147 = hidden constant [106 x i8] c"xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2356 = load i8*, i8** %_impzPtr
%zone2357 = bitcast i8* %tzone2356 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ
%dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone2357, i64 8)
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***
%tzone2337 = load i8*, i8** %_impzPtr
%zone2338 = bitcast i8* %tzone2337 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2338)
; malloc closure structure
%clsptr2339 = call i8* @llvm_zone_malloc(%mzone* %zone2338, i64 24)
%closure2340 = bitcast i8* %clsptr2339 to { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*

; malloc environment structure
%envptr2341 = call i8* @llvm_zone_malloc(%mzone* %zone2338, i64 8)
%environment2342 = bitcast i8* %envptr2341 to {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}*

; malloc closure address table
%addytable2343 = call %clsvar* @new_address_table()
%var2344 = bitcast [53 x i8]* @gsxtmrational146 to i8*
%var2345 = bitcast [51 x i8]* @gsxtmrational67 to i8*
%addytable2346 = call %clsvar* @add_address_table(%mzone* %zone2338, i8* %var2344, i32 0, i8* %var2345, i32 3, %clsvar* %addytable2343)
%address-table2347 = bitcast %clsvar* %addytable2346 to i8*

; insert table, function and environment into closure struct
%closure.table2350 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure2340, i32 0, i32 0
store i8* %address-table2347, i8** %closure.table2350
%closure.env2351 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure2340, i32 0, i32 1
store i8* %envptr2341, i8** %closure.env2351
%closure.func2352 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure2340, i32 0, i32 2
store %Rational (i8*, i8*, i1, %Rational)* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ__2324, %Rational (i8*, i8*, i1, %Rational)** %closure.func2352
%closure_size2353 = call i64 @llvm_zone_mark_size(%mzone* %zone2338)
call void @llvm_zone_ptr_set_size(i8* %clsptr2339, i64 %closure_size2353)
%wrapper_ptr2354 = call i8* @llvm_zone_malloc(%mzone* %zone2338, i64 8)
%closure_wrapper2355 = bitcast i8* %wrapper_ptr2354 to { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure2340, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_wrapper2355

; let value assignment
%xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_wrapper2355, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_wrapper2355
store { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ
%tmp_envptr2349 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}***}* %environment2342, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**** %tmp_envptr2349


%val2358 = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*** %xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %val2358
}


@xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i1, %Rational)*,  %Rational (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_native(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i1, %Rational)*,  %Rational (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1, %Rational}*
%arg_p_0 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
%arg_p_1 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W1JhdGlvbmFsLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i1, %Rational)*,  %Rational (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational148 = hidden constant [55 x i8] c"xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd\00"
define dllexport fastcc double @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd__2360(i8* %_impz,i8* %_impenv, %Rational %a, double %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2361 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}*
%xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}, {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}***, {i8*, i8*, double (i8*, i8*, %Rational, double)*}**** %xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca double
store double %b, double* %bPtr


%val2362 = load %Rational, %Rational* %aPtr
; tuple ref
%val2363 = extractvalue %Rational %val2362, 0
%val2364 = sitofp i64 %val2363 to double
%val2365 = load %Rational, %Rational* %aPtr
; tuple ref
%val2366 = extractvalue %Rational %val2365, 1
%val2367 = sitofp i64 %val2366 to double
%val2368 = fdiv double %val2364, %val2367
%val2369 = load double, double* %bPtr
%val2370 = fsub double %val2368, %val2369
ret double %val2370
}
@gsxtmrational149 = hidden constant [108 x i8] c"xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, %Rational, double)*}** @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2390 = load i8*, i8** %_impzPtr
%zone2391 = bitcast i8* %tzone2390 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd
%dat_xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone2391, i64 8)
%xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd to { i8*, i8*, double (i8*, i8*, %Rational, double)*}***
%tzone2371 = load i8*, i8** %_impzPtr
%zone2372 = bitcast i8* %tzone2371 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2372)
; malloc closure structure
%clsptr2373 = call i8* @llvm_zone_malloc(%mzone* %zone2372, i64 24)
%closure2374 = bitcast i8* %clsptr2373 to { i8*, i8*, double (i8*, i8*, %Rational, double)*}*

; malloc environment structure
%envptr2375 = call i8* @llvm_zone_malloc(%mzone* %zone2372, i64 8)
%environment2376 = bitcast i8* %envptr2375 to {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}*

; malloc closure address table
%addytable2377 = call %clsvar* @new_address_table()
%var2378 = bitcast [55 x i8]* @gsxtmrational148 to i8*
%var2379 = bitcast [52 x i8]* @gsxtmrational70 to i8*
%addytable2380 = call %clsvar* @add_address_table(%mzone* %zone2372, i8* %var2378, i32 0, i8* %var2379, i32 3, %clsvar* %addytable2377)
%address-table2381 = bitcast %clsvar* %addytable2380 to i8*

; insert table, function and environment into closure struct
%closure.table2384 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational, double)*}, { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure2374, i32 0, i32 0
store i8* %address-table2381, i8** %closure.table2384
%closure.env2385 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational, double)*}, { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure2374, i32 0, i32 1
store i8* %envptr2375, i8** %closure.env2385
%closure.func2386 = getelementptr { i8*, i8*, double (i8*, i8*, %Rational, double)*}, { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure2374, i32 0, i32 2
store double (i8*, i8*, %Rational, double)* @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd__2360, double (i8*, i8*, %Rational, double)** %closure.func2386
%closure_size2387 = call i64 @llvm_zone_mark_size(%mzone* %zone2372)
call void @llvm_zone_ptr_set_size(i8* %clsptr2373, i64 %closure_size2387)
%wrapper_ptr2388 = call i8* @llvm_zone_malloc(%mzone* %zone2372, i64 8)
%closure_wrapper2389 = bitcast i8* %wrapper_ptr2388 to { i8*, i8*, double (i8*, i8*, %Rational, double)*}**
store { i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure2374, { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_wrapper2389

; let value assignment
%xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd = select i1 true, { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_wrapper2389, { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_wrapper2389
store { i8*, i8*, double (i8*, i8*, %Rational, double)*}** %xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd, { i8*, i8*, double (i8*, i8*, %Rational, double)*}*** %xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd
%tmp_envptr2383 = getelementptr {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}, {{i8*, i8*, double (i8*, i8*, %Rational, double)*}***}* %environment2376, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, %Rational, double)*}*** %xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr, {i8*, i8*, double (i8*, i8*, %Rational, double)*}**** %tmp_envptr2383


%val2392 = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}**, {i8*, i8*, double (i8*, i8*, %Rational, double)*}*** %xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVdPtr
ret {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %val2392
}


@xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, %Rational, double)*}** @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd(%Rational %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}*, {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational, double)*,  double (i8*, i8*, %Rational, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc double @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_native(%Rational %arg_0,double %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}*, {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational, double)*,  double (i8*, i8*, %Rational, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0, double %arg_1)
ret double %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, double}*
%arg_p_0 = getelementptr {%Rational, double}, {%Rational, double}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, double}, {%Rational, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2RvdWJsZSxSYXRpb25hbCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, %Rational, double)*}**
%closure = load {i8*, i8*, double (i8*, i8*, %Rational, double)*}*, {i8*, i8*, double (i8*, i8*, %Rational, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, %Rational, double)*}, {i8*, i8*, double (i8*, i8*, %Rational, double)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, %Rational, double)*,  double (i8*, i8*, %Rational, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, %Rational %arg_0, double %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational150 = hidden constant [55 x i8] c"xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd\00"
define dllexport fastcc double @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd__2394(i8* %_impz,i8* %_impenv, double %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2395 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}*
%xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr_ = getelementptr {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}, {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}***, {i8*, i8*, double (i8*, i8*, double, %Rational)*}**** %xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr_

; setup arguments
%bPtr = alloca double
store double %b, double* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2396 = load %Rational, %Rational* %aPtr
; tuple ref
%val2397 = extractvalue %Rational %val2396, 0
%val2398 = sitofp i64 %val2397 to double
%val2399 = load %Rational, %Rational* %aPtr
; tuple ref
%val2400 = extractvalue %Rational %val2399, 1
%val2401 = sitofp i64 %val2400 to double
%val2402 = fdiv double %val2398, %val2401
%val2403 = load double, double* %bPtr
%val2404 = fsub double %val2402, %val2403
ret double %val2404
}
@gsxtmrational151 = hidden constant [108 x i8] c"xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, double (i8*, i8*, double, %Rational)*}** @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2424 = load i8*, i8** %_impzPtr
%zone2425 = bitcast i8* %tzone2424 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd
%dat_xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd = call i8* @llvm_zone_malloc(%mzone* %zone2425, i64 8)
%xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd to { i8*, i8*, double (i8*, i8*, double, %Rational)*}***
%tzone2405 = load i8*, i8** %_impzPtr
%zone2406 = bitcast i8* %tzone2405 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2406)
; malloc closure structure
%clsptr2407 = call i8* @llvm_zone_malloc(%mzone* %zone2406, i64 24)
%closure2408 = bitcast i8* %clsptr2407 to { i8*, i8*, double (i8*, i8*, double, %Rational)*}*

; malloc environment structure
%envptr2409 = call i8* @llvm_zone_malloc(%mzone* %zone2406, i64 8)
%environment2410 = bitcast i8* %envptr2409 to {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}*

; malloc closure address table
%addytable2411 = call %clsvar* @new_address_table()
%var2412 = bitcast [55 x i8]* @gsxtmrational150 to i8*
%var2413 = bitcast [52 x i8]* @gsxtmrational73 to i8*
%addytable2414 = call %clsvar* @add_address_table(%mzone* %zone2406, i8* %var2412, i32 0, i8* %var2413, i32 3, %clsvar* %addytable2411)
%address-table2415 = bitcast %clsvar* %addytable2414 to i8*

; insert table, function and environment into closure struct
%closure.table2418 = getelementptr { i8*, i8*, double (i8*, i8*, double, %Rational)*}, { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure2408, i32 0, i32 0
store i8* %address-table2415, i8** %closure.table2418
%closure.env2419 = getelementptr { i8*, i8*, double (i8*, i8*, double, %Rational)*}, { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure2408, i32 0, i32 1
store i8* %envptr2409, i8** %closure.env2419
%closure.func2420 = getelementptr { i8*, i8*, double (i8*, i8*, double, %Rational)*}, { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure2408, i32 0, i32 2
store double (i8*, i8*, double, %Rational)* @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd__2394, double (i8*, i8*, double, %Rational)** %closure.func2420
%closure_size2421 = call i64 @llvm_zone_mark_size(%mzone* %zone2406)
call void @llvm_zone_ptr_set_size(i8* %clsptr2407, i64 %closure_size2421)
%wrapper_ptr2422 = call i8* @llvm_zone_malloc(%mzone* %zone2406, i64 8)
%closure_wrapper2423 = bitcast i8* %wrapper_ptr2422 to { i8*, i8*, double (i8*, i8*, double, %Rational)*}**
store { i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure2408, { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_wrapper2423

; let value assignment
%xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd = select i1 true, { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_wrapper2423, { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_wrapper2423
store { i8*, i8*, double (i8*, i8*, double, %Rational)*}** %xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd, { i8*, i8*, double (i8*, i8*, double, %Rational)*}*** %xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd
%tmp_envptr2417 = getelementptr {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}, {{i8*, i8*, double (i8*, i8*, double, %Rational)*}***}* %environment2410, i32 0, i32 0
store {i8*, i8*, double (i8*, i8*, double, %Rational)*}*** %xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr, {i8*, i8*, double (i8*, i8*, double, %Rational)*}**** %tmp_envptr2417


%val2426 = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}**, {i8*, i8*, double (i8*, i8*, double, %Rational)*}*** %xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxdPtr
ret {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %val2426
}


@xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, double (i8*, i8*, double, %Rational)*}** @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc double @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd(double %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}*, {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %Rational)*,  double (i8*, i8*, double, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %Rational %arg_1)
ret double %result
}


define dllexport ccc double @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_native(double %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}*, {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %Rational)*,  double (i8*, i8*, double, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %Rational %arg_1)
ret double %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {double, %Rational}*
%arg_p_0 = getelementptr {double, %Rational}, {double, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load double, double* %arg_p_0
%arg_p_1 = getelementptr {double, %Rational}, {double, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2RvdWJsZSxkb3VibGUsUmF0aW9uYWxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, double (i8*, i8*, double, %Rational)*}**
%closure = load {i8*, i8*, double (i8*, i8*, double, %Rational)*}*, {i8*, i8*, double (i8*, i8*, double, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, double (i8*, i8*, double, %Rational)*}, {i8*, i8*, double (i8*, i8*, double, %Rational)*}* %closure, i32 0, i32 1
%ff = load  double (i8*, i8*, double, %Rational)*,  double (i8*, i8*, double, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc double %ff(i8* %_impz, i8* %ee, double %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational152 = hidden constant [53 x i8] c"xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ\00"
define dllexport fastcc float @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ__2428(i8* %_impz,i8* %_impenv, %Rational %a, float %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2429 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}*
%xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}, {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}***, {i8*, i8*, float (i8*, i8*, %Rational, float)*}**** %xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca float
store float %b, float* %bPtr


%val2430 = load %Rational, %Rational* %aPtr
; tuple ref
%val2431 = extractvalue %Rational %val2430, 0
%val2432 = sitofp i64 %val2431 to float
%val2433 = load %Rational, %Rational* %aPtr
; tuple ref
%val2434 = extractvalue %Rational %val2433, 1
%val2435 = sitofp i64 %val2434 to float
%val2436 = fdiv float %val2432, %val2435
%val2437 = load float, float* %bPtr
%val2438 = fsub float %val2436, %val2437
ret float %val2438
}
@gsxtmrational153 = hidden constant [106 x i8] c"xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %Rational, float)*}** @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2458 = load i8*, i8** %_impzPtr
%zone2459 = bitcast i8* %tzone2458 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ
%dat_xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone2459, i64 8)
%xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ to { i8*, i8*, float (i8*, i8*, %Rational, float)*}***
%tzone2439 = load i8*, i8** %_impzPtr
%zone2440 = bitcast i8* %tzone2439 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2440)
; malloc closure structure
%clsptr2441 = call i8* @llvm_zone_malloc(%mzone* %zone2440, i64 24)
%closure2442 = bitcast i8* %clsptr2441 to { i8*, i8*, float (i8*, i8*, %Rational, float)*}*

; malloc environment structure
%envptr2443 = call i8* @llvm_zone_malloc(%mzone* %zone2440, i64 8)
%environment2444 = bitcast i8* %envptr2443 to {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}*

; malloc closure address table
%addytable2445 = call %clsvar* @new_address_table()
%var2446 = bitcast [53 x i8]* @gsxtmrational152 to i8*
%var2447 = bitcast [50 x i8]* @gsxtmrational76 to i8*
%addytable2448 = call %clsvar* @add_address_table(%mzone* %zone2440, i8* %var2446, i32 0, i8* %var2447, i32 3, %clsvar* %addytable2445)
%address-table2449 = bitcast %clsvar* %addytable2448 to i8*

; insert table, function and environment into closure struct
%closure.table2452 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational, float)*}, { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure2442, i32 0, i32 0
store i8* %address-table2449, i8** %closure.table2452
%closure.env2453 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational, float)*}, { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure2442, i32 0, i32 1
store i8* %envptr2443, i8** %closure.env2453
%closure.func2454 = getelementptr { i8*, i8*, float (i8*, i8*, %Rational, float)*}, { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure2442, i32 0, i32 2
store float (i8*, i8*, %Rational, float)* @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ__2428, float (i8*, i8*, %Rational, float)** %closure.func2454
%closure_size2455 = call i64 @llvm_zone_mark_size(%mzone* %zone2440)
call void @llvm_zone_ptr_set_size(i8* %clsptr2441, i64 %closure_size2455)
%wrapper_ptr2456 = call i8* @llvm_zone_malloc(%mzone* %zone2440, i64 8)
%closure_wrapper2457 = bitcast i8* %wrapper_ptr2456 to { i8*, i8*, float (i8*, i8*, %Rational, float)*}**
store { i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure2442, { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_wrapper2457

; let value assignment
%xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ = select i1 true, { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_wrapper2457, { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_wrapper2457
store { i8*, i8*, float (i8*, i8*, %Rational, float)*}** %xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ, { i8*, i8*, float (i8*, i8*, %Rational, float)*}*** %xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ
%tmp_envptr2451 = getelementptr {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}, {{i8*, i8*, float (i8*, i8*, %Rational, float)*}***}* %environment2444, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %Rational, float)*}*** %xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr, {i8*, i8*, float (i8*, i8*, %Rational, float)*}**** %tmp_envptr2451


%val2460 = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}**, {i8*, i8*, float (i8*, i8*, %Rational, float)*}*** %xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQPtr
ret {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %val2460
}


@xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %Rational, float)*}** @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ(%Rational %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}*, {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational, float)*,  float (i8*, i8*, %Rational, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0, float %arg_1)
ret float %result
}


define dllexport ccc float @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_native(%Rational %arg_0,float %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}*, {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational, float)*,  float (i8*, i8*, %Rational, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0, float %arg_1)
ret float %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, float}*
%arg_p_0 = getelementptr {%Rational, float}, {%Rational, float}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, float}, {%Rational, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2Zsb2F0LFJhdGlvbmFsLGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %Rational, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %Rational, float)*}*, {i8*, i8*, float (i8*, i8*, %Rational, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %Rational, float)*}, {i8*, i8*, float (i8*, i8*, %Rational, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %Rational, float)*,  float (i8*, i8*, %Rational, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %Rational %arg_0, float %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational154 = hidden constant [53 x i8] c"xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ\00"
define dllexport fastcc float @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ__2462(i8* %_impz,i8* %_impenv, float %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2463 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}*
%xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}, {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}***, {i8*, i8*, float (i8*, i8*, float, %Rational)*}**** %xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca float
store float %b, float* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2464 = load %Rational, %Rational* %aPtr
; tuple ref
%val2465 = extractvalue %Rational %val2464, 0
%val2466 = sitofp i64 %val2465 to float
%val2467 = load %Rational, %Rational* %aPtr
; tuple ref
%val2468 = extractvalue %Rational %val2467, 1
%val2469 = sitofp i64 %val2468 to float
%val2470 = fdiv float %val2466, %val2469
%val2471 = load float, float* %bPtr
%val2472 = fsub float %val2470, %val2471
ret float %val2472
}
@gsxtmrational155 = hidden constant [106 x i8] c"xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, float, %Rational)*}** @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2492 = load i8*, i8** %_impzPtr
%zone2493 = bitcast i8* %tzone2492 to %mzone*

; let assign value to symbol xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ
%dat_xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone2493, i64 8)
%xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ to { i8*, i8*, float (i8*, i8*, float, %Rational)*}***
%tzone2473 = load i8*, i8** %_impzPtr
%zone2474 = bitcast i8* %tzone2473 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2474)
; malloc closure structure
%clsptr2475 = call i8* @llvm_zone_malloc(%mzone* %zone2474, i64 24)
%closure2476 = bitcast i8* %clsptr2475 to { i8*, i8*, float (i8*, i8*, float, %Rational)*}*

; malloc environment structure
%envptr2477 = call i8* @llvm_zone_malloc(%mzone* %zone2474, i64 8)
%environment2478 = bitcast i8* %envptr2477 to {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}*

; malloc closure address table
%addytable2479 = call %clsvar* @new_address_table()
%var2480 = bitcast [53 x i8]* @gsxtmrational154 to i8*
%var2481 = bitcast [50 x i8]* @gsxtmrational79 to i8*
%addytable2482 = call %clsvar* @add_address_table(%mzone* %zone2474, i8* %var2480, i32 0, i8* %var2481, i32 3, %clsvar* %addytable2479)
%address-table2483 = bitcast %clsvar* %addytable2482 to i8*

; insert table, function and environment into closure struct
%closure.table2486 = getelementptr { i8*, i8*, float (i8*, i8*, float, %Rational)*}, { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure2476, i32 0, i32 0
store i8* %address-table2483, i8** %closure.table2486
%closure.env2487 = getelementptr { i8*, i8*, float (i8*, i8*, float, %Rational)*}, { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure2476, i32 0, i32 1
store i8* %envptr2477, i8** %closure.env2487
%closure.func2488 = getelementptr { i8*, i8*, float (i8*, i8*, float, %Rational)*}, { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure2476, i32 0, i32 2
store float (i8*, i8*, float, %Rational)* @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ__2462, float (i8*, i8*, float, %Rational)** %closure.func2488
%closure_size2489 = call i64 @llvm_zone_mark_size(%mzone* %zone2474)
call void @llvm_zone_ptr_set_size(i8* %clsptr2475, i64 %closure_size2489)
%wrapper_ptr2490 = call i8* @llvm_zone_malloc(%mzone* %zone2474, i64 8)
%closure_wrapper2491 = bitcast i8* %wrapper_ptr2490 to { i8*, i8*, float (i8*, i8*, float, %Rational)*}**
store { i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure2476, { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_wrapper2491

; let value assignment
%xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_wrapper2491, { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_wrapper2491
store { i8*, i8*, float (i8*, i8*, float, %Rational)*}** %xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ, { i8*, i8*, float (i8*, i8*, float, %Rational)*}*** %xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ
%tmp_envptr2485 = getelementptr {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}, {{i8*, i8*, float (i8*, i8*, float, %Rational)*}***}* %environment2478, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, float, %Rational)*}*** %xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr, {i8*, i8*, float (i8*, i8*, float, %Rational)*}**** %tmp_envptr2485


%val2494 = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}**, {i8*, i8*, float (i8*, i8*, float, %Rational)*}*** %xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQPtr
ret {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %val2494
}


@xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, float, %Rational)*}** @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ(float %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}*, {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %Rational)*,  float (i8*, i8*, float, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %Rational %arg_1)
ret float %result
}


define dllexport ccc float @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_native(float %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}*, {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %Rational)*,  float (i8*, i8*, float, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %Rational %arg_1)
ret float %result
}


define dllexport ccc void @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float, %Rational}*
%arg_p_0 = getelementptr {float, %Rational}, {float, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load float, float* %arg_p_0
%arg_p_1 = getelementptr {float, %Rational}, {float, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_subtraction_adhoc_W2Zsb2F0LGZsb2F0LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, float, %Rational)*}**
%closure = load {i8*, i8*, float (i8*, i8*, float, %Rational)*}*, {i8*, i8*, float (i8*, i8*, float, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, float, %Rational)*}, {i8*, i8*, float (i8*, i8*, float, %Rational)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, float, %Rational)*,  float (i8*, i8*, float, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, float %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational156 = hidden constant [47 x i8] c"xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ\00"
@gsxtmrational157 = hidden constant [51 x i8] c"{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**\00"
define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ__2496(i8* %_impz,i8* %_impenv, %Rational %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2497 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}*
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%tzone2500 = load i8*, i8** %_impzPtr
%zone2501 = bitcast i8* %tzone2500 to %mzone*

; let assign value to symbol reduced_a
%reduced_aPtr = alloca %Rational
%tzone2504 = load i8*, i8** %_impzPtr
%zone2505 = bitcast i8* %tzone2504 to %mzone*

; let assign value to symbol reduced_b
%reduced_bPtr = alloca %Rational
%val2498 = load %Rational, %Rational* %aPtr
%res2499 = call fastcc %Rational @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val2498)

; let value assignment
%reduced_a = select i1 true, %Rational %res2499, %Rational %res2499
store %Rational %reduced_a, %Rational* %reduced_aPtr

%val2502 = load %Rational, %Rational* %bPtr
%res2503 = call fastcc %Rational @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val2502)

; let value assignment
%reduced_b = select i1 true, %Rational %res2503, %Rational %res2503
store %Rational %reduced_b, %Rational* %reduced_bPtr

%val2507 = load %Rational, %Rational* %reduced_aPtr
; tuple ref
%val2508 = extractvalue %Rational %val2507, 0
%val2509 = load %Rational, %Rational* %reduced_bPtr
; tuple ref
%val2510 = extractvalue %Rational %val2509, 0
%cmp2511 = icmp eq i64 %val2508, %val2510
br i1 %cmp2511, label %then2506, label %else2506

then2506:
%val2513 = load %Rational, %Rational* %reduced_aPtr
; tuple ref
%val2514 = extractvalue %Rational %val2513, 1
%val2515 = load %Rational, %Rational* %reduced_bPtr
; tuple ref
%val2516 = extractvalue %Rational %val2515, 1
%cmp2517 = icmp eq i64 %val2514, %val2516
br i1 %cmp2517, label %then2512, label %else2512

then2512:
%val2518 = load %Rational, %Rational* %reduced_aPtr
; tuple ref
%val2519 = extractvalue %Rational %val2518, 1
%val2520 = load %Rational, %Rational* %reduced_bPtr
; tuple ref
%val2521 = extractvalue %Rational %val2520, 1
%cmp2522 = icmp eq i64 %val2519, %val2521
ret i1 %cmp2522

else2512:
%res2523 = call ccc i1 @impc_false()
ret i1 %res2523

else2506:
%res2524 = call ccc i1 @impc_false()
ret i1 %res2524
}
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2544 = load i8*, i8** %_impzPtr
%zone2545 = bitcast i8* %tzone2544 to %mzone*

; let assign value to symbol xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ
%dat_xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone2545, i64 8)
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***
%tzone2525 = load i8*, i8** %_impzPtr
%zone2526 = bitcast i8* %tzone2525 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2526)
; malloc closure structure
%clsptr2527 = call i8* @llvm_zone_malloc(%mzone* %zone2526, i64 24)
%closure2528 = bitcast i8* %clsptr2527 to { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*

; malloc environment structure
%envptr2529 = call i8* @llvm_zone_malloc(%mzone* %zone2526, i64 8)
%environment2530 = bitcast i8* %envptr2529 to {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}*

; malloc closure address table
%addytable2531 = call %clsvar* @new_address_table()
%var2532 = bitcast [47 x i8]* @gsxtmrational156 to i8*
%var2533 = bitcast [51 x i8]* @gsxtmrational157 to i8*
%addytable2534 = call %clsvar* @add_address_table(%mzone* %zone2526, i8* %var2532, i32 0, i8* %var2533, i32 3, %clsvar* %addytable2531)
%address-table2535 = bitcast %clsvar* %addytable2534 to i8*

; insert table, function and environment into closure struct
%closure.table2538 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure2528, i32 0, i32 0
store i8* %address-table2535, i8** %closure.table2538
%closure.env2539 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure2528, i32 0, i32 1
store i8* %envptr2529, i8** %closure.env2539
%closure.func2540 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure2528, i32 0, i32 2
store i1 (i8*, i8*, %Rational, %Rational)* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ__2496, i1 (i8*, i8*, %Rational, %Rational)** %closure.func2540
%closure_size2541 = call i64 @llvm_zone_mark_size(%mzone* %zone2526)
call void @llvm_zone_ptr_set_size(i8* %clsptr2527, i64 %closure_size2541)
%wrapper_ptr2542 = call i8* @llvm_zone_malloc(%mzone* %zone2526, i64 8)
%closure_wrapper2543 = bitcast i8* %wrapper_ptr2542 to { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure2528, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper2543

; let value assignment
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper2543, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper2543
store { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ
%tmp_envptr2537 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}* %environment2530, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**** %tmp_envptr2537


%val2546 = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %val2546
}


@xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, %Rational)*,  i1 (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_native(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, %Rational)*,  i1 (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, %Rational}*
%arg_p_0 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, %Rational)*,  i1 (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational158 = hidden constant [40 x i8] c"xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0\00"
@gsxtmrational159 = hidden constant [45 x i8] c"{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**\00"
define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0__2547(i8* %_impz,i8* %_impenv, %Rational %a, i64 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2548 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}*
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}* %impenv, i32 0, i32 0
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i64
store i64 %b, i64* %bPtr


%val2549 = load %Rational, %Rational* %aPtr
%val2550 = load i64, i64* %bPtr
%res2551 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2550, i64 1)
%res2552 = call fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val2549, %Rational %res2551)
ret i1 %res2552
}
@gsxtmrational160 = hidden constant [93 x i8] c"xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2572 = load i8*, i8** %_impzPtr
%zone2573 = bitcast i8* %tzone2572 to %mzone*

; let assign value to symbol xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0
%dat_xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone2573, i64 8)
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr = bitcast i8* %dat_xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 to { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***
%tzone2553 = load i8*, i8** %_impzPtr
%zone2554 = bitcast i8* %tzone2553 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2554)
; malloc closure structure
%clsptr2555 = call i8* @llvm_zone_malloc(%mzone* %zone2554, i64 24)
%closure2556 = bitcast i8* %clsptr2555 to { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*

; malloc environment structure
%envptr2557 = call i8* @llvm_zone_malloc(%mzone* %zone2554, i64 8)
%environment2558 = bitcast i8* %envptr2557 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}*

; malloc closure address table
%addytable2559 = call %clsvar* @new_address_table()
%var2560 = bitcast [40 x i8]* @gsxtmrational158 to i8*
%var2561 = bitcast [45 x i8]* @gsxtmrational159 to i8*
%addytable2562 = call %clsvar* @add_address_table(%mzone* %zone2554, i8* %var2560, i32 0, i8* %var2561, i32 3, %clsvar* %addytable2559)
%address-table2563 = bitcast %clsvar* %addytable2562 to i8*

; insert table, function and environment into closure struct
%closure.table2566 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure2556, i32 0, i32 0
store i8* %address-table2563, i8** %closure.table2566
%closure.env2567 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure2556, i32 0, i32 1
store i8* %envptr2557, i8** %closure.env2567
%closure.func2568 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure2556, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i64)* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0__2547, i1 (i8*, i8*, %Rational, i64)** %closure.func2568
%closure_size2569 = call i64 @llvm_zone_mark_size(%mzone* %zone2554)
call void @llvm_zone_ptr_set_size(i8* %clsptr2555, i64 %closure_size2569)
%wrapper_ptr2570 = call i8* @llvm_zone_malloc(%mzone* %zone2554, i64 8)
%closure_wrapper2571 = bitcast i8* %wrapper_ptr2570 to { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure2556, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_wrapper2571

; let value assignment
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_wrapper2571, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_wrapper2571
store { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0
%tmp_envptr2565 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}* %environment2558, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**** %tmp_envptr2565


%val2574 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %val2574
}


@xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i64)*,  i1 (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_native(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i64)*,  i1 (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i64}*
%arg_p_0 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i64)*,  i1 (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational161 = hidden constant [40 x i8] c"xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0\00"
@gsxtmrational162 = hidden constant [45 x i8] c"{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**\00"
define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0__2576(i8* %_impz,i8* %_impenv, i64 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2577 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}*
%xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**** %xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i64
store i64 %b, i64* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2578 = load i64, i64* %bPtr
%res2579 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2578, i64 1)
%val2580 = load %Rational, %Rational* %aPtr
%res2581 = call fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res2579, %Rational %val2580)
ret i1 %res2581
}
@gsxtmrational163 = hidden constant [93 x i8] c"xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2601 = load i8*, i8** %_impzPtr
%zone2602 = bitcast i8* %tzone2601 to %mzone*

; let assign value to symbol xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0
%dat_xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone2602, i64 8)
%xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0 to { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***
%tzone2582 = load i8*, i8** %_impzPtr
%zone2583 = bitcast i8* %tzone2582 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2583)
; malloc closure structure
%clsptr2584 = call i8* @llvm_zone_malloc(%mzone* %zone2583, i64 24)
%closure2585 = bitcast i8* %clsptr2584 to { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*

; malloc environment structure
%envptr2586 = call i8* @llvm_zone_malloc(%mzone* %zone2583, i64 8)
%environment2587 = bitcast i8* %envptr2586 to {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}*

; malloc closure address table
%addytable2588 = call %clsvar* @new_address_table()
%var2589 = bitcast [40 x i8]* @gsxtmrational161 to i8*
%var2590 = bitcast [45 x i8]* @gsxtmrational162 to i8*
%addytable2591 = call %clsvar* @add_address_table(%mzone* %zone2583, i8* %var2589, i32 0, i8* %var2590, i32 3, %clsvar* %addytable2588)
%address-table2592 = bitcast %clsvar* %addytable2591 to i8*

; insert table, function and environment into closure struct
%closure.table2595 = getelementptr { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure2585, i32 0, i32 0
store i8* %address-table2592, i8** %closure.table2595
%closure.env2596 = getelementptr { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure2585, i32 0, i32 1
store i8* %envptr2586, i8** %closure.env2596
%closure.func2597 = getelementptr { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure2585, i32 0, i32 2
store i1 (i8*, i8*, i64, %Rational)* @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0__2576, i1 (i8*, i8*, i64, %Rational)** %closure.func2597
%closure_size2598 = call i64 @llvm_zone_mark_size(%mzone* %zone2583)
call void @llvm_zone_ptr_set_size(i8* %clsptr2584, i64 %closure_size2598)
%wrapper_ptr2599 = call i8* @llvm_zone_malloc(%mzone* %zone2583, i64 8)
%closure_wrapper2600 = bitcast i8* %wrapper_ptr2599 to { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure2585, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_wrapper2600

; let value assignment
%xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_wrapper2600, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_wrapper2600
store { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*** %xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0
%tmp_envptr2594 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}* %environment2587, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*** %xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**** %tmp_envptr2594


%val2603 = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*** %xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr
ret {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %val2603
}


@xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i64, %Rational)*,  i1 (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_native(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i64, %Rational)*,  i1 (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, %Rational}*
%arg_p_0 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i64, %Rational)*,  i1 (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational164 = hidden constant [40 x i8] c"xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0\00"
@gsxtmrational165 = hidden constant [45 x i8] c"{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**\00"
define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0__2605(i8* %_impz,i8* %_impenv, %Rational %a, i32 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2606 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}*
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}* %impenv, i32 0, i32 0
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i32
store i32 %b, i32* %bPtr


%val2607 = load %Rational, %Rational* %aPtr
%val2608 = load i32, i32* %bPtr
%res2609 = call ccc i64 @i32toi64(i32 %val2608)
%res2610 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res2609, i64 1)
%res2611 = call fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val2607, %Rational %res2610)
ret i1 %res2611
}
@gsxtmrational166 = hidden constant [93 x i8] c"xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2631 = load i8*, i8** %_impzPtr
%zone2632 = bitcast i8* %tzone2631 to %mzone*

; let assign value to symbol xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0
%dat_xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2632, i64 8)
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr = bitcast i8* %dat_xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 to { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***
%tzone2612 = load i8*, i8** %_impzPtr
%zone2613 = bitcast i8* %tzone2612 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2613)
; malloc closure structure
%clsptr2614 = call i8* @llvm_zone_malloc(%mzone* %zone2613, i64 24)
%closure2615 = bitcast i8* %clsptr2614 to { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*

; malloc environment structure
%envptr2616 = call i8* @llvm_zone_malloc(%mzone* %zone2613, i64 8)
%environment2617 = bitcast i8* %envptr2616 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}*

; malloc closure address table
%addytable2618 = call %clsvar* @new_address_table()
%var2619 = bitcast [40 x i8]* @gsxtmrational164 to i8*
%var2620 = bitcast [45 x i8]* @gsxtmrational165 to i8*
%addytable2621 = call %clsvar* @add_address_table(%mzone* %zone2613, i8* %var2619, i32 0, i8* %var2620, i32 3, %clsvar* %addytable2618)
%address-table2622 = bitcast %clsvar* %addytable2621 to i8*

; insert table, function and environment into closure struct
%closure.table2625 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure2615, i32 0, i32 0
store i8* %address-table2622, i8** %closure.table2625
%closure.env2626 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure2615, i32 0, i32 1
store i8* %envptr2616, i8** %closure.env2626
%closure.func2627 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure2615, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i32)* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0__2605, i1 (i8*, i8*, %Rational, i32)** %closure.func2627
%closure_size2628 = call i64 @llvm_zone_mark_size(%mzone* %zone2613)
call void @llvm_zone_ptr_set_size(i8* %clsptr2614, i64 %closure_size2628)
%wrapper_ptr2629 = call i8* @llvm_zone_malloc(%mzone* %zone2613, i64 8)
%closure_wrapper2630 = bitcast i8* %wrapper_ptr2629 to { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure2615, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_wrapper2630

; let value assignment
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_wrapper2630, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_wrapper2630
store { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0
%tmp_envptr2624 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}* %environment2617, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**** %tmp_envptr2624


%val2633 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %val2633
}


@xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i32)*,  i1 (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_native(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i32)*,  i1 (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i32}*
%arg_p_0 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i32)*,  i1 (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational167 = hidden constant [40 x i8] c"xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0\00"
@gsxtmrational168 = hidden constant [45 x i8] c"{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**\00"
define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0__2635(i8* %_impz,i8* %_impenv, i32 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2636 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}*
%xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**** %xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i32
store i32 %b, i32* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2637 = load i32, i32* %bPtr
%res2638 = call ccc i64 @i32toi64(i32 %val2637)
%res2639 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res2638, i64 1)
%val2640 = load %Rational, %Rational* %aPtr
%res2641 = call fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res2639, %Rational %val2640)
ret i1 %res2641
}
@gsxtmrational169 = hidden constant [93 x i8] c"xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2661 = load i8*, i8** %_impzPtr
%zone2662 = bitcast i8* %tzone2661 to %mzone*

; let assign value to symbol xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0
%dat_xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone2662, i64 8)
%xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0 to { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***
%tzone2642 = load i8*, i8** %_impzPtr
%zone2643 = bitcast i8* %tzone2642 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2643)
; malloc closure structure
%clsptr2644 = call i8* @llvm_zone_malloc(%mzone* %zone2643, i64 24)
%closure2645 = bitcast i8* %clsptr2644 to { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*

; malloc environment structure
%envptr2646 = call i8* @llvm_zone_malloc(%mzone* %zone2643, i64 8)
%environment2647 = bitcast i8* %envptr2646 to {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}*

; malloc closure address table
%addytable2648 = call %clsvar* @new_address_table()
%var2649 = bitcast [40 x i8]* @gsxtmrational167 to i8*
%var2650 = bitcast [45 x i8]* @gsxtmrational168 to i8*
%addytable2651 = call %clsvar* @add_address_table(%mzone* %zone2643, i8* %var2649, i32 0, i8* %var2650, i32 3, %clsvar* %addytable2648)
%address-table2652 = bitcast %clsvar* %addytable2651 to i8*

; insert table, function and environment into closure struct
%closure.table2655 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure2645, i32 0, i32 0
store i8* %address-table2652, i8** %closure.table2655
%closure.env2656 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure2645, i32 0, i32 1
store i8* %envptr2646, i8** %closure.env2656
%closure.func2657 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure2645, i32 0, i32 2
store i1 (i8*, i8*, i32, %Rational)* @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0__2635, i1 (i8*, i8*, i32, %Rational)** %closure.func2657
%closure_size2658 = call i64 @llvm_zone_mark_size(%mzone* %zone2643)
call void @llvm_zone_ptr_set_size(i8* %clsptr2644, i64 %closure_size2658)
%wrapper_ptr2659 = call i8* @llvm_zone_malloc(%mzone* %zone2643, i64 8)
%closure_wrapper2660 = bitcast i8* %wrapper_ptr2659 to { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure2645, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_wrapper2660

; let value assignment
%xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_wrapper2660, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_wrapper2660
store { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*** %xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0
%tmp_envptr2654 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}* %environment2647, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*** %xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**** %tmp_envptr2654


%val2663 = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*** %xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr
ret {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %val2663
}


@xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, %Rational)*,  i1 (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_native(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, %Rational)*,  i1 (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Rational}*
%arg_p_0 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, %Rational)*,  i1 (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational170 = hidden constant [39 x i8] c"xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ\00"
@gsxtmrational171 = hidden constant [44 x i8] c"{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**\00"
define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ__2665(i8* %_impz,i8* %_impenv, %Rational %a, i8 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2666 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}*
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}* %impenv, i32 0, i32 0
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i8
store i8 %b, i8* %bPtr


%val2667 = load %Rational, %Rational* %aPtr
%val2668 = load i8, i8* %bPtr
%res2669 = call ccc i64 @i8toi64(i8 %val2668)
%res2670 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res2669, i64 1)
%res2671 = call fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val2667, %Rational %res2670)
ret i1 %res2671
}
@gsxtmrational172 = hidden constant [92 x i8] c"xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2691 = load i8*, i8** %_impzPtr
%zone2692 = bitcast i8* %tzone2691 to %mzone*

; let assign value to symbol xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ
%dat_xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ = call i8* @llvm_zone_malloc(%mzone* %zone2692, i64 8)
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr = bitcast i8* %dat_xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ to { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***
%tzone2672 = load i8*, i8** %_impzPtr
%zone2673 = bitcast i8* %tzone2672 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2673)
; malloc closure structure
%clsptr2674 = call i8* @llvm_zone_malloc(%mzone* %zone2673, i64 24)
%closure2675 = bitcast i8* %clsptr2674 to { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*

; malloc environment structure
%envptr2676 = call i8* @llvm_zone_malloc(%mzone* %zone2673, i64 8)
%environment2677 = bitcast i8* %envptr2676 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}*

; malloc closure address table
%addytable2678 = call %clsvar* @new_address_table()
%var2679 = bitcast [39 x i8]* @gsxtmrational170 to i8*
%var2680 = bitcast [44 x i8]* @gsxtmrational171 to i8*
%addytable2681 = call %clsvar* @add_address_table(%mzone* %zone2673, i8* %var2679, i32 0, i8* %var2680, i32 3, %clsvar* %addytable2678)
%address-table2682 = bitcast %clsvar* %addytable2681 to i8*

; insert table, function and environment into closure struct
%closure.table2685 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure2675, i32 0, i32 0
store i8* %address-table2682, i8** %closure.table2685
%closure.env2686 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure2675, i32 0, i32 1
store i8* %envptr2676, i8** %closure.env2686
%closure.func2687 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure2675, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i8)* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ__2665, i1 (i8*, i8*, %Rational, i8)** %closure.func2687
%closure_size2688 = call i64 @llvm_zone_mark_size(%mzone* %zone2673)
call void @llvm_zone_ptr_set_size(i8* %clsptr2674, i64 %closure_size2688)
%wrapper_ptr2689 = call i8* @llvm_zone_malloc(%mzone* %zone2673, i64 8)
%closure_wrapper2690 = bitcast i8* %wrapper_ptr2689 to { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure2675, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_wrapper2690

; let value assignment
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_wrapper2690, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_wrapper2690
store { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr

; add data to environment
; don't need to alloc for env var xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ
%tmp_envptr2684 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}* %environment2677, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**** %tmp_envptr2684


%val2693 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %val2693
}


@xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i8)*,  i1 (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_native(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i8)*,  i1 (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i8}*
%arg_p_0 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i8)*,  i1 (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational173 = hidden constant [39 x i8] c"xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ\00"
@gsxtmrational174 = hidden constant [44 x i8] c"{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**\00"
define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ__2695(i8* %_impz,i8* %_impenv, i8 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2696 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}*
%xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**** %xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i8
store i8 %b, i8* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2697 = load i8, i8* %bPtr
%res2698 = call ccc i64 @i8toi64(i8 %val2697)
%res2699 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res2698, i64 1)
%val2700 = load %Rational, %Rational* %aPtr
%res2701 = call fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res2699, %Rational %val2700)
ret i1 %res2701
}
@gsxtmrational175 = hidden constant [92 x i8] c"xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2721 = load i8*, i8** %_impzPtr
%zone2722 = bitcast i8* %tzone2721 to %mzone*

; let assign value to symbol xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ
%dat_xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone2722, i64 8)
%xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***
%tzone2702 = load i8*, i8** %_impzPtr
%zone2703 = bitcast i8* %tzone2702 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2703)
; malloc closure structure
%clsptr2704 = call i8* @llvm_zone_malloc(%mzone* %zone2703, i64 24)
%closure2705 = bitcast i8* %clsptr2704 to { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*

; malloc environment structure
%envptr2706 = call i8* @llvm_zone_malloc(%mzone* %zone2703, i64 8)
%environment2707 = bitcast i8* %envptr2706 to {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}*

; malloc closure address table
%addytable2708 = call %clsvar* @new_address_table()
%var2709 = bitcast [39 x i8]* @gsxtmrational173 to i8*
%var2710 = bitcast [44 x i8]* @gsxtmrational174 to i8*
%addytable2711 = call %clsvar* @add_address_table(%mzone* %zone2703, i8* %var2709, i32 0, i8* %var2710, i32 3, %clsvar* %addytable2708)
%address-table2712 = bitcast %clsvar* %addytable2711 to i8*

; insert table, function and environment into closure struct
%closure.table2715 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure2705, i32 0, i32 0
store i8* %address-table2712, i8** %closure.table2715
%closure.env2716 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure2705, i32 0, i32 1
store i8* %envptr2706, i8** %closure.env2716
%closure.func2717 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure2705, i32 0, i32 2
store i1 (i8*, i8*, i8, %Rational)* @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ__2695, i1 (i8*, i8*, i8, %Rational)** %closure.func2717
%closure_size2718 = call i64 @llvm_zone_mark_size(%mzone* %zone2703)
call void @llvm_zone_ptr_set_size(i8* %clsptr2704, i64 %closure_size2718)
%wrapper_ptr2719 = call i8* @llvm_zone_malloc(%mzone* %zone2703, i64 8)
%closure_wrapper2720 = bitcast i8* %wrapper_ptr2719 to { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure2705, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_wrapper2720

; let value assignment
%xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_wrapper2720, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_wrapper2720
store { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*** %xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ
%tmp_envptr2714 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}* %environment2707, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*** %xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**** %tmp_envptr2714


%val2723 = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*** %xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %val2723
}


@xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8, %Rational)*,  i1 (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_native(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8, %Rational)*,  i1 (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8, %Rational}*
%arg_p_0 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
%arg_p_1 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8, %Rational)*,  i1 (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational176 = hidden constant [39 x i8] c"xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ\00"
@gsxtmrational177 = hidden constant [44 x i8] c"{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**\00"
define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ__2725(i8* %_impz,i8* %_impenv, %Rational %a, i1 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2726 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}*
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}* %impenv, i32 0, i32 0
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i1
store i1 %b, i1* %bPtr


%val2727 = load %Rational, %Rational* %aPtr
%val2728 = load i1, i1* %bPtr
%res2729 = call ccc i64 @i1toi64(i1 %val2728)
%res2730 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res2729, i64 1)
%res2731 = call fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val2727, %Rational %res2730)
ret i1 %res2731
}
@gsxtmrational178 = hidden constant [92 x i8] c"xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2751 = load i8*, i8** %_impzPtr
%zone2752 = bitcast i8* %tzone2751 to %mzone*

; let assign value to symbol xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ
%dat_xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ = call i8* @llvm_zone_malloc(%mzone* %zone2752, i64 8)
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr = bitcast i8* %dat_xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ to { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***
%tzone2732 = load i8*, i8** %_impzPtr
%zone2733 = bitcast i8* %tzone2732 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2733)
; malloc closure structure
%clsptr2734 = call i8* @llvm_zone_malloc(%mzone* %zone2733, i64 24)
%closure2735 = bitcast i8* %clsptr2734 to { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*

; malloc environment structure
%envptr2736 = call i8* @llvm_zone_malloc(%mzone* %zone2733, i64 8)
%environment2737 = bitcast i8* %envptr2736 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}*

; malloc closure address table
%addytable2738 = call %clsvar* @new_address_table()
%var2739 = bitcast [39 x i8]* @gsxtmrational176 to i8*
%var2740 = bitcast [44 x i8]* @gsxtmrational177 to i8*
%addytable2741 = call %clsvar* @add_address_table(%mzone* %zone2733, i8* %var2739, i32 0, i8* %var2740, i32 3, %clsvar* %addytable2738)
%address-table2742 = bitcast %clsvar* %addytable2741 to i8*

; insert table, function and environment into closure struct
%closure.table2745 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure2735, i32 0, i32 0
store i8* %address-table2742, i8** %closure.table2745
%closure.env2746 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure2735, i32 0, i32 1
store i8* %envptr2736, i8** %closure.env2746
%closure.func2747 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure2735, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i1)* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ__2725, i1 (i8*, i8*, %Rational, i1)** %closure.func2747
%closure_size2748 = call i64 @llvm_zone_mark_size(%mzone* %zone2733)
call void @llvm_zone_ptr_set_size(i8* %clsptr2734, i64 %closure_size2748)
%wrapper_ptr2749 = call i8* @llvm_zone_malloc(%mzone* %zone2733, i64 8)
%closure_wrapper2750 = bitcast i8* %wrapper_ptr2749 to { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure2735, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_wrapper2750

; let value assignment
%xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_wrapper2750, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_wrapper2750
store { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr

; add data to environment
; don't need to alloc for env var xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ
%tmp_envptr2744 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}* %environment2737, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**** %tmp_envptr2744


%val2753 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*** %xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %val2753
}


@xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i1)*,  i1 (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_native(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i1)*,  i1 (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i1}*
%arg_p_0 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 1
%arg_1 = load i1, i1* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i1)*,  i1 (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational179 = hidden constant [39 x i8] c"xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ\00"
@gsxtmrational180 = hidden constant [44 x i8] c"{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**\00"
define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ__2755(i8* %_impz,i8* %_impenv, i1 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2756 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}*
%xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**** %xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i1
store i1 %b, i1* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2757 = load i1, i1* %bPtr
%res2758 = call ccc i64 @i1toi64(i1 %val2757)
%res2759 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res2758, i64 1)
%val2760 = load %Rational, %Rational* %aPtr
%res2761 = call fastcc i1 @xtm_equal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res2759, %Rational %val2760)
ret i1 %res2761
}
@gsxtmrational181 = hidden constant [92 x i8] c"xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2781 = load i8*, i8** %_impzPtr
%zone2782 = bitcast i8* %tzone2781 to %mzone*

; let assign value to symbol xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ
%dat_xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone2782, i64 8)
%xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***
%tzone2762 = load i8*, i8** %_impzPtr
%zone2763 = bitcast i8* %tzone2762 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2763)
; malloc closure structure
%clsptr2764 = call i8* @llvm_zone_malloc(%mzone* %zone2763, i64 24)
%closure2765 = bitcast i8* %clsptr2764 to { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*

; malloc environment structure
%envptr2766 = call i8* @llvm_zone_malloc(%mzone* %zone2763, i64 8)
%environment2767 = bitcast i8* %envptr2766 to {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}*

; malloc closure address table
%addytable2768 = call %clsvar* @new_address_table()
%var2769 = bitcast [39 x i8]* @gsxtmrational179 to i8*
%var2770 = bitcast [44 x i8]* @gsxtmrational180 to i8*
%addytable2771 = call %clsvar* @add_address_table(%mzone* %zone2763, i8* %var2769, i32 0, i8* %var2770, i32 3, %clsvar* %addytable2768)
%address-table2772 = bitcast %clsvar* %addytable2771 to i8*

; insert table, function and environment into closure struct
%closure.table2775 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure2765, i32 0, i32 0
store i8* %address-table2772, i8** %closure.table2775
%closure.env2776 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure2765, i32 0, i32 1
store i8* %envptr2766, i8** %closure.env2776
%closure.func2777 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure2765, i32 0, i32 2
store i1 (i8*, i8*, i1, %Rational)* @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ__2755, i1 (i8*, i8*, i1, %Rational)** %closure.func2777
%closure_size2778 = call i64 @llvm_zone_mark_size(%mzone* %zone2763)
call void @llvm_zone_ptr_set_size(i8* %clsptr2764, i64 %closure_size2778)
%wrapper_ptr2779 = call i8* @llvm_zone_malloc(%mzone* %zone2763, i64 8)
%closure_wrapper2780 = bitcast i8* %wrapper_ptr2779 to { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure2765, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_wrapper2780

; let value assignment
%xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_wrapper2780, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_wrapper2780
store { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*** %xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ
%tmp_envptr2774 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}* %environment2767, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*** %xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**** %tmp_envptr2774


%val2783 = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*** %xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %val2783
}


@xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %Rational)*,  i1 (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_native(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %Rational)*,  i1 (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1, %Rational}*
%arg_p_0 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
%arg_p_1 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_equal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %Rational)*,  i1 (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational182 = hidden constant [50 x i8] c"xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ\00"
define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ__2785(i8* %_impz,i8* %_impenv, %Rational %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2786 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}*
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%tzone2789 = load i8*, i8** %_impzPtr
%zone2790 = bitcast i8* %tzone2789 to %mzone*

; let assign value to symbol reduced_a
%reduced_aPtr = alloca %Rational
%tzone2793 = load i8*, i8** %_impzPtr
%zone2794 = bitcast i8* %tzone2793 to %mzone*

; let assign value to symbol reduced_b
%reduced_bPtr = alloca %Rational
%val2787 = load %Rational, %Rational* %aPtr
%res2788 = call fastcc %Rational @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val2787)

; let value assignment
%reduced_a = select i1 true, %Rational %res2788, %Rational %res2788
store %Rational %reduced_a, %Rational* %reduced_aPtr

%val2791 = load %Rational, %Rational* %bPtr
%res2792 = call fastcc %Rational @Rational_reduce_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val2791)

; let value assignment
%reduced_b = select i1 true, %Rational %res2792, %Rational %res2792
store %Rational %reduced_b, %Rational* %reduced_bPtr

%val2796 = load %Rational, %Rational* %reduced_aPtr
; tuple ref
%val2797 = extractvalue %Rational %val2796, 0
%val2798 = load %Rational, %Rational* %reduced_bPtr
; tuple ref
%val2799 = extractvalue %Rational %val2798, 0
%cmp2800 = icmp ne i64 %val2797, %val2799
br i1 %cmp2800, label %then2795, label %else2795

then2795:
%val2801 = load %Rational, %Rational* %reduced_aPtr
; tuple ref
%val2802 = extractvalue %Rational %val2801, 0
%val2803 = load %Rational, %Rational* %reduced_bPtr
; tuple ref
%val2804 = extractvalue %Rational %val2803, 0
%cmp2805 = icmp ne i64 %val2802, %val2804
ret i1 %cmp2805

else2795:
%val2807 = load %Rational, %Rational* %reduced_aPtr
; tuple ref
%val2808 = extractvalue %Rational %val2807, 1
%val2809 = load %Rational, %Rational* %reduced_bPtr
; tuple ref
%val2810 = extractvalue %Rational %val2809, 1
%cmp2811 = icmp ne i64 %val2808, %val2810
br i1 %cmp2811, label %then2806, label %else2806

then2806:
%val2812 = load %Rational, %Rational* %reduced_aPtr
; tuple ref
%val2813 = extractvalue %Rational %val2812, 1
%val2814 = load %Rational, %Rational* %reduced_bPtr
; tuple ref
%val2815 = extractvalue %Rational %val2814, 1
%cmp2816 = icmp ne i64 %val2813, %val2815
ret i1 %cmp2816

else2806:
%res2817 = call ccc i1 @impc_false()
ret i1 %res2817
}
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2837 = load i8*, i8** %_impzPtr
%zone2838 = bitcast i8* %tzone2837 to %mzone*

; let assign value to symbol xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ
%dat_xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone2838, i64 8)
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***
%tzone2818 = load i8*, i8** %_impzPtr
%zone2819 = bitcast i8* %tzone2818 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2819)
; malloc closure structure
%clsptr2820 = call i8* @llvm_zone_malloc(%mzone* %zone2819, i64 24)
%closure2821 = bitcast i8* %clsptr2820 to { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*

; malloc environment structure
%envptr2822 = call i8* @llvm_zone_malloc(%mzone* %zone2819, i64 8)
%environment2823 = bitcast i8* %envptr2822 to {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}*

; malloc closure address table
%addytable2824 = call %clsvar* @new_address_table()
%var2825 = bitcast [50 x i8]* @gsxtmrational182 to i8*
%var2826 = bitcast [51 x i8]* @gsxtmrational157 to i8*
%addytable2827 = call %clsvar* @add_address_table(%mzone* %zone2819, i8* %var2825, i32 0, i8* %var2826, i32 3, %clsvar* %addytable2824)
%address-table2828 = bitcast %clsvar* %addytable2827 to i8*

; insert table, function and environment into closure struct
%closure.table2831 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure2821, i32 0, i32 0
store i8* %address-table2828, i8** %closure.table2831
%closure.env2832 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure2821, i32 0, i32 1
store i8* %envptr2822, i8** %closure.env2832
%closure.func2833 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure2821, i32 0, i32 2
store i1 (i8*, i8*, %Rational, %Rational)* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ__2785, i1 (i8*, i8*, %Rational, %Rational)** %closure.func2833
%closure_size2834 = call i64 @llvm_zone_mark_size(%mzone* %zone2819)
call void @llvm_zone_ptr_set_size(i8* %clsptr2820, i64 %closure_size2834)
%wrapper_ptr2835 = call i8* @llvm_zone_malloc(%mzone* %zone2819, i64 8)
%closure_wrapper2836 = bitcast i8* %wrapper_ptr2835 to { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure2821, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper2836

; let value assignment
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper2836, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper2836
store { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ
%tmp_envptr2830 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}* %environment2823, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**** %tmp_envptr2830


%val2839 = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %val2839
}


@xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, %Rational)*,  i1 (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_native(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, %Rational)*,  i1 (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, %Rational}*
%arg_p_0 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, %Rational)*,  i1 (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational183 = hidden constant [43 x i8] c"xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0\00"
define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0__2840(i8* %_impz,i8* %_impenv, %Rational %a, i64 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2841 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}*
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}* %impenv, i32 0, i32 0
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i64
store i64 %b, i64* %bPtr


%val2842 = load %Rational, %Rational* %aPtr
%val2843 = load i64, i64* %bPtr
%res2844 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2843, i64 1)
%res2845 = call fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val2842, %Rational %res2844)
ret i1 %res2845
}
@gsxtmrational184 = hidden constant [96 x i8] c"xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2865 = load i8*, i8** %_impzPtr
%zone2866 = bitcast i8* %tzone2865 to %mzone*

; let assign value to symbol xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0
%dat_xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone2866, i64 8)
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr = bitcast i8* %dat_xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 to { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***
%tzone2846 = load i8*, i8** %_impzPtr
%zone2847 = bitcast i8* %tzone2846 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2847)
; malloc closure structure
%clsptr2848 = call i8* @llvm_zone_malloc(%mzone* %zone2847, i64 24)
%closure2849 = bitcast i8* %clsptr2848 to { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*

; malloc environment structure
%envptr2850 = call i8* @llvm_zone_malloc(%mzone* %zone2847, i64 8)
%environment2851 = bitcast i8* %envptr2850 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}*

; malloc closure address table
%addytable2852 = call %clsvar* @new_address_table()
%var2853 = bitcast [43 x i8]* @gsxtmrational183 to i8*
%var2854 = bitcast [45 x i8]* @gsxtmrational159 to i8*
%addytable2855 = call %clsvar* @add_address_table(%mzone* %zone2847, i8* %var2853, i32 0, i8* %var2854, i32 3, %clsvar* %addytable2852)
%address-table2856 = bitcast %clsvar* %addytable2855 to i8*

; insert table, function and environment into closure struct
%closure.table2859 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure2849, i32 0, i32 0
store i8* %address-table2856, i8** %closure.table2859
%closure.env2860 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure2849, i32 0, i32 1
store i8* %envptr2850, i8** %closure.env2860
%closure.func2861 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure2849, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i64)* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0__2840, i1 (i8*, i8*, %Rational, i64)** %closure.func2861
%closure_size2862 = call i64 @llvm_zone_mark_size(%mzone* %zone2847)
call void @llvm_zone_ptr_set_size(i8* %clsptr2848, i64 %closure_size2862)
%wrapper_ptr2863 = call i8* @llvm_zone_malloc(%mzone* %zone2847, i64 8)
%closure_wrapper2864 = bitcast i8* %wrapper_ptr2863 to { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure2849, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_wrapper2864

; let value assignment
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_wrapper2864, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_wrapper2864
store { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0
%tmp_envptr2858 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}* %environment2851, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**** %tmp_envptr2858


%val2867 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %val2867
}


@xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i64)*,  i1 (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_native(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i64)*,  i1 (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i64}*
%arg_p_0 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i64)*,  i1 (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational185 = hidden constant [43 x i8] c"xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0\00"
define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0__2869(i8* %_impz,i8* %_impenv, i64 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2870 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}*
%xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**** %xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i64
store i64 %b, i64* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2871 = load i64, i64* %bPtr
%res2872 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val2871, i64 1)
%val2873 = load %Rational, %Rational* %aPtr
%res2874 = call fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res2872, %Rational %val2873)
ret i1 %res2874
}
@gsxtmrational186 = hidden constant [96 x i8] c"xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2894 = load i8*, i8** %_impzPtr
%zone2895 = bitcast i8* %tzone2894 to %mzone*

; let assign value to symbol xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0
%dat_xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone2895, i64 8)
%xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0 to { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***
%tzone2875 = load i8*, i8** %_impzPtr
%zone2876 = bitcast i8* %tzone2875 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2876)
; malloc closure structure
%clsptr2877 = call i8* @llvm_zone_malloc(%mzone* %zone2876, i64 24)
%closure2878 = bitcast i8* %clsptr2877 to { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*

; malloc environment structure
%envptr2879 = call i8* @llvm_zone_malloc(%mzone* %zone2876, i64 8)
%environment2880 = bitcast i8* %envptr2879 to {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}*

; malloc closure address table
%addytable2881 = call %clsvar* @new_address_table()
%var2882 = bitcast [43 x i8]* @gsxtmrational185 to i8*
%var2883 = bitcast [45 x i8]* @gsxtmrational162 to i8*
%addytable2884 = call %clsvar* @add_address_table(%mzone* %zone2876, i8* %var2882, i32 0, i8* %var2883, i32 3, %clsvar* %addytable2881)
%address-table2885 = bitcast %clsvar* %addytable2884 to i8*

; insert table, function and environment into closure struct
%closure.table2888 = getelementptr { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure2878, i32 0, i32 0
store i8* %address-table2885, i8** %closure.table2888
%closure.env2889 = getelementptr { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure2878, i32 0, i32 1
store i8* %envptr2879, i8** %closure.env2889
%closure.func2890 = getelementptr { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure2878, i32 0, i32 2
store i1 (i8*, i8*, i64, %Rational)* @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0__2869, i1 (i8*, i8*, i64, %Rational)** %closure.func2890
%closure_size2891 = call i64 @llvm_zone_mark_size(%mzone* %zone2876)
call void @llvm_zone_ptr_set_size(i8* %clsptr2877, i64 %closure_size2891)
%wrapper_ptr2892 = call i8* @llvm_zone_malloc(%mzone* %zone2876, i64 8)
%closure_wrapper2893 = bitcast i8* %wrapper_ptr2892 to { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure2878, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_wrapper2893

; let value assignment
%xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_wrapper2893, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_wrapper2893
store { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*** %xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0
%tmp_envptr2887 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}* %environment2880, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*** %xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**** %tmp_envptr2887


%val2896 = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*** %xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr
ret {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %val2896
}


@xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i64, %Rational)*,  i1 (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_native(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i64, %Rational)*,  i1 (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, %Rational}*
%arg_p_0 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i64, %Rational)*,  i1 (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational187 = hidden constant [43 x i8] c"xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0\00"
define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0__2898(i8* %_impz,i8* %_impenv, %Rational %a, i32 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2899 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}*
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}* %impenv, i32 0, i32 0
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i32
store i32 %b, i32* %bPtr


%val2900 = load %Rational, %Rational* %aPtr
%val2901 = load i32, i32* %bPtr
%res2902 = call ccc i64 @i32toi64(i32 %val2901)
%res2903 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res2902, i64 1)
%res2904 = call fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val2900, %Rational %res2903)
ret i1 %res2904
}
@gsxtmrational188 = hidden constant [96 x i8] c"xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2924 = load i8*, i8** %_impzPtr
%zone2925 = bitcast i8* %tzone2924 to %mzone*

; let assign value to symbol xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0
%dat_xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2925, i64 8)
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr = bitcast i8* %dat_xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 to { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***
%tzone2905 = load i8*, i8** %_impzPtr
%zone2906 = bitcast i8* %tzone2905 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2906)
; malloc closure structure
%clsptr2907 = call i8* @llvm_zone_malloc(%mzone* %zone2906, i64 24)
%closure2908 = bitcast i8* %clsptr2907 to { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*

; malloc environment structure
%envptr2909 = call i8* @llvm_zone_malloc(%mzone* %zone2906, i64 8)
%environment2910 = bitcast i8* %envptr2909 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}*

; malloc closure address table
%addytable2911 = call %clsvar* @new_address_table()
%var2912 = bitcast [43 x i8]* @gsxtmrational187 to i8*
%var2913 = bitcast [45 x i8]* @gsxtmrational165 to i8*
%addytable2914 = call %clsvar* @add_address_table(%mzone* %zone2906, i8* %var2912, i32 0, i8* %var2913, i32 3, %clsvar* %addytable2911)
%address-table2915 = bitcast %clsvar* %addytable2914 to i8*

; insert table, function and environment into closure struct
%closure.table2918 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure2908, i32 0, i32 0
store i8* %address-table2915, i8** %closure.table2918
%closure.env2919 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure2908, i32 0, i32 1
store i8* %envptr2909, i8** %closure.env2919
%closure.func2920 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure2908, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i32)* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0__2898, i1 (i8*, i8*, %Rational, i32)** %closure.func2920
%closure_size2921 = call i64 @llvm_zone_mark_size(%mzone* %zone2906)
call void @llvm_zone_ptr_set_size(i8* %clsptr2907, i64 %closure_size2921)
%wrapper_ptr2922 = call i8* @llvm_zone_malloc(%mzone* %zone2906, i64 8)
%closure_wrapper2923 = bitcast i8* %wrapper_ptr2922 to { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure2908, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_wrapper2923

; let value assignment
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_wrapper2923, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_wrapper2923
store { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0
%tmp_envptr2917 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}* %environment2910, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**** %tmp_envptr2917


%val2926 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %val2926
}


@xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i32)*,  i1 (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_native(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i32)*,  i1 (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i32}*
%arg_p_0 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i32)*,  i1 (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational189 = hidden constant [43 x i8] c"xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0\00"
define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0__2928(i8* %_impz,i8* %_impenv, i32 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2929 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}*
%xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**** %xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i32
store i32 %b, i32* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2930 = load i32, i32* %bPtr
%res2931 = call ccc i64 @i32toi64(i32 %val2930)
%res2932 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res2931, i64 1)
%val2933 = load %Rational, %Rational* %aPtr
%res2934 = call fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res2932, %Rational %val2933)
ret i1 %res2934
}
@gsxtmrational190 = hidden constant [96 x i8] c"xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2954 = load i8*, i8** %_impzPtr
%zone2955 = bitcast i8* %tzone2954 to %mzone*

; let assign value to symbol xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0
%dat_xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone2955, i64 8)
%xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0 to { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***
%tzone2935 = load i8*, i8** %_impzPtr
%zone2936 = bitcast i8* %tzone2935 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2936)
; malloc closure structure
%clsptr2937 = call i8* @llvm_zone_malloc(%mzone* %zone2936, i64 24)
%closure2938 = bitcast i8* %clsptr2937 to { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*

; malloc environment structure
%envptr2939 = call i8* @llvm_zone_malloc(%mzone* %zone2936, i64 8)
%environment2940 = bitcast i8* %envptr2939 to {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}*

; malloc closure address table
%addytable2941 = call %clsvar* @new_address_table()
%var2942 = bitcast [43 x i8]* @gsxtmrational189 to i8*
%var2943 = bitcast [45 x i8]* @gsxtmrational168 to i8*
%addytable2944 = call %clsvar* @add_address_table(%mzone* %zone2936, i8* %var2942, i32 0, i8* %var2943, i32 3, %clsvar* %addytable2941)
%address-table2945 = bitcast %clsvar* %addytable2944 to i8*

; insert table, function and environment into closure struct
%closure.table2948 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure2938, i32 0, i32 0
store i8* %address-table2945, i8** %closure.table2948
%closure.env2949 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure2938, i32 0, i32 1
store i8* %envptr2939, i8** %closure.env2949
%closure.func2950 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure2938, i32 0, i32 2
store i1 (i8*, i8*, i32, %Rational)* @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0__2928, i1 (i8*, i8*, i32, %Rational)** %closure.func2950
%closure_size2951 = call i64 @llvm_zone_mark_size(%mzone* %zone2936)
call void @llvm_zone_ptr_set_size(i8* %clsptr2937, i64 %closure_size2951)
%wrapper_ptr2952 = call i8* @llvm_zone_malloc(%mzone* %zone2936, i64 8)
%closure_wrapper2953 = bitcast i8* %wrapper_ptr2952 to { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure2938, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_wrapper2953

; let value assignment
%xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_wrapper2953, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_wrapper2953
store { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*** %xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0
%tmp_envptr2947 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}* %environment2940, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*** %xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**** %tmp_envptr2947


%val2956 = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*** %xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr
ret {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %val2956
}


@xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, %Rational)*,  i1 (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_native(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, %Rational)*,  i1 (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Rational}*
%arg_p_0 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, %Rational)*,  i1 (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational191 = hidden constant [42 x i8] c"xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ\00"
define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ__2958(i8* %_impz,i8* %_impenv, %Rational %a, i8 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2959 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}*
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}* %impenv, i32 0, i32 0
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i8
store i8 %b, i8* %bPtr


%val2960 = load %Rational, %Rational* %aPtr
%val2961 = load i8, i8* %bPtr
%res2962 = call ccc i64 @i8toi64(i8 %val2961)
%res2963 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res2962, i64 1)
%res2964 = call fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val2960, %Rational %res2963)
ret i1 %res2964
}
@gsxtmrational192 = hidden constant [95 x i8] c"xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2984 = load i8*, i8** %_impzPtr
%zone2985 = bitcast i8* %tzone2984 to %mzone*

; let assign value to symbol xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ
%dat_xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ = call i8* @llvm_zone_malloc(%mzone* %zone2985, i64 8)
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr = bitcast i8* %dat_xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ to { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***
%tzone2965 = load i8*, i8** %_impzPtr
%zone2966 = bitcast i8* %tzone2965 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2966)
; malloc closure structure
%clsptr2967 = call i8* @llvm_zone_malloc(%mzone* %zone2966, i64 24)
%closure2968 = bitcast i8* %clsptr2967 to { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*

; malloc environment structure
%envptr2969 = call i8* @llvm_zone_malloc(%mzone* %zone2966, i64 8)
%environment2970 = bitcast i8* %envptr2969 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}*

; malloc closure address table
%addytable2971 = call %clsvar* @new_address_table()
%var2972 = bitcast [42 x i8]* @gsxtmrational191 to i8*
%var2973 = bitcast [44 x i8]* @gsxtmrational171 to i8*
%addytable2974 = call %clsvar* @add_address_table(%mzone* %zone2966, i8* %var2972, i32 0, i8* %var2973, i32 3, %clsvar* %addytable2971)
%address-table2975 = bitcast %clsvar* %addytable2974 to i8*

; insert table, function and environment into closure struct
%closure.table2978 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure2968, i32 0, i32 0
store i8* %address-table2975, i8** %closure.table2978
%closure.env2979 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure2968, i32 0, i32 1
store i8* %envptr2969, i8** %closure.env2979
%closure.func2980 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure2968, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i8)* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ__2958, i1 (i8*, i8*, %Rational, i8)** %closure.func2980
%closure_size2981 = call i64 @llvm_zone_mark_size(%mzone* %zone2966)
call void @llvm_zone_ptr_set_size(i8* %clsptr2967, i64 %closure_size2981)
%wrapper_ptr2982 = call i8* @llvm_zone_malloc(%mzone* %zone2966, i64 8)
%closure_wrapper2983 = bitcast i8* %wrapper_ptr2982 to { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure2968, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_wrapper2983

; let value assignment
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_wrapper2983, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_wrapper2983
store { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr

; add data to environment
; don't need to alloc for env var xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ
%tmp_envptr2977 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}* %environment2970, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**** %tmp_envptr2977


%val2986 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %val2986
}


@xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i8)*,  i1 (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_native(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i8)*,  i1 (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i8}*
%arg_p_0 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i8)*,  i1 (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational193 = hidden constant [42 x i8] c"xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ\00"
define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ__2988(i8* %_impz,i8* %_impenv, i8 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2989 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}*
%xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**** %xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i8
store i8 %b, i8* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val2990 = load i8, i8* %bPtr
%res2991 = call ccc i64 @i8toi64(i8 %val2990)
%res2992 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res2991, i64 1)
%val2993 = load %Rational, %Rational* %aPtr
%res2994 = call fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res2992, %Rational %val2993)
ret i1 %res2994
}
@gsxtmrational194 = hidden constant [95 x i8] c"xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3014 = load i8*, i8** %_impzPtr
%zone3015 = bitcast i8* %tzone3014 to %mzone*

; let assign value to symbol xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ
%dat_xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone3015, i64 8)
%xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***
%tzone2995 = load i8*, i8** %_impzPtr
%zone2996 = bitcast i8* %tzone2995 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2996)
; malloc closure structure
%clsptr2997 = call i8* @llvm_zone_malloc(%mzone* %zone2996, i64 24)
%closure2998 = bitcast i8* %clsptr2997 to { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*

; malloc environment structure
%envptr2999 = call i8* @llvm_zone_malloc(%mzone* %zone2996, i64 8)
%environment3000 = bitcast i8* %envptr2999 to {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}*

; malloc closure address table
%addytable3001 = call %clsvar* @new_address_table()
%var3002 = bitcast [42 x i8]* @gsxtmrational193 to i8*
%var3003 = bitcast [44 x i8]* @gsxtmrational174 to i8*
%addytable3004 = call %clsvar* @add_address_table(%mzone* %zone2996, i8* %var3002, i32 0, i8* %var3003, i32 3, %clsvar* %addytable3001)
%address-table3005 = bitcast %clsvar* %addytable3004 to i8*

; insert table, function and environment into closure struct
%closure.table3008 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure2998, i32 0, i32 0
store i8* %address-table3005, i8** %closure.table3008
%closure.env3009 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure2998, i32 0, i32 1
store i8* %envptr2999, i8** %closure.env3009
%closure.func3010 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure2998, i32 0, i32 2
store i1 (i8*, i8*, i8, %Rational)* @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ__2988, i1 (i8*, i8*, i8, %Rational)** %closure.func3010
%closure_size3011 = call i64 @llvm_zone_mark_size(%mzone* %zone2996)
call void @llvm_zone_ptr_set_size(i8* %clsptr2997, i64 %closure_size3011)
%wrapper_ptr3012 = call i8* @llvm_zone_malloc(%mzone* %zone2996, i64 8)
%closure_wrapper3013 = bitcast i8* %wrapper_ptr3012 to { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure2998, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_wrapper3013

; let value assignment
%xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_wrapper3013, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_wrapper3013
store { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*** %xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ
%tmp_envptr3007 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}* %environment3000, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*** %xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**** %tmp_envptr3007


%val3016 = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*** %xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %val3016
}


@xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8, %Rational)*,  i1 (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_native(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8, %Rational)*,  i1 (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8, %Rational}*
%arg_p_0 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
%arg_p_1 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8, %Rational)*,  i1 (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational195 = hidden constant [42 x i8] c"xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ\00"
define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ__3018(i8* %_impz,i8* %_impenv, %Rational %a, i1 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3019 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}*
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}* %impenv, i32 0, i32 0
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i1
store i1 %b, i1* %bPtr


%val3020 = load %Rational, %Rational* %aPtr
%val3021 = load i1, i1* %bPtr
%res3022 = call ccc i64 @i1toi64(i1 %val3021)
%res3023 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res3022, i64 1)
%res3024 = call fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val3020, %Rational %res3023)
ret i1 %res3024
}
@gsxtmrational196 = hidden constant [95 x i8] c"xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3044 = load i8*, i8** %_impzPtr
%zone3045 = bitcast i8* %tzone3044 to %mzone*

; let assign value to symbol xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ
%dat_xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ = call i8* @llvm_zone_malloc(%mzone* %zone3045, i64 8)
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr = bitcast i8* %dat_xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ to { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***
%tzone3025 = load i8*, i8** %_impzPtr
%zone3026 = bitcast i8* %tzone3025 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3026)
; malloc closure structure
%clsptr3027 = call i8* @llvm_zone_malloc(%mzone* %zone3026, i64 24)
%closure3028 = bitcast i8* %clsptr3027 to { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*

; malloc environment structure
%envptr3029 = call i8* @llvm_zone_malloc(%mzone* %zone3026, i64 8)
%environment3030 = bitcast i8* %envptr3029 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}*

; malloc closure address table
%addytable3031 = call %clsvar* @new_address_table()
%var3032 = bitcast [42 x i8]* @gsxtmrational195 to i8*
%var3033 = bitcast [44 x i8]* @gsxtmrational177 to i8*
%addytable3034 = call %clsvar* @add_address_table(%mzone* %zone3026, i8* %var3032, i32 0, i8* %var3033, i32 3, %clsvar* %addytable3031)
%address-table3035 = bitcast %clsvar* %addytable3034 to i8*

; insert table, function and environment into closure struct
%closure.table3038 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure3028, i32 0, i32 0
store i8* %address-table3035, i8** %closure.table3038
%closure.env3039 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure3028, i32 0, i32 1
store i8* %envptr3029, i8** %closure.env3039
%closure.func3040 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure3028, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i1)* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ__3018, i1 (i8*, i8*, %Rational, i1)** %closure.func3040
%closure_size3041 = call i64 @llvm_zone_mark_size(%mzone* %zone3026)
call void @llvm_zone_ptr_set_size(i8* %clsptr3027, i64 %closure_size3041)
%wrapper_ptr3042 = call i8* @llvm_zone_malloc(%mzone* %zone3026, i64 8)
%closure_wrapper3043 = bitcast i8* %wrapper_ptr3042 to { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure3028, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_wrapper3043

; let value assignment
%xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_wrapper3043, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_wrapper3043
store { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr

; add data to environment
; don't need to alloc for env var xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ
%tmp_envptr3037 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}* %environment3030, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**** %tmp_envptr3037


%val3046 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*** %xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %val3046
}


@xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i1)*,  i1 (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_native(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i1)*,  i1 (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i1}*
%arg_p_0 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 1
%arg_1 = load i1, i1* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i1)*,  i1 (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational197 = hidden constant [42 x i8] c"xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ\00"
define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ__3048(i8* %_impz,i8* %_impenv, i1 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3049 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}*
%xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**** %xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i1
store i1 %b, i1* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val3050 = load i1, i1* %bPtr
%res3051 = call ccc i64 @i1toi64(i1 %val3050)
%res3052 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res3051, i64 1)
%val3053 = load %Rational, %Rational* %aPtr
%res3054 = call fastcc i1 @xtm_notequal_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res3052, %Rational %val3053)
ret i1 %res3054
}
@gsxtmrational198 = hidden constant [95 x i8] c"xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3074 = load i8*, i8** %_impzPtr
%zone3075 = bitcast i8* %tzone3074 to %mzone*

; let assign value to symbol xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ
%dat_xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone3075, i64 8)
%xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***
%tzone3055 = load i8*, i8** %_impzPtr
%zone3056 = bitcast i8* %tzone3055 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3056)
; malloc closure structure
%clsptr3057 = call i8* @llvm_zone_malloc(%mzone* %zone3056, i64 24)
%closure3058 = bitcast i8* %clsptr3057 to { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*

; malloc environment structure
%envptr3059 = call i8* @llvm_zone_malloc(%mzone* %zone3056, i64 8)
%environment3060 = bitcast i8* %envptr3059 to {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}*

; malloc closure address table
%addytable3061 = call %clsvar* @new_address_table()
%var3062 = bitcast [42 x i8]* @gsxtmrational197 to i8*
%var3063 = bitcast [44 x i8]* @gsxtmrational180 to i8*
%addytable3064 = call %clsvar* @add_address_table(%mzone* %zone3056, i8* %var3062, i32 0, i8* %var3063, i32 3, %clsvar* %addytable3061)
%address-table3065 = bitcast %clsvar* %addytable3064 to i8*

; insert table, function and environment into closure struct
%closure.table3068 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure3058, i32 0, i32 0
store i8* %address-table3065, i8** %closure.table3068
%closure.env3069 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure3058, i32 0, i32 1
store i8* %envptr3059, i8** %closure.env3069
%closure.func3070 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure3058, i32 0, i32 2
store i1 (i8*, i8*, i1, %Rational)* @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ__3048, i1 (i8*, i8*, i1, %Rational)** %closure.func3070
%closure_size3071 = call i64 @llvm_zone_mark_size(%mzone* %zone3056)
call void @llvm_zone_ptr_set_size(i8* %clsptr3057, i64 %closure_size3071)
%wrapper_ptr3072 = call i8* @llvm_zone_malloc(%mzone* %zone3056, i64 8)
%closure_wrapper3073 = bitcast i8* %wrapper_ptr3072 to { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure3058, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_wrapper3073

; let value assignment
%xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_wrapper3073, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_wrapper3073
store { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*** %xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ
%tmp_envptr3067 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}* %environment3060, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*** %xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**** %tmp_envptr3067


%val3076 = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*** %xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %val3076
}


@xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %Rational)*,  i1 (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_native(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %Rational)*,  i1 (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1, %Rational}*
%arg_p_0 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
%arg_p_1 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_notequal_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %Rational)*,  i1 (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational199 = hidden constant [50 x i8] c"xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ\00"
define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ__3078(i8* %_impz,i8* %_impenv, %Rational %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3079 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}*
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%val3080 = load %Rational, %Rational* %aPtr
; tuple ref
%val3081 = extractvalue %Rational %val3080, 0
%val3082 = load %Rational, %Rational* %bPtr
; tuple ref
%val3083 = extractvalue %Rational %val3082, 1
%val3084 = mul i64 %val3081, %val3083
%val3085 = load %Rational, %Rational* %bPtr
; tuple ref
%val3086 = extractvalue %Rational %val3085, 0
%val3087 = load %Rational, %Rational* %aPtr
; tuple ref
%val3088 = extractvalue %Rational %val3087, 1
%val3089 = mul i64 %val3086, %val3088
%cmp3090 = icmp slt i64 %val3084, %val3089
ret i1 %cmp3090
}
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3110 = load i8*, i8** %_impzPtr
%zone3111 = bitcast i8* %tzone3110 to %mzone*

; let assign value to symbol xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ
%dat_xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone3111, i64 8)
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***
%tzone3091 = load i8*, i8** %_impzPtr
%zone3092 = bitcast i8* %tzone3091 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3092)
; malloc closure structure
%clsptr3093 = call i8* @llvm_zone_malloc(%mzone* %zone3092, i64 24)
%closure3094 = bitcast i8* %clsptr3093 to { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*

; malloc environment structure
%envptr3095 = call i8* @llvm_zone_malloc(%mzone* %zone3092, i64 8)
%environment3096 = bitcast i8* %envptr3095 to {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}*

; malloc closure address table
%addytable3097 = call %clsvar* @new_address_table()
%var3098 = bitcast [50 x i8]* @gsxtmrational199 to i8*
%var3099 = bitcast [51 x i8]* @gsxtmrational157 to i8*
%addytable3100 = call %clsvar* @add_address_table(%mzone* %zone3092, i8* %var3098, i32 0, i8* %var3099, i32 3, %clsvar* %addytable3097)
%address-table3101 = bitcast %clsvar* %addytable3100 to i8*

; insert table, function and environment into closure struct
%closure.table3104 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure3094, i32 0, i32 0
store i8* %address-table3101, i8** %closure.table3104
%closure.env3105 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure3094, i32 0, i32 1
store i8* %envptr3095, i8** %closure.env3105
%closure.func3106 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure3094, i32 0, i32 2
store i1 (i8*, i8*, %Rational, %Rational)* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ__3078, i1 (i8*, i8*, %Rational, %Rational)** %closure.func3106
%closure_size3107 = call i64 @llvm_zone_mark_size(%mzone* %zone3092)
call void @llvm_zone_ptr_set_size(i8* %clsptr3093, i64 %closure_size3107)
%wrapper_ptr3108 = call i8* @llvm_zone_malloc(%mzone* %zone3092, i64 8)
%closure_wrapper3109 = bitcast i8* %wrapper_ptr3108 to { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure3094, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper3109

; let value assignment
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper3109, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper3109
store { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ
%tmp_envptr3103 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}* %environment3096, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**** %tmp_envptr3103


%val3112 = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %val3112
}


@xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, %Rational)*,  i1 (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_native(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, %Rational)*,  i1 (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, %Rational}*
%arg_p_0 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, %Rational)*,  i1 (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational200 = hidden constant [43 x i8] c"xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0\00"
define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0__3113(i8* %_impz,i8* %_impenv, %Rational %a, i64 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3114 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}*
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}* %impenv, i32 0, i32 0
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i64
store i64 %b, i64* %bPtr


%val3115 = load %Rational, %Rational* %aPtr
; tuple ref
%val3116 = extractvalue %Rational %val3115, 0
%val3117 = load i64, i64* %bPtr
%val3118 = load %Rational, %Rational* %aPtr
; tuple ref
%val3119 = extractvalue %Rational %val3118, 1
%val3120 = mul i64 %val3117, %val3119
%cmp3121 = icmp slt i64 %val3116, %val3120
ret i1 %cmp3121
}
@gsxtmrational201 = hidden constant [96 x i8] c"xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3141 = load i8*, i8** %_impzPtr
%zone3142 = bitcast i8* %tzone3141 to %mzone*

; let assign value to symbol xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0
%dat_xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone3142, i64 8)
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr = bitcast i8* %dat_xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 to { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***
%tzone3122 = load i8*, i8** %_impzPtr
%zone3123 = bitcast i8* %tzone3122 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3123)
; malloc closure structure
%clsptr3124 = call i8* @llvm_zone_malloc(%mzone* %zone3123, i64 24)
%closure3125 = bitcast i8* %clsptr3124 to { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*

; malloc environment structure
%envptr3126 = call i8* @llvm_zone_malloc(%mzone* %zone3123, i64 8)
%environment3127 = bitcast i8* %envptr3126 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}*

; malloc closure address table
%addytable3128 = call %clsvar* @new_address_table()
%var3129 = bitcast [43 x i8]* @gsxtmrational200 to i8*
%var3130 = bitcast [45 x i8]* @gsxtmrational159 to i8*
%addytable3131 = call %clsvar* @add_address_table(%mzone* %zone3123, i8* %var3129, i32 0, i8* %var3130, i32 3, %clsvar* %addytable3128)
%address-table3132 = bitcast %clsvar* %addytable3131 to i8*

; insert table, function and environment into closure struct
%closure.table3135 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure3125, i32 0, i32 0
store i8* %address-table3132, i8** %closure.table3135
%closure.env3136 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure3125, i32 0, i32 1
store i8* %envptr3126, i8** %closure.env3136
%closure.func3137 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure3125, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i64)* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0__3113, i1 (i8*, i8*, %Rational, i64)** %closure.func3137
%closure_size3138 = call i64 @llvm_zone_mark_size(%mzone* %zone3123)
call void @llvm_zone_ptr_set_size(i8* %clsptr3124, i64 %closure_size3138)
%wrapper_ptr3139 = call i8* @llvm_zone_malloc(%mzone* %zone3123, i64 8)
%closure_wrapper3140 = bitcast i8* %wrapper_ptr3139 to { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure3125, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_wrapper3140

; let value assignment
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_wrapper3140, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_wrapper3140
store { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0
%tmp_envptr3134 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}* %environment3127, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**** %tmp_envptr3134


%val3143 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %val3143
}


@xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i64)*,  i1 (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_native(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i64)*,  i1 (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i64}*
%arg_p_0 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i64)*,  i1 (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational202 = hidden constant [43 x i8] c"xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0\00"
define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0__3145(i8* %_impz,i8* %_impenv, i64 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3146 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}*
%xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**** %xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i64
store i64 %b, i64* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val3147 = load %Rational, %Rational* %aPtr
; tuple ref
%val3148 = extractvalue %Rational %val3147, 0
%val3149 = load i64, i64* %bPtr
%val3150 = load %Rational, %Rational* %aPtr
; tuple ref
%val3151 = extractvalue %Rational %val3150, 1
%val3152 = mul i64 %val3149, %val3151
%cmp3153 = icmp slt i64 %val3148, %val3152
ret i1 %cmp3153
}
@gsxtmrational203 = hidden constant [96 x i8] c"xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3173 = load i8*, i8** %_impzPtr
%zone3174 = bitcast i8* %tzone3173 to %mzone*

; let assign value to symbol xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0
%dat_xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone3174, i64 8)
%xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0 to { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***
%tzone3154 = load i8*, i8** %_impzPtr
%zone3155 = bitcast i8* %tzone3154 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3155)
; malloc closure structure
%clsptr3156 = call i8* @llvm_zone_malloc(%mzone* %zone3155, i64 24)
%closure3157 = bitcast i8* %clsptr3156 to { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*

; malloc environment structure
%envptr3158 = call i8* @llvm_zone_malloc(%mzone* %zone3155, i64 8)
%environment3159 = bitcast i8* %envptr3158 to {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}*

; malloc closure address table
%addytable3160 = call %clsvar* @new_address_table()
%var3161 = bitcast [43 x i8]* @gsxtmrational202 to i8*
%var3162 = bitcast [45 x i8]* @gsxtmrational162 to i8*
%addytable3163 = call %clsvar* @add_address_table(%mzone* %zone3155, i8* %var3161, i32 0, i8* %var3162, i32 3, %clsvar* %addytable3160)
%address-table3164 = bitcast %clsvar* %addytable3163 to i8*

; insert table, function and environment into closure struct
%closure.table3167 = getelementptr { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure3157, i32 0, i32 0
store i8* %address-table3164, i8** %closure.table3167
%closure.env3168 = getelementptr { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure3157, i32 0, i32 1
store i8* %envptr3158, i8** %closure.env3168
%closure.func3169 = getelementptr { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure3157, i32 0, i32 2
store i1 (i8*, i8*, i64, %Rational)* @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0__3145, i1 (i8*, i8*, i64, %Rational)** %closure.func3169
%closure_size3170 = call i64 @llvm_zone_mark_size(%mzone* %zone3155)
call void @llvm_zone_ptr_set_size(i8* %clsptr3156, i64 %closure_size3170)
%wrapper_ptr3171 = call i8* @llvm_zone_malloc(%mzone* %zone3155, i64 8)
%closure_wrapper3172 = bitcast i8* %wrapper_ptr3171 to { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure3157, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_wrapper3172

; let value assignment
%xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_wrapper3172, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_wrapper3172
store { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0
%tmp_envptr3166 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}* %environment3159, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**** %tmp_envptr3166


%val3175 = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr
ret {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %val3175
}


@xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i64, %Rational)*,  i1 (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_native(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i64, %Rational)*,  i1 (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, %Rational}*
%arg_p_0 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i64, %Rational)*,  i1 (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational204 = hidden constant [43 x i8] c"xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0\00"
define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0__3177(i8* %_impz,i8* %_impenv, %Rational %a, i32 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3178 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}*
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}* %impenv, i32 0, i32 0
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i32
store i32 %b, i32* %bPtr


%val3179 = load %Rational, %Rational* %aPtr
; tuple ref
%val3180 = extractvalue %Rational %val3179, 0
%val3181 = load i32, i32* %bPtr
%res3182 = call ccc i64 @i32toi64(i32 %val3181)
%val3183 = load %Rational, %Rational* %aPtr
; tuple ref
%val3184 = extractvalue %Rational %val3183, 1
%val3185 = mul i64 %res3182, %val3184
%cmp3186 = icmp slt i64 %val3180, %val3185
ret i1 %cmp3186
}
@gsxtmrational205 = hidden constant [96 x i8] c"xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3206 = load i8*, i8** %_impzPtr
%zone3207 = bitcast i8* %tzone3206 to %mzone*

; let assign value to symbol xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0
%dat_xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone3207, i64 8)
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr = bitcast i8* %dat_xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 to { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***
%tzone3187 = load i8*, i8** %_impzPtr
%zone3188 = bitcast i8* %tzone3187 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3188)
; malloc closure structure
%clsptr3189 = call i8* @llvm_zone_malloc(%mzone* %zone3188, i64 24)
%closure3190 = bitcast i8* %clsptr3189 to { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*

; malloc environment structure
%envptr3191 = call i8* @llvm_zone_malloc(%mzone* %zone3188, i64 8)
%environment3192 = bitcast i8* %envptr3191 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}*

; malloc closure address table
%addytable3193 = call %clsvar* @new_address_table()
%var3194 = bitcast [43 x i8]* @gsxtmrational204 to i8*
%var3195 = bitcast [45 x i8]* @gsxtmrational165 to i8*
%addytable3196 = call %clsvar* @add_address_table(%mzone* %zone3188, i8* %var3194, i32 0, i8* %var3195, i32 3, %clsvar* %addytable3193)
%address-table3197 = bitcast %clsvar* %addytable3196 to i8*

; insert table, function and environment into closure struct
%closure.table3200 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure3190, i32 0, i32 0
store i8* %address-table3197, i8** %closure.table3200
%closure.env3201 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure3190, i32 0, i32 1
store i8* %envptr3191, i8** %closure.env3201
%closure.func3202 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure3190, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i32)* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0__3177, i1 (i8*, i8*, %Rational, i32)** %closure.func3202
%closure_size3203 = call i64 @llvm_zone_mark_size(%mzone* %zone3188)
call void @llvm_zone_ptr_set_size(i8* %clsptr3189, i64 %closure_size3203)
%wrapper_ptr3204 = call i8* @llvm_zone_malloc(%mzone* %zone3188, i64 8)
%closure_wrapper3205 = bitcast i8* %wrapper_ptr3204 to { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure3190, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_wrapper3205

; let value assignment
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_wrapper3205, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_wrapper3205
store { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0
%tmp_envptr3199 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}* %environment3192, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**** %tmp_envptr3199


%val3208 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %val3208
}


@xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i32)*,  i1 (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_native(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i32)*,  i1 (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i32}*
%arg_p_0 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i32)*,  i1 (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational206 = hidden constant [43 x i8] c"xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0\00"
define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0__3210(i8* %_impz,i8* %_impenv, i32 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3211 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}*
%xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**** %xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i32
store i32 %b, i32* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val3212 = load %Rational, %Rational* %aPtr
; tuple ref
%val3213 = extractvalue %Rational %val3212, 0
%val3214 = load i32, i32* %bPtr
%res3215 = call ccc i64 @i32toi64(i32 %val3214)
%val3216 = load %Rational, %Rational* %aPtr
; tuple ref
%val3217 = extractvalue %Rational %val3216, 1
%val3218 = mul i64 %res3215, %val3217
%cmp3219 = icmp slt i64 %val3213, %val3218
ret i1 %cmp3219
}
@gsxtmrational207 = hidden constant [96 x i8] c"xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3239 = load i8*, i8** %_impzPtr
%zone3240 = bitcast i8* %tzone3239 to %mzone*

; let assign value to symbol xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0
%dat_xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone3240, i64 8)
%xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0 to { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***
%tzone3220 = load i8*, i8** %_impzPtr
%zone3221 = bitcast i8* %tzone3220 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3221)
; malloc closure structure
%clsptr3222 = call i8* @llvm_zone_malloc(%mzone* %zone3221, i64 24)
%closure3223 = bitcast i8* %clsptr3222 to { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*

; malloc environment structure
%envptr3224 = call i8* @llvm_zone_malloc(%mzone* %zone3221, i64 8)
%environment3225 = bitcast i8* %envptr3224 to {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}*

; malloc closure address table
%addytable3226 = call %clsvar* @new_address_table()
%var3227 = bitcast [43 x i8]* @gsxtmrational206 to i8*
%var3228 = bitcast [45 x i8]* @gsxtmrational168 to i8*
%addytable3229 = call %clsvar* @add_address_table(%mzone* %zone3221, i8* %var3227, i32 0, i8* %var3228, i32 3, %clsvar* %addytable3226)
%address-table3230 = bitcast %clsvar* %addytable3229 to i8*

; insert table, function and environment into closure struct
%closure.table3233 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure3223, i32 0, i32 0
store i8* %address-table3230, i8** %closure.table3233
%closure.env3234 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure3223, i32 0, i32 1
store i8* %envptr3224, i8** %closure.env3234
%closure.func3235 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure3223, i32 0, i32 2
store i1 (i8*, i8*, i32, %Rational)* @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0__3210, i1 (i8*, i8*, i32, %Rational)** %closure.func3235
%closure_size3236 = call i64 @llvm_zone_mark_size(%mzone* %zone3221)
call void @llvm_zone_ptr_set_size(i8* %clsptr3222, i64 %closure_size3236)
%wrapper_ptr3237 = call i8* @llvm_zone_malloc(%mzone* %zone3221, i64 8)
%closure_wrapper3238 = bitcast i8* %wrapper_ptr3237 to { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure3223, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_wrapper3238

; let value assignment
%xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_wrapper3238, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_wrapper3238
store { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0
%tmp_envptr3232 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}* %environment3225, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**** %tmp_envptr3232


%val3241 = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr
ret {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %val3241
}


@xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, %Rational)*,  i1 (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_native(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, %Rational)*,  i1 (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Rational}*
%arg_p_0 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, %Rational)*,  i1 (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational208 = hidden constant [42 x i8] c"xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ\00"
define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ__3243(i8* %_impz,i8* %_impenv, %Rational %a, i8 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3244 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}*
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}* %impenv, i32 0, i32 0
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i8
store i8 %b, i8* %bPtr


%val3245 = load %Rational, %Rational* %aPtr
; tuple ref
%val3246 = extractvalue %Rational %val3245, 0
%val3247 = load i8, i8* %bPtr
%res3248 = call ccc i64 @i8toi64(i8 %val3247)
%val3249 = load %Rational, %Rational* %aPtr
; tuple ref
%val3250 = extractvalue %Rational %val3249, 1
%val3251 = mul i64 %res3248, %val3250
%cmp3252 = icmp slt i64 %val3246, %val3251
ret i1 %cmp3252
}
@gsxtmrational209 = hidden constant [95 x i8] c"xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3272 = load i8*, i8** %_impzPtr
%zone3273 = bitcast i8* %tzone3272 to %mzone*

; let assign value to symbol xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ
%dat_xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ = call i8* @llvm_zone_malloc(%mzone* %zone3273, i64 8)
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr = bitcast i8* %dat_xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ to { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***
%tzone3253 = load i8*, i8** %_impzPtr
%zone3254 = bitcast i8* %tzone3253 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3254)
; malloc closure structure
%clsptr3255 = call i8* @llvm_zone_malloc(%mzone* %zone3254, i64 24)
%closure3256 = bitcast i8* %clsptr3255 to { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*

; malloc environment structure
%envptr3257 = call i8* @llvm_zone_malloc(%mzone* %zone3254, i64 8)
%environment3258 = bitcast i8* %envptr3257 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}*

; malloc closure address table
%addytable3259 = call %clsvar* @new_address_table()
%var3260 = bitcast [42 x i8]* @gsxtmrational208 to i8*
%var3261 = bitcast [44 x i8]* @gsxtmrational171 to i8*
%addytable3262 = call %clsvar* @add_address_table(%mzone* %zone3254, i8* %var3260, i32 0, i8* %var3261, i32 3, %clsvar* %addytable3259)
%address-table3263 = bitcast %clsvar* %addytable3262 to i8*

; insert table, function and environment into closure struct
%closure.table3266 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure3256, i32 0, i32 0
store i8* %address-table3263, i8** %closure.table3266
%closure.env3267 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure3256, i32 0, i32 1
store i8* %envptr3257, i8** %closure.env3267
%closure.func3268 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure3256, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i8)* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ__3243, i1 (i8*, i8*, %Rational, i8)** %closure.func3268
%closure_size3269 = call i64 @llvm_zone_mark_size(%mzone* %zone3254)
call void @llvm_zone_ptr_set_size(i8* %clsptr3255, i64 %closure_size3269)
%wrapper_ptr3270 = call i8* @llvm_zone_malloc(%mzone* %zone3254, i64 8)
%closure_wrapper3271 = bitcast i8* %wrapper_ptr3270 to { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure3256, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_wrapper3271

; let value assignment
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_wrapper3271, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_wrapper3271
store { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr

; add data to environment
; don't need to alloc for env var xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ
%tmp_envptr3265 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}* %environment3258, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**** %tmp_envptr3265


%val3274 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %val3274
}


@xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i8)*,  i1 (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_native(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i8)*,  i1 (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i8}*
%arg_p_0 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i8)*,  i1 (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational210 = hidden constant [42 x i8] c"xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ\00"
define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ__3276(i8* %_impz,i8* %_impenv, i8 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3277 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}*
%xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**** %xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i8
store i8 %b, i8* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val3278 = load %Rational, %Rational* %aPtr
; tuple ref
%val3279 = extractvalue %Rational %val3278, 0
%val3280 = load i8, i8* %bPtr
%res3281 = call ccc i64 @i8toi64(i8 %val3280)
%val3282 = load %Rational, %Rational* %aPtr
; tuple ref
%val3283 = extractvalue %Rational %val3282, 1
%val3284 = mul i64 %res3281, %val3283
%cmp3285 = icmp slt i64 %val3279, %val3284
ret i1 %cmp3285
}
@gsxtmrational211 = hidden constant [95 x i8] c"xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3305 = load i8*, i8** %_impzPtr
%zone3306 = bitcast i8* %tzone3305 to %mzone*

; let assign value to symbol xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ
%dat_xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone3306, i64 8)
%xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***
%tzone3286 = load i8*, i8** %_impzPtr
%zone3287 = bitcast i8* %tzone3286 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3287)
; malloc closure structure
%clsptr3288 = call i8* @llvm_zone_malloc(%mzone* %zone3287, i64 24)
%closure3289 = bitcast i8* %clsptr3288 to { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*

; malloc environment structure
%envptr3290 = call i8* @llvm_zone_malloc(%mzone* %zone3287, i64 8)
%environment3291 = bitcast i8* %envptr3290 to {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}*

; malloc closure address table
%addytable3292 = call %clsvar* @new_address_table()
%var3293 = bitcast [42 x i8]* @gsxtmrational210 to i8*
%var3294 = bitcast [44 x i8]* @gsxtmrational174 to i8*
%addytable3295 = call %clsvar* @add_address_table(%mzone* %zone3287, i8* %var3293, i32 0, i8* %var3294, i32 3, %clsvar* %addytable3292)
%address-table3296 = bitcast %clsvar* %addytable3295 to i8*

; insert table, function and environment into closure struct
%closure.table3299 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure3289, i32 0, i32 0
store i8* %address-table3296, i8** %closure.table3299
%closure.env3300 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure3289, i32 0, i32 1
store i8* %envptr3290, i8** %closure.env3300
%closure.func3301 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure3289, i32 0, i32 2
store i1 (i8*, i8*, i8, %Rational)* @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ__3276, i1 (i8*, i8*, i8, %Rational)** %closure.func3301
%closure_size3302 = call i64 @llvm_zone_mark_size(%mzone* %zone3287)
call void @llvm_zone_ptr_set_size(i8* %clsptr3288, i64 %closure_size3302)
%wrapper_ptr3303 = call i8* @llvm_zone_malloc(%mzone* %zone3287, i64 8)
%closure_wrapper3304 = bitcast i8* %wrapper_ptr3303 to { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure3289, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_wrapper3304

; let value assignment
%xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_wrapper3304, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_wrapper3304
store { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ
%tmp_envptr3298 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}* %environment3291, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**** %tmp_envptr3298


%val3307 = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %val3307
}


@xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8, %Rational)*,  i1 (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_native(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8, %Rational)*,  i1 (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8, %Rational}*
%arg_p_0 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
%arg_p_1 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8, %Rational)*,  i1 (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational212 = hidden constant [42 x i8] c"xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ\00"
define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ__3309(i8* %_impz,i8* %_impenv, %Rational %a, i1 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3310 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}*
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}* %impenv, i32 0, i32 0
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i1
store i1 %b, i1* %bPtr


%val3311 = load %Rational, %Rational* %aPtr
; tuple ref
%val3312 = extractvalue %Rational %val3311, 0
%val3313 = load i1, i1* %bPtr
%res3314 = call ccc i64 @i1toi64(i1 %val3313)
%val3315 = load %Rational, %Rational* %aPtr
; tuple ref
%val3316 = extractvalue %Rational %val3315, 1
%val3317 = mul i64 %res3314, %val3316
%cmp3318 = icmp slt i64 %val3312, %val3317
ret i1 %cmp3318
}
@gsxtmrational213 = hidden constant [95 x i8] c"xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3338 = load i8*, i8** %_impzPtr
%zone3339 = bitcast i8* %tzone3338 to %mzone*

; let assign value to symbol xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ
%dat_xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ = call i8* @llvm_zone_malloc(%mzone* %zone3339, i64 8)
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr = bitcast i8* %dat_xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ to { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***
%tzone3319 = load i8*, i8** %_impzPtr
%zone3320 = bitcast i8* %tzone3319 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3320)
; malloc closure structure
%clsptr3321 = call i8* @llvm_zone_malloc(%mzone* %zone3320, i64 24)
%closure3322 = bitcast i8* %clsptr3321 to { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*

; malloc environment structure
%envptr3323 = call i8* @llvm_zone_malloc(%mzone* %zone3320, i64 8)
%environment3324 = bitcast i8* %envptr3323 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}*

; malloc closure address table
%addytable3325 = call %clsvar* @new_address_table()
%var3326 = bitcast [42 x i8]* @gsxtmrational212 to i8*
%var3327 = bitcast [44 x i8]* @gsxtmrational177 to i8*
%addytable3328 = call %clsvar* @add_address_table(%mzone* %zone3320, i8* %var3326, i32 0, i8* %var3327, i32 3, %clsvar* %addytable3325)
%address-table3329 = bitcast %clsvar* %addytable3328 to i8*

; insert table, function and environment into closure struct
%closure.table3332 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure3322, i32 0, i32 0
store i8* %address-table3329, i8** %closure.table3332
%closure.env3333 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure3322, i32 0, i32 1
store i8* %envptr3323, i8** %closure.env3333
%closure.func3334 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure3322, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i1)* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ__3309, i1 (i8*, i8*, %Rational, i1)** %closure.func3334
%closure_size3335 = call i64 @llvm_zone_mark_size(%mzone* %zone3320)
call void @llvm_zone_ptr_set_size(i8* %clsptr3321, i64 %closure_size3335)
%wrapper_ptr3336 = call i8* @llvm_zone_malloc(%mzone* %zone3320, i64 8)
%closure_wrapper3337 = bitcast i8* %wrapper_ptr3336 to { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure3322, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_wrapper3337

; let value assignment
%xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_wrapper3337, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_wrapper3337
store { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr

; add data to environment
; don't need to alloc for env var xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ
%tmp_envptr3331 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}* %environment3324, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**** %tmp_envptr3331


%val3340 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*** %xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %val3340
}


@xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i1)*,  i1 (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_native(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i1)*,  i1 (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i1}*
%arg_p_0 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 1
%arg_1 = load i1, i1* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i1)*,  i1 (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational214 = hidden constant [42 x i8] c"xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ\00"
define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ__3342(i8* %_impz,i8* %_impenv, i1 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3343 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}*
%xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**** %xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i1
store i1 %b, i1* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val3344 = load %Rational, %Rational* %aPtr
; tuple ref
%val3345 = extractvalue %Rational %val3344, 0
%val3346 = load i1, i1* %bPtr
%res3347 = call ccc i64 @i1toi64(i1 %val3346)
%val3348 = load %Rational, %Rational* %aPtr
; tuple ref
%val3349 = extractvalue %Rational %val3348, 1
%val3350 = mul i64 %res3347, %val3349
%cmp3351 = icmp slt i64 %val3345, %val3350
ret i1 %cmp3351
}
@gsxtmrational215 = hidden constant [95 x i8] c"xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3371 = load i8*, i8** %_impzPtr
%zone3372 = bitcast i8* %tzone3371 to %mzone*

; let assign value to symbol xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ
%dat_xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone3372, i64 8)
%xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***
%tzone3352 = load i8*, i8** %_impzPtr
%zone3353 = bitcast i8* %tzone3352 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3353)
; malloc closure structure
%clsptr3354 = call i8* @llvm_zone_malloc(%mzone* %zone3353, i64 24)
%closure3355 = bitcast i8* %clsptr3354 to { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*

; malloc environment structure
%envptr3356 = call i8* @llvm_zone_malloc(%mzone* %zone3353, i64 8)
%environment3357 = bitcast i8* %envptr3356 to {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}*

; malloc closure address table
%addytable3358 = call %clsvar* @new_address_table()
%var3359 = bitcast [42 x i8]* @gsxtmrational214 to i8*
%var3360 = bitcast [44 x i8]* @gsxtmrational180 to i8*
%addytable3361 = call %clsvar* @add_address_table(%mzone* %zone3353, i8* %var3359, i32 0, i8* %var3360, i32 3, %clsvar* %addytable3358)
%address-table3362 = bitcast %clsvar* %addytable3361 to i8*

; insert table, function and environment into closure struct
%closure.table3365 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure3355, i32 0, i32 0
store i8* %address-table3362, i8** %closure.table3365
%closure.env3366 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure3355, i32 0, i32 1
store i8* %envptr3356, i8** %closure.env3366
%closure.func3367 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure3355, i32 0, i32 2
store i1 (i8*, i8*, i1, %Rational)* @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ__3342, i1 (i8*, i8*, i1, %Rational)** %closure.func3367
%closure_size3368 = call i64 @llvm_zone_mark_size(%mzone* %zone3353)
call void @llvm_zone_ptr_set_size(i8* %clsptr3354, i64 %closure_size3368)
%wrapper_ptr3369 = call i8* @llvm_zone_malloc(%mzone* %zone3353, i64 8)
%closure_wrapper3370 = bitcast i8* %wrapper_ptr3369 to { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure3355, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_wrapper3370

; let value assignment
%xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_wrapper3370, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_wrapper3370
store { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ
%tmp_envptr3364 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}* %environment3357, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**** %tmp_envptr3364


%val3373 = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*** %xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %val3373
}


@xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %Rational)*,  i1 (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_native(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %Rational)*,  i1 (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1, %Rational}*
%arg_p_0 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
%arg_p_1 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_lessthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %Rational)*,  i1 (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational216 = hidden constant [53 x i8] c"xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ\00"
define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ__3375(i8* %_impz,i8* %_impenv, %Rational %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3376 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}*
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%val3377 = load %Rational, %Rational* %aPtr
; tuple ref
%val3378 = extractvalue %Rational %val3377, 0
%val3379 = load %Rational, %Rational* %bPtr
; tuple ref
%val3380 = extractvalue %Rational %val3379, 1
%val3381 = mul i64 %val3378, %val3380
%val3382 = load %Rational, %Rational* %bPtr
; tuple ref
%val3383 = extractvalue %Rational %val3382, 0
%val3384 = load %Rational, %Rational* %aPtr
; tuple ref
%val3385 = extractvalue %Rational %val3384, 1
%val3386 = mul i64 %val3383, %val3385
%cmp3387 = icmp sgt i64 %val3381, %val3386
ret i1 %cmp3387
}
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3407 = load i8*, i8** %_impzPtr
%zone3408 = bitcast i8* %tzone3407 to %mzone*

; let assign value to symbol xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ
%dat_xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone3408, i64 8)
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***
%tzone3388 = load i8*, i8** %_impzPtr
%zone3389 = bitcast i8* %tzone3388 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3389)
; malloc closure structure
%clsptr3390 = call i8* @llvm_zone_malloc(%mzone* %zone3389, i64 24)
%closure3391 = bitcast i8* %clsptr3390 to { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*

; malloc environment structure
%envptr3392 = call i8* @llvm_zone_malloc(%mzone* %zone3389, i64 8)
%environment3393 = bitcast i8* %envptr3392 to {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}*

; malloc closure address table
%addytable3394 = call %clsvar* @new_address_table()
%var3395 = bitcast [53 x i8]* @gsxtmrational216 to i8*
%var3396 = bitcast [51 x i8]* @gsxtmrational157 to i8*
%addytable3397 = call %clsvar* @add_address_table(%mzone* %zone3389, i8* %var3395, i32 0, i8* %var3396, i32 3, %clsvar* %addytable3394)
%address-table3398 = bitcast %clsvar* %addytable3397 to i8*

; insert table, function and environment into closure struct
%closure.table3401 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure3391, i32 0, i32 0
store i8* %address-table3398, i8** %closure.table3401
%closure.env3402 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure3391, i32 0, i32 1
store i8* %envptr3392, i8** %closure.env3402
%closure.func3403 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure3391, i32 0, i32 2
store i1 (i8*, i8*, %Rational, %Rational)* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ__3375, i1 (i8*, i8*, %Rational, %Rational)** %closure.func3403
%closure_size3404 = call i64 @llvm_zone_mark_size(%mzone* %zone3389)
call void @llvm_zone_ptr_set_size(i8* %clsptr3390, i64 %closure_size3404)
%wrapper_ptr3405 = call i8* @llvm_zone_malloc(%mzone* %zone3389, i64 8)
%closure_wrapper3406 = bitcast i8* %wrapper_ptr3405 to { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure3391, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper3406

; let value assignment
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper3406, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper3406
store { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ
%tmp_envptr3400 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}***}* %environment3393, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**** %tmp_envptr3400


%val3409 = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %val3409
}


@xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, %Rational)*,  i1 (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_native(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, %Rational)*,  i1 (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, %Rational}*
%arg_p_0 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, %Rational)*,  i1 (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational217 = hidden constant [46 x i8] c"xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0\00"
define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0__3410(i8* %_impz,i8* %_impenv, %Rational %a, i64 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3411 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}*
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}* %impenv, i32 0, i32 0
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i64
store i64 %b, i64* %bPtr


%val3412 = load %Rational, %Rational* %aPtr
; tuple ref
%val3413 = extractvalue %Rational %val3412, 0
%val3414 = load i64, i64* %bPtr
%val3415 = load %Rational, %Rational* %aPtr
; tuple ref
%val3416 = extractvalue %Rational %val3415, 1
%val3417 = mul i64 %val3414, %val3416
%cmp3418 = icmp sgt i64 %val3413, %val3417
ret i1 %cmp3418
}
@gsxtmrational218 = hidden constant [99 x i8] c"xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3438 = load i8*, i8** %_impzPtr
%zone3439 = bitcast i8* %tzone3438 to %mzone*

; let assign value to symbol xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0
%dat_xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone3439, i64 8)
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr = bitcast i8* %dat_xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 to { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***
%tzone3419 = load i8*, i8** %_impzPtr
%zone3420 = bitcast i8* %tzone3419 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3420)
; malloc closure structure
%clsptr3421 = call i8* @llvm_zone_malloc(%mzone* %zone3420, i64 24)
%closure3422 = bitcast i8* %clsptr3421 to { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*

; malloc environment structure
%envptr3423 = call i8* @llvm_zone_malloc(%mzone* %zone3420, i64 8)
%environment3424 = bitcast i8* %envptr3423 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}*

; malloc closure address table
%addytable3425 = call %clsvar* @new_address_table()
%var3426 = bitcast [46 x i8]* @gsxtmrational217 to i8*
%var3427 = bitcast [45 x i8]* @gsxtmrational159 to i8*
%addytable3428 = call %clsvar* @add_address_table(%mzone* %zone3420, i8* %var3426, i32 0, i8* %var3427, i32 3, %clsvar* %addytable3425)
%address-table3429 = bitcast %clsvar* %addytable3428 to i8*

; insert table, function and environment into closure struct
%closure.table3432 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure3422, i32 0, i32 0
store i8* %address-table3429, i8** %closure.table3432
%closure.env3433 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure3422, i32 0, i32 1
store i8* %envptr3423, i8** %closure.env3433
%closure.func3434 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure3422, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i64)* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0__3410, i1 (i8*, i8*, %Rational, i64)** %closure.func3434
%closure_size3435 = call i64 @llvm_zone_mark_size(%mzone* %zone3420)
call void @llvm_zone_ptr_set_size(i8* %clsptr3421, i64 %closure_size3435)
%wrapper_ptr3436 = call i8* @llvm_zone_malloc(%mzone* %zone3420, i64 8)
%closure_wrapper3437 = bitcast i8* %wrapper_ptr3436 to { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure3422, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_wrapper3437

; let value assignment
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_wrapper3437, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_wrapper3437
store { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0, { i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0
%tmp_envptr3431 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}***}* %environment3424, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**** %tmp_envptr3431


%val3440 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0Ptr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %val3440
}


@xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i64)*,  i1 (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_native(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i64)*,  i1 (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i64}*
%arg_p_0 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i64)*,  i1 (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational219 = hidden constant [46 x i8] c"xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0\00"
define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0__3442(i8* %_impz,i8* %_impenv, i64 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3443 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}*
%xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**** %xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i64
store i64 %b, i64* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val3444 = load %Rational, %Rational* %aPtr
; tuple ref
%val3445 = extractvalue %Rational %val3444, 0
%val3446 = load i64, i64* %bPtr
%val3447 = load %Rational, %Rational* %aPtr
; tuple ref
%val3448 = extractvalue %Rational %val3447, 1
%val3449 = mul i64 %val3446, %val3448
%cmp3450 = icmp sgt i64 %val3445, %val3449
ret i1 %cmp3450
}
@gsxtmrational220 = hidden constant [99 x i8] c"xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3470 = load i8*, i8** %_impzPtr
%zone3471 = bitcast i8* %tzone3470 to %mzone*

; let assign value to symbol xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0
%dat_xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone3471, i64 8)
%xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0 to { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***
%tzone3451 = load i8*, i8** %_impzPtr
%zone3452 = bitcast i8* %tzone3451 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3452)
; malloc closure structure
%clsptr3453 = call i8* @llvm_zone_malloc(%mzone* %zone3452, i64 24)
%closure3454 = bitcast i8* %clsptr3453 to { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*

; malloc environment structure
%envptr3455 = call i8* @llvm_zone_malloc(%mzone* %zone3452, i64 8)
%environment3456 = bitcast i8* %envptr3455 to {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}*

; malloc closure address table
%addytable3457 = call %clsvar* @new_address_table()
%var3458 = bitcast [46 x i8]* @gsxtmrational219 to i8*
%var3459 = bitcast [45 x i8]* @gsxtmrational162 to i8*
%addytable3460 = call %clsvar* @add_address_table(%mzone* %zone3452, i8* %var3458, i32 0, i8* %var3459, i32 3, %clsvar* %addytable3457)
%address-table3461 = bitcast %clsvar* %addytable3460 to i8*

; insert table, function and environment into closure struct
%closure.table3464 = getelementptr { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure3454, i32 0, i32 0
store i8* %address-table3461, i8** %closure.table3464
%closure.env3465 = getelementptr { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure3454, i32 0, i32 1
store i8* %envptr3455, i8** %closure.env3465
%closure.func3466 = getelementptr { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure3454, i32 0, i32 2
store i1 (i8*, i8*, i64, %Rational)* @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0__3442, i1 (i8*, i8*, i64, %Rational)** %closure.func3466
%closure_size3467 = call i64 @llvm_zone_mark_size(%mzone* %zone3452)
call void @llvm_zone_ptr_set_size(i8* %clsptr3453, i64 %closure_size3467)
%wrapper_ptr3468 = call i8* @llvm_zone_malloc(%mzone* %zone3452, i64 8)
%closure_wrapper3469 = bitcast i8* %wrapper_ptr3468 to { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure3454, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_wrapper3469

; let value assignment
%xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_wrapper3469, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_wrapper3469
store { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0, { i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0
%tmp_envptr3463 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}***}* %environment3456, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**** %tmp_envptr3463


%val3472 = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0Ptr
ret {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %val3472
}


@xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i64, %Rational)*,  i1 (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_native(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i64, %Rational)*,  i1 (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, %Rational}*
%arg_p_0 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i64, %Rational)*,  i1 (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational221 = hidden constant [46 x i8] c"xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0\00"
define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0__3474(i8* %_impz,i8* %_impenv, %Rational %a, i32 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3475 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}*
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}* %impenv, i32 0, i32 0
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i32
store i32 %b, i32* %bPtr


%val3476 = load %Rational, %Rational* %aPtr
; tuple ref
%val3477 = extractvalue %Rational %val3476, 0
%val3478 = load i32, i32* %bPtr
%res3479 = call ccc i64 @i32toi64(i32 %val3478)
%val3480 = load %Rational, %Rational* %aPtr
; tuple ref
%val3481 = extractvalue %Rational %val3480, 1
%val3482 = mul i64 %res3479, %val3481
%cmp3483 = icmp sgt i64 %val3477, %val3482
ret i1 %cmp3483
}
@gsxtmrational222 = hidden constant [99 x i8] c"xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3503 = load i8*, i8** %_impzPtr
%zone3504 = bitcast i8* %tzone3503 to %mzone*

; let assign value to symbol xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0
%dat_xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone3504, i64 8)
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr = bitcast i8* %dat_xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 to { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***
%tzone3484 = load i8*, i8** %_impzPtr
%zone3485 = bitcast i8* %tzone3484 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3485)
; malloc closure structure
%clsptr3486 = call i8* @llvm_zone_malloc(%mzone* %zone3485, i64 24)
%closure3487 = bitcast i8* %clsptr3486 to { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*

; malloc environment structure
%envptr3488 = call i8* @llvm_zone_malloc(%mzone* %zone3485, i64 8)
%environment3489 = bitcast i8* %envptr3488 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}*

; malloc closure address table
%addytable3490 = call %clsvar* @new_address_table()
%var3491 = bitcast [46 x i8]* @gsxtmrational221 to i8*
%var3492 = bitcast [45 x i8]* @gsxtmrational165 to i8*
%addytable3493 = call %clsvar* @add_address_table(%mzone* %zone3485, i8* %var3491, i32 0, i8* %var3492, i32 3, %clsvar* %addytable3490)
%address-table3494 = bitcast %clsvar* %addytable3493 to i8*

; insert table, function and environment into closure struct
%closure.table3497 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure3487, i32 0, i32 0
store i8* %address-table3494, i8** %closure.table3497
%closure.env3498 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure3487, i32 0, i32 1
store i8* %envptr3488, i8** %closure.env3498
%closure.func3499 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure3487, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i32)* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0__3474, i1 (i8*, i8*, %Rational, i32)** %closure.func3499
%closure_size3500 = call i64 @llvm_zone_mark_size(%mzone* %zone3485)
call void @llvm_zone_ptr_set_size(i8* %clsptr3486, i64 %closure_size3500)
%wrapper_ptr3501 = call i8* @llvm_zone_malloc(%mzone* %zone3485, i64 8)
%closure_wrapper3502 = bitcast i8* %wrapper_ptr3501 to { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure3487, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_wrapper3502

; let value assignment
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_wrapper3502, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_wrapper3502
store { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0, { i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0
%tmp_envptr3496 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}***}* %environment3489, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**** %tmp_envptr3496


%val3505 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %val3505
}


@xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i32)*,  i1 (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_native(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i32)*,  i1 (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i32}*
%arg_p_0 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i32)*,  i1 (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational223 = hidden constant [46 x i8] c"xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0\00"
define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0__3507(i8* %_impz,i8* %_impenv, i32 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3508 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}*
%xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**** %xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr_

; setup arguments
%bPtr = alloca i32
store i32 %b, i32* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val3509 = load %Rational, %Rational* %aPtr
; tuple ref
%val3510 = extractvalue %Rational %val3509, 0
%val3511 = load i32, i32* %bPtr
%res3512 = call ccc i64 @i32toi64(i32 %val3511)
%val3513 = load %Rational, %Rational* %aPtr
; tuple ref
%val3514 = extractvalue %Rational %val3513, 1
%val3515 = mul i64 %res3512, %val3514
%cmp3516 = icmp sgt i64 %val3510, %val3515
ret i1 %cmp3516
}
@gsxtmrational224 = hidden constant [99 x i8] c"xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3536 = load i8*, i8** %_impzPtr
%zone3537 = bitcast i8* %tzone3536 to %mzone*

; let assign value to symbol xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0
%dat_xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone3537, i64 8)
%xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0 to { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***
%tzone3517 = load i8*, i8** %_impzPtr
%zone3518 = bitcast i8* %tzone3517 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3518)
; malloc closure structure
%clsptr3519 = call i8* @llvm_zone_malloc(%mzone* %zone3518, i64 24)
%closure3520 = bitcast i8* %clsptr3519 to { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*

; malloc environment structure
%envptr3521 = call i8* @llvm_zone_malloc(%mzone* %zone3518, i64 8)
%environment3522 = bitcast i8* %envptr3521 to {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}*

; malloc closure address table
%addytable3523 = call %clsvar* @new_address_table()
%var3524 = bitcast [46 x i8]* @gsxtmrational223 to i8*
%var3525 = bitcast [45 x i8]* @gsxtmrational168 to i8*
%addytable3526 = call %clsvar* @add_address_table(%mzone* %zone3518, i8* %var3524, i32 0, i8* %var3525, i32 3, %clsvar* %addytable3523)
%address-table3527 = bitcast %clsvar* %addytable3526 to i8*

; insert table, function and environment into closure struct
%closure.table3530 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure3520, i32 0, i32 0
store i8* %address-table3527, i8** %closure.table3530
%closure.env3531 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure3520, i32 0, i32 1
store i8* %envptr3521, i8** %closure.env3531
%closure.func3532 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure3520, i32 0, i32 2
store i1 (i8*, i8*, i32, %Rational)* @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0__3507, i1 (i8*, i8*, i32, %Rational)** %closure.func3532
%closure_size3533 = call i64 @llvm_zone_mark_size(%mzone* %zone3518)
call void @llvm_zone_ptr_set_size(i8* %clsptr3519, i64 %closure_size3533)
%wrapper_ptr3534 = call i8* @llvm_zone_malloc(%mzone* %zone3518, i64 8)
%closure_wrapper3535 = bitcast i8* %wrapper_ptr3534 to { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure3520, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_wrapper3535

; let value assignment
%xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_wrapper3535, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_wrapper3535
store { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0, { i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0
%tmp_envptr3529 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}***}* %environment3522, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**** %tmp_envptr3529


%val3538 = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0Ptr
ret {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %val3538
}


@xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, %Rational)*,  i1 (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_native(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, %Rational)*,  i1 (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Rational}*
%arg_p_0 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, %Rational)*,  i1 (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational225 = hidden constant [45 x i8] c"xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ\00"
define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ__3540(i8* %_impz,i8* %_impenv, %Rational %a, i8 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3541 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}*
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}* %impenv, i32 0, i32 0
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i8
store i8 %b, i8* %bPtr


%val3542 = load %Rational, %Rational* %aPtr
; tuple ref
%val3543 = extractvalue %Rational %val3542, 0
%val3544 = load i8, i8* %bPtr
%res3545 = call ccc i64 @i8toi64(i8 %val3544)
%val3546 = load %Rational, %Rational* %aPtr
; tuple ref
%val3547 = extractvalue %Rational %val3546, 1
%val3548 = mul i64 %res3545, %val3547
%cmp3549 = icmp sgt i64 %val3543, %val3548
ret i1 %cmp3549
}
@gsxtmrational226 = hidden constant [98 x i8] c"xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3569 = load i8*, i8** %_impzPtr
%zone3570 = bitcast i8* %tzone3569 to %mzone*

; let assign value to symbol xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ
%dat_xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ = call i8* @llvm_zone_malloc(%mzone* %zone3570, i64 8)
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr = bitcast i8* %dat_xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ to { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***
%tzone3550 = load i8*, i8** %_impzPtr
%zone3551 = bitcast i8* %tzone3550 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3551)
; malloc closure structure
%clsptr3552 = call i8* @llvm_zone_malloc(%mzone* %zone3551, i64 24)
%closure3553 = bitcast i8* %clsptr3552 to { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*

; malloc environment structure
%envptr3554 = call i8* @llvm_zone_malloc(%mzone* %zone3551, i64 8)
%environment3555 = bitcast i8* %envptr3554 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}*

; malloc closure address table
%addytable3556 = call %clsvar* @new_address_table()
%var3557 = bitcast [45 x i8]* @gsxtmrational225 to i8*
%var3558 = bitcast [44 x i8]* @gsxtmrational171 to i8*
%addytable3559 = call %clsvar* @add_address_table(%mzone* %zone3551, i8* %var3557, i32 0, i8* %var3558, i32 3, %clsvar* %addytable3556)
%address-table3560 = bitcast %clsvar* %addytable3559 to i8*

; insert table, function and environment into closure struct
%closure.table3563 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure3553, i32 0, i32 0
store i8* %address-table3560, i8** %closure.table3563
%closure.env3564 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure3553, i32 0, i32 1
store i8* %envptr3554, i8** %closure.env3564
%closure.func3565 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure3553, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i8)* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ__3540, i1 (i8*, i8*, %Rational, i8)** %closure.func3565
%closure_size3566 = call i64 @llvm_zone_mark_size(%mzone* %zone3551)
call void @llvm_zone_ptr_set_size(i8* %clsptr3552, i64 %closure_size3566)
%wrapper_ptr3567 = call i8* @llvm_zone_malloc(%mzone* %zone3551, i64 8)
%closure_wrapper3568 = bitcast i8* %wrapper_ptr3567 to { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure3553, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_wrapper3568

; let value assignment
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_wrapper3568, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_wrapper3568
store { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ, { i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr

; add data to environment
; don't need to alloc for env var xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ
%tmp_envptr3562 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}***}* %environment3555, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**** %tmp_envptr3562


%val3571 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %val3571
}


@xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i8)*,  i1 (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_native(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i8)*,  i1 (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i8}*
%arg_p_0 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i8)*,  i1 (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational227 = hidden constant [45 x i8] c"xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ\00"
define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ__3573(i8* %_impz,i8* %_impenv, i8 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3574 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}*
%xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**** %xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i8
store i8 %b, i8* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val3575 = load %Rational, %Rational* %aPtr
; tuple ref
%val3576 = extractvalue %Rational %val3575, 0
%val3577 = load i8, i8* %bPtr
%res3578 = call ccc i64 @i8toi64(i8 %val3577)
%val3579 = load %Rational, %Rational* %aPtr
; tuple ref
%val3580 = extractvalue %Rational %val3579, 1
%val3581 = mul i64 %res3578, %val3580
%cmp3582 = icmp sgt i64 %val3576, %val3581
ret i1 %cmp3582
}
@gsxtmrational228 = hidden constant [98 x i8] c"xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3602 = load i8*, i8** %_impzPtr
%zone3603 = bitcast i8* %tzone3602 to %mzone*

; let assign value to symbol xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ
%dat_xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone3603, i64 8)
%xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***
%tzone3583 = load i8*, i8** %_impzPtr
%zone3584 = bitcast i8* %tzone3583 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3584)
; malloc closure structure
%clsptr3585 = call i8* @llvm_zone_malloc(%mzone* %zone3584, i64 24)
%closure3586 = bitcast i8* %clsptr3585 to { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*

; malloc environment structure
%envptr3587 = call i8* @llvm_zone_malloc(%mzone* %zone3584, i64 8)
%environment3588 = bitcast i8* %envptr3587 to {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}*

; malloc closure address table
%addytable3589 = call %clsvar* @new_address_table()
%var3590 = bitcast [45 x i8]* @gsxtmrational227 to i8*
%var3591 = bitcast [44 x i8]* @gsxtmrational174 to i8*
%addytable3592 = call %clsvar* @add_address_table(%mzone* %zone3584, i8* %var3590, i32 0, i8* %var3591, i32 3, %clsvar* %addytable3589)
%address-table3593 = bitcast %clsvar* %addytable3592 to i8*

; insert table, function and environment into closure struct
%closure.table3596 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure3586, i32 0, i32 0
store i8* %address-table3593, i8** %closure.table3596
%closure.env3597 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure3586, i32 0, i32 1
store i8* %envptr3587, i8** %closure.env3597
%closure.func3598 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure3586, i32 0, i32 2
store i1 (i8*, i8*, i8, %Rational)* @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ__3573, i1 (i8*, i8*, i8, %Rational)** %closure.func3598
%closure_size3599 = call i64 @llvm_zone_mark_size(%mzone* %zone3584)
call void @llvm_zone_ptr_set_size(i8* %clsptr3585, i64 %closure_size3599)
%wrapper_ptr3600 = call i8* @llvm_zone_malloc(%mzone* %zone3584, i64 8)
%closure_wrapper3601 = bitcast i8* %wrapper_ptr3600 to { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure3586, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_wrapper3601

; let value assignment
%xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_wrapper3601, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_wrapper3601
store { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ
%tmp_envptr3595 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}***}* %environment3588, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**** %tmp_envptr3595


%val3604 = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %val3604
}


@xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8, %Rational)*,  i1 (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_native(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8, %Rational)*,  i1 (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8, %Rational}*
%arg_p_0 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
%arg_p_1 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8, %Rational)*,  i1 (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational229 = hidden constant [45 x i8] c"xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ\00"
define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ__3606(i8* %_impz,i8* %_impenv, %Rational %a, i1 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3607 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}*
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}* %impenv, i32 0, i32 0
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i1
store i1 %b, i1* %bPtr


%val3608 = load %Rational, %Rational* %aPtr
; tuple ref
%val3609 = extractvalue %Rational %val3608, 0
%val3610 = load i1, i1* %bPtr
%res3611 = call ccc i64 @i1toi64(i1 %val3610)
%val3612 = load %Rational, %Rational* %aPtr
; tuple ref
%val3613 = extractvalue %Rational %val3612, 1
%val3614 = mul i64 %res3611, %val3613
%cmp3615 = icmp sgt i64 %val3609, %val3614
ret i1 %cmp3615
}
@gsxtmrational230 = hidden constant [98 x i8] c"xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3635 = load i8*, i8** %_impzPtr
%zone3636 = bitcast i8* %tzone3635 to %mzone*

; let assign value to symbol xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ
%dat_xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ = call i8* @llvm_zone_malloc(%mzone* %zone3636, i64 8)
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr = bitcast i8* %dat_xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ to { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***
%tzone3616 = load i8*, i8** %_impzPtr
%zone3617 = bitcast i8* %tzone3616 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3617)
; malloc closure structure
%clsptr3618 = call i8* @llvm_zone_malloc(%mzone* %zone3617, i64 24)
%closure3619 = bitcast i8* %clsptr3618 to { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*

; malloc environment structure
%envptr3620 = call i8* @llvm_zone_malloc(%mzone* %zone3617, i64 8)
%environment3621 = bitcast i8* %envptr3620 to {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}*

; malloc closure address table
%addytable3622 = call %clsvar* @new_address_table()
%var3623 = bitcast [45 x i8]* @gsxtmrational229 to i8*
%var3624 = bitcast [44 x i8]* @gsxtmrational177 to i8*
%addytable3625 = call %clsvar* @add_address_table(%mzone* %zone3617, i8* %var3623, i32 0, i8* %var3624, i32 3, %clsvar* %addytable3622)
%address-table3626 = bitcast %clsvar* %addytable3625 to i8*

; insert table, function and environment into closure struct
%closure.table3629 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure3619, i32 0, i32 0
store i8* %address-table3626, i8** %closure.table3629
%closure.env3630 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure3619, i32 0, i32 1
store i8* %envptr3620, i8** %closure.env3630
%closure.func3631 = getelementptr { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure3619, i32 0, i32 2
store i1 (i8*, i8*, %Rational, i1)* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ__3606, i1 (i8*, i8*, %Rational, i1)** %closure.func3631
%closure_size3632 = call i64 @llvm_zone_mark_size(%mzone* %zone3617)
call void @llvm_zone_ptr_set_size(i8* %clsptr3618, i64 %closure_size3632)
%wrapper_ptr3633 = call i8* @llvm_zone_malloc(%mzone* %zone3617, i64 8)
%closure_wrapper3634 = bitcast i8* %wrapper_ptr3633 to { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
store { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure3619, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_wrapper3634

; let value assignment
%xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_wrapper3634, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_wrapper3634
store { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ, { i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr

; add data to environment
; don't need to alloc for env var xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ
%tmp_envptr3628 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}, {{i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}***}* %environment3621, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**** %tmp_envptr3628


%val3637 = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*** %xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQPtr
ret {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %val3637
}


@xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i1)*,  i1 (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_native(%Rational %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i1)*,  i1 (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i1}*
%arg_p_0 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i1}, {%Rational, i1}* %fstruct, i32 0, i32 1
%arg_1 = load i1, i1* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLFJhdGlvbmFsLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}*, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}, {i8*, i8*, i1 (i8*, i8*, %Rational, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %Rational, i1)*,  i1 (i8*, i8*, %Rational, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i1 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational231 = hidden constant [45 x i8] c"xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ\00"
define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ__3639(i8* %_impz,i8* %_impenv, i1 %b, %Rational %a) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3640 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}*
%xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**** %xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr_

; setup arguments
%bPtr = alloca i1
store i1 %b, i1* %bPtr
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr


%val3641 = load %Rational, %Rational* %aPtr
; tuple ref
%val3642 = extractvalue %Rational %val3641, 0
%val3643 = load i1, i1* %bPtr
%res3644 = call ccc i64 @i1toi64(i1 %val3643)
%val3645 = load %Rational, %Rational* %aPtr
; tuple ref
%val3646 = extractvalue %Rational %val3645, 1
%val3647 = mul i64 %res3644, %val3646
%cmp3648 = icmp sgt i64 %val3642, %val3647
ret i1 %cmp3648
}
@gsxtmrational232 = hidden constant [98 x i8] c"xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3668 = load i8*, i8** %_impzPtr
%zone3669 = bitcast i8* %tzone3668 to %mzone*

; let assign value to symbol xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ
%dat_xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone3669, i64 8)
%xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ to { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***
%tzone3649 = load i8*, i8** %_impzPtr
%zone3650 = bitcast i8* %tzone3649 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3650)
; malloc closure structure
%clsptr3651 = call i8* @llvm_zone_malloc(%mzone* %zone3650, i64 24)
%closure3652 = bitcast i8* %clsptr3651 to { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*

; malloc environment structure
%envptr3653 = call i8* @llvm_zone_malloc(%mzone* %zone3650, i64 8)
%environment3654 = bitcast i8* %envptr3653 to {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}*

; malloc closure address table
%addytable3655 = call %clsvar* @new_address_table()
%var3656 = bitcast [45 x i8]* @gsxtmrational231 to i8*
%var3657 = bitcast [44 x i8]* @gsxtmrational180 to i8*
%addytable3658 = call %clsvar* @add_address_table(%mzone* %zone3650, i8* %var3656, i32 0, i8* %var3657, i32 3, %clsvar* %addytable3655)
%address-table3659 = bitcast %clsvar* %addytable3658 to i8*

; insert table, function and environment into closure struct
%closure.table3662 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure3652, i32 0, i32 0
store i8* %address-table3659, i8** %closure.table3662
%closure.env3663 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure3652, i32 0, i32 1
store i8* %envptr3653, i8** %closure.env3663
%closure.func3664 = getelementptr { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure3652, i32 0, i32 2
store i1 (i8*, i8*, i1, %Rational)* @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ__3639, i1 (i8*, i8*, i1, %Rational)** %closure.func3664
%closure_size3665 = call i64 @llvm_zone_mark_size(%mzone* %zone3650)
call void @llvm_zone_ptr_set_size(i8* %clsptr3651, i64 %closure_size3665)
%wrapper_ptr3666 = call i8* @llvm_zone_malloc(%mzone* %zone3650, i64 8)
%closure_wrapper3667 = bitcast i8* %wrapper_ptr3666 to { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
store { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure3652, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_wrapper3667

; let value assignment
%xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_wrapper3667, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_wrapper3667
store { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ, { i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ
%tmp_envptr3661 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}, {{i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}***}* %environment3654, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**** %tmp_envptr3661


%val3670 = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*** %xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQPtr
ret {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %val3670
}


@xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %Rational)*,  i1 (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc i1 @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_native(i1 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %Rational)*,  i1 (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
ret i1 %result
}


define dllexport ccc void @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i1, %Rational}*
%arg_p_0 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i1, i1* %arg_p_0
%arg_p_1 = getelementptr {i1, %Rational}, {i1, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_greaterthan_adhoc_W2kxLGkxLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}*, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}, {i8*, i8*, i1 (i8*, i8*, i1, %Rational)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i1, %Rational)*,  i1 (i8*, i8*, i1, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i1 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational233 = hidden constant [56 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ\00"
define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ__3672(i8* %_impz,i8* %_impenv, %Rational %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3673 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}*
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%tzone3677 = load i8*, i8** %_impzPtr
%zone3678 = bitcast i8* %tzone3677 to %mzone*

; let assign value to symbol c
%cPtr = alloca %Rational
%tzone3687 = load i8*, i8** %_impzPtr
%zone3688 = bitcast i8* %tzone3687 to %mzone*

; let assign value to symbol n
%nPtr = alloca %Rational
%val3674 = load %Rational, %Rational* %aPtr
%val3675 = load %Rational, %Rational* %bPtr
%res3676 = call fastcc %Rational @xtm_division_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val3674, %Rational %val3675)

; let value assignment
%c = select i1 true, %Rational %res3676, %Rational %res3676
store %Rational %c, %Rational* %cPtr

%val3679 = load %Rational, %Rational* %cPtr
; tuple ref
%val3680 = extractvalue %Rational %val3679, 0
%val3681 = load %Rational, %Rational* %cPtr
; tuple ref
%val3682 = extractvalue %Rational %val3681, 1
%val3683 = srem i64 %val3680, %val3682
%val3684 = load %Rational, %Rational* %cPtr
; tuple ref
%val3685 = extractvalue %Rational %val3684, 1
%res3686 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val3683, i64 %val3685)

; let value assignment
%n = select i1 true, %Rational %res3686, %Rational %res3686
store %Rational %n, %Rational* %nPtr

%val3689 = load %Rational, %Rational* %bPtr
%val3690 = load %Rational, %Rational* %nPtr
%res3691 = call fastcc %Rational @xtm_multiplication_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val3689, %Rational %val3690)
ret %Rational %res3691
}
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3711 = load i8*, i8** %_impzPtr
%zone3712 = bitcast i8* %tzone3711 to %mzone*

; let assign value to symbol xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ
%dat_xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone3712, i64 8)
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***
%tzone3692 = load i8*, i8** %_impzPtr
%zone3693 = bitcast i8* %tzone3692 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3693)
; malloc closure structure
%clsptr3694 = call i8* @llvm_zone_malloc(%mzone* %zone3693, i64 24)
%closure3695 = bitcast i8* %clsptr3694 to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*

; malloc environment structure
%envptr3696 = call i8* @llvm_zone_malloc(%mzone* %zone3693, i64 8)
%environment3697 = bitcast i8* %envptr3696 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}*

; malloc closure address table
%addytable3698 = call %clsvar* @new_address_table()
%var3699 = bitcast [56 x i8]* @gsxtmrational233 to i8*
%var3700 = bitcast [58 x i8]* @gsxtmrational44 to i8*
%addytable3701 = call %clsvar* @add_address_table(%mzone* %zone3693, i8* %var3699, i32 0, i8* %var3700, i32 3, %clsvar* %addytable3698)
%address-table3702 = bitcast %clsvar* %addytable3701 to i8*

; insert table, function and environment into closure struct
%closure.table3705 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure3695, i32 0, i32 0
store i8* %address-table3702, i8** %closure.table3705
%closure.env3706 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure3695, i32 0, i32 1
store i8* %envptr3696, i8** %closure.env3706
%closure.func3707 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure3695, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, %Rational)* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ__3672, %Rational (i8*, i8*, %Rational, %Rational)** %closure.func3707
%closure_size3708 = call i64 @llvm_zone_mark_size(%mzone* %zone3693)
call void @llvm_zone_ptr_set_size(i8* %clsptr3694, i64 %closure_size3708)
%wrapper_ptr3709 = call i8* @llvm_zone_malloc(%mzone* %zone3693, i64 8)
%closure_wrapper3710 = bitcast i8* %wrapper_ptr3709 to { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure3695, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper3710

; let value assignment
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper3710, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_wrapper3710
store { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ
%tmp_envptr3704 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}***}* %environment3697, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**** %tmp_envptr3704


%val3713 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %val3713
}


@xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_native(%Rational %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, %Rational}*
%arg_p_0 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, %Rational}, {%Rational, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, %Rational)*,  %Rational (i8*, i8*, %Rational, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational234 = hidden constant [49 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0\00"
define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0__3714(i8* %_impz,i8* %_impenv, %Rational %a, i64 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3715 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}*
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}* %impenv, i32 0, i32 0
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i64
store i64 %b, i64* %bPtr


%val3716 = load %Rational, %Rational* %aPtr
%val3717 = load i64, i64* %bPtr
%res3718 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val3717, i64 1)
%res3719 = call fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val3716, %Rational %res3718)
ret %Rational %res3719
}
@gsxtmrational235 = hidden constant [102 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3739 = load i8*, i8** %_impzPtr
%zone3740 = bitcast i8* %tzone3739 to %mzone*

; let assign value to symbol xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0
%dat_xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone3740, i64 8)
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr = bitcast i8* %dat_xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***
%tzone3720 = load i8*, i8** %_impzPtr
%zone3721 = bitcast i8* %tzone3720 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3721)
; malloc closure structure
%clsptr3722 = call i8* @llvm_zone_malloc(%mzone* %zone3721, i64 24)
%closure3723 = bitcast i8* %clsptr3722 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*

; malloc environment structure
%envptr3724 = call i8* @llvm_zone_malloc(%mzone* %zone3721, i64 8)
%environment3725 = bitcast i8* %envptr3724 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}*

; malloc closure address table
%addytable3726 = call %clsvar* @new_address_table()
%var3727 = bitcast [49 x i8]* @gsxtmrational234 to i8*
%var3728 = bitcast [52 x i8]* @gsxtmrational46 to i8*
%addytable3729 = call %clsvar* @add_address_table(%mzone* %zone3721, i8* %var3727, i32 0, i8* %var3728, i32 3, %clsvar* %addytable3726)
%address-table3730 = bitcast %clsvar* %addytable3729 to i8*

; insert table, function and environment into closure struct
%closure.table3733 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure3723, i32 0, i32 0
store i8* %address-table3730, i8** %closure.table3733
%closure.env3734 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure3723, i32 0, i32 1
store i8* %envptr3724, i8** %closure.env3734
%closure.func3735 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure3723, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i64)* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0__3714, %Rational (i8*, i8*, %Rational, i64)** %closure.func3735
%closure_size3736 = call i64 @llvm_zone_mark_size(%mzone* %zone3721)
call void @llvm_zone_ptr_set_size(i8* %clsptr3722, i64 %closure_size3736)
%wrapper_ptr3737 = call i8* @llvm_zone_malloc(%mzone* %zone3721, i64 8)
%closure_wrapper3738 = bitcast i8* %wrapper_ptr3737 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure3723, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper3738

; let value assignment
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper3738, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_wrapper3738
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0, { i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0
%tmp_envptr3732 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}***}* %environment3725, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**** %tmp_envptr3732


%val3741 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %val3741
}


@xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_native(%Rational %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i64}*
%arg_p_0 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i64}, {%Rational, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i64)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i64)*,  %Rational (i8*, i8*, %Rational, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational236 = hidden constant [49 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0\00"
define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0__3743(i8* %_impz,i8* %_impenv, i64 %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3744 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}*
%xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**** %xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr_

; setup arguments
%aPtr = alloca i64
store i64 %a, i64* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%val3745 = load i64, i64* %aPtr
%res3746 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %val3745, i64 1)
%val3747 = load %Rational, %Rational* %bPtr
%res3748 = call fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res3746, %Rational %val3747)
ret %Rational %res3748
}
@gsxtmrational237 = hidden constant [102 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3768 = load i8*, i8** %_impzPtr
%zone3769 = bitcast i8* %tzone3768 to %mzone*

; let assign value to symbol xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0
%dat_xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone3769, i64 8)
%xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***
%tzone3749 = load i8*, i8** %_impzPtr
%zone3750 = bitcast i8* %tzone3749 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3750)
; malloc closure structure
%clsptr3751 = call i8* @llvm_zone_malloc(%mzone* %zone3750, i64 24)
%closure3752 = bitcast i8* %clsptr3751 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*

; malloc environment structure
%envptr3753 = call i8* @llvm_zone_malloc(%mzone* %zone3750, i64 8)
%environment3754 = bitcast i8* %envptr3753 to {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}*

; malloc closure address table
%addytable3755 = call %clsvar* @new_address_table()
%var3756 = bitcast [49 x i8]* @gsxtmrational236 to i8*
%var3757 = bitcast [52 x i8]* @gsxtmrational49 to i8*
%addytable3758 = call %clsvar* @add_address_table(%mzone* %zone3750, i8* %var3756, i32 0, i8* %var3757, i32 3, %clsvar* %addytable3755)
%address-table3759 = bitcast %clsvar* %addytable3758 to i8*

; insert table, function and environment into closure struct
%closure.table3762 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure3752, i32 0, i32 0
store i8* %address-table3759, i8** %closure.table3762
%closure.env3763 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure3752, i32 0, i32 1
store i8* %envptr3753, i8** %closure.env3763
%closure.func3764 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure3752, i32 0, i32 2
store %Rational (i8*, i8*, i64, %Rational)* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0__3743, %Rational (i8*, i8*, i64, %Rational)** %closure.func3764
%closure_size3765 = call i64 @llvm_zone_mark_size(%mzone* %zone3750)
call void @llvm_zone_ptr_set_size(i8* %clsptr3751, i64 %closure_size3765)
%wrapper_ptr3766 = call i8* @llvm_zone_malloc(%mzone* %zone3750, i64 8)
%closure_wrapper3767 = bitcast i8* %wrapper_ptr3766 to { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure3752, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper3767

; let value assignment
%xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper3767, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_wrapper3767
store { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0, { i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0
%tmp_envptr3761 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}***}* %environment3754, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**** %tmp_envptr3761


%val3770 = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %val3770
}


@xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_native(i64 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, %Rational}*
%arg_p_0 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, %Rational}, {i64, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk2NCxSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i64, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i64, %Rational)*,  %Rational (i8*, i8*, i64, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i64 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational238 = hidden constant [49 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0\00"
define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0__3772(i8* %_impz,i8* %_impenv, %Rational %a, i32 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3773 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}*
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}* %impenv, i32 0, i32 0
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i32
store i32 %b, i32* %bPtr


%val3774 = load %Rational, %Rational* %aPtr
%val3775 = load i32, i32* %bPtr
%res3776 = call ccc i64 @i32toi64(i32 %val3775)
%res3777 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res3776, i64 1)
%res3778 = call fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val3774, %Rational %res3777)
ret %Rational %res3778
}
@gsxtmrational239 = hidden constant [102 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3798 = load i8*, i8** %_impzPtr
%zone3799 = bitcast i8* %tzone3798 to %mzone*

; let assign value to symbol xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0
%dat_xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone3799, i64 8)
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr = bitcast i8* %dat_xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***
%tzone3779 = load i8*, i8** %_impzPtr
%zone3780 = bitcast i8* %tzone3779 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3780)
; malloc closure structure
%clsptr3781 = call i8* @llvm_zone_malloc(%mzone* %zone3780, i64 24)
%closure3782 = bitcast i8* %clsptr3781 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*

; malloc environment structure
%envptr3783 = call i8* @llvm_zone_malloc(%mzone* %zone3780, i64 8)
%environment3784 = bitcast i8* %envptr3783 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}*

; malloc closure address table
%addytable3785 = call %clsvar* @new_address_table()
%var3786 = bitcast [49 x i8]* @gsxtmrational238 to i8*
%var3787 = bitcast [52 x i8]* @gsxtmrational52 to i8*
%addytable3788 = call %clsvar* @add_address_table(%mzone* %zone3780, i8* %var3786, i32 0, i8* %var3787, i32 3, %clsvar* %addytable3785)
%address-table3789 = bitcast %clsvar* %addytable3788 to i8*

; insert table, function and environment into closure struct
%closure.table3792 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure3782, i32 0, i32 0
store i8* %address-table3789, i8** %closure.table3792
%closure.env3793 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure3782, i32 0, i32 1
store i8* %envptr3783, i8** %closure.env3793
%closure.func3794 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure3782, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i32)* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0__3772, %Rational (i8*, i8*, %Rational, i32)** %closure.func3794
%closure_size3795 = call i64 @llvm_zone_mark_size(%mzone* %zone3780)
call void @llvm_zone_ptr_set_size(i8* %clsptr3781, i64 %closure_size3795)
%wrapper_ptr3796 = call i8* @llvm_zone_malloc(%mzone* %zone3780, i64 8)
%closure_wrapper3797 = bitcast i8* %wrapper_ptr3796 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure3782, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper3797

; let value assignment
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper3797, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_wrapper3797
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0, { i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0
%tmp_envptr3791 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}***}* %environment3784, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**** %tmp_envptr3791


%val3800 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %val3800
}


@xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_native(%Rational %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i32}*
%arg_p_0 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i32}, {%Rational, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i32)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i32)*,  %Rational (i8*, i8*, %Rational, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational240 = hidden constant [49 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0\00"
define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0__3802(i8* %_impz,i8* %_impenv, i32 %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3803 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}*
%xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**** %xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr_

; setup arguments
%aPtr = alloca i32
store i32 %a, i32* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%val3804 = load i32, i32* %aPtr
%res3805 = call ccc i64 @i32toi64(i32 %val3804)
%res3806 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res3805, i64 1)
%val3807 = load %Rational, %Rational* %bPtr
%res3808 = call fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res3806, %Rational %val3807)
ret %Rational %res3808
}
@gsxtmrational241 = hidden constant [102 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3828 = load i8*, i8** %_impzPtr
%zone3829 = bitcast i8* %tzone3828 to %mzone*

; let assign value to symbol xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0
%dat_xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 = call i8* @llvm_zone_malloc(%mzone* %zone3829, i64 8)
%xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr = bitcast i8* %dat_xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***
%tzone3809 = load i8*, i8** %_impzPtr
%zone3810 = bitcast i8* %tzone3809 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3810)
; malloc closure structure
%clsptr3811 = call i8* @llvm_zone_malloc(%mzone* %zone3810, i64 24)
%closure3812 = bitcast i8* %clsptr3811 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*

; malloc environment structure
%envptr3813 = call i8* @llvm_zone_malloc(%mzone* %zone3810, i64 8)
%environment3814 = bitcast i8* %envptr3813 to {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}*

; malloc closure address table
%addytable3815 = call %clsvar* @new_address_table()
%var3816 = bitcast [49 x i8]* @gsxtmrational240 to i8*
%var3817 = bitcast [52 x i8]* @gsxtmrational55 to i8*
%addytable3818 = call %clsvar* @add_address_table(%mzone* %zone3810, i8* %var3816, i32 0, i8* %var3817, i32 3, %clsvar* %addytable3815)
%address-table3819 = bitcast %clsvar* %addytable3818 to i8*

; insert table, function and environment into closure struct
%closure.table3822 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure3812, i32 0, i32 0
store i8* %address-table3819, i8** %closure.table3822
%closure.env3823 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure3812, i32 0, i32 1
store i8* %envptr3813, i8** %closure.env3823
%closure.func3824 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure3812, i32 0, i32 2
store %Rational (i8*, i8*, i32, %Rational)* @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0__3802, %Rational (i8*, i8*, i32, %Rational)** %closure.func3824
%closure_size3825 = call i64 @llvm_zone_mark_size(%mzone* %zone3810)
call void @llvm_zone_ptr_set_size(i8* %clsptr3811, i64 %closure_size3825)
%wrapper_ptr3826 = call i8* @llvm_zone_malloc(%mzone* %zone3810, i64 8)
%closure_wrapper3827 = bitcast i8* %wrapper_ptr3826 to { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure3812, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper3827

; let value assignment
%xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0 = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper3827, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_wrapper3827
store { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0, { i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr

; add data to environment
; don't need to alloc for env var xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0
%tmp_envptr3821 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}***}* %environment3814, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**** %tmp_envptr3821


%val3830 = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0Ptr
ret {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %val3830
}


@xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_native(i32 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Rational}*
%arg_p_0 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Rational}, {i32, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGkzMixSYXRpb25hbF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i32, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i32, %Rational)*,  %Rational (i8*, i8*, i32, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational242 = hidden constant [48 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ\00"
define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ__3832(i8* %_impz,i8* %_impenv, %Rational %a, i8 %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3833 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}*
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}* %impenv, i32 0, i32 0
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr_

; setup arguments
%aPtr = alloca %Rational
store %Rational %a, %Rational* %aPtr
%bPtr = alloca i8
store i8 %b, i8* %bPtr


%val3834 = load %Rational, %Rational* %aPtr
%val3835 = load i8, i8* %bPtr
%res3836 = call ccc i64 @i8toi64(i8 %val3835)
%res3837 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res3836, i64 1)
%res3838 = call fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %val3834, %Rational %res3837)
ret %Rational %res3838
}
@gsxtmrational243 = hidden constant [101 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3858 = load i8*, i8** %_impzPtr
%zone3859 = bitcast i8* %tzone3858 to %mzone*

; let assign value to symbol xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ
%dat_xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ = call i8* @llvm_zone_malloc(%mzone* %zone3859, i64 8)
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr = bitcast i8* %dat_xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***
%tzone3839 = load i8*, i8** %_impzPtr
%zone3840 = bitcast i8* %tzone3839 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3840)
; malloc closure structure
%clsptr3841 = call i8* @llvm_zone_malloc(%mzone* %zone3840, i64 24)
%closure3842 = bitcast i8* %clsptr3841 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*

; malloc environment structure
%envptr3843 = call i8* @llvm_zone_malloc(%mzone* %zone3840, i64 8)
%environment3844 = bitcast i8* %envptr3843 to {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}*

; malloc closure address table
%addytable3845 = call %clsvar* @new_address_table()
%var3846 = bitcast [48 x i8]* @gsxtmrational242 to i8*
%var3847 = bitcast [51 x i8]* @gsxtmrational58 to i8*
%addytable3848 = call %clsvar* @add_address_table(%mzone* %zone3840, i8* %var3846, i32 0, i8* %var3847, i32 3, %clsvar* %addytable3845)
%address-table3849 = bitcast %clsvar* %addytable3848 to i8*

; insert table, function and environment into closure struct
%closure.table3852 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure3842, i32 0, i32 0
store i8* %address-table3849, i8** %closure.table3852
%closure.env3853 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure3842, i32 0, i32 1
store i8* %envptr3843, i8** %closure.env3853
%closure.func3854 = getelementptr { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure3842, i32 0, i32 2
store %Rational (i8*, i8*, %Rational, i8)* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ__3832, %Rational (i8*, i8*, %Rational, i8)** %closure.func3854
%closure_size3855 = call i64 @llvm_zone_mark_size(%mzone* %zone3840)
call void @llvm_zone_ptr_set_size(i8* %clsptr3841, i64 %closure_size3855)
%wrapper_ptr3856 = call i8* @llvm_zone_malloc(%mzone* %zone3840, i64 8)
%closure_wrapper3857 = bitcast i8* %wrapper_ptr3856 to { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure3842, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper3857

; let value assignment
%xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper3857, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_wrapper3857
store { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ, { i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr

; add data to environment
; don't need to alloc for env var xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ
%tmp_envptr3851 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}, {{i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}***}* %environment3844, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**** %tmp_envptr3851


%val3860 = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQPtr
ret {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %val3860
}


@xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_native(%Rational %arg_0,i8 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Rational, i8}*
%arg_p_0 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 0
%arg_0 = load %Rational, %Rational* %arg_p_0
%arg_p_1 = getelementptr {%Rational, i8}, {%Rational, i8}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLGk4XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}*, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}, {i8*, i8*, %Rational (i8*, i8*, %Rational, i8)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, %Rational, i8)*,  %Rational (i8*, i8*, %Rational, i8)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, %Rational %arg_0, i8 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmrational244 = hidden constant [48 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ\00"
define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ__3862(i8* %_impz,i8* %_impenv, i8 %a, %Rational %b) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3863 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}*
%xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr_ = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}* %impenv, i32 0, i32 0
%xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**** %xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr_

; setup arguments
%aPtr = alloca i8
store i8 %a, i8* %aPtr
%bPtr = alloca %Rational
store %Rational %b, %Rational* %bPtr


%val3864 = load i8, i8* %aPtr
%res3865 = call ccc i64 @i8toi64(i8 %val3864)
%res3866 = call fastcc %Rational @Rat_adhoc_W1JhdGlvbmFsLGk2NCxpNjRd(i64 %res3865, i64 1)
%val3867 = load %Rational, %Rational* %bPtr
%res3868 = call fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLFJhdGlvbmFsLFJhdGlvbmFsXQ(%Rational %res3866, %Rational %val3867)
ret %Rational %res3868
}
@gsxtmrational245 = hidden constant [101 x i8] c"xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3888 = load i8*, i8** %_impzPtr
%zone3889 = bitcast i8* %tzone3888 to %mzone*

; let assign value to symbol xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ
%dat_xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ = call i8* @llvm_zone_malloc(%mzone* %zone3889, i64 8)
%xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr = bitcast i8* %dat_xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***
%tzone3869 = load i8*, i8** %_impzPtr
%zone3870 = bitcast i8* %tzone3869 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3870)
; malloc closure structure
%clsptr3871 = call i8* @llvm_zone_malloc(%mzone* %zone3870, i64 24)
%closure3872 = bitcast i8* %clsptr3871 to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*

; malloc environment structure
%envptr3873 = call i8* @llvm_zone_malloc(%mzone* %zone3870, i64 8)
%environment3874 = bitcast i8* %envptr3873 to {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}*

; malloc closure address table
%addytable3875 = call %clsvar* @new_address_table()
%var3876 = bitcast [48 x i8]* @gsxtmrational244 to i8*
%var3877 = bitcast [51 x i8]* @gsxtmrational61 to i8*
%addytable3878 = call %clsvar* @add_address_table(%mzone* %zone3870, i8* %var3876, i32 0, i8* %var3877, i32 3, %clsvar* %addytable3875)
%address-table3879 = bitcast %clsvar* %addytable3878 to i8*

; insert table, function and environment into closure struct
%closure.table3882 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure3872, i32 0, i32 0
store i8* %address-table3879, i8** %closure.table3882
%closure.env3883 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure3872, i32 0, i32 1
store i8* %envptr3873, i8** %closure.env3883
%closure.func3884 = getelementptr { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure3872, i32 0, i32 2
store %Rational (i8*, i8*, i8, %Rational)* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ__3862, %Rational (i8*, i8*, i8, %Rational)** %closure.func3884
%closure_size3885 = call i64 @llvm_zone_mark_size(%mzone* %zone3870)
call void @llvm_zone_ptr_set_size(i8* %clsptr3871, i64 %closure_size3885)
%wrapper_ptr3886 = call i8* @llvm_zone_malloc(%mzone* %zone3870, i64 8)
%closure_wrapper3887 = bitcast i8* %wrapper_ptr3886 to { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
store { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure3872, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper3887

; let value assignment
%xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ = select i1 true, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper3887, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_wrapper3887
store { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ, { i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr

; add data to environment
; don't need to alloc for env var xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ
%tmp_envptr3881 = getelementptr {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}, {{i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}***}* %environment3874, i32 0, i32 0
store {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**** %tmp_envptr3881


%val3890 = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*** %xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQPtr
ret {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %val3890
}


@xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var = dllexport global [1 x i8*] [ i8* null ]

@xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc %Rational @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_native(i8 %arg_0,%Rational %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
ret %Rational %result
}


define dllexport ccc void @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8, %Rational}*
%arg_p_0 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 0
%arg_0 = load i8, i8* %arg_p_0
%arg_p_1 = getelementptr {i8, %Rational}, {i8, %Rational}* %fstruct, i32 0, i32 1
%arg_1 = load %Rational, %Rational* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @xtm_modulo_adhoc_W1JhdGlvbmFsLGk4LFJhdGlvbmFsXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}**
%closure = load {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}*, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}, {i8*, i8*, %Rational (i8*, i8*, i8, %Rational)*}* %closure, i32 0, i32 1
%ff = load  %Rational (i8*, i8*, i8, %Rational)*,  %Rational (i8*, i8*, i8, %Rational)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Rational %ff(i8* %_impz, i8* %ee, i8 %arg_0, %Rational %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


