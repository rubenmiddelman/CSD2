(sys:load "libs/core/instruments.xtm" 'quiet)
(sys:load "libs/external/sndfile.xtm" 'quiet)
(sys:load-preload-check 'instruments_ext)
(define *xtmlib-instruments_ext-loaded* #t)
(define *xtmlib-instruments_ext-loaded-timer* (clock:clock))
(set! *impc:aot:prev-compiler-message-level* *impc:compiler:message:level*)
(set! *impc:compiler:message:level* 'low)

(print "Loading ")
(print-with-colors 'blue 'default #t (print 'xtminstruments_ext))
(print " library... ")
(llvm:compile-ir (sys:slurp-file "libs/aot-cache/xtminstruments_ext.ll"));; flush the JIT-compilation queue, so we only get this file's code in the module
(impc:compiler:flush-jit-compilation-queue)
(register-lib-func xtminstruments_ext set_sample_data__adhoc_W2k2NCxbZmxvYXQsZmxvYXQsaTY0LGk2NCxmbG9hdCpdKixpOCosaTY0LGk2NCxpNjQsaTMyLGk2NF0 [i64,[float,float,i64,i64,float*]*,i8*,i64,i64,i64,i32,i64]* 0 "" '(let ((set_sample_data__adhoc_1 (lambda (inst:[SAMPLE,SAMPLE,i64,i64,SAMPLE*]* filename index:i64 offset lgth bank:i32 print_p:i64) (let ((info:SF_INFO* (salloc)) (audiofile (sf_open filename SFM_READ info)) (channels:i64 (convert (tref info 2))) (num (if (= 0 lgth) (- (tref info 0) offset) lgth))) (if (<> null audiofile) (let ((adat:SAMPLE* (halloc (* num channels))) (samples:|20,|128,SAMPLE*||* (inst.samples)) (samples_channels:|20,|128,i64||* (inst.samples_channels)) (samples_length:|20,|128,i64||* (inst.samples_length)) (samples_read (sf_read_file_into_buffer filename adat (* offset channels) num (i64toi1 print_p))) (olddat (if (<> 0 (aref (aref-ptr samples_length bank) index)) (bitcast (aref (aref-ptr samples bank) index) i8*) null))) (aset! (aref-ptr samples_length bank) index (/ samples_read channels)) (aset! (aref-ptr samples_channels bank) index (convert channels)) (aset! (aref-ptr samples bank) index adat) (sf_close audiofile) (if (not (null? olddat)) (free olddat)) 1) (begin (sf_close audiofile) (printf "%s\n" (sf_strerror audiofile)) 0)))))) set_sample_data__adhoc_1))
(bind-poly set_sample_data_ set_sample_data__adhoc_W2k2NCxbZmxvYXQsZmxvYXQsaTY0LGk2NCxmbG9hdCpdKixpOCosaTY0LGk2NCxpNjQsaTMyLGk2NF0 "")
(register-lib-func xtminstruments_ext clear_sample_data__adhoc_W2k2NCxbZmxvYXQsZmxvYXQsaTY0LGk2NCxmbG9hdCpdKixpNjQsaTMyXQ [i64,[float,float,i64,i64,float*]*,i64,i32]* 0 "" '(let ((clear_sample_data__adhoc_2 (lambda (inst:[SAMPLE,SAMPLE,i64,i64,SAMPLE*]* index:i64 bank:i32) (let ((samples:|20,|128,SAMPLE*||* (inst.samples)) (samples_channels:|20,|128,i64||* (inst.samples_channels)) (samples_length:|20,|128,i64||* (inst.samples_length)) (olddat (if (<> 0 (aref (aref-ptr samples_length bank) index)) (bitcast (aref (aref-ptr samples bank) index) i8*) null))) (aset! (aref-ptr samples_length bank) index 0) (aset! (aref-ptr samples_channels bank) index 0) (aset! (aref-ptr samples bank) index null) (if (null? olddat) 0 (begin (free olddat) 1)))))) clear_sample_data__adhoc_2))
(bind-poly clear_sample_data_ clear_sample_data__adhoc_W2k2NCxbZmxvYXQsZmxvYXQsaTY0LGk2NCxmbG9hdCpdKixpNjQsaTMyXQ "")
(register-lib-func xtminstruments_ext set_sample_offset__adhoc_W2k2NCxbZmxvYXQsZmxvYXQsaTY0LGk2NCxmbG9hdCpdKixpNjQsaTY0LGk2NF0 [i64,[float,float,i64,i64,float*]*,i64,i64,i64]* 0 "" '(let ((set_sample_offset__adhoc_3 (lambda (inst:[SAMPLE,SAMPLE,i64,i64,SAMPLE*]* index:i64 bank:i64 offset:i64) (let ((offsets:|20,|128,i64||* (inst.samples_offsets))) (aset! (aref-ptr offsets bank) index offset) 1)))) set_sample_offset__adhoc_3))
(bind-poly set_sample_offset_ set_sample_offset__adhoc_W2k2NCxbZmxvYXQsZmxvYXQsaTY0LGk2NCxmbG9hdCpdKixpNjQsaTY0LGk2NF0 "")
(register-lib-func xtminstruments_ext sampler_note_linear_adhoc_W1tbZmxvYXQsaTY0LGk2NF0qLE5vdGVEYXRhKix8MTI4LGZsb2F0KnwqLHwxMjgsaTY0fCosfDEyOCxpNjR8Kix8MTI4LGk2NHwqLGk2NCxpNjQsZmxvYXQqXSpd [[[float,i64,i64]*,NoteData*,|128,float*|*,|128,i64|*,|128,i64|*,|128,i64|*,i64,i64,float*]*]* 0 "" '(let ((sampler_note_linear_adhoc_4 (lambda () (let ((amp_env:|4,float| (array 10.0:f 50.000000000000000000 0.59999999999999997780 200.00000000000000000))) (lambda (data:NoteData* samples:|128,SAMPLE*|* samples_length:|128,i64|* samples_offsets:|128,i64|* samples_channels:|128,i64|* index:i64 nargs:i64 dargs) (let ((starttime (note_starttime data)) (freq (note_frequency data)) (amp (note_amplitude data)) (duration (note_duration data)) (gate 1.0:f) (pan:SAMPLE (if (> nargs 1) (pref dargs 1) 0.50000000000000000000)) (offset:SAMPLE (if (> nargs 2) (pref dargs 2) 0.00000000000000000000)) (rev:i1 (if (> nargs 3) (if (> (pref dargs 3) 0.010000000000000000208) #t #f) #f)) (a (aref amp_env 0)) (d (aref amp_env 1)) (s (aref amp_env 2)) (r (aref amp_env 3)) (rtime:i64 (convert (* SRf (/ (aref amp_env 3) 1000.0000000000000000)))) (dt 0) (rt 0) (total_time (+ duration rtime)) (env (adsr_c)) (eamp 0.00000000000000000000) (idx_freq (convert (midi2frq (convert index)))) (phase:double (convert (+ offset (convert (aref samples_offsets index)))))) (if (and rev (< phase 0.010000000000000000208)) (set! phase (convert (- (aref samples_length index) 10)))) (lambda (time:i64 chan:i64) (if (= chan 0) (begin (set! dt (+ dt 1)) (if (> dt duration) (set! gate 0.00000000000000000000)) (set! eamp (env chan gate a d s r)) (if (< gate 0.10000000000000000555) (begin (set! rt (+ rt 1)) (if (> rt rtime) (note_active data #f)))))) (let ((rate:double (/ (convert freq) idx_freq)) (pos:double (if (= chan 0) (if rev (set! phase (- phase rate)) (set! phase (+ phase rate))) phase)) (posi:i64 (convert (floor pos))) (posx (+ (* posi 2) chan)) (lgth:i64 (convert (- (aref samples_length index) 10))) (dat (aref samples index))) (* amp eamp (if (or (> posi lgth) (< posi 0)) 0.00000000000000000000 (pref dat posx))))))))))) sampler_note_linear_adhoc_4))
(bind-poly sampler_note_linear sampler_note_linear_adhoc_W1tbZmxvYXQsaTY0LGk2NF0qLE5vdGVEYXRhKix8MTI4LGZsb2F0KnwqLHwxMjgsaTY0fCosfDEyOCxpNjR8Kix8MTI4LGk2NHwqLGk2NCxpNjQsZmxvYXQqXSpd "")
(register-lib-func xtminstruments_ext sampler_note_adhoc_W1tbZmxvYXQsaTY0LGk2NF0qLE5vdGVEYXRhKix8MTI4LGZsb2F0KnwqLHwxMjgsaTY0fCosfDEyOCxpNjR8Kix8MTI4LGk2NHwqLGk2NCxpNjQsZmxvYXQqXSpd [[[float,i64,i64]*,NoteData*,|128,float*|*,|128,i64|*,|128,i64|*,|128,i64|*,i64,i64,float*]*]* 0 "" '(let ((sampler_note_adhoc_5 (lambda () (let ((amp_env:|4,float| (array 3.0:f 0.00000000000000000000 1.0000000000000000000 20.000000000000000000))) (lambda (data:NoteData* samples:|128,SAMPLE*|* samples_length:|128,i64|* samples_offsets:|128,i64|* samples_channels:|128,i64|* index:i64 nargs dargs) (let ((starttime (note_starttime data)) (freq (note_frequency data)) (amp (note_amplitude data)) (duration (note_duration data)) (gate 1.0:f) (pan:SAMPLE (if (> nargs 1) (pref dargs 1) 0.50000000000000000000)) (offset:SAMPLE (if (> nargs 2) (pref dargs 2) 0.00000000000000000000)) (rev:i1 (if (> nargs 3) (if (> (pref dargs 3) 0.010000000000000000208) #t #f) #f)) (a (aref amp_env 0)) (d (aref amp_env 1)) (s (aref amp_env 2)) (r (aref amp_env 3)) (rtime:i64 (convert (* SRf (/ (aref amp_env 3) 1000.0000000000000000)))) (dt 0) (rt 0) (total_time (+ duration rtime)) (env (adsr_c)) (eamp 0.00000000000000000000) (idx_freq (convert (midi2frq (convert index SAMPLE)))) (channels:i64 (convert (aref samples_channels index))) (phase:double (convert (+ offset (convert (aref samples_offsets index)))))) (if (and rev (< phase 0.010000000000000000208)) (set! phase (convert (- (aref samples_length index) 10)))) (lambda (time:i64 chan:i64) (if (= chan 0) (begin (set! dt (+ dt 1)) (if (> dt duration) (set! gate 0.00000000000000000000)) (set! eamp (env chan gate a d s r)) (if (< gate 0.10000000000000000555) (begin (set! rt (+ rt 1)) (if (> rt rtime) (note_active data #f)))))) (let ((rate (/ (convert freq) idx_freq)) (pos:double (if (= chan 0) (if rev (set! phase (- phase rate)) (set! phase (+ phase rate))) phase)) (posi:i64 (convert (floor pos))) (posx (+ (* posi channels) (if (< chan channels) chan 0))) (lgth:i64 (- (aref samples_length index) 10)) (dat (aref samples index))) (if (< (fabs (- rate 1.0000000000000000000)) 0.010000000000000000208) (if (or (> posi lgth) (< posi 0)) 0.00000000000000000000 (* amp eamp (panner chan pan) (pref dat posx))) (let ((y1 (if (or (> posi lgth) (< posi 1)) 0.00000000000000000000 (if rev (pref dat (+ posx channels)) (pref dat (- posx channels))))) (x0 (if (or (> posi lgth) (< posi 0)) 0.00000000000000000000 (pref dat posx))) (x1 (if (or (> (+ posi 1) lgth) (< (- posi 1) 0)) 0.00000000000000000000 (if rev (pref dat (- posx channels)) (pref dat (+ posx channels))))) (x2 (if (or (> (+ posi 2) lgth) (< (- posi 2) 0)) 0.00000000000000000000 (if rev (pref dat (- posx (* 2 channels))) (pref dat (+ posx (* 2 channels))))))) (* (panner chan pan) amp eamp (hermite_interp (dtof (modulo pos 1.0000000000000000000)) y1 x0 x1 x2)))))))))))) sampler_note_adhoc_5))
(bind-poly sampler_note sampler_note_adhoc_W1tbZmxvYXQsaTY0LGk2NF0qLE5vdGVEYXRhKix8MTI4LGZsb2F0KnwqLHwxMjgsaTY0fCosfDEyOCxpNjR8Kix8MTI4LGk2NHwqLGk2NCxpNjQsZmxvYXQqXSpd "")
(bind-alias NOTE_KERNEL_SAMPLER [[float,i64,i64]*,NoteData*,|128,float*|*,|128,i64|*,|128,i64|*,|128,i64|*,i64,i64,float*]* "")
(register-lib-func xtminstruments_ext make_instrument_adhoc_W1tmbG9hdCxmbG9hdCxpNjQsaTY0LGZsb2F0Kl0qLFtbZmxvYXQsaTY0LGk2NF0qLE5vdGVEYXRhKix8MTI4LGZsb2F0KnwqLHwxMjgsaTY0fCosfDEyOCxpNjR8Kix8MTI4LGk2NHwqLGk2NCxpNjQsZmxvYXQqXSosW2Zsb2F0LGZsb2F0LGk2NCxpNjQsZmxvYXQqXSpd [[float,float,i64,i64,float*]*,[[float,i64,i64]*,NoteData*,|128,float*|*,|128,i64|*,|128,i64|*,|128,i64|*,i64,i64,float*]*,[float,float,i64,i64,float*]*]* 0 "" '(let ((make_instrument_adhoc_6 (lambda (note_kernel:NOTE_KERNEL_SAMPLER effect_kernel:FX_KERNEL) (effect_kernel.notekernel:NOTE_KERNEL_SAMPLER note_kernel) (let ((poly:i64 36) (samples:|20,|128,SAMPLE*||* (zalloc)) (samples_length:|20,|128,i64||* (zalloc)) (samples_channels:|20,|128,i64||* (zalloc)) (samples_offsets:|20,|128,i64||* (zalloc)) (notes:NoteData** (zalloc poly)) (note:NoteData* null) (kernels:[SAMPLE,i64,i64]** (zalloc poly)) (kernel:[SAMPLE,i64,i64]* null) (starttime:i64 0) (out:SAMPLE 0.00000000000000000000) (k:i64 0) (i:i64 0) (new_note (lambda (start:i64 freq:SAMPLE dur:i64 amp:SAMPLE nargs:i64 dargs:SAMPLE*) (let ((free_note (instrument_find_note notes poly)) (idx (note_idx free_note)) (zone (note_zone (free_note))) (bank:i32 (if (< nargs 1) (i64toi32 0) (convert (pref dargs 0)))) (midiidx:i64 (convert (floor (frq2midi freq)))) (closest 1000000) (i:i64 0) (iii:i64 0) (idxi:i64 0) (new_idx idx)) (dotimes (idxi 128) (let ((v (llabs (- midiidx idxi)))) (if (and (<> (aref (aref-ptr samples_length bank) idxi) 0) (< v closest)) (begin (set! new_idx idxi) (set! closest v) 0)))) (if (null? free_note) null (if (note_active free_note) (begin (tfill! free_note idx start freq amp dur 1.0000000000000000000 #t 0 (cast zone)) free_note) (begin (reset_zone zone) (push_zone zone) (tfill! free_note idx start freq amp dur 1.0000000000000000000 #t 0 (cast zone)) (pset! kernels idx (note_kernel free_note (aref-ptr samples bank) (aref-ptr samples_length bank) (aref-ptr samples_offsets bank) (aref-ptr samples_channels bank) new_idx nargs dargs)) (pop_zone) free_note))))))) (dotimes (k 128) (dotimes (i 20) (aset! (aref-ptr samples_offsets i) k 0) (aset! (aref-ptr samples_length i) k 0))) (dotimes (i poly) (pset! kernels i (cast null)) (pset! notes i (NoteData i 0 0.00000000000000000000 0.00000000000000000000 0 1.0000000000000000000 #f 0 (cast (create_zone (* 10 1024)))))) (lambda (in:SAMPLE time:i64 chan:i64 dat:SAMPLE*) (set! out 0.00000000000000000000) (dotimes (k poly) (set! note (pref notes k)) (set! starttime (note_starttime note)) (if (not (note_active note)) (pset! kernels k (cast null))) (set! kernel (pref kernels k)) (if (and (> time starttime) (not (null? kernel))) (set! out (+ out (* 0.29999999999999998890 (kernel time chan)))))) (* 2.0000000000000000000 (effect_kernel out time chan dat))))))) make_instrument_adhoc_6))
(bind-poly make_instrument make_instrument_adhoc_W1tmbG9hdCxmbG9hdCxpNjQsaTY0LGZsb2F0Kl0qLFtbZmxvYXQsaTY0LGk2NF0qLE5vdGVEYXRhKix8MTI4LGZsb2F0KnwqLHwxMjgsaTY0fCosfDEyOCxpNjR8Kix8MTI4LGk2NHwqLGk2NCxpNjQsZmxvYXQqXSosW2Zsb2F0LGZsb2F0LGk2NCxpNjQsZmxvYXQqXSpd "")
(register-lib-func xtminstruments_ext sampler_fx_adhoc_W1tmbG9hdCxmbG9hdCxpNjQsaTY0LGZsb2F0Kl0qXQ [[float,float,i64,i64,float*]*]* 0 "" '(let ((sampler_fx_adhoc_7 (lambda () (let ((notekernel:NOTE_KERNEL_SAMPLER null) (reverb (reverb_st_c)) (reverb_mix 0.14999999999999999445) (reverb_predelay 40.000000000000000000) (reverb_size 0.29999999999999998890) (reverb_absorb 0.45000000000000001110) (pan (pan_c (i32toi64 CHANNELS))) (pan_pos 0.50000000000000000000) (pan_width 1.0000000000000000000) (gain 2.0000000000000000000) (out 0.00000000000000000000)) (lambda (in:SAMPLE time:i64 chan:i64 dat:SAMPLE*) (set! out (pan chan in pan_width pan_pos)) (if (> reverb_mix 0.0010000000000000000208) (set! out (reverb chan out reverb_size reverb_predelay reverb_absorb reverb_mix))) (* gain out)))))) sampler_fx_adhoc_7))
(bind-poly sampler_fx sampler_fx_adhoc_W1tmbG9hdCxmbG9hdCxpNjQsaTY0LGZsb2F0Kl0qXQ "")
(register-lib-func xtminstruments_ext set_sampler_audiobuffer_adhoc_W2k2NCxbZmxvYXQsZmxvYXQsaTY0LGk2NCxmbG9hdCpdKixBdWRpb0J1ZmZlciosaTY0LGkzMl0 [i64,[float,float,i64,i64,float*]*,AudioBuffer*,i64,i32]* 0 "" '(let ((set_sampler_audiobuffer_adhoc_8 (lambda (inst:[SAMPLE,SAMPLE,i64,i64,SAMPLE*]* buf:AudioBuffer* index:i64 bank:i32) (let ((channels:i64 (AudioBuffer_channels buf)) (num (AudioBuffer_frames buf)) (adat:SAMPLE* (AudioBuffer_ptr buf 0 0)) (offsets:|20,|128,i64||* (inst.samples_offsets)) (samples:|20,|128,SAMPLE*||* (inst.samples)) (samples_channels:|20,|128,i64||* (inst.samples_channels)) (samples_length:|20,|128,i64||* (inst.samples_length))) (aset! (aref-ptr samples_channels bank) index (convert channels)) (aset! (aref-ptr samples bank) index adat) (aset! (aref-ptr offsets bank) index (AudioBuffer_loop_start buf)) (aset! (aref-ptr samples_length bank) index num) 1)))) set_sampler_audiobuffer_adhoc_8))
(bind-poly set_sampler_audiobuffer set_sampler_audiobuffer_adhoc_W2k2NCxbZmxvYXQsZmxvYXQsaTY0LGk2NCxmbG9hdCpdKixBdWRpb0J1ZmZlciosaTY0LGkzMl0 "")
(sys:load "libs/external/instruments_ext-scm.xtm")
(print-with-colors 'green 'default #t (print "done"))(print " in" (- (clock:clock) *xtmlib-instruments_ext-loaded-timer*) "seconds\n")
(define *xtmlib-instruments_ext-loaded-timer* (clock:clock))
(set! *impc:compiler:message:level* *impc:aot:prev-compiler-message-level*)
