@GLFW_VERSION_MAJOR = dllexport global i32 3
@GLFW_VERSION_MINOR = dllexport global i32 2
@GLFW_VERSION_REVISION = dllexport global i32 0
@GLFW_TRUE = dllexport global i32 1
@GLFW_FALSE = dllexport global i32 0
@GLFW_RELEASE = dllexport global i32 0
@GLFW_PRESS = dllexport global i32 1
@GLFW_REPEAT = dllexport global i32 2
@GLFW_KEY_UNKNOWN = dllexport global i32 -1
@GLFW_KEY_SPACE = dllexport global i32 32
@GLFW_KEY_APOSTROPHE = dllexport global i32 39
@GLFW_KEY_COMMA = dllexport global i32 44
@GLFW_KEY_MINUS = dllexport global i32 45
@GLFW_KEY_PERIOD = dllexport global i32 46
@GLFW_KEY_SLASH = dllexport global i32 47
@GLFW_KEY_0 = dllexport global i32 48
@GLFW_KEY_1 = dllexport global i32 49
@GLFW_KEY_2 = dllexport global i32 50
@GLFW_KEY_3 = dllexport global i32 51
@GLFW_KEY_4 = dllexport global i32 52
@GLFW_KEY_5 = dllexport global i32 53
@GLFW_KEY_6 = dllexport global i32 54
@GLFW_KEY_7 = dllexport global i32 55
@GLFW_KEY_8 = dllexport global i32 56
@GLFW_KEY_9 = dllexport global i32 57
@GLFW_KEY_SEMICOLON = dllexport global i32 59
@GLFW_KEY_EQUAL = dllexport global i32 61
@GLFW_KEY_A = dllexport global i32 65
@GLFW_KEY_B = dllexport global i32 66
@GLFW_KEY_C = dllexport global i32 67
@GLFW_KEY_D = dllexport global i32 68
@GLFW_KEY_E = dllexport global i32 69
@GLFW_KEY_F = dllexport global i32 70
@GLFW_KEY_G = dllexport global i32 71
@GLFW_KEY_H = dllexport global i32 72
@GLFW_KEY_I = dllexport global i32 73
@GLFW_KEY_J = dllexport global i32 74
@GLFW_KEY_K = dllexport global i32 75
@GLFW_KEY_L = dllexport global i32 76
@GLFW_KEY_M = dllexport global i32 77
@GLFW_KEY_N = dllexport global i32 78
@GLFW_KEY_O = dllexport global i32 79
@GLFW_KEY_P = dllexport global i32 80
@GLFW_KEY_Q = dllexport global i32 81
@GLFW_KEY_R = dllexport global i32 82
@GLFW_KEY_S = dllexport global i32 83
@GLFW_KEY_T = dllexport global i32 84
@GLFW_KEY_U = dllexport global i32 85
@GLFW_KEY_V = dllexport global i32 86
@GLFW_KEY_W = dllexport global i32 87
@GLFW_KEY_X = dllexport global i32 88
@GLFW_KEY_Y = dllexport global i32 89
@GLFW_KEY_Z = dllexport global i32 90
@GLFW_KEY_LEFT_BRACKET = dllexport global i32 91
@GLFW_KEY_BACKSLASH = dllexport global i32 92
@GLFW_KEY_RIGHT_BRACKET = dllexport global i32 93
@GLFW_KEY_GRAVE_ACCENT = dllexport global i32 96
@GLFW_KEY_WORLD_1 = dllexport global i32 161
@GLFW_KEY_WORLD_2 = dllexport global i32 162
@GLFW_KEY_ESCAPE = dllexport global i32 256
@GLFW_KEY_ENTER = dllexport global i32 257
@GLFW_KEY_TAB = dllexport global i32 258
@GLFW_KEY_BACKSPACE = dllexport global i32 259
@GLFW_KEY_INSERT = dllexport global i32 260
@GLFW_KEY_DELETE = dllexport global i32 261
@GLFW_KEY_RIGHT = dllexport global i32 262
@GLFW_KEY_LEFT = dllexport global i32 263
@GLFW_KEY_DOWN = dllexport global i32 264
@GLFW_KEY_UP = dllexport global i32 265
@GLFW_KEY_PAGE_UP = dllexport global i32 266
@GLFW_KEY_PAGE_DOWN = dllexport global i32 267
@GLFW_KEY_HOME = dllexport global i32 268
@GLFW_KEY_END = dllexport global i32 269
@GLFW_KEY_CAPS_LOCK = dllexport global i32 280
@GLFW_KEY_SCROLL_LOCK = dllexport global i32 281
@GLFW_KEY_NUM_LOCK = dllexport global i32 282
@GLFW_KEY_PRINT_SCREEN = dllexport global i32 283
@GLFW_KEY_PAUSE = dllexport global i32 284
@GLFW_KEY_F1 = dllexport global i32 290
@GLFW_KEY_F2 = dllexport global i32 291
@GLFW_KEY_F3 = dllexport global i32 292
@GLFW_KEY_F4 = dllexport global i32 293
@GLFW_KEY_F5 = dllexport global i32 294
@GLFW_KEY_F6 = dllexport global i32 295
@GLFW_KEY_F7 = dllexport global i32 296
@GLFW_KEY_F8 = dllexport global i32 297
@GLFW_KEY_F9 = dllexport global i32 298
@GLFW_KEY_F10 = dllexport global i32 299
@GLFW_KEY_F11 = dllexport global i32 300
@GLFW_KEY_F12 = dllexport global i32 301
@GLFW_KEY_F13 = dllexport global i32 302
@GLFW_KEY_F14 = dllexport global i32 303
@GLFW_KEY_F15 = dllexport global i32 304
@GLFW_KEY_F16 = dllexport global i32 305
@GLFW_KEY_F17 = dllexport global i32 306
@GLFW_KEY_F18 = dllexport global i32 307
@GLFW_KEY_F19 = dllexport global i32 308
@GLFW_KEY_F20 = dllexport global i32 309
@GLFW_KEY_F21 = dllexport global i32 310
@GLFW_KEY_F22 = dllexport global i32 311
@GLFW_KEY_F23 = dllexport global i32 312
@GLFW_KEY_F24 = dllexport global i32 313
@GLFW_KEY_F25 = dllexport global i32 314
@GLFW_KEY_KP_0 = dllexport global i32 320
@GLFW_KEY_KP_1 = dllexport global i32 321
@GLFW_KEY_KP_2 = dllexport global i32 322
@GLFW_KEY_KP_3 = dllexport global i32 323
@GLFW_KEY_KP_4 = dllexport global i32 324
@GLFW_KEY_KP_5 = dllexport global i32 325
@GLFW_KEY_KP_6 = dllexport global i32 326
@GLFW_KEY_KP_7 = dllexport global i32 327
@GLFW_KEY_KP_8 = dllexport global i32 328
@GLFW_KEY_KP_9 = dllexport global i32 329
@GLFW_KEY_KP_DECIMAL = dllexport global i32 330
@GLFW_KEY_KP_DIVIDE = dllexport global i32 331
@GLFW_KEY_KP_MULTIPLY = dllexport global i32 332
@GLFW_KEY_KP_SUBTRACT = dllexport global i32 333
@GLFW_KEY_KP_ADD = dllexport global i32 334
@GLFW_KEY_KP_ENTER = dllexport global i32 335
@GLFW_KEY_KP_EQUAL = dllexport global i32 336
@GLFW_KEY_LEFT_SHIFT = dllexport global i32 340
@GLFW_KEY_LEFT_CONTROL = dllexport global i32 341
@GLFW_KEY_LEFT_ALT = dllexport global i32 342
@GLFW_KEY_LEFT_SUPER = dllexport global i32 343
@GLFW_KEY_RIGHT_SHIFT = dllexport global i32 344
@GLFW_KEY_RIGHT_CONTROL = dllexport global i32 345
@GLFW_KEY_RIGHT_ALT = dllexport global i32 346
@GLFW_KEY_RIGHT_SUPER = dllexport global i32 347
@GLFW_KEY_MENU = dllexport global i32 348
@GLFW_KEY_LAST = dllexport global i32 zeroinitializer
@GLFW_MOD_SHIFT = dllexport global i32 1
@GLFW_MOD_CONTROL = dllexport global i32 2
@GLFW_MOD_ALT = dllexport global i32 4
@GLFW_MOD_SUPER = dllexport global i32 8
@GLFW_MOUSE_BUTTON_1 = dllexport global i32 0
@GLFW_MOUSE_BUTTON_2 = dllexport global i32 1
@GLFW_MOUSE_BUTTON_3 = dllexport global i32 2
@GLFW_MOUSE_BUTTON_4 = dllexport global i32 3
@GLFW_MOUSE_BUTTON_5 = dllexport global i32 4
@GLFW_MOUSE_BUTTON_6 = dllexport global i32 5
@GLFW_MOUSE_BUTTON_7 = dllexport global i32 6
@GLFW_MOUSE_BUTTON_8 = dllexport global i32 7
@GLFW_MOUSE_BUTTON_LAST = dllexport global i32 zeroinitializer
@GLFW_MOUSE_BUTTON_LEFT = dllexport global i32 zeroinitializer
@GLFW_MOUSE_BUTTON_RIGHT = dllexport global i32 zeroinitializer
@GLFW_MOUSE_BUTTON_MIDDLE = dllexport global i32 zeroinitializer
@GLFW_JOYSTICK_1 = dllexport global i32 0
@GLFW_JOYSTICK_2 = dllexport global i32 1
@GLFW_JOYSTICK_3 = dllexport global i32 2
@GLFW_JOYSTICK_4 = dllexport global i32 3
@GLFW_JOYSTICK_5 = dllexport global i32 4
@GLFW_JOYSTICK_6 = dllexport global i32 5
@GLFW_JOYSTICK_7 = dllexport global i32 6
@GLFW_JOYSTICK_8 = dllexport global i32 7
@GLFW_JOYSTICK_9 = dllexport global i32 8
@GLFW_JOYSTICK_10 = dllexport global i32 9
@GLFW_JOYSTICK_11 = dllexport global i32 10
@GLFW_JOYSTICK_12 = dllexport global i32 11
@GLFW_JOYSTICK_13 = dllexport global i32 12
@GLFW_JOYSTICK_14 = dllexport global i32 13
@GLFW_JOYSTICK_15 = dllexport global i32 14
@GLFW_JOYSTICK_16 = dllexport global i32 15
@GLFW_JOYSTICK_LAST = dllexport global i32 zeroinitializer
@GLFW_NOT_INITIALIZED = dllexport global i32 65537
@GLFW_NO_CURRENT_CONTEXT = dllexport global i32 65538
@GLFW_INVALID_ENUM = dllexport global i32 65539
@GLFW_INVALID_VALUE = dllexport global i32 65540
@GLFW_OUT_OF_MEMORY = dllexport global i32 65541
@GLFW_API_UNAVAILABLE = dllexport global i32 65542
@GLFW_VERSION_UNAVAILABLE = dllexport global i32 65543
@GLFW_PLATFORM_ERROR = dllexport global i32 65544
@GLFW_FORMAT_UNAVAILABLE = dllexport global i32 65545
@GLFW_NO_WINDOW_CONTEXT = dllexport global i32 65546
@GLFW_FOCUSED = dllexport global i32 131073
@GLFW_ICONIFIED = dllexport global i32 131074
@GLFW_RESIZABLE = dllexport global i32 131075
@GLFW_VISIBLE = dllexport global i32 131076
@GLFW_DECORATED = dllexport global i32 131077
@GLFW_AUTO_ICONIFY = dllexport global i32 131078
@GLFW_FLOATING = dllexport global i32 131079
@GLFW_MAXIMIZED = dllexport global i32 131080
@GLFW_RED_BITS = dllexport global i32 135169
@GLFW_GREEN_BITS = dllexport global i32 135170
@GLFW_BLUE_BITS = dllexport global i32 135171
@GLFW_ALPHA_BITS = dllexport global i32 135172
@GLFW_DEPTH_BITS = dllexport global i32 135173
@GLFW_STENCIL_BITS = dllexport global i32 135174
@GLFW_ACCUM_RED_BITS = dllexport global i32 135175
@GLFW_ACCUM_GREEN_BITS = dllexport global i32 135176
@GLFW_ACCUM_BLUE_BITS = dllexport global i32 135177
@GLFW_ACCUM_ALPHA_BITS = dllexport global i32 135178
@GLFW_AUX_BUFFERS = dllexport global i32 135179
@GLFW_STEREO = dllexport global i32 135180
@GLFW_SAMPLES = dllexport global i32 135181
@GLFW_SRGB_CAPABLE = dllexport global i32 135182
@GLFW_REFRESH_RATE = dllexport global i32 135183
@GLFW_DOUBLEBUFFER = dllexport global i32 135184
@GLFW_CLIENT_API = dllexport global i32 139265
@GLFW_CONTEXT_VERSION_MAJOR = dllexport global i32 139266
@GLFW_CONTEXT_VERSION_MINOR = dllexport global i32 139267
@GLFW_CONTEXT_REVISION = dllexport global i32 139268
@GLFW_CONTEXT_ROBUSTNESS = dllexport global i32 139269
@GLFW_OPENGL_FORWARD_COMPAT = dllexport global i32 139270
@GLFW_OPENGL_DEBUG_CONTEXT = dllexport global i32 139271
@GLFW_OPENGL_PROFILE = dllexport global i32 139272
@GLFW_CONTEXT_RELEASE_BEHAVIOR = dllexport global i32 139273
@GLFW_CONTEXT_NO_ERROR = dllexport global i32 139274
@GLFW_CONTEXT_CREATION_API = dllexport global i32 139275
@GLFW_NO_API = dllexport global i32 0
@GLFW_OPENGL_API = dllexport global i32 196609
@GLFW_OPENGL_ES_API = dllexport global i32 196610
@GLFW_NO_ROBUSTNESS = dllexport global i32 0
@GLFW_NO_RESET_NOTIFICATION = dllexport global i32 200705
@GLFW_LOSE_CONTEXT_ON_RESET = dllexport global i32 200706
@GLFW_OPENGL_ANY_PROFILE = dllexport global i32 0
@GLFW_OPENGL_CORE_PROFILE = dllexport global i32 204801
@GLFW_OPENGL_COMPAT_PROFILE = dllexport global i32 204802
@GLFW_CURSOR = dllexport global i32 208897
@GLFW_STICKY_KEYS = dllexport global i32 208898
@GLFW_STICKY_MOUSE_BUTTONS = dllexport global i32 208899
@GLFW_CURSOR_NORMAL = dllexport global i32 212993
@GLFW_CURSOR_HIDDEN = dllexport global i32 212994
@GLFW_CURSOR_DISABLED = dllexport global i32 212995
@GLFW_ANY_RELEASE_BEHAVIOR = dllexport global i32 0
@GLFW_RELEASE_BEHAVIOR_FLUSH = dllexport global i32 217089
@GLFW_RELEASE_BEHAVIOR_NONE = dllexport global i32 217090
@GLFW_NATIVE_CONTEXT_API = dllexport global i32 221185
@GLFW_EGL_CONTEXT_API = dllexport global i32 221186
@GLFW_ARROW_CURSOR = dllexport global i32 221185
@GLFW_IBEAM_CURSOR = dllexport global i32 221186
@GLFW_CROSSHAIR_CURSOR = dllexport global i32 221187
@GLFW_HAND_CURSOR = dllexport global i32 221188
@GLFW_HRESIZE_CURSOR = dllexport global i32 221189
@GLFW_VRESIZE_CURSOR = dllexport global i32 221190
@GLFW_CONNECTED = dllexport global i32 262145
@GLFW_DISCONNECTED = dllexport global i32 262146
@GLFW_DONT_CARE = dllexport global i32 zeroinitializer
%GLFWvidmode = type {i32,i32,i32,i32,i32,i32}
@gsxtmglfw30 = hidden constant [70 x i8] c"GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0\00"
@gsxtmglfw31 = hidden constant [70 x i8] c"{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**\00"
define dllexport fastcc %GLFWvidmode* @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0__1(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}*
%GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**** %GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr


%tzone7 = load i8*, i8** %_impzPtr
%zone8 = bitcast i8* %tzone7 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWvidmode*
%tzone3 = load i8*, i8** %_impzPtr
%zone4 = bitcast i8* %tzone3 to %mzone*
%dat5 = call i8* @llvm_zone_malloc(%mzone* %zone4, i64 24)
call i8* @memset(i8* %dat5, i32 0, i64 24)
%val6 = bitcast i8* %dat5 to %GLFWvidmode*

; let value assignment
%obj = select i1 true, %GLFWvidmode* %val6, %GLFWvidmode* %val6
store %GLFWvidmode* %obj, %GLFWvidmode** %objPtr

%val9 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val10 = load i32, i32* %arg_0Ptr
; set tuple
%val11 = getelementptr %GLFWvidmode, %GLFWvidmode* %val9, i64 0, i32 0
store i32 %val10, i32* %val11
%val12 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val13 = load i32, i32* %arg_1Ptr
; set tuple
%val14 = getelementptr %GLFWvidmode, %GLFWvidmode* %val12, i64 0, i32 1
store i32 %val13, i32* %val14
%val15 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val16 = load i32, i32* %arg_2Ptr
; set tuple
%val17 = getelementptr %GLFWvidmode, %GLFWvidmode* %val15, i64 0, i32 2
store i32 %val16, i32* %val17
%val18 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val19 = load i32, i32* %arg_3Ptr
; set tuple
%val20 = getelementptr %GLFWvidmode, %GLFWvidmode* %val18, i64 0, i32 3
store i32 %val19, i32* %val20
%val21 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val22 = load i32, i32* %arg_4Ptr
; set tuple
%val23 = getelementptr %GLFWvidmode, %GLFWvidmode* %val21, i64 0, i32 4
store i32 %val22, i32* %val23
%val24 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val25 = load i32, i32* %arg_5Ptr
; set tuple
%val26 = getelementptr %GLFWvidmode, %GLFWvidmode* %val24, i64 0, i32 5
store i32 %val25, i32* %val26
%val27 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
ret %GLFWvidmode* %val27
}
@gsxtmglfw32 = hidden constant [123 x i8] c"GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone47 = load i8*, i8** %_impzPtr
%zone48 = bitcast i8* %tzone47 to %mzone*

; let assign value to symbol GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0
%dat_GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone48, i64 8)
%GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***
%tzone28 = load i8*, i8** %_impzPtr
%zone29 = bitcast i8* %tzone28 to %mzone*
call void @llvm_zone_mark(%mzone* %zone29)
; malloc closure structure
%clsptr30 = call i8* @llvm_zone_malloc(%mzone* %zone29, i64 24)
%closure31 = bitcast i8* %clsptr30 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr32 = call i8* @llvm_zone_malloc(%mzone* %zone29, i64 8)
%environment33 = bitcast i8* %envptr32 to {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable34 = call %clsvar* @new_address_table()
%var35 = bitcast [70 x i8]* @gsxtmglfw30 to i8*
%var36 = bitcast [70 x i8]* @gsxtmglfw31 to i8*
%addytable37 = call %clsvar* @add_address_table(%mzone* %zone29, i8* %var35, i32 0, i8* %var36, i32 3, %clsvar* %addytable34)
%address-table38 = bitcast %clsvar* %addytable37 to i8*

; insert table, function and environment into closure struct
%closure.table41 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure31, i32 0, i32 0
store i8* %address-table38, i8** %closure.table41
%closure.env42 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure31, i32 0, i32 1
store i8* %envptr32, i8** %closure.env42
%closure.func43 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure31, i32 0, i32 2
store %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)* @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0__1, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %closure.func43
%closure_size44 = call i64 @llvm_zone_mark_size(%mzone* %zone29)
call void @llvm_zone_ptr_set_size(i8* %clsptr30, i64 %closure_size44)
%wrapper_ptr45 = call i8* @llvm_zone_malloc(%mzone* %zone29, i64 8)
%closure_wrapper46 = bitcast i8* %wrapper_ptr45 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure31, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_wrapper46

; let value assignment
%GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_wrapper46, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_wrapper46
store { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*** %GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0
%tmp_envptr40 = getelementptr {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}* %environment33, i32 0, i32 0
store {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*** %GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**** %tmp_envptr40


%val49 = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*** %GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %val49
}


@GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWvidmode* @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %GLFWvidmode* %result
}


define dllexport ccc %GLFWvidmode* @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %GLFWvidmode* %result
}


define dllexport ccc i8*  @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var50 = bitcast [123 x i8]* @gsxtmglfw32 to i8*
call i32 (i8*, ...) @printf(i8* %var50)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var51 = bitcast [123 x i8]* @gsxtmglfw32 to i8*
call i32 (i8*, ...) @printf(i8* %var51)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var52 = bitcast [123 x i8]* @gsxtmglfw32 to i8*
call i32 (i8*, ...) @printf(i8* %var52)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var53 = bitcast [123 x i8]* @gsxtmglfw32 to i8*
call i32 (i8*, ...) @printf(i8* %var53)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var54 = bitcast [123 x i8]* @gsxtmglfw32 to i8*
call i32 (i8*, ...) @printf(i8* %var54)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var55 = bitcast [123 x i8]* @gsxtmglfw32 to i8*
call i32 (i8*, ...) @printf(i8* %var55)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%tmpres = bitcast %GLFWvidmode* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw33 = hidden constant [72 x i8] c"GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0\00"
define dllexport fastcc %GLFWvidmode* @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0__56(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone57 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}*
%GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**** %GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr


%tzone62 = load i8*, i8** %_impzPtr
%zone63 = bitcast i8* %tzone62 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWvidmode*
%tzone58 = load i8*, i8** %_impzPtr
%zone59 = bitcast i8* %tzone58 to %mzone*
%dat60 = call i8* @llvm_zone_malloc(%mzone* %zone59, i64 24)
call i8* @memset(i8* %dat60, i32 0, i64 24)
%val61 = bitcast i8* %dat60 to %GLFWvidmode*

; let value assignment
%obj = select i1 true, %GLFWvidmode* %val61, %GLFWvidmode* %val61
store %GLFWvidmode* %obj, %GLFWvidmode** %objPtr

%val64 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val65 = load i32, i32* %arg_0Ptr
; set tuple
%val66 = getelementptr %GLFWvidmode, %GLFWvidmode* %val64, i64 0, i32 0
store i32 %val65, i32* %val66
%val67 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val68 = load i32, i32* %arg_1Ptr
; set tuple
%val69 = getelementptr %GLFWvidmode, %GLFWvidmode* %val67, i64 0, i32 1
store i32 %val68, i32* %val69
%val70 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val71 = load i32, i32* %arg_2Ptr
; set tuple
%val72 = getelementptr %GLFWvidmode, %GLFWvidmode* %val70, i64 0, i32 2
store i32 %val71, i32* %val72
%val73 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val74 = load i32, i32* %arg_3Ptr
; set tuple
%val75 = getelementptr %GLFWvidmode, %GLFWvidmode* %val73, i64 0, i32 3
store i32 %val74, i32* %val75
%val76 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val77 = load i32, i32* %arg_4Ptr
; set tuple
%val78 = getelementptr %GLFWvidmode, %GLFWvidmode* %val76, i64 0, i32 4
store i32 %val77, i32* %val78
%val79 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val80 = load i32, i32* %arg_5Ptr
; set tuple
%val81 = getelementptr %GLFWvidmode, %GLFWvidmode* %val79, i64 0, i32 5
store i32 %val80, i32* %val81
%val82 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
ret %GLFWvidmode* %val82
}
@gsxtmglfw34 = hidden constant [125 x i8] c"GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone102 = load i8*, i8** %_impzPtr
%zone103 = bitcast i8* %tzone102 to %mzone*

; let assign value to symbol GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0
%dat_GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone103, i64 8)
%GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***
%tzone83 = load i8*, i8** %_impzPtr
%zone84 = bitcast i8* %tzone83 to %mzone*
call void @llvm_zone_mark(%mzone* %zone84)
; malloc closure structure
%clsptr85 = call i8* @llvm_zone_malloc(%mzone* %zone84, i64 24)
%closure86 = bitcast i8* %clsptr85 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr87 = call i8* @llvm_zone_malloc(%mzone* %zone84, i64 8)
%environment88 = bitcast i8* %envptr87 to {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable89 = call %clsvar* @new_address_table()
%var90 = bitcast [72 x i8]* @gsxtmglfw33 to i8*
%var91 = bitcast [70 x i8]* @gsxtmglfw31 to i8*
%addytable92 = call %clsvar* @add_address_table(%mzone* %zone84, i8* %var90, i32 0, i8* %var91, i32 3, %clsvar* %addytable89)
%address-table93 = bitcast %clsvar* %addytable92 to i8*

; insert table, function and environment into closure struct
%closure.table96 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure86, i32 0, i32 0
store i8* %address-table93, i8** %closure.table96
%closure.env97 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure86, i32 0, i32 1
store i8* %envptr87, i8** %closure.env97
%closure.func98 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure86, i32 0, i32 2
store %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)* @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0__56, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %closure.func98
%closure_size99 = call i64 @llvm_zone_mark_size(%mzone* %zone84)
call void @llvm_zone_ptr_set_size(i8* %clsptr85, i64 %closure_size99)
%wrapper_ptr100 = call i8* @llvm_zone_malloc(%mzone* %zone84, i64 8)
%closure_wrapper101 = bitcast i8* %wrapper_ptr100 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure86, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_wrapper101

; let value assignment
%GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_wrapper101, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_wrapper101
store { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*** %GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0
%tmp_envptr95 = getelementptr {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}* %environment88, i32 0, i32 0
store {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*** %GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**** %tmp_envptr95


%val104 = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*** %GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %val104
}


@GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWvidmode* @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %GLFWvidmode* %result
}


define dllexport ccc %GLFWvidmode* @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %GLFWvidmode* %result
}


define dllexport ccc i8*  @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var105 = bitcast [125 x i8]* @gsxtmglfw34 to i8*
call i32 (i8*, ...) @printf(i8* %var105)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var106 = bitcast [125 x i8]* @gsxtmglfw34 to i8*
call i32 (i8*, ...) @printf(i8* %var106)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var107 = bitcast [125 x i8]* @gsxtmglfw34 to i8*
call i32 (i8*, ...) @printf(i8* %var107)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var108 = bitcast [125 x i8]* @gsxtmglfw34 to i8*
call i32 (i8*, ...) @printf(i8* %var108)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var109 = bitcast [125 x i8]* @gsxtmglfw34 to i8*
call i32 (i8*, ...) @printf(i8* %var109)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var110 = bitcast [125 x i8]* @gsxtmglfw34 to i8*
call i32 (i8*, ...) @printf(i8* %var110)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%tmpres = bitcast %GLFWvidmode* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_z_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw35 = hidden constant [72 x i8] c"GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0\00"
define dllexport fastcc %GLFWvidmode* @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0__111(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone112 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}*
%GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**** %GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr


%tzone115 = load i8*, i8** %_impzPtr
%zone116 = bitcast i8* %tzone115 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWvidmode*
%dat113 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat113, i32 0, i64 24)
%val114 = bitcast i8* %dat113 to %GLFWvidmode*

; let value assignment
%obj = select i1 true, %GLFWvidmode* %val114, %GLFWvidmode* %val114
store %GLFWvidmode* %obj, %GLFWvidmode** %objPtr

%val117 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val118 = load i32, i32* %arg_0Ptr
; set tuple
%val119 = getelementptr %GLFWvidmode, %GLFWvidmode* %val117, i64 0, i32 0
store i32 %val118, i32* %val119
%val120 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val121 = load i32, i32* %arg_1Ptr
; set tuple
%val122 = getelementptr %GLFWvidmode, %GLFWvidmode* %val120, i64 0, i32 1
store i32 %val121, i32* %val122
%val123 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val124 = load i32, i32* %arg_2Ptr
; set tuple
%val125 = getelementptr %GLFWvidmode, %GLFWvidmode* %val123, i64 0, i32 2
store i32 %val124, i32* %val125
%val126 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val127 = load i32, i32* %arg_3Ptr
; set tuple
%val128 = getelementptr %GLFWvidmode, %GLFWvidmode* %val126, i64 0, i32 3
store i32 %val127, i32* %val128
%val129 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val130 = load i32, i32* %arg_4Ptr
; set tuple
%val131 = getelementptr %GLFWvidmode, %GLFWvidmode* %val129, i64 0, i32 4
store i32 %val130, i32* %val131
%val132 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val133 = load i32, i32* %arg_5Ptr
; set tuple
%val134 = getelementptr %GLFWvidmode, %GLFWvidmode* %val132, i64 0, i32 5
store i32 %val133, i32* %val134
%val135 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
ret %GLFWvidmode* %val135
}
@gsxtmglfw36 = hidden constant [125 x i8] c"GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone155 = load i8*, i8** %_impzPtr
%zone156 = bitcast i8* %tzone155 to %mzone*

; let assign value to symbol GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0
%dat_GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone156, i64 8)
%GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***
%tzone136 = load i8*, i8** %_impzPtr
%zone137 = bitcast i8* %tzone136 to %mzone*
call void @llvm_zone_mark(%mzone* %zone137)
; malloc closure structure
%clsptr138 = call i8* @llvm_zone_malloc(%mzone* %zone137, i64 24)
%closure139 = bitcast i8* %clsptr138 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr140 = call i8* @llvm_zone_malloc(%mzone* %zone137, i64 8)
%environment141 = bitcast i8* %envptr140 to {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable142 = call %clsvar* @new_address_table()
%var143 = bitcast [72 x i8]* @gsxtmglfw35 to i8*
%var144 = bitcast [70 x i8]* @gsxtmglfw31 to i8*
%addytable145 = call %clsvar* @add_address_table(%mzone* %zone137, i8* %var143, i32 0, i8* %var144, i32 3, %clsvar* %addytable142)
%address-table146 = bitcast %clsvar* %addytable145 to i8*

; insert table, function and environment into closure struct
%closure.table149 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure139, i32 0, i32 0
store i8* %address-table146, i8** %closure.table149
%closure.env150 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure139, i32 0, i32 1
store i8* %envptr140, i8** %closure.env150
%closure.func151 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure139, i32 0, i32 2
store %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)* @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0__111, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %closure.func151
%closure_size152 = call i64 @llvm_zone_mark_size(%mzone* %zone137)
call void @llvm_zone_ptr_set_size(i8* %clsptr138, i64 %closure_size152)
%wrapper_ptr153 = call i8* @llvm_zone_malloc(%mzone* %zone137, i64 8)
%closure_wrapper154 = bitcast i8* %wrapper_ptr153 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure139, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_wrapper154

; let value assignment
%GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_wrapper154, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_wrapper154
store { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0, { i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*** %GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0
%tmp_envptr148 = getelementptr {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}* %environment141, i32 0, i32 0
store {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*** %GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**** %tmp_envptr148


%val157 = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*** %GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %val157
}


@GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWvidmode* @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %GLFWvidmode* %result
}


define dllexport ccc %GLFWvidmode* @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %GLFWvidmode* %result
}


define dllexport ccc i8*  @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var158 = bitcast [125 x i8]* @gsxtmglfw36 to i8*
call i32 (i8*, ...) @printf(i8* %var158)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var159 = bitcast [125 x i8]* @gsxtmglfw36 to i8*
call i32 (i8*, ...) @printf(i8* %var159)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var160 = bitcast [125 x i8]* @gsxtmglfw36 to i8*
call i32 (i8*, ...) @printf(i8* %var160)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var161 = bitcast [125 x i8]* @gsxtmglfw36 to i8*
call i32 (i8*, ...) @printf(i8* %var161)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var162 = bitcast [125 x i8]* @gsxtmglfw36 to i8*
call i32 (i8*, ...) @printf(i8* %var162)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var163 = bitcast [125 x i8]* @gsxtmglfw36 to i8*
call i32 (i8*, ...) @printf(i8* %var163)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%tmpres = bitcast %GLFWvidmode* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_h_adhoc_W0dMRld2aWRtb2RlKixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode* (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw37 = hidden constant [3 x i8] c"%s\00"
@gsxtmglfw38 = hidden constant [19 x i8] c"<GLFWvidmode:null>\00"
@gsxtmglfw39 = hidden constant [14 x i8] c"<GLFWvidmode:\00"
@gsxtmglfw310 = hidden constant [2 x i8] c",\00"
@gsxtmglfw311 = hidden constant [2 x i8] c">\00"
@gsxtmglfw312 = hidden constant [46 x i8] c"toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ\00"
@gsxtmglfw313 = hidden constant [50 x i8] c"{i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ__164(i8* %_impz,i8* %_impenv, %GLFWvidmode* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone165 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}***}*
%toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}***, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}**** %toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQPtr_

; setup arguments
%xPtr = alloca %GLFWvidmode*
store %GLFWvidmode* %x, %GLFWvidmode** %xPtr


%val167 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
%val168 = icmp eq %GLFWvidmode* %val167, null
br i1 %val168, label %then166, label %else166

then166:
%zone169 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone169)
%zone_ptr170 = bitcast %mzone* %zone169 to i8*
store i8* %zone_ptr170, i8** %_impzPtr
%tzone180 = load i8*, i8** %_impzPtr
%zone181 = bitcast i8* %tzone180 to %mzone*

; let assign value to symbol res0
%res0Ptr = alloca %String*
%tzone185 = load i8*, i8** %_impzPtr
%zone186 = bitcast i8* %tzone185 to %mzone*

; let assign value to symbol zone0
%zone0Ptr = alloca %mzone*
%tzone188 = load i8*, i8** %_impzPtr
%zone189 = bitcast i8* %tzone188 to %mzone*

; let assign value to symbol newz0
%newz0Ptr = alloca %mzone*
%tzone172 = load i8*, i8** %_impzPtr
%zone173 = bitcast i8* %tzone172 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat171 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat171, i8* %dat171
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val174 = load i8*, i8** %xx_t_mstPtr
%var175 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var176 = bitcast [19 x i8]* @gsxtmglfw38 to i8*

%val177 = call i32 (i8*,i8*, ...) @sprintf(i8* %val174, i8* %var175, i8* %var176)
%val178 = load i8*, i8** %xx_t_mstPtr
%res179 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val178)

; let value assignment
%res0 = select i1 true, %String* %res179, %String* %res179
store %String* %res0, %String** %res0Ptr

%oldzone182 = call %mzone* @llvm_pop_zone_stack()
%newzone183 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr184 = bitcast %mzone* %newzone183 to i8*
store i8* %zone_ptr184, i8** %_impzPtr

; let value assignment
%zone0 = select i1 true, %mzone* %oldzone182, %mzone* %oldzone182
store %mzone* %zone0, %mzone** %zone0Ptr

%res187 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz0 = select i1 true, %mzone* %res187, %mzone* %res187
store %mzone* %newz0, %mzone** %newz0Ptr

%tzone194 = load i8*, i8** %_impzPtr
%zone195 = bitcast i8* %tzone194 to %mzone*

; let assign value to symbol rescopy0
%rescopy0Ptr = alloca %String*
%tzone200 = load i8*, i8** %_impzPtr
%zone201 = bitcast i8* %tzone200 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone203 = load i8*, i8** %_impzPtr
%zone204 = bitcast i8* %tzone203 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val190 = load %String*, %String** %res0Ptr
%val191 = load %mzone*, %mzone** %zone0Ptr
%val192 = load %mzone*, %mzone** %newz0Ptr
%res193 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val190, %mzone* %val191, %mzone* %val192)

; let value assignment
%rescopy0 = select i1 true, %String* %res193, %String* %res193
store %String* %rescopy0, %String** %rescopy0Ptr

%val196 = load %mzone*, %mzone** %zone0Ptr
; tuple ref
%val197 = getelementptr %mzone, %mzone* %val196, i64 0, i32 4
%val198 = load i8*, i8** %val197
%val199 = bitcast i8* %val198 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val199, {i64,i8*,i8*}* %val199
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null202 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null202, {i8*, i8*, void (i8*, i8*)*}** %null202
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone240 = load i8*, i8** %_impzPtr
%zone241 = bitcast i8* %tzone240 to %mzone*
%ifptr230 = alloca i1
%ifptr206 = alloca i1
; while loop
%val207 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val208 = icmp eq {i64,i8*,i8*}* %val207, null
br i1 %val208, label %then206, label %else206

then206:
%res209 = call ccc i1 @impc_false()
store i1 %res209, i1* %ifptr206
br label %ifcont206

else206:
%res210 = call ccc i1 @impc_true()
store i1 %res210, i1* %ifptr206
br label %ifcont206

ifcont206:
%ifres211 = load i1, i1* %ifptr206

br i1 %ifres211, label %loop205, label %after205

loop205:
; do set!
%val212 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val213 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val212, i64 0, i32 1
%val214 = load i8*, i8** %val213
%val215 = bitcast i8* %val214 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val215, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval216 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val217 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval216
%fPtr218 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val217, i32 0, i32 2
%ePtr219 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val217, i32 0, i32 1
%f220 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr218
%e221 = load i8*, i8** %ePtr219
%tzone222 = load i8*, i8** %_impzPtr
%zone223 = bitcast i8* %tzone222 to %mzone*
%z224 = bitcast %mzone* %zone223 to i8*
tail call fastcc void %f220(i8* %z224, i8* %e221)
; do set!
%val226 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val227 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val226, i64 0, i32 2
%val228 = load i8*, i8** %val227
%val229 = bitcast i8* %val228 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val229, {i64,i8*,i8*}** %hookPtr
%val231 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val232 = icmp eq {i64,i8*,i8*}* %val231, null
br i1 %val232, label %then230, label %else230

then230:
%res233 = call ccc i1 @impc_false()
store i1 %res233, i1* %ifptr230
br label %ifcont230

else230:
%res234 = call ccc i1 @impc_true()
store i1 %res234, i1* %ifptr230
br label %ifcont230

ifcont230:
%ifres235 = load i1, i1* %ifptr230

br i1 %ifres235, label %loop205, label %after205

after205:
%val237 = load %mzone*, %mzone** %zone0Ptr
call ccc void @llvm_zone_destroy(%mzone* %val237)
%val239 = load %String*, %String** %rescopy0Ptr
ret %String* %val239

else166:
%zone242 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone242)
%zone_ptr243 = bitcast %mzone* %zone242 to i8*
store i8* %zone_ptr243, i8** %_impzPtr
%tzone343 = load i8*, i8** %_impzPtr
%zone344 = bitcast i8* %tzone343 to %mzone*

; let assign value to symbol res1
%res1Ptr = alloca %String*
%tzone348 = load i8*, i8** %_impzPtr
%zone349 = bitcast i8* %tzone348 to %mzone*

; let assign value to symbol zone1
%zone1Ptr = alloca %mzone*
%tzone351 = load i8*, i8** %_impzPtr
%zone352 = bitcast i8* %tzone351 to %mzone*

; let assign value to symbol newz1
%newz1Ptr = alloca %mzone*
%tzone245 = load i8*, i8** %_impzPtr
%zone246 = bitcast i8* %tzone245 to %mzone*

; let assign value to symbol xx_t_mst_s_1
%xx_t_mst_s_1Ptr = alloca i8*
%dat244 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_1 = select i1 true, i8* %dat244, i8* %dat244
store i8* %xx_t_mst_s_1, i8** %xx_t_mst_s_1Ptr

%val247 = load i8*, i8** %xx_t_mst_s_1Ptr
%var248 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var249 = bitcast [14 x i8]* @gsxtmglfw39 to i8*

%val250 = call i32 (i8*,i8*, ...) @sprintf(i8* %val247, i8* %var248, i8* %var249)
%val251 = load i8*, i8** %xx_t_mst_s_1Ptr
%res252 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val251)
%val253 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val254 = getelementptr %GLFWvidmode, %GLFWvidmode* %val253, i64 0, i32 0
%val255 = load i32, i32* %val254
%res256 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val255)
%res257 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res252, %String* %res256)
%tzone259 = load i8*, i8** %_impzPtr
%zone260 = bitcast i8* %tzone259 to %mzone*

; let assign value to symbol xx_t_mst_s_2
%xx_t_mst_s_2Ptr = alloca i8*
%dat258 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_2 = select i1 true, i8* %dat258, i8* %dat258
store i8* %xx_t_mst_s_2, i8** %xx_t_mst_s_2Ptr

%val261 = load i8*, i8** %xx_t_mst_s_2Ptr
%var262 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var263 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val264 = call i32 (i8*,i8*, ...) @sprintf(i8* %val261, i8* %var262, i8* %var263)
%val265 = load i8*, i8** %xx_t_mst_s_2Ptr
%res266 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val265)
%res267 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res257, %String* %res266)
%val268 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val269 = getelementptr %GLFWvidmode, %GLFWvidmode* %val268, i64 0, i32 1
%val270 = load i32, i32* %val269
%res271 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val270)
%res272 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res267, %String* %res271)
%tzone274 = load i8*, i8** %_impzPtr
%zone275 = bitcast i8* %tzone274 to %mzone*

; let assign value to symbol xx_t_mst_s_3
%xx_t_mst_s_3Ptr = alloca i8*
%dat273 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_3 = select i1 true, i8* %dat273, i8* %dat273
store i8* %xx_t_mst_s_3, i8** %xx_t_mst_s_3Ptr

%val276 = load i8*, i8** %xx_t_mst_s_3Ptr
%var277 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var278 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val279 = call i32 (i8*,i8*, ...) @sprintf(i8* %val276, i8* %var277, i8* %var278)
%val280 = load i8*, i8** %xx_t_mst_s_3Ptr
%res281 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val280)
%res282 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res272, %String* %res281)
%val283 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val284 = getelementptr %GLFWvidmode, %GLFWvidmode* %val283, i64 0, i32 2
%val285 = load i32, i32* %val284
%res286 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val285)
%res287 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res282, %String* %res286)
%tzone289 = load i8*, i8** %_impzPtr
%zone290 = bitcast i8* %tzone289 to %mzone*

; let assign value to symbol xx_t_mst_s_4
%xx_t_mst_s_4Ptr = alloca i8*
%dat288 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_4 = select i1 true, i8* %dat288, i8* %dat288
store i8* %xx_t_mst_s_4, i8** %xx_t_mst_s_4Ptr

%val291 = load i8*, i8** %xx_t_mst_s_4Ptr
%var292 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var293 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val294 = call i32 (i8*,i8*, ...) @sprintf(i8* %val291, i8* %var292, i8* %var293)
%val295 = load i8*, i8** %xx_t_mst_s_4Ptr
%res296 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val295)
%res297 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res287, %String* %res296)
%val298 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val299 = getelementptr %GLFWvidmode, %GLFWvidmode* %val298, i64 0, i32 3
%val300 = load i32, i32* %val299
%res301 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val300)
%res302 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res297, %String* %res301)
%tzone304 = load i8*, i8** %_impzPtr
%zone305 = bitcast i8* %tzone304 to %mzone*

; let assign value to symbol xx_t_mst_s_5
%xx_t_mst_s_5Ptr = alloca i8*
%dat303 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_5 = select i1 true, i8* %dat303, i8* %dat303
store i8* %xx_t_mst_s_5, i8** %xx_t_mst_s_5Ptr

%val306 = load i8*, i8** %xx_t_mst_s_5Ptr
%var307 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var308 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val309 = call i32 (i8*,i8*, ...) @sprintf(i8* %val306, i8* %var307, i8* %var308)
%val310 = load i8*, i8** %xx_t_mst_s_5Ptr
%res311 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val310)
%res312 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res302, %String* %res311)
%val313 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val314 = getelementptr %GLFWvidmode, %GLFWvidmode* %val313, i64 0, i32 4
%val315 = load i32, i32* %val314
%res316 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val315)
%res317 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res312, %String* %res316)
%tzone319 = load i8*, i8** %_impzPtr
%zone320 = bitcast i8* %tzone319 to %mzone*

; let assign value to symbol xx_t_mst_s_6
%xx_t_mst_s_6Ptr = alloca i8*
%dat318 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_6 = select i1 true, i8* %dat318, i8* %dat318
store i8* %xx_t_mst_s_6, i8** %xx_t_mst_s_6Ptr

%val321 = load i8*, i8** %xx_t_mst_s_6Ptr
%var322 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var323 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val324 = call i32 (i8*,i8*, ...) @sprintf(i8* %val321, i8* %var322, i8* %var323)
%val325 = load i8*, i8** %xx_t_mst_s_6Ptr
%res326 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val325)
%res327 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res317, %String* %res326)
%val328 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val329 = getelementptr %GLFWvidmode, %GLFWvidmode* %val328, i64 0, i32 5
%val330 = load i32, i32* %val329
%res331 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val330)
%res332 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res327, %String* %res331)
%tzone334 = load i8*, i8** %_impzPtr
%zone335 = bitcast i8* %tzone334 to %mzone*

; let assign value to symbol xx_t_mst_s_7
%xx_t_mst_s_7Ptr = alloca i8*
%dat333 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_7 = select i1 true, i8* %dat333, i8* %dat333
store i8* %xx_t_mst_s_7, i8** %xx_t_mst_s_7Ptr

%val336 = load i8*, i8** %xx_t_mst_s_7Ptr
%var337 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var338 = bitcast [2 x i8]* @gsxtmglfw311 to i8*

%val339 = call i32 (i8*,i8*, ...) @sprintf(i8* %val336, i8* %var337, i8* %var338)
%val340 = load i8*, i8** %xx_t_mst_s_7Ptr
%res341 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val340)
%res342 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res332, %String* %res341)

; let value assignment
%res1 = select i1 true, %String* %res342, %String* %res342
store %String* %res1, %String** %res1Ptr

%oldzone345 = call %mzone* @llvm_pop_zone_stack()
%newzone346 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr347 = bitcast %mzone* %newzone346 to i8*
store i8* %zone_ptr347, i8** %_impzPtr

; let value assignment
%zone1 = select i1 true, %mzone* %oldzone345, %mzone* %oldzone345
store %mzone* %zone1, %mzone** %zone1Ptr

%res350 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz1 = select i1 true, %mzone* %res350, %mzone* %res350
store %mzone* %newz1, %mzone** %newz1Ptr

%tzone357 = load i8*, i8** %_impzPtr
%zone358 = bitcast i8* %tzone357 to %mzone*

; let assign value to symbol rescopy1
%rescopy1Ptr = alloca %String*
%tzone363 = load i8*, i8** %_impzPtr
%zone364 = bitcast i8* %tzone363 to %mzone*

; let assign value to symbol hook_s_8
%hook_s_8Ptr = alloca {i64,i8*,i8*}*
%tzone366 = load i8*, i8** %_impzPtr
%zone367 = bitcast i8* %tzone366 to %mzone*

; let assign value to symbol f_s_9
%f_s_9Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val353 = load %String*, %String** %res1Ptr
%val354 = load %mzone*, %mzone** %zone1Ptr
%val355 = load %mzone*, %mzone** %newz1Ptr
%res356 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val353, %mzone* %val354, %mzone* %val355)

; let value assignment
%rescopy1 = select i1 true, %String* %res356, %String* %res356
store %String* %rescopy1, %String** %rescopy1Ptr

%val359 = load %mzone*, %mzone** %zone1Ptr
; tuple ref
%val360 = getelementptr %mzone, %mzone* %val359, i64 0, i32 4
%val361 = load i8*, i8** %val360
%val362 = bitcast i8* %val361 to {i64,i8*,i8*}*

; let value assignment
%hook_s_8 = select i1 true, {i64,i8*,i8*}* %val362, {i64,i8*,i8*}* %val362
store {i64,i8*,i8*}* %hook_s_8, {i64,i8*,i8*}** %hook_s_8Ptr

%null365 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_9 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null365, {i8*, i8*, void (i8*, i8*)*}** %null365
store {i8*, i8*, void (i8*, i8*)*}** %f_s_9, {i8*, i8*, void (i8*, i8*)*}*** %f_s_9Ptr

; promote local stack var allocations
%tzone403 = load i8*, i8** %_impzPtr
%zone404 = bitcast i8* %tzone403 to %mzone*
%ifptr393 = alloca i1
%ifptr369 = alloca i1
; while loop
%val370 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_8Ptr
%val371 = icmp eq {i64,i8*,i8*}* %val370, null
br i1 %val371, label %then369, label %else369

then369:
%res372 = call ccc i1 @impc_false()
store i1 %res372, i1* %ifptr369
br label %ifcont369

else369:
%res373 = call ccc i1 @impc_true()
store i1 %res373, i1* %ifptr369
br label %ifcont369

ifcont369:
%ifres374 = load i1, i1* %ifptr369

br i1 %ifres374, label %loop368, label %after368

loop368:
; do set!
%val375 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_8Ptr
; tuple ref
%val376 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val375, i64 0, i32 1
%val377 = load i8*, i8** %val376
%val378 = bitcast i8* %val377 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val378, {i8*, i8*, void (i8*, i8*)*}*** %f_s_9Ptr

; apply closure 
%vval379 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_9Ptr
%val380 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval379
%fPtr381 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val380, i32 0, i32 2
%ePtr382 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val380, i32 0, i32 1
%f383 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr381
%e384 = load i8*, i8** %ePtr382
%tzone385 = load i8*, i8** %_impzPtr
%zone386 = bitcast i8* %tzone385 to %mzone*
%z387 = bitcast %mzone* %zone386 to i8*
tail call fastcc void %f383(i8* %z387, i8* %e384)
; do set!
%val389 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_8Ptr
; tuple ref
%val390 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val389, i64 0, i32 2
%val391 = load i8*, i8** %val390
%val392 = bitcast i8* %val391 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val392, {i64,i8*,i8*}** %hook_s_8Ptr
%val394 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_8Ptr
%val395 = icmp eq {i64,i8*,i8*}* %val394, null
br i1 %val395, label %then393, label %else393

then393:
%res396 = call ccc i1 @impc_false()
store i1 %res396, i1* %ifptr393
br label %ifcont393

else393:
%res397 = call ccc i1 @impc_true()
store i1 %res397, i1* %ifptr393
br label %ifcont393

ifcont393:
%ifres398 = load i1, i1* %ifptr393

br i1 %ifres398, label %loop368, label %after368

after368:
%val400 = load %mzone*, %mzone** %zone1Ptr
call ccc void @llvm_zone_destroy(%mzone* %val400)
%val402 = load %String*, %String** %rescopy1Ptr
ret %String* %val402
}
@gsxtmglfw314 = hidden constant [99 x i8] c"toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}** @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone424 = load i8*, i8** %_impzPtr
%zone425 = bitcast i8* %tzone424 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ
%dat_toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone425, i64 8)
%toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ to { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}***
%tzone405 = load i8*, i8** %_impzPtr
%zone406 = bitcast i8* %tzone405 to %mzone*
call void @llvm_zone_mark(%mzone* %zone406)
; malloc closure structure
%clsptr407 = call i8* @llvm_zone_malloc(%mzone* %zone406, i64 24)
%closure408 = bitcast i8* %clsptr407 to { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}*

; malloc environment structure
%envptr409 = call i8* @llvm_zone_malloc(%mzone* %zone406, i64 8)
%environment410 = bitcast i8* %envptr409 to {{i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}***}*

; malloc closure address table
%addytable411 = call %clsvar* @new_address_table()
%var412 = bitcast [46 x i8]* @gsxtmglfw312 to i8*
%var413 = bitcast [50 x i8]* @gsxtmglfw313 to i8*
%addytable414 = call %clsvar* @add_address_table(%mzone* %zone406, i8* %var412, i32 0, i8* %var413, i32 3, %clsvar* %addytable411)
%address-table415 = bitcast %clsvar* %addytable414 to i8*

; insert table, function and environment into closure struct
%closure.table418 = getelementptr { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}* %closure408, i32 0, i32 0
store i8* %address-table415, i8** %closure.table418
%closure.env419 = getelementptr { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}* %closure408, i32 0, i32 1
store i8* %envptr409, i8** %closure.env419
%closure.func420 = getelementptr { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}* %closure408, i32 0, i32 2
store %String* (i8*, i8*, %GLFWvidmode*)* @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ__164, %String* (i8*, i8*, %GLFWvidmode*)** %closure.func420
%closure_size421 = call i64 @llvm_zone_mark_size(%mzone* %zone406)
call void @llvm_zone_ptr_set_size(i8* %clsptr407, i64 %closure_size421)
%wrapper_ptr422 = call i8* @llvm_zone_malloc(%mzone* %zone406, i64 8)
%closure_wrapper423 = bitcast i8* %wrapper_ptr422 to { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}**
store { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}* %closure408, { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper423

; let value assignment
%toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper423, { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper423
store { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}** %toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ, { i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}*** %toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ
%tmp_envptr417 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}***}* %environment410, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}*** %toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQPtr, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}**** %tmp_envptr417


%val426 = load {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}**, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}*** %toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}** %val426
}


@toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}** @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ(%GLFWvidmode* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %GLFWvidmode*)*,  %String* (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_native(%GLFWvidmode* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %GLFWvidmode*)*,  %String* (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var427 = bitcast [99 x i8]* @gsxtmglfw314 to i8*
call i32 (i8*, ...) @printf(i8* %var427)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWvidmode*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %GLFWvidmode*)*,  %String* (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWvidmode*}*
%arg_p_0 = getelementptr {%GLFWvidmode*}, {%GLFWvidmode*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWvidmode*, %GLFWvidmode** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %GLFWvidmode*)*,  %String* (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw315 = hidden constant [39 x i8] c"print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ\00"
@gsxtmglfw316 = hidden constant [46 x i8] c"{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ__428(i8* %_impz,i8* %_impenv, %GLFWvidmode* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone429 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***}*
%print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***}, {{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr = load {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**** %print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr_

; setup arguments
%xPtr = alloca %GLFWvidmode*
store %GLFWvidmode* %x, %GLFWvidmode** %xPtr


%val431 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
%val432 = icmp eq %GLFWvidmode* %val431, null
br i1 %val432, label %then430, label %else430

then430:
%var433 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var434 = bitcast [19 x i8]* @gsxtmglfw38 to i8*

%val435 = call i32 (i8*, ...) @printf(i8* %var433, i8* %var434)
br label %ifcont430

else430:
%var437 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var438 = bitcast [14 x i8]* @gsxtmglfw39 to i8*

%val439 = call i32 (i8*, ...) @printf(i8* %var437, i8* %var438)
%val440 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val441 = getelementptr %GLFWvidmode, %GLFWvidmode* %val440, i64 0, i32 0
%val442 = load i32, i32* %val441
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val442)
%var444 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var445 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val446 = call i32 (i8*, ...) @printf(i8* %var444, i8* %var445)
%val447 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val448 = getelementptr %GLFWvidmode, %GLFWvidmode* %val447, i64 0, i32 1
%val449 = load i32, i32* %val448
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val449)
%var451 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var452 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val453 = call i32 (i8*, ...) @printf(i8* %var451, i8* %var452)
%val454 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val455 = getelementptr %GLFWvidmode, %GLFWvidmode* %val454, i64 0, i32 2
%val456 = load i32, i32* %val455
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val456)
%var458 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var459 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val460 = call i32 (i8*, ...) @printf(i8* %var458, i8* %var459)
%val461 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val462 = getelementptr %GLFWvidmode, %GLFWvidmode* %val461, i64 0, i32 3
%val463 = load i32, i32* %val462
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val463)
%var465 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var466 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val467 = call i32 (i8*, ...) @printf(i8* %var465, i8* %var466)
%val468 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val469 = getelementptr %GLFWvidmode, %GLFWvidmode* %val468, i64 0, i32 4
%val470 = load i32, i32* %val469
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val470)
%var472 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var473 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val474 = call i32 (i8*, ...) @printf(i8* %var472, i8* %var473)
%val475 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val476 = getelementptr %GLFWvidmode, %GLFWvidmode* %val475, i64 0, i32 5
%val477 = load i32, i32* %val476
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val477)
%var479 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var480 = bitcast [2 x i8]* @gsxtmglfw311 to i8*

%val481 = call i32 (i8*, ...) @printf(i8* %var479, i8* %var480)
br label %ifcont430

ifcont430:
ret void
}
@gsxtmglfw317 = hidden constant [92 x i8] c"print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone503 = load i8*, i8** %_impzPtr
%zone504 = bitcast i8* %tzone503 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ
%dat_print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone504, i64 8)
%print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ to { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***
%tzone484 = load i8*, i8** %_impzPtr
%zone485 = bitcast i8* %tzone484 to %mzone*
call void @llvm_zone_mark(%mzone* %zone485)
; malloc closure structure
%clsptr486 = call i8* @llvm_zone_malloc(%mzone* %zone485, i64 24)
%closure487 = bitcast i8* %clsptr486 to { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*

; malloc environment structure
%envptr488 = call i8* @llvm_zone_malloc(%mzone* %zone485, i64 8)
%environment489 = bitcast i8* %envptr488 to {{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***}*

; malloc closure address table
%addytable490 = call %clsvar* @new_address_table()
%var491 = bitcast [39 x i8]* @gsxtmglfw315 to i8*
%var492 = bitcast [46 x i8]* @gsxtmglfw316 to i8*
%addytable493 = call %clsvar* @add_address_table(%mzone* %zone485, i8* %var491, i32 0, i8* %var492, i32 3, %clsvar* %addytable490)
%address-table494 = bitcast %clsvar* %addytable493 to i8*

; insert table, function and environment into closure struct
%closure.table497 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure487, i32 0, i32 0
store i8* %address-table494, i8** %closure.table497
%closure.env498 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure487, i32 0, i32 1
store i8* %envptr488, i8** %closure.env498
%closure.func499 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure487, i32 0, i32 2
store void (i8*, i8*, %GLFWvidmode*)* @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ__428, void (i8*, i8*, %GLFWvidmode*)** %closure.func499
%closure_size500 = call i64 @llvm_zone_mark_size(%mzone* %zone485)
call void @llvm_zone_ptr_set_size(i8* %clsptr486, i64 %closure_size500)
%wrapper_ptr501 = call i8* @llvm_zone_malloc(%mzone* %zone485, i64 8)
%closure_wrapper502 = bitcast i8* %wrapper_ptr501 to { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**
store { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure487, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper502

; let value assignment
%print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper502, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper502
store { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*** %print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ
%tmp_envptr496 = getelementptr {{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***}, {{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***}* %environment489, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*** %print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**** %tmp_envptr496


%val505 = load {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*** %print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr
ret {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %val505
}


@print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ(%GLFWvidmode* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWvidmode*)*,  void (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_native(%GLFWvidmode* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWvidmode*)*,  void (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var506 = bitcast [92 x i8]* @gsxtmglfw317 to i8*
call i32 (i8*, ...) @printf(i8* %var506)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWvidmode*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWvidmode*)*,  void (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWvidmode*}*
%arg_p_0 = getelementptr {%GLFWvidmode*}, {%GLFWvidmode*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWvidmode*, %GLFWvidmode** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWvidmode*)*,  void (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw318 = hidden constant [73 x i8] c"GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ\00"
@gsxtmglfw319 = hidden constant [69 x i8] c"{i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**\00"
define dllexport fastcc %GLFWvidmode @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ__507(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone508 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}*
%GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQPtr = load {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***, {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**** %GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr


%tzone510 = load i8*, i8** %_impzPtr
%zone511 = bitcast i8* %tzone510 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWvidmode*
%dat509 = alloca %GLFWvidmode, align 16

; let value assignment
%obj = select i1 true, %GLFWvidmode* %dat509, %GLFWvidmode* %dat509
store %GLFWvidmode* %obj, %GLFWvidmode** %objPtr

%val512 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val513 = load i32, i32* %arg_0Ptr
; set tuple
%val514 = getelementptr %GLFWvidmode, %GLFWvidmode* %val512, i64 0, i32 0
store i32 %val513, i32* %val514
%val515 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val516 = load i32, i32* %arg_1Ptr
; set tuple
%val517 = getelementptr %GLFWvidmode, %GLFWvidmode* %val515, i64 0, i32 1
store i32 %val516, i32* %val517
%val518 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val519 = load i32, i32* %arg_2Ptr
; set tuple
%val520 = getelementptr %GLFWvidmode, %GLFWvidmode* %val518, i64 0, i32 2
store i32 %val519, i32* %val520
%val521 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val522 = load i32, i32* %arg_3Ptr
; set tuple
%val523 = getelementptr %GLFWvidmode, %GLFWvidmode* %val521, i64 0, i32 3
store i32 %val522, i32* %val523
%val524 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val525 = load i32, i32* %arg_4Ptr
; set tuple
%val526 = getelementptr %GLFWvidmode, %GLFWvidmode* %val524, i64 0, i32 4
store i32 %val525, i32* %val526
%val527 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val528 = load i32, i32* %arg_5Ptr
; set tuple
%val529 = getelementptr %GLFWvidmode, %GLFWvidmode* %val527, i64 0, i32 5
store i32 %val528, i32* %val529
%val530 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
; pointer ref
%val531 = getelementptr %GLFWvidmode, %GLFWvidmode* %val530, i64 0
%val532 = load %GLFWvidmode, %GLFWvidmode* %val531
ret %GLFWvidmode %val532
}
@gsxtmglfw320 = hidden constant [126 x i8] c"GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone552 = load i8*, i8** %_impzPtr
%zone553 = bitcast i8* %tzone552 to %mzone*

; let assign value to symbol GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ
%dat_GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone553, i64 8)
%GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQPtr = bitcast i8* %dat_GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ to { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***
%tzone533 = load i8*, i8** %_impzPtr
%zone534 = bitcast i8* %tzone533 to %mzone*
call void @llvm_zone_mark(%mzone* %zone534)
; malloc closure structure
%clsptr535 = call i8* @llvm_zone_malloc(%mzone* %zone534, i64 24)
%closure536 = bitcast i8* %clsptr535 to { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr537 = call i8* @llvm_zone_malloc(%mzone* %zone534, i64 8)
%environment538 = bitcast i8* %envptr537 to {{i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable539 = call %clsvar* @new_address_table()
%var540 = bitcast [73 x i8]* @gsxtmglfw318 to i8*
%var541 = bitcast [69 x i8]* @gsxtmglfw319 to i8*
%addytable542 = call %clsvar* @add_address_table(%mzone* %zone534, i8* %var540, i32 0, i8* %var541, i32 3, %clsvar* %addytable539)
%address-table543 = bitcast %clsvar* %addytable542 to i8*

; insert table, function and environment into closure struct
%closure.table546 = getelementptr { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure536, i32 0, i32 0
store i8* %address-table543, i8** %closure.table546
%closure.env547 = getelementptr { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure536, i32 0, i32 1
store i8* %envptr537, i8** %closure.env547
%closure.func548 = getelementptr { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure536, i32 0, i32 2
store %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)* @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ__507, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)** %closure.func548
%closure_size549 = call i64 @llvm_zone_mark_size(%mzone* %zone534)
call void @llvm_zone_ptr_set_size(i8* %clsptr535, i64 %closure_size549)
%wrapper_ptr550 = call i8* @llvm_zone_malloc(%mzone* %zone534, i64 8)
%closure_wrapper551 = bitcast i8* %wrapper_ptr550 to { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure536, { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_wrapper551

; let value assignment
%GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ = select i1 true, { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_wrapper551, { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_wrapper551
store { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ, { i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*** %GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ
%tmp_envptr545 = getelementptr {{i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}***}* %environment538, i32 0, i32 0
store {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*** %GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQPtr, {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**** %tmp_envptr545


%val554 = load {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**, {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*** %GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQPtr
ret {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %val554
}


@GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWvidmode @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %GLFWvidmode %result
}


define dllexport ccc %GLFWvidmode @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %GLFWvidmode %result
}


define dllexport ccc void @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {i32, i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWvidmode_val_adhoc_W0dMRld2aWRtb2RlLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}, {i8*, i8*, %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)*,  %GLFWvidmode (i8*, i8*, i32, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw321 = hidden constant [49 x i8] c"hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd\00"
@gsxtmglfw322 = hidden constant [55 x i8] c"{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}**\00"
define dllexport fastcc %GLFWvidmode* @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd__561(i8* %_impz,i8* %_impenv, %GLFWvidmode* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone562 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}***}*
%hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpdPtr_ = getelementptr {{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}***}, {{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpdPtr = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}***, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}**** %hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpdPtr_

; setup arguments
%xPtr = alloca %GLFWvidmode*
store %GLFWvidmode* %x, %GLFWvidmode** %xPtr


%tzone565 = load i8*, i8** %_impzPtr
%zone566 = bitcast i8* %tzone565 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWvidmode*
%dat563 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat563, i32 0, i64 24)
%val564 = bitcast i8* %dat563 to %GLFWvidmode*

; let value assignment
%obj = select i1 true, %GLFWvidmode* %val564, %GLFWvidmode* %val564
store %GLFWvidmode* %obj, %GLFWvidmode** %objPtr

%val567 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val568 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val569 = getelementptr %GLFWvidmode, %GLFWvidmode* %val568, i64 0, i32 0
%val570 = load i32, i32* %val569
; set tuple
%val571 = getelementptr %GLFWvidmode, %GLFWvidmode* %val567, i64 0, i32 0
store i32 %val570, i32* %val571
%val572 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val573 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val574 = getelementptr %GLFWvidmode, %GLFWvidmode* %val573, i64 0, i32 1
%val575 = load i32, i32* %val574
; set tuple
%val576 = getelementptr %GLFWvidmode, %GLFWvidmode* %val572, i64 0, i32 1
store i32 %val575, i32* %val576
%val577 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val578 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val579 = getelementptr %GLFWvidmode, %GLFWvidmode* %val578, i64 0, i32 2
%val580 = load i32, i32* %val579
; set tuple
%val581 = getelementptr %GLFWvidmode, %GLFWvidmode* %val577, i64 0, i32 2
store i32 %val580, i32* %val581
%val582 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val583 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val584 = getelementptr %GLFWvidmode, %GLFWvidmode* %val583, i64 0, i32 3
%val585 = load i32, i32* %val584
; set tuple
%val586 = getelementptr %GLFWvidmode, %GLFWvidmode* %val582, i64 0, i32 3
store i32 %val585, i32* %val586
%val587 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val588 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val589 = getelementptr %GLFWvidmode, %GLFWvidmode* %val588, i64 0, i32 4
%val590 = load i32, i32* %val589
; set tuple
%val591 = getelementptr %GLFWvidmode, %GLFWvidmode* %val587, i64 0, i32 4
store i32 %val590, i32* %val591
%val592 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val593 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val594 = getelementptr %GLFWvidmode, %GLFWvidmode* %val593, i64 0, i32 5
%val595 = load i32, i32* %val594
; set tuple
%val596 = getelementptr %GLFWvidmode, %GLFWvidmode* %val592, i64 0, i32 5
store i32 %val595, i32* %val596
%val597 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
ret %GLFWvidmode* %val597
}
@gsxtmglfw323 = hidden constant [102 x i8] c"hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}** @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone617 = load i8*, i8** %_impzPtr
%zone618 = bitcast i8* %tzone617 to %mzone*

; let assign value to symbol hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd
%dat_hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd = call i8* @llvm_zone_malloc(%mzone* %zone618, i64 8)
%hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpdPtr = bitcast i8* %dat_hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd to { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}***
%tzone598 = load i8*, i8** %_impzPtr
%zone599 = bitcast i8* %tzone598 to %mzone*
call void @llvm_zone_mark(%mzone* %zone599)
; malloc closure structure
%clsptr600 = call i8* @llvm_zone_malloc(%mzone* %zone599, i64 24)
%closure601 = bitcast i8* %clsptr600 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}*

; malloc environment structure
%envptr602 = call i8* @llvm_zone_malloc(%mzone* %zone599, i64 8)
%environment603 = bitcast i8* %envptr602 to {{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}***}*

; malloc closure address table
%addytable604 = call %clsvar* @new_address_table()
%var605 = bitcast [49 x i8]* @gsxtmglfw321 to i8*
%var606 = bitcast [55 x i8]* @gsxtmglfw322 to i8*
%addytable607 = call %clsvar* @add_address_table(%mzone* %zone599, i8* %var605, i32 0, i8* %var606, i32 3, %clsvar* %addytable604)
%address-table608 = bitcast %clsvar* %addytable607 to i8*

; insert table, function and environment into closure struct
%closure.table611 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}* %closure601, i32 0, i32 0
store i8* %address-table608, i8** %closure.table611
%closure.env612 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}* %closure601, i32 0, i32 1
store i8* %envptr602, i8** %closure.env612
%closure.func613 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}* %closure601, i32 0, i32 2
store %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)* @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd__561, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)** %closure.func613
%closure_size614 = call i64 @llvm_zone_mark_size(%mzone* %zone599)
call void @llvm_zone_ptr_set_size(i8* %clsptr600, i64 %closure_size614)
%wrapper_ptr615 = call i8* @llvm_zone_malloc(%mzone* %zone599, i64 8)
%closure_wrapper616 = bitcast i8* %wrapper_ptr615 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}**
store { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}* %closure601, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper616

; let value assignment
%hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd = select i1 true, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper616, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper616
store { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}** %hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}*** %hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpdPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd
%tmp_envptr610 = getelementptr {{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}***}, {{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}***}* %environment603, i32 0, i32 0
store {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}*** %hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpdPtr, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}**** %tmp_envptr610


%val619 = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}**, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}*** %hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpdPtr
ret {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}** %val619
}


@hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}** @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWvidmode* @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd(%GLFWvidmode* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*,  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
ret %GLFWvidmode* %result
}


define dllexport ccc %GLFWvidmode* @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_native(%GLFWvidmode* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*,  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
ret %GLFWvidmode* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var620 = bitcast [102 x i8]* @gsxtmglfw323 to i8*
call i32 (i8*, ...) @printf(i8* %var620)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWvidmode*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*,  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
%tmpres = bitcast %GLFWvidmode* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWvidmode*}*
%arg_p_0 = getelementptr {%GLFWvidmode*}, {%GLFWvidmode*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWvidmode*, %GLFWvidmode** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)*,  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw324 = hidden constant [39 x i8] c"hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ__621(i8* %_impz,i8* %_impenv, %GLFWvidmode* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone622 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***}*
%hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***}, {{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr = load {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**** %hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr_

; setup arguments
%xPtr = alloca %GLFWvidmode*
store %GLFWvidmode* %x, %GLFWvidmode** %xPtr


%val623 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
%val624 = bitcast %GLFWvidmode* %val623 to i8*
call ccc void @free(i8* %val624)
ret void
}
@gsxtmglfw325 = hidden constant [92 x i8] c"hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone646 = load i8*, i8** %_impzPtr
%zone647 = bitcast i8* %tzone646 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ
%dat_hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone647, i64 8)
%hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ to { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***
%tzone627 = load i8*, i8** %_impzPtr
%zone628 = bitcast i8* %tzone627 to %mzone*
call void @llvm_zone_mark(%mzone* %zone628)
; malloc closure structure
%clsptr629 = call i8* @llvm_zone_malloc(%mzone* %zone628, i64 24)
%closure630 = bitcast i8* %clsptr629 to { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*

; malloc environment structure
%envptr631 = call i8* @llvm_zone_malloc(%mzone* %zone628, i64 8)
%environment632 = bitcast i8* %envptr631 to {{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***}*

; malloc closure address table
%addytable633 = call %clsvar* @new_address_table()
%var634 = bitcast [39 x i8]* @gsxtmglfw324 to i8*
%var635 = bitcast [46 x i8]* @gsxtmglfw316 to i8*
%addytable636 = call %clsvar* @add_address_table(%mzone* %zone628, i8* %var634, i32 0, i8* %var635, i32 3, %clsvar* %addytable633)
%address-table637 = bitcast %clsvar* %addytable636 to i8*

; insert table, function and environment into closure struct
%closure.table640 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure630, i32 0, i32 0
store i8* %address-table637, i8** %closure.table640
%closure.env641 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure630, i32 0, i32 1
store i8* %envptr631, i8** %closure.env641
%closure.func642 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure630, i32 0, i32 2
store void (i8*, i8*, %GLFWvidmode*)* @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ__621, void (i8*, i8*, %GLFWvidmode*)** %closure.func642
%closure_size643 = call i64 @llvm_zone_mark_size(%mzone* %zone628)
call void @llvm_zone_ptr_set_size(i8* %clsptr629, i64 %closure_size643)
%wrapper_ptr644 = call i8* @llvm_zone_malloc(%mzone* %zone628, i64 8)
%closure_wrapper645 = bitcast i8* %wrapper_ptr644 to { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**
store { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure630, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper645

; let value assignment
%hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper645, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper645
store { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ, { i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*** %hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ
%tmp_envptr639 = getelementptr {{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***}, {{i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}***}* %environment632, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*** %hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**** %tmp_envptr639


%val648 = load {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*** %hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQPtr
ret {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %val648
}


@hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ(%GLFWvidmode* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWvidmode*)*,  void (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_native(%GLFWvidmode* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWvidmode*)*,  void (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var649 = bitcast [92 x i8]* @gsxtmglfw325 to i8*
call i32 (i8*, ...) @printf(i8* %var649)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWvidmode*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWvidmode*)*,  void (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWvidmode*}*
%arg_p_0 = getelementptr {%GLFWvidmode*}, {%GLFWvidmode*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWvidmode*, %GLFWvidmode** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV3ZpZG1vZGUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, void (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWvidmode*)*,  void (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw326 = hidden constant [68 x i8] c"zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0\00"
@gsxtmglfw327 = hidden constant [73 x i8] c"{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %GLFWvidmode* @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0__650(i8* %_impz,i8* %_impenv, %GLFWvidmode* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone651 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}***, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca %GLFWvidmode*
store %GLFWvidmode* %x, %GLFWvidmode** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val653 = load %mzone*, %mzone** %fromzPtr
%val654 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
%val655 = bitcast %GLFWvidmode* %val654 to i8*
%res656 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val653, i8* %val655)
br i1 %res656, label %then652, label %else652

then652:
%val657 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val657)
%zone_ptr658 = bitcast %mzone* %val657 to i8*
store i8* %zone_ptr658, i8** %_impzPtr
%tzone664 = load i8*, i8** %_impzPtr
%zone665 = bitcast i8* %tzone664 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWvidmode*
%tzone660 = load i8*, i8** %_impzPtr
%zone661 = bitcast i8* %tzone660 to %mzone*
%dat662 = call i8* @llvm_zone_malloc(%mzone* %zone661, i64 24)
call i8* @memset(i8* %dat662, i32 0, i64 24)
%val663 = bitcast i8* %dat662 to %GLFWvidmode*

; let value assignment
%obj = select i1 true, %GLFWvidmode* %val663, %GLFWvidmode* %val663
store %GLFWvidmode* %obj, %GLFWvidmode** %objPtr

%val666 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val667 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val668 = getelementptr %GLFWvidmode, %GLFWvidmode* %val667, i64 0, i32 0
%val669 = load i32, i32* %val668
; set tuple
%val670 = getelementptr %GLFWvidmode, %GLFWvidmode* %val666, i64 0, i32 0
store i32 %val669, i32* %val670
%val671 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val672 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val673 = getelementptr %GLFWvidmode, %GLFWvidmode* %val672, i64 0, i32 1
%val674 = load i32, i32* %val673
; set tuple
%val675 = getelementptr %GLFWvidmode, %GLFWvidmode* %val671, i64 0, i32 1
store i32 %val674, i32* %val675
%val676 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val677 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val678 = getelementptr %GLFWvidmode, %GLFWvidmode* %val677, i64 0, i32 2
%val679 = load i32, i32* %val678
; set tuple
%val680 = getelementptr %GLFWvidmode, %GLFWvidmode* %val676, i64 0, i32 2
store i32 %val679, i32* %val680
%val681 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val682 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val683 = getelementptr %GLFWvidmode, %GLFWvidmode* %val682, i64 0, i32 3
%val684 = load i32, i32* %val683
; set tuple
%val685 = getelementptr %GLFWvidmode, %GLFWvidmode* %val681, i64 0, i32 3
store i32 %val684, i32* %val685
%val686 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val687 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val688 = getelementptr %GLFWvidmode, %GLFWvidmode* %val687, i64 0, i32 4
%val689 = load i32, i32* %val688
; set tuple
%val690 = getelementptr %GLFWvidmode, %GLFWvidmode* %val686, i64 0, i32 4
store i32 %val689, i32* %val690
%val691 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
%val692 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
; tuple ref
%val693 = getelementptr %GLFWvidmode, %GLFWvidmode* %val692, i64 0, i32 5
%val694 = load i32, i32* %val693
; set tuple
%val695 = getelementptr %GLFWvidmode, %GLFWvidmode* %val691, i64 0, i32 5
store i32 %val694, i32* %val695
%oldzone696 = call %mzone* @llvm_pop_zone_stack()
%newzone697 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr698 = bitcast %mzone* %newzone697 to i8*
store i8* %zone_ptr698, i8** %_impzPtr
%val699 = load %GLFWvidmode*, %GLFWvidmode** %objPtr
ret %GLFWvidmode* %val699

else652:
%val700 = load %GLFWvidmode*, %GLFWvidmode** %xPtr
ret %GLFWvidmode* %val700
}
@gsxtmglfw328 = hidden constant [121 x i8] c"zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone720 = load i8*, i8** %_impzPtr
%zone721 = bitcast i8* %tzone720 to %mzone*

; let assign value to symbol zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone721, i64 8)
%zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}***
%tzone701 = load i8*, i8** %_impzPtr
%zone702 = bitcast i8* %tzone701 to %mzone*
call void @llvm_zone_mark(%mzone* %zone702)
; malloc closure structure
%clsptr703 = call i8* @llvm_zone_malloc(%mzone* %zone702, i64 24)
%closure704 = bitcast i8* %clsptr703 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr705 = call i8* @llvm_zone_malloc(%mzone* %zone702, i64 8)
%environment706 = bitcast i8* %envptr705 to {{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable707 = call %clsvar* @new_address_table()
%var708 = bitcast [68 x i8]* @gsxtmglfw326 to i8*
%var709 = bitcast [73 x i8]* @gsxtmglfw327 to i8*
%addytable710 = call %clsvar* @add_address_table(%mzone* %zone702, i8* %var708, i32 0, i8* %var709, i32 3, %clsvar* %addytable707)
%address-table711 = bitcast %clsvar* %addytable710 to i8*

; insert table, function and environment into closure struct
%closure.table714 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}* %closure704, i32 0, i32 0
store i8* %address-table711, i8** %closure.table714
%closure.env715 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}* %closure704, i32 0, i32 1
store i8* %envptr705, i8** %closure.env715
%closure.func716 = getelementptr { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}* %closure704, i32 0, i32 2
store %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)* @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0__650, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)** %closure.func716
%closure_size717 = call i64 @llvm_zone_mark_size(%mzone* %zone702)
call void @llvm_zone_ptr_set_size(i8* %clsptr703, i64 %closure_size717)
%wrapper_ptr718 = call i8* @llvm_zone_malloc(%mzone* %zone702, i64 8)
%closure_wrapper719 = bitcast i8* %wrapper_ptr718 to { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}**
store { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}* %closure704, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}** %closure_wrapper719

; let value assignment
%zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}** %closure_wrapper719, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}** %closure_wrapper719
store { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}** %zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0, { i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0
%tmp_envptr713 = getelementptr {{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}***}* %environment706, i32 0, i32 0
store {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}**** %tmp_envptr713


%val722 = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}**, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}** %val722
}


@zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWvidmode* @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0(%GLFWvidmode* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*,  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %GLFWvidmode* %result
}


define dllexport ccc %GLFWvidmode* @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_native(%GLFWvidmode* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*,  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %GLFWvidmode* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var723 = bitcast [121 x i8]* @gsxtmglfw328 to i8*
call i32 (i8*, ...) @printf(i8* %var723)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWvidmode*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var724 = bitcast [121 x i8]* @gsxtmglfw328 to i8*
call i32 (i8*, ...) @printf(i8* %var724)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var725 = bitcast [121 x i8]* @gsxtmglfw328 to i8*
call i32 (i8*, ...) @printf(i8* %var725)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*,  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %GLFWvidmode* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWvidmode*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%GLFWvidmode*, %mzone*, %mzone*}, {%GLFWvidmode*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWvidmode*, %GLFWvidmode** %arg_p_0
%arg_p_1 = getelementptr {%GLFWvidmode*, %mzone*, %mzone*}, {%GLFWvidmode*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%GLFWvidmode*, %mzone*, %mzone*}, {%GLFWvidmode*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRld2aWRtb2RlKixHTEZXdmlkbW9kZSosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}*, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)*,  %GLFWvidmode* (i8*, i8*, %GLFWvidmode*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWvidmode* %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%GLFWgammaramp = type {i16*,i16*,i16*,i32}
@gsxtmglfw329 = hidden constant [68 x i8] c"GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0\00"
@gsxtmglfw330 = hidden constant [65 x i8] c"{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**\00"
define dllexport fastcc %GLFWgammaramp* @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0__726(i8* %_impz,i8* %_impenv, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone727 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}*
%GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}, {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}* %impenv, i32 0, i32 0
%GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**** %GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i16*
store i16* %arg_0, i16** %arg_0Ptr
%arg_1Ptr = alloca i16*
store i16* %arg_1, i16** %arg_1Ptr
%arg_2Ptr = alloca i16*
store i16* %arg_2, i16** %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr


%tzone732 = load i8*, i8** %_impzPtr
%zone733 = bitcast i8* %tzone732 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWgammaramp*
%tzone728 = load i8*, i8** %_impzPtr
%zone729 = bitcast i8* %tzone728 to %mzone*
%dat730 = call i8* @llvm_zone_malloc(%mzone* %zone729, i64 32)
call i8* @memset(i8* %dat730, i32 0, i64 32)
%val731 = bitcast i8* %dat730 to %GLFWgammaramp*

; let value assignment
%obj = select i1 true, %GLFWgammaramp* %val731, %GLFWgammaramp* %val731
store %GLFWgammaramp* %obj, %GLFWgammaramp** %objPtr

%val734 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val735 = load i16*, i16** %arg_0Ptr
; set tuple
%val736 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val734, i64 0, i32 0
store i16* %val735, i16** %val736
%val737 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val738 = load i16*, i16** %arg_1Ptr
; set tuple
%val739 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val737, i64 0, i32 1
store i16* %val738, i16** %val739
%val740 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val741 = load i16*, i16** %arg_2Ptr
; set tuple
%val742 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val740, i64 0, i32 2
store i16* %val741, i16** %val742
%val743 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val744 = load i32, i32* %arg_3Ptr
; set tuple
%val745 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val743, i64 0, i32 3
store i32 %val744, i32* %val745
%val746 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
ret %GLFWgammaramp* %val746
}
@gsxtmglfw331 = hidden constant [121 x i8] c"GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone766 = load i8*, i8** %_impzPtr
%zone767 = bitcast i8* %tzone766 to %mzone*

; let assign value to symbol GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0
%dat_GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone767, i64 8)
%GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr = bitcast i8* %dat_GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***
%tzone747 = load i8*, i8** %_impzPtr
%zone748 = bitcast i8* %tzone747 to %mzone*
call void @llvm_zone_mark(%mzone* %zone748)
; malloc closure structure
%clsptr749 = call i8* @llvm_zone_malloc(%mzone* %zone748, i64 24)
%closure750 = bitcast i8* %clsptr749 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*

; malloc environment structure
%envptr751 = call i8* @llvm_zone_malloc(%mzone* %zone748, i64 8)
%environment752 = bitcast i8* %envptr751 to {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}*

; malloc closure address table
%addytable753 = call %clsvar* @new_address_table()
%var754 = bitcast [68 x i8]* @gsxtmglfw329 to i8*
%var755 = bitcast [65 x i8]* @gsxtmglfw330 to i8*
%addytable756 = call %clsvar* @add_address_table(%mzone* %zone748, i8* %var754, i32 0, i8* %var755, i32 3, %clsvar* %addytable753)
%address-table757 = bitcast %clsvar* %addytable756 to i8*

; insert table, function and environment into closure struct
%closure.table760 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure750, i32 0, i32 0
store i8* %address-table757, i8** %closure.table760
%closure.env761 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure750, i32 0, i32 1
store i8* %envptr751, i8** %closure.env761
%closure.func762 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure750, i32 0, i32 2
store %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)* @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0__726, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %closure.func762
%closure_size763 = call i64 @llvm_zone_mark_size(%mzone* %zone748)
call void @llvm_zone_ptr_set_size(i8* %clsptr749, i64 %closure_size763)
%wrapper_ptr764 = call i8* @llvm_zone_malloc(%mzone* %zone748, i64 8)
%closure_wrapper765 = bitcast i8* %wrapper_ptr764 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
store { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure750, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_wrapper765

; let value assignment
%GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0 = select i1 true, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_wrapper765, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_wrapper765
store { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*** %GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0
%tmp_envptr759 = getelementptr {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}, {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}* %environment752, i32 0, i32 0
store {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*** %GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**** %tmp_envptr759


%val768 = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*** %GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr
ret {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %val768
}


@GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWgammaramp* @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0(i16* %arg_0,i16* %arg_1,i16* %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
ret %GLFWgammaramp* %result
}


define dllexport ccc %GLFWgammaramp* @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_native(i16* %arg_0,i16* %arg_1,i16* %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
ret %GLFWgammaramp* %result
}


define dllexport ccc i8*  @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var769 = bitcast [121 x i8]* @gsxtmglfw331 to i8*
call i32 (i8*, ...) @printf(i8* %var769)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i16*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var770 = bitcast [121 x i8]* @gsxtmglfw331 to i8*
call i32 (i8*, ...) @printf(i8* %var770)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to i16*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var771 = bitcast [121 x i8]* @gsxtmglfw331 to i8*
call i32 (i8*, ...) @printf(i8* %var771)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to i16*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var772 = bitcast [121 x i8]* @gsxtmglfw331 to i8*
call i32 (i8*, ...) @printf(i8* %var772)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
%tmpres = bitcast %GLFWgammaramp* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16*, i16*, i16*, i32}*
%arg_p_0 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i16*, i16** %arg_p_0
%arg_p_1 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i16*, i16** %arg_p_1
%arg_p_2 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i16*, i16** %arg_p_2
%arg_p_3 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw332 = hidden constant [70 x i8] c"GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0\00"
define dllexport fastcc %GLFWgammaramp* @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0__773(i8* %_impz,i8* %_impenv, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone774 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}*
%GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}, {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}* %impenv, i32 0, i32 0
%GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**** %GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i16*
store i16* %arg_0, i16** %arg_0Ptr
%arg_1Ptr = alloca i16*
store i16* %arg_1, i16** %arg_1Ptr
%arg_2Ptr = alloca i16*
store i16* %arg_2, i16** %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr


%tzone779 = load i8*, i8** %_impzPtr
%zone780 = bitcast i8* %tzone779 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWgammaramp*
%tzone775 = load i8*, i8** %_impzPtr
%zone776 = bitcast i8* %tzone775 to %mzone*
%dat777 = call i8* @llvm_zone_malloc(%mzone* %zone776, i64 32)
call i8* @memset(i8* %dat777, i32 0, i64 32)
%val778 = bitcast i8* %dat777 to %GLFWgammaramp*

; let value assignment
%obj = select i1 true, %GLFWgammaramp* %val778, %GLFWgammaramp* %val778
store %GLFWgammaramp* %obj, %GLFWgammaramp** %objPtr

%val781 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val782 = load i16*, i16** %arg_0Ptr
; set tuple
%val783 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val781, i64 0, i32 0
store i16* %val782, i16** %val783
%val784 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val785 = load i16*, i16** %arg_1Ptr
; set tuple
%val786 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val784, i64 0, i32 1
store i16* %val785, i16** %val786
%val787 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val788 = load i16*, i16** %arg_2Ptr
; set tuple
%val789 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val787, i64 0, i32 2
store i16* %val788, i16** %val789
%val790 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val791 = load i32, i32* %arg_3Ptr
; set tuple
%val792 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val790, i64 0, i32 3
store i32 %val791, i32* %val792
%val793 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
ret %GLFWgammaramp* %val793
}
@gsxtmglfw333 = hidden constant [123 x i8] c"GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone813 = load i8*, i8** %_impzPtr
%zone814 = bitcast i8* %tzone813 to %mzone*

; let assign value to symbol GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0
%dat_GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone814, i64 8)
%GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr = bitcast i8* %dat_GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***
%tzone794 = load i8*, i8** %_impzPtr
%zone795 = bitcast i8* %tzone794 to %mzone*
call void @llvm_zone_mark(%mzone* %zone795)
; malloc closure structure
%clsptr796 = call i8* @llvm_zone_malloc(%mzone* %zone795, i64 24)
%closure797 = bitcast i8* %clsptr796 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*

; malloc environment structure
%envptr798 = call i8* @llvm_zone_malloc(%mzone* %zone795, i64 8)
%environment799 = bitcast i8* %envptr798 to {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}*

; malloc closure address table
%addytable800 = call %clsvar* @new_address_table()
%var801 = bitcast [70 x i8]* @gsxtmglfw332 to i8*
%var802 = bitcast [65 x i8]* @gsxtmglfw330 to i8*
%addytable803 = call %clsvar* @add_address_table(%mzone* %zone795, i8* %var801, i32 0, i8* %var802, i32 3, %clsvar* %addytable800)
%address-table804 = bitcast %clsvar* %addytable803 to i8*

; insert table, function and environment into closure struct
%closure.table807 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure797, i32 0, i32 0
store i8* %address-table804, i8** %closure.table807
%closure.env808 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure797, i32 0, i32 1
store i8* %envptr798, i8** %closure.env808
%closure.func809 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure797, i32 0, i32 2
store %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)* @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0__773, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %closure.func809
%closure_size810 = call i64 @llvm_zone_mark_size(%mzone* %zone795)
call void @llvm_zone_ptr_set_size(i8* %clsptr796, i64 %closure_size810)
%wrapper_ptr811 = call i8* @llvm_zone_malloc(%mzone* %zone795, i64 8)
%closure_wrapper812 = bitcast i8* %wrapper_ptr811 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
store { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure797, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_wrapper812

; let value assignment
%GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0 = select i1 true, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_wrapper812, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_wrapper812
store { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*** %GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0
%tmp_envptr806 = getelementptr {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}, {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}* %environment799, i32 0, i32 0
store {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*** %GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**** %tmp_envptr806


%val815 = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*** %GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr
ret {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %val815
}


@GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWgammaramp* @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0(i16* %arg_0,i16* %arg_1,i16* %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
ret %GLFWgammaramp* %result
}


define dllexport ccc %GLFWgammaramp* @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_native(i16* %arg_0,i16* %arg_1,i16* %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
ret %GLFWgammaramp* %result
}


define dllexport ccc i8*  @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var816 = bitcast [123 x i8]* @gsxtmglfw333 to i8*
call i32 (i8*, ...) @printf(i8* %var816)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i16*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var817 = bitcast [123 x i8]* @gsxtmglfw333 to i8*
call i32 (i8*, ...) @printf(i8* %var817)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to i16*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var818 = bitcast [123 x i8]* @gsxtmglfw333 to i8*
call i32 (i8*, ...) @printf(i8* %var818)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to i16*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var819 = bitcast [123 x i8]* @gsxtmglfw333 to i8*
call i32 (i8*, ...) @printf(i8* %var819)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
%tmpres = bitcast %GLFWgammaramp* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16*, i16*, i16*, i32}*
%arg_p_0 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i16*, i16** %arg_p_0
%arg_p_1 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i16*, i16** %arg_p_1
%arg_p_2 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i16*, i16** %arg_p_2
%arg_p_3 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_z_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw334 = hidden constant [70 x i8] c"GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0\00"
define dllexport fastcc %GLFWgammaramp* @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0__820(i8* %_impz,i8* %_impenv, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone821 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}*
%GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}, {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}* %impenv, i32 0, i32 0
%GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**** %GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i16*
store i16* %arg_0, i16** %arg_0Ptr
%arg_1Ptr = alloca i16*
store i16* %arg_1, i16** %arg_1Ptr
%arg_2Ptr = alloca i16*
store i16* %arg_2, i16** %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr


%tzone824 = load i8*, i8** %_impzPtr
%zone825 = bitcast i8* %tzone824 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWgammaramp*
%dat822 = call i8* @malloc(i64 32)
call i8* @memset(i8* %dat822, i32 0, i64 32)
%val823 = bitcast i8* %dat822 to %GLFWgammaramp*

; let value assignment
%obj = select i1 true, %GLFWgammaramp* %val823, %GLFWgammaramp* %val823
store %GLFWgammaramp* %obj, %GLFWgammaramp** %objPtr

%val826 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val827 = load i16*, i16** %arg_0Ptr
; set tuple
%val828 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val826, i64 0, i32 0
store i16* %val827, i16** %val828
%val829 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val830 = load i16*, i16** %arg_1Ptr
; set tuple
%val831 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val829, i64 0, i32 1
store i16* %val830, i16** %val831
%val832 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val833 = load i16*, i16** %arg_2Ptr
; set tuple
%val834 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val832, i64 0, i32 2
store i16* %val833, i16** %val834
%val835 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val836 = load i32, i32* %arg_3Ptr
; set tuple
%val837 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val835, i64 0, i32 3
store i32 %val836, i32* %val837
%val838 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
ret %GLFWgammaramp* %val838
}
@gsxtmglfw335 = hidden constant [123 x i8] c"GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone858 = load i8*, i8** %_impzPtr
%zone859 = bitcast i8* %tzone858 to %mzone*

; let assign value to symbol GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0
%dat_GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone859, i64 8)
%GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr = bitcast i8* %dat_GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***
%tzone839 = load i8*, i8** %_impzPtr
%zone840 = bitcast i8* %tzone839 to %mzone*
call void @llvm_zone_mark(%mzone* %zone840)
; malloc closure structure
%clsptr841 = call i8* @llvm_zone_malloc(%mzone* %zone840, i64 24)
%closure842 = bitcast i8* %clsptr841 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*

; malloc environment structure
%envptr843 = call i8* @llvm_zone_malloc(%mzone* %zone840, i64 8)
%environment844 = bitcast i8* %envptr843 to {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}*

; malloc closure address table
%addytable845 = call %clsvar* @new_address_table()
%var846 = bitcast [70 x i8]* @gsxtmglfw334 to i8*
%var847 = bitcast [65 x i8]* @gsxtmglfw330 to i8*
%addytable848 = call %clsvar* @add_address_table(%mzone* %zone840, i8* %var846, i32 0, i8* %var847, i32 3, %clsvar* %addytable845)
%address-table849 = bitcast %clsvar* %addytable848 to i8*

; insert table, function and environment into closure struct
%closure.table852 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure842, i32 0, i32 0
store i8* %address-table849, i8** %closure.table852
%closure.env853 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure842, i32 0, i32 1
store i8* %envptr843, i8** %closure.env853
%closure.func854 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure842, i32 0, i32 2
store %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)* @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0__820, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %closure.func854
%closure_size855 = call i64 @llvm_zone_mark_size(%mzone* %zone840)
call void @llvm_zone_ptr_set_size(i8* %clsptr841, i64 %closure_size855)
%wrapper_ptr856 = call i8* @llvm_zone_malloc(%mzone* %zone840, i64 8)
%closure_wrapper857 = bitcast i8* %wrapper_ptr856 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
store { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure842, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_wrapper857

; let value assignment
%GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0 = select i1 true, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_wrapper857, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_wrapper857
store { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*** %GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0
%tmp_envptr851 = getelementptr {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}, {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}***}* %environment844, i32 0, i32 0
store {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*** %GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**** %tmp_envptr851


%val860 = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*** %GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0Ptr
ret {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %val860
}


@GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWgammaramp* @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0(i16* %arg_0,i16* %arg_1,i16* %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
ret %GLFWgammaramp* %result
}


define dllexport ccc %GLFWgammaramp* @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_native(i16* %arg_0,i16* %arg_1,i16* %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
ret %GLFWgammaramp* %result
}


define dllexport ccc i8*  @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var861 = bitcast [123 x i8]* @gsxtmglfw335 to i8*
call i32 (i8*, ...) @printf(i8* %var861)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i16*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var862 = bitcast [123 x i8]* @gsxtmglfw335 to i8*
call i32 (i8*, ...) @printf(i8* %var862)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to i16*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var863 = bitcast [123 x i8]* @gsxtmglfw335 to i8*
call i32 (i8*, ...) @printf(i8* %var863)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to i16*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var864 = bitcast [123 x i8]* @gsxtmglfw335 to i8*
call i32 (i8*, ...) @printf(i8* %var864)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
%tmpres = bitcast %GLFWgammaramp* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16*, i16*, i16*, i32}*
%arg_p_0 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i16*, i16** %arg_p_0
%arg_p_1 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i16*, i16** %arg_p_1
%arg_p_2 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i16*, i16** %arg_p_2
%arg_p_3 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_h_adhoc_W0dMRldnYW1tYXJhbXAqLGkxNiosaTE2KixpMTYqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp* (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw336 = hidden constant [2 x i8] c"_\00"
@gsxtmglfw337 = hidden constant [35 x i8] c"toString_poly_W1N0cmluZyosaTE2Kl0q\00"
@gsxtmglfw338 = hidden constant [41 x i8] c"{i8*, i8*, %String* (i8*, i8*, i16*)*}**\00"
define dllexport fastcc %String* @toString_poly_W1N0cmluZyosaTE2Kl0q__866(i8* %_impz,i8* %_impenv, i16* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone867 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, i16*)*}***}*
%toString_poly_W1N0cmluZyosaTE2Kl0qPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, i16*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i16*)*}***}* %impenv, i32 0, i32 0
%toString_poly_W1N0cmluZyosaTE2Kl0qPtr = load {i8*, i8*, %String* (i8*, i8*, i16*)*}***, {i8*, i8*, %String* (i8*, i8*, i16*)*}**** %toString_poly_W1N0cmluZyosaTE2Kl0qPtr_

; setup arguments
%xPtr = alloca i16*
store i16* %x, i16** %xPtr


%var868 = bitcast [2 x i8]* @gsxtmglfw336 to i8*
%res869 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var868)
ret %String* %res869
}
@gsxtmglfw339 = hidden constant [88 x i8] c"toString_poly_W1N0cmluZyosaTE2Kl0q Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, i16*)*}** @toString_poly_W1N0cmluZyosaTE2Kl0q_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone889 = load i8*, i8** %_impzPtr
%zone890 = bitcast i8* %tzone889 to %mzone*

; let assign value to symbol toString_poly_W1N0cmluZyosaTE2Kl0q
%dat_toString_poly_W1N0cmluZyosaTE2Kl0q = call i8* @llvm_zone_malloc(%mzone* %zone890, i64 8)
%toString_poly_W1N0cmluZyosaTE2Kl0qPtr = bitcast i8* %dat_toString_poly_W1N0cmluZyosaTE2Kl0q to { i8*, i8*, %String* (i8*, i8*, i16*)*}***
%tzone870 = load i8*, i8** %_impzPtr
%zone871 = bitcast i8* %tzone870 to %mzone*
call void @llvm_zone_mark(%mzone* %zone871)
; malloc closure structure
%clsptr872 = call i8* @llvm_zone_malloc(%mzone* %zone871, i64 24)
%closure873 = bitcast i8* %clsptr872 to { i8*, i8*, %String* (i8*, i8*, i16*)*}*

; malloc environment structure
%envptr874 = call i8* @llvm_zone_malloc(%mzone* %zone871, i64 8)
%environment875 = bitcast i8* %envptr874 to {{i8*, i8*, %String* (i8*, i8*, i16*)*}***}*

; malloc closure address table
%addytable876 = call %clsvar* @new_address_table()
%var877 = bitcast [35 x i8]* @gsxtmglfw337 to i8*
%var878 = bitcast [41 x i8]* @gsxtmglfw338 to i8*
%addytable879 = call %clsvar* @add_address_table(%mzone* %zone871, i8* %var877, i32 0, i8* %var878, i32 3, %clsvar* %addytable876)
%address-table880 = bitcast %clsvar* %addytable879 to i8*

; insert table, function and environment into closure struct
%closure.table883 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16*)*}, { i8*, i8*, %String* (i8*, i8*, i16*)*}* %closure873, i32 0, i32 0
store i8* %address-table880, i8** %closure.table883
%closure.env884 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16*)*}, { i8*, i8*, %String* (i8*, i8*, i16*)*}* %closure873, i32 0, i32 1
store i8* %envptr874, i8** %closure.env884
%closure.func885 = getelementptr { i8*, i8*, %String* (i8*, i8*, i16*)*}, { i8*, i8*, %String* (i8*, i8*, i16*)*}* %closure873, i32 0, i32 2
store %String* (i8*, i8*, i16*)* @toString_poly_W1N0cmluZyosaTE2Kl0q__866, %String* (i8*, i8*, i16*)** %closure.func885
%closure_size886 = call i64 @llvm_zone_mark_size(%mzone* %zone871)
call void @llvm_zone_ptr_set_size(i8* %clsptr872, i64 %closure_size886)
%wrapper_ptr887 = call i8* @llvm_zone_malloc(%mzone* %zone871, i64 8)
%closure_wrapper888 = bitcast i8* %wrapper_ptr887 to { i8*, i8*, %String* (i8*, i8*, i16*)*}**
store { i8*, i8*, %String* (i8*, i8*, i16*)*}* %closure873, { i8*, i8*, %String* (i8*, i8*, i16*)*}** %closure_wrapper888

; let value assignment
%toString_poly_W1N0cmluZyosaTE2Kl0q = select i1 true, { i8*, i8*, %String* (i8*, i8*, i16*)*}** %closure_wrapper888, { i8*, i8*, %String* (i8*, i8*, i16*)*}** %closure_wrapper888
store { i8*, i8*, %String* (i8*, i8*, i16*)*}** %toString_poly_W1N0cmluZyosaTE2Kl0q, { i8*, i8*, %String* (i8*, i8*, i16*)*}*** %toString_poly_W1N0cmluZyosaTE2Kl0qPtr

; add data to environment
; don't need to alloc for env var toString_poly_W1N0cmluZyosaTE2Kl0q
%tmp_envptr882 = getelementptr {{i8*, i8*, %String* (i8*, i8*, i16*)*}***}, {{i8*, i8*, %String* (i8*, i8*, i16*)*}***}* %environment875, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, i16*)*}*** %toString_poly_W1N0cmluZyosaTE2Kl0qPtr, {i8*, i8*, %String* (i8*, i8*, i16*)*}**** %tmp_envptr882


%val891 = load {i8*, i8*, %String* (i8*, i8*, i16*)*}**, {i8*, i8*, %String* (i8*, i8*, i16*)*}*** %toString_poly_W1N0cmluZyosaTE2Kl0qPtr
ret {i8*, i8*, %String* (i8*, i8*, i16*)*}** %val891
}


@toString_poly_W1N0cmluZyosaTE2Kl0q_var = dllexport global [1 x i8*] [ i8* null ]

@toString_poly_W1N0cmluZyosaTE2Kl0q_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_poly_W1N0cmluZyosaTE2Kl0q_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosaTE2Kl0q_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, i16*)*}** @toString_poly_W1N0cmluZyosaTE2Kl0q_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, i16*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_poly_W1N0cmluZyosaTE2Kl0q_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_poly_W1N0cmluZyosaTE2Kl0q_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosaTE2Kl0q_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_poly_W1N0cmluZyosaTE2Kl0q(i16* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosaTE2Kl0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16*)*}*, {i8*, i8*, %String* (i8*, i8*, i16*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16*)*}, {i8*, i8*, %String* (i8*, i8*, i16*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16*)*}, {i8*, i8*, %String* (i8*, i8*, i16*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16*)*,  %String* (i8*, i8*, i16*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_poly_W1N0cmluZyosaTE2Kl0q_native(i16* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosaTE2Kl0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16*)*}*, {i8*, i8*, %String* (i8*, i8*, i16*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16*)*}, {i8*, i8*, %String* (i8*, i8*, i16*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16*)*}, {i8*, i8*, %String* (i8*, i8*, i16*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16*)*,  %String* (i8*, i8*, i16*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_poly_W1N0cmluZyosaTE2Kl0q_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var892 = bitcast [88 x i8]* @gsxtmglfw339 to i8*
call i32 (i8*, ...) @printf(i8* %var892)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i16*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosaTE2Kl0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16*)*}*, {i8*, i8*, %String* (i8*, i8*, i16*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16*)*}, {i8*, i8*, %String* (i8*, i8*, i16*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16*)*}, {i8*, i8*, %String* (i8*, i8*, i16*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16*)*,  %String* (i8*, i8*, i16*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_poly_W1N0cmluZyosaTE2Kl0q_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16*}*
%arg_p_0 = getelementptr {i16*}, {i16*}* %fstruct, i32 0, i32 0
%arg_0 = load i16*, i16** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosaTE2Kl0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, i16*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, i16*)*}*, {i8*, i8*, %String* (i8*, i8*, i16*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16*)*}, {i8*, i8*, %String* (i8*, i8*, i16*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, i16*)*}, {i8*, i8*, %String* (i8*, i8*, i16*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, i16*)*,  %String* (i8*, i8*, i16*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, i16* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw340 = hidden constant [21 x i8] c"<GLFWgammaramp:null>\00"
@gsxtmglfw341 = hidden constant [16 x i8] c"<GLFWgammaramp:\00"
@gsxtmglfw342 = hidden constant [48 x i8] c"toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd\00"
@gsxtmglfw343 = hidden constant [52 x i8] c"{i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd__865(i8* %_impz,i8* %_impenv, %GLFWgammaramp* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone893 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}***}*
%toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpdPtr = load {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}***, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}**** %toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpdPtr_

; setup arguments
%xPtr = alloca %GLFWgammaramp*
store %GLFWgammaramp* %x, %GLFWgammaramp** %xPtr


%val895 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
%val896 = icmp eq %GLFWgammaramp* %val895, null
br i1 %val896, label %then894, label %else894

then894:
%zone897 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone897)
%zone_ptr898 = bitcast %mzone* %zone897 to i8*
store i8* %zone_ptr898, i8** %_impzPtr
%tzone908 = load i8*, i8** %_impzPtr
%zone909 = bitcast i8* %tzone908 to %mzone*

; let assign value to symbol res2
%res2Ptr = alloca %String*
%tzone913 = load i8*, i8** %_impzPtr
%zone914 = bitcast i8* %tzone913 to %mzone*

; let assign value to symbol zone2
%zone2Ptr = alloca %mzone*
%tzone916 = load i8*, i8** %_impzPtr
%zone917 = bitcast i8* %tzone916 to %mzone*

; let assign value to symbol newz2
%newz2Ptr = alloca %mzone*
%tzone900 = load i8*, i8** %_impzPtr
%zone901 = bitcast i8* %tzone900 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat899 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat899, i8* %dat899
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val902 = load i8*, i8** %xx_t_mstPtr
%var903 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var904 = bitcast [21 x i8]* @gsxtmglfw340 to i8*

%val905 = call i32 (i8*,i8*, ...) @sprintf(i8* %val902, i8* %var903, i8* %var904)
%val906 = load i8*, i8** %xx_t_mstPtr
%res907 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val906)

; let value assignment
%res2 = select i1 true, %String* %res907, %String* %res907
store %String* %res2, %String** %res2Ptr

%oldzone910 = call %mzone* @llvm_pop_zone_stack()
%newzone911 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr912 = bitcast %mzone* %newzone911 to i8*
store i8* %zone_ptr912, i8** %_impzPtr

; let value assignment
%zone2 = select i1 true, %mzone* %oldzone910, %mzone* %oldzone910
store %mzone* %zone2, %mzone** %zone2Ptr

%res915 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz2 = select i1 true, %mzone* %res915, %mzone* %res915
store %mzone* %newz2, %mzone** %newz2Ptr

%tzone922 = load i8*, i8** %_impzPtr
%zone923 = bitcast i8* %tzone922 to %mzone*

; let assign value to symbol rescopy2
%rescopy2Ptr = alloca %String*
%tzone928 = load i8*, i8** %_impzPtr
%zone929 = bitcast i8* %tzone928 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone931 = load i8*, i8** %_impzPtr
%zone932 = bitcast i8* %tzone931 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val918 = load %String*, %String** %res2Ptr
%val919 = load %mzone*, %mzone** %zone2Ptr
%val920 = load %mzone*, %mzone** %newz2Ptr
%res921 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val918, %mzone* %val919, %mzone* %val920)

; let value assignment
%rescopy2 = select i1 true, %String* %res921, %String* %res921
store %String* %rescopy2, %String** %rescopy2Ptr

%val924 = load %mzone*, %mzone** %zone2Ptr
; tuple ref
%val925 = getelementptr %mzone, %mzone* %val924, i64 0, i32 4
%val926 = load i8*, i8** %val925
%val927 = bitcast i8* %val926 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val927, {i64,i8*,i8*}* %val927
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null930 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null930, {i8*, i8*, void (i8*, i8*)*}** %null930
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone968 = load i8*, i8** %_impzPtr
%zone969 = bitcast i8* %tzone968 to %mzone*
%ifptr958 = alloca i1
%ifptr934 = alloca i1
; while loop
%val935 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val936 = icmp eq {i64,i8*,i8*}* %val935, null
br i1 %val936, label %then934, label %else934

then934:
%res937 = call ccc i1 @impc_false()
store i1 %res937, i1* %ifptr934
br label %ifcont934

else934:
%res938 = call ccc i1 @impc_true()
store i1 %res938, i1* %ifptr934
br label %ifcont934

ifcont934:
%ifres939 = load i1, i1* %ifptr934

br i1 %ifres939, label %loop933, label %after933

loop933:
; do set!
%val940 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val941 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val940, i64 0, i32 1
%val942 = load i8*, i8** %val941
%val943 = bitcast i8* %val942 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val943, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval944 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val945 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval944
%fPtr946 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val945, i32 0, i32 2
%ePtr947 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val945, i32 0, i32 1
%f948 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr946
%e949 = load i8*, i8** %ePtr947
%tzone950 = load i8*, i8** %_impzPtr
%zone951 = bitcast i8* %tzone950 to %mzone*
%z952 = bitcast %mzone* %zone951 to i8*
tail call fastcc void %f948(i8* %z952, i8* %e949)
; do set!
%val954 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val955 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val954, i64 0, i32 2
%val956 = load i8*, i8** %val955
%val957 = bitcast i8* %val956 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val957, {i64,i8*,i8*}** %hookPtr
%val959 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val960 = icmp eq {i64,i8*,i8*}* %val959, null
br i1 %val960, label %then958, label %else958

then958:
%res961 = call ccc i1 @impc_false()
store i1 %res961, i1* %ifptr958
br label %ifcont958

else958:
%res962 = call ccc i1 @impc_true()
store i1 %res962, i1* %ifptr958
br label %ifcont958

ifcont958:
%ifres963 = load i1, i1* %ifptr958

br i1 %ifres963, label %loop933, label %after933

after933:
%val965 = load %mzone*, %mzone** %zone2Ptr
call ccc void @llvm_zone_destroy(%mzone* %val965)
%val967 = load %String*, %String** %rescopy2Ptr
ret %String* %val967

else894:
%zone970 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone970)
%zone_ptr971 = bitcast %mzone* %zone970 to i8*
store i8* %zone_ptr971, i8** %_impzPtr
%tzone1041 = load i8*, i8** %_impzPtr
%zone1042 = bitcast i8* %tzone1041 to %mzone*

; let assign value to symbol res3
%res3Ptr = alloca %String*
%tzone1046 = load i8*, i8** %_impzPtr
%zone1047 = bitcast i8* %tzone1046 to %mzone*

; let assign value to symbol zone3
%zone3Ptr = alloca %mzone*
%tzone1049 = load i8*, i8** %_impzPtr
%zone1050 = bitcast i8* %tzone1049 to %mzone*

; let assign value to symbol newz3
%newz3Ptr = alloca %mzone*
%tzone973 = load i8*, i8** %_impzPtr
%zone974 = bitcast i8* %tzone973 to %mzone*

; let assign value to symbol xx_t_mst_s_10
%xx_t_mst_s_10Ptr = alloca i8*
%dat972 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_10 = select i1 true, i8* %dat972, i8* %dat972
store i8* %xx_t_mst_s_10, i8** %xx_t_mst_s_10Ptr

%val975 = load i8*, i8** %xx_t_mst_s_10Ptr
%var976 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var977 = bitcast [16 x i8]* @gsxtmglfw341 to i8*

%val978 = call i32 (i8*,i8*, ...) @sprintf(i8* %val975, i8* %var976, i8* %var977)
%val979 = load i8*, i8** %xx_t_mst_s_10Ptr
%res980 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val979)
%val981 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val982 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val981, i64 0, i32 0
%val983 = load i16*, i16** %val982
%res984 = call fastcc %String* @toString_poly_W1N0cmluZyosaTE2Kl0q(i16* %val983)
%res985 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res980, %String* %res984)
%tzone987 = load i8*, i8** %_impzPtr
%zone988 = bitcast i8* %tzone987 to %mzone*

; let assign value to symbol xx_t_mst_s_11
%xx_t_mst_s_11Ptr = alloca i8*
%dat986 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_11 = select i1 true, i8* %dat986, i8* %dat986
store i8* %xx_t_mst_s_11, i8** %xx_t_mst_s_11Ptr

%val989 = load i8*, i8** %xx_t_mst_s_11Ptr
%var990 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var991 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val992 = call i32 (i8*,i8*, ...) @sprintf(i8* %val989, i8* %var990, i8* %var991)
%val993 = load i8*, i8** %xx_t_mst_s_11Ptr
%res994 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val993)
%res995 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res985, %String* %res994)
%val996 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val997 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val996, i64 0, i32 1
%val998 = load i16*, i16** %val997
%res999 = call fastcc %String* @toString_poly_W1N0cmluZyosaTE2Kl0q(i16* %val998)
%res1000 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res995, %String* %res999)
%tzone1002 = load i8*, i8** %_impzPtr
%zone1003 = bitcast i8* %tzone1002 to %mzone*

; let assign value to symbol xx_t_mst_s_12
%xx_t_mst_s_12Ptr = alloca i8*
%dat1001 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_12 = select i1 true, i8* %dat1001, i8* %dat1001
store i8* %xx_t_mst_s_12, i8** %xx_t_mst_s_12Ptr

%val1004 = load i8*, i8** %xx_t_mst_s_12Ptr
%var1005 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1006 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val1007 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1004, i8* %var1005, i8* %var1006)
%val1008 = load i8*, i8** %xx_t_mst_s_12Ptr
%res1009 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1008)
%res1010 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1000, %String* %res1009)
%val1011 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1012 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1011, i64 0, i32 2
%val1013 = load i16*, i16** %val1012
%res1014 = call fastcc %String* @toString_poly_W1N0cmluZyosaTE2Kl0q(i16* %val1013)
%res1015 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1010, %String* %res1014)
%tzone1017 = load i8*, i8** %_impzPtr
%zone1018 = bitcast i8* %tzone1017 to %mzone*

; let assign value to symbol xx_t_mst_s_13
%xx_t_mst_s_13Ptr = alloca i8*
%dat1016 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_13 = select i1 true, i8* %dat1016, i8* %dat1016
store i8* %xx_t_mst_s_13, i8** %xx_t_mst_s_13Ptr

%val1019 = load i8*, i8** %xx_t_mst_s_13Ptr
%var1020 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1021 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val1022 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1019, i8* %var1020, i8* %var1021)
%val1023 = load i8*, i8** %xx_t_mst_s_13Ptr
%res1024 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1023)
%res1025 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1015, %String* %res1024)
%val1026 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1027 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1026, i64 0, i32 3
%val1028 = load i32, i32* %val1027
%res1029 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val1028)
%res1030 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1025, %String* %res1029)
%tzone1032 = load i8*, i8** %_impzPtr
%zone1033 = bitcast i8* %tzone1032 to %mzone*

; let assign value to symbol xx_t_mst_s_14
%xx_t_mst_s_14Ptr = alloca i8*
%dat1031 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_14 = select i1 true, i8* %dat1031, i8* %dat1031
store i8* %xx_t_mst_s_14, i8** %xx_t_mst_s_14Ptr

%val1034 = load i8*, i8** %xx_t_mst_s_14Ptr
%var1035 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1036 = bitcast [2 x i8]* @gsxtmglfw311 to i8*

%val1037 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1034, i8* %var1035, i8* %var1036)
%val1038 = load i8*, i8** %xx_t_mst_s_14Ptr
%res1039 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1038)
%res1040 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1030, %String* %res1039)

; let value assignment
%res3 = select i1 true, %String* %res1040, %String* %res1040
store %String* %res3, %String** %res3Ptr

%oldzone1043 = call %mzone* @llvm_pop_zone_stack()
%newzone1044 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1045 = bitcast %mzone* %newzone1044 to i8*
store i8* %zone_ptr1045, i8** %_impzPtr

; let value assignment
%zone3 = select i1 true, %mzone* %oldzone1043, %mzone* %oldzone1043
store %mzone* %zone3, %mzone** %zone3Ptr

%res1048 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz3 = select i1 true, %mzone* %res1048, %mzone* %res1048
store %mzone* %newz3, %mzone** %newz3Ptr

%tzone1055 = load i8*, i8** %_impzPtr
%zone1056 = bitcast i8* %tzone1055 to %mzone*

; let assign value to symbol rescopy3
%rescopy3Ptr = alloca %String*
%tzone1061 = load i8*, i8** %_impzPtr
%zone1062 = bitcast i8* %tzone1061 to %mzone*

; let assign value to symbol hook_s_15
%hook_s_15Ptr = alloca {i64,i8*,i8*}*
%tzone1064 = load i8*, i8** %_impzPtr
%zone1065 = bitcast i8* %tzone1064 to %mzone*

; let assign value to symbol f_s_16
%f_s_16Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val1051 = load %String*, %String** %res3Ptr
%val1052 = load %mzone*, %mzone** %zone3Ptr
%val1053 = load %mzone*, %mzone** %newz3Ptr
%res1054 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val1051, %mzone* %val1052, %mzone* %val1053)

; let value assignment
%rescopy3 = select i1 true, %String* %res1054, %String* %res1054
store %String* %rescopy3, %String** %rescopy3Ptr

%val1057 = load %mzone*, %mzone** %zone3Ptr
; tuple ref
%val1058 = getelementptr %mzone, %mzone* %val1057, i64 0, i32 4
%val1059 = load i8*, i8** %val1058
%val1060 = bitcast i8* %val1059 to {i64,i8*,i8*}*

; let value assignment
%hook_s_15 = select i1 true, {i64,i8*,i8*}* %val1060, {i64,i8*,i8*}* %val1060
store {i64,i8*,i8*}* %hook_s_15, {i64,i8*,i8*}** %hook_s_15Ptr

%null1063 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_16 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null1063, {i8*, i8*, void (i8*, i8*)*}** %null1063
store {i8*, i8*, void (i8*, i8*)*}** %f_s_16, {i8*, i8*, void (i8*, i8*)*}*** %f_s_16Ptr

; promote local stack var allocations
%tzone1101 = load i8*, i8** %_impzPtr
%zone1102 = bitcast i8* %tzone1101 to %mzone*
%ifptr1091 = alloca i1
%ifptr1067 = alloca i1
; while loop
%val1068 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_15Ptr
%val1069 = icmp eq {i64,i8*,i8*}* %val1068, null
br i1 %val1069, label %then1067, label %else1067

then1067:
%res1070 = call ccc i1 @impc_false()
store i1 %res1070, i1* %ifptr1067
br label %ifcont1067

else1067:
%res1071 = call ccc i1 @impc_true()
store i1 %res1071, i1* %ifptr1067
br label %ifcont1067

ifcont1067:
%ifres1072 = load i1, i1* %ifptr1067

br i1 %ifres1072, label %loop1066, label %after1066

loop1066:
; do set!
%val1073 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_15Ptr
; tuple ref
%val1074 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1073, i64 0, i32 1
%val1075 = load i8*, i8** %val1074
%val1076 = bitcast i8* %val1075 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val1076, {i8*, i8*, void (i8*, i8*)*}*** %f_s_16Ptr

; apply closure 
%vval1077 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_16Ptr
%val1078 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval1077
%fPtr1079 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1078, i32 0, i32 2
%ePtr1080 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1078, i32 0, i32 1
%f1081 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr1079
%e1082 = load i8*, i8** %ePtr1080
%tzone1083 = load i8*, i8** %_impzPtr
%zone1084 = bitcast i8* %tzone1083 to %mzone*
%z1085 = bitcast %mzone* %zone1084 to i8*
tail call fastcc void %f1081(i8* %z1085, i8* %e1082)
; do set!
%val1087 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_15Ptr
; tuple ref
%val1088 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1087, i64 0, i32 2
%val1089 = load i8*, i8** %val1088
%val1090 = bitcast i8* %val1089 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val1090, {i64,i8*,i8*}** %hook_s_15Ptr
%val1092 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_15Ptr
%val1093 = icmp eq {i64,i8*,i8*}* %val1092, null
br i1 %val1093, label %then1091, label %else1091

then1091:
%res1094 = call ccc i1 @impc_false()
store i1 %res1094, i1* %ifptr1091
br label %ifcont1091

else1091:
%res1095 = call ccc i1 @impc_true()
store i1 %res1095, i1* %ifptr1091
br label %ifcont1091

ifcont1091:
%ifres1096 = load i1, i1* %ifptr1091

br i1 %ifres1096, label %loop1066, label %after1066

after1066:
%val1098 = load %mzone*, %mzone** %zone3Ptr
call ccc void @llvm_zone_destroy(%mzone* %val1098)
%val1100 = load %String*, %String** %rescopy3Ptr
ret %String* %val1100
}
@gsxtmglfw344 = hidden constant [101 x i8] c"toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}** @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1122 = load i8*, i8** %_impzPtr
%zone1123 = bitcast i8* %tzone1122 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd
%dat_toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd = call i8* @llvm_zone_malloc(%mzone* %zone1123, i64 8)
%toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd to { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}***
%tzone1103 = load i8*, i8** %_impzPtr
%zone1104 = bitcast i8* %tzone1103 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1104)
; malloc closure structure
%clsptr1105 = call i8* @llvm_zone_malloc(%mzone* %zone1104, i64 24)
%closure1106 = bitcast i8* %clsptr1105 to { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}*

; malloc environment structure
%envptr1107 = call i8* @llvm_zone_malloc(%mzone* %zone1104, i64 8)
%environment1108 = bitcast i8* %envptr1107 to {{i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}***}*

; malloc closure address table
%addytable1109 = call %clsvar* @new_address_table()
%var1110 = bitcast [48 x i8]* @gsxtmglfw342 to i8*
%var1111 = bitcast [52 x i8]* @gsxtmglfw343 to i8*
%addytable1112 = call %clsvar* @add_address_table(%mzone* %zone1104, i8* %var1110, i32 0, i8* %var1111, i32 3, %clsvar* %addytable1109)
%address-table1113 = bitcast %clsvar* %addytable1112 to i8*

; insert table, function and environment into closure struct
%closure.table1116 = getelementptr { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}, { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}* %closure1106, i32 0, i32 0
store i8* %address-table1113, i8** %closure.table1116
%closure.env1117 = getelementptr { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}, { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}* %closure1106, i32 0, i32 1
store i8* %envptr1107, i8** %closure.env1117
%closure.func1118 = getelementptr { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}, { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}* %closure1106, i32 0, i32 2
store %String* (i8*, i8*, %GLFWgammaramp*)* @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd__865, %String* (i8*, i8*, %GLFWgammaramp*)** %closure.func1118
%closure_size1119 = call i64 @llvm_zone_mark_size(%mzone* %zone1104)
call void @llvm_zone_ptr_set_size(i8* %clsptr1105, i64 %closure_size1119)
%wrapper_ptr1120 = call i8* @llvm_zone_malloc(%mzone* %zone1104, i64 8)
%closure_wrapper1121 = bitcast i8* %wrapper_ptr1120 to { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}**
store { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}* %closure1106, { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}** %closure_wrapper1121

; let value assignment
%toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}** %closure_wrapper1121, { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}** %closure_wrapper1121
store { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}** %toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd, { i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}*** %toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd
%tmp_envptr1115 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}***}* %environment1108, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}*** %toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpdPtr, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}**** %tmp_envptr1115


%val1124 = load {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}**, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}*** %toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpdPtr
ret {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}** %val1124
}


@toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}** @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd(%GLFWgammaramp* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %GLFWgammaramp*)*,  %String* (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_native(%GLFWgammaramp* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %GLFWgammaramp*)*,  %String* (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1125 = bitcast [101 x i8]* @gsxtmglfw344 to i8*
call i32 (i8*, ...) @printf(i8* %var1125)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWgammaramp*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %GLFWgammaramp*)*,  %String* (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWgammaramp*}*
%arg_p_0 = getelementptr {%GLFWgammaramp*}, {%GLFWgammaramp*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWgammaramp*, %GLFWgammaramp** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %GLFWgammaramp*)*,  %String* (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw345 = hidden constant [28 x i8] c"print_poly_W3ZvaWQsaTE2Kl0q\00"
@gsxtmglfw346 = hidden constant [37 x i8] c"{i8*, i8*, void (i8*, i8*, i16*)*}**\00"
define dllexport fastcc void @print_poly_W3ZvaWQsaTE2Kl0q__1127(i8* %_impz,i8* %_impenv, i16* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1128 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i16*)*}***}*
%print_poly_W3ZvaWQsaTE2Kl0qPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i16*)*}***}, {{i8*, i8*, void (i8*, i8*, i16*)*}***}* %impenv, i32 0, i32 0
%print_poly_W3ZvaWQsaTE2Kl0qPtr = load {i8*, i8*, void (i8*, i8*, i16*)*}***, {i8*, i8*, void (i8*, i8*, i16*)*}**** %print_poly_W3ZvaWQsaTE2Kl0qPtr_

; setup arguments
%xPtr = alloca i16*
store i16* %x, i16** %xPtr


%var1129 = bitcast [2 x i8]* @gsxtmglfw336 to i8*

%val1130 = call i32 (i8*, ...) @printf(i8* %var1129)
ret void
}
@gsxtmglfw347 = hidden constant [81 x i8] c"print_poly_W3ZvaWQsaTE2Kl0q Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i16*)*}** @print_poly_W3ZvaWQsaTE2Kl0q_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1151 = load i8*, i8** %_impzPtr
%zone1152 = bitcast i8* %tzone1151 to %mzone*

; let assign value to symbol print_poly_W3ZvaWQsaTE2Kl0q
%dat_print_poly_W3ZvaWQsaTE2Kl0q = call i8* @llvm_zone_malloc(%mzone* %zone1152, i64 8)
%print_poly_W3ZvaWQsaTE2Kl0qPtr = bitcast i8* %dat_print_poly_W3ZvaWQsaTE2Kl0q to { i8*, i8*, void (i8*, i8*, i16*)*}***
%tzone1132 = load i8*, i8** %_impzPtr
%zone1133 = bitcast i8* %tzone1132 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1133)
; malloc closure structure
%clsptr1134 = call i8* @llvm_zone_malloc(%mzone* %zone1133, i64 24)
%closure1135 = bitcast i8* %clsptr1134 to { i8*, i8*, void (i8*, i8*, i16*)*}*

; malloc environment structure
%envptr1136 = call i8* @llvm_zone_malloc(%mzone* %zone1133, i64 8)
%environment1137 = bitcast i8* %envptr1136 to {{i8*, i8*, void (i8*, i8*, i16*)*}***}*

; malloc closure address table
%addytable1138 = call %clsvar* @new_address_table()
%var1139 = bitcast [28 x i8]* @gsxtmglfw345 to i8*
%var1140 = bitcast [37 x i8]* @gsxtmglfw346 to i8*
%addytable1141 = call %clsvar* @add_address_table(%mzone* %zone1133, i8* %var1139, i32 0, i8* %var1140, i32 3, %clsvar* %addytable1138)
%address-table1142 = bitcast %clsvar* %addytable1141 to i8*

; insert table, function and environment into closure struct
%closure.table1145 = getelementptr { i8*, i8*, void (i8*, i8*, i16*)*}, { i8*, i8*, void (i8*, i8*, i16*)*}* %closure1135, i32 0, i32 0
store i8* %address-table1142, i8** %closure.table1145
%closure.env1146 = getelementptr { i8*, i8*, void (i8*, i8*, i16*)*}, { i8*, i8*, void (i8*, i8*, i16*)*}* %closure1135, i32 0, i32 1
store i8* %envptr1136, i8** %closure.env1146
%closure.func1147 = getelementptr { i8*, i8*, void (i8*, i8*, i16*)*}, { i8*, i8*, void (i8*, i8*, i16*)*}* %closure1135, i32 0, i32 2
store void (i8*, i8*, i16*)* @print_poly_W3ZvaWQsaTE2Kl0q__1127, void (i8*, i8*, i16*)** %closure.func1147
%closure_size1148 = call i64 @llvm_zone_mark_size(%mzone* %zone1133)
call void @llvm_zone_ptr_set_size(i8* %clsptr1134, i64 %closure_size1148)
%wrapper_ptr1149 = call i8* @llvm_zone_malloc(%mzone* %zone1133, i64 8)
%closure_wrapper1150 = bitcast i8* %wrapper_ptr1149 to { i8*, i8*, void (i8*, i8*, i16*)*}**
store { i8*, i8*, void (i8*, i8*, i16*)*}* %closure1135, { i8*, i8*, void (i8*, i8*, i16*)*}** %closure_wrapper1150

; let value assignment
%print_poly_W3ZvaWQsaTE2Kl0q = select i1 true, { i8*, i8*, void (i8*, i8*, i16*)*}** %closure_wrapper1150, { i8*, i8*, void (i8*, i8*, i16*)*}** %closure_wrapper1150
store { i8*, i8*, void (i8*, i8*, i16*)*}** %print_poly_W3ZvaWQsaTE2Kl0q, { i8*, i8*, void (i8*, i8*, i16*)*}*** %print_poly_W3ZvaWQsaTE2Kl0qPtr

; add data to environment
; don't need to alloc for env var print_poly_W3ZvaWQsaTE2Kl0q
%tmp_envptr1144 = getelementptr {{i8*, i8*, void (i8*, i8*, i16*)*}***}, {{i8*, i8*, void (i8*, i8*, i16*)*}***}* %environment1137, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i16*)*}*** %print_poly_W3ZvaWQsaTE2Kl0qPtr, {i8*, i8*, void (i8*, i8*, i16*)*}**** %tmp_envptr1144


%val1153 = load {i8*, i8*, void (i8*, i8*, i16*)*}**, {i8*, i8*, void (i8*, i8*, i16*)*}*** %print_poly_W3ZvaWQsaTE2Kl0qPtr
ret {i8*, i8*, void (i8*, i8*, i16*)*}** %val1153
}


@print_poly_W3ZvaWQsaTE2Kl0q_var = dllexport global [1 x i8*] [ i8* null ]

@print_poly_W3ZvaWQsaTE2Kl0q_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_poly_W3ZvaWQsaTE2Kl0q_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsaTE2Kl0q_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i16*)*}** @print_poly_W3ZvaWQsaTE2Kl0q_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i16*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_poly_W3ZvaWQsaTE2Kl0q_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_poly_W3ZvaWQsaTE2Kl0q_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsaTE2Kl0q_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_poly_W3ZvaWQsaTE2Kl0q(i16* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsaTE2Kl0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16*)*}*, {i8*, i8*, void (i8*, i8*, i16*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*)*}, {i8*, i8*, void (i8*, i8*, i16*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*)*}, {i8*, i8*, void (i8*, i8*, i16*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16*)*,  void (i8*, i8*, i16*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16* %arg_0)
ret void
}


define dllexport ccc void @print_poly_W3ZvaWQsaTE2Kl0q_native(i16* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsaTE2Kl0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16*)*}*, {i8*, i8*, void (i8*, i8*, i16*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*)*}, {i8*, i8*, void (i8*, i8*, i16*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*)*}, {i8*, i8*, void (i8*, i8*, i16*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16*)*,  void (i8*, i8*, i16*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16* %arg_0)
ret void
}


define dllexport ccc i8*  @print_poly_W3ZvaWQsaTE2Kl0q_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1154 = bitcast [81 x i8]* @gsxtmglfw347 to i8*
call i32 (i8*, ...) @printf(i8* %var1154)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i16*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsaTE2Kl0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16*)*}*, {i8*, i8*, void (i8*, i8*, i16*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*)*}, {i8*, i8*, void (i8*, i8*, i16*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*)*}, {i8*, i8*, void (i8*, i8*, i16*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16*)*,  void (i8*, i8*, i16*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_poly_W3ZvaWQsaTE2Kl0q_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16*}*
%arg_p_0 = getelementptr {i16*}, {i16*}* %fstruct, i32 0, i32 0
%arg_0 = load i16*, i16** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsaTE2Kl0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i16*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i16*)*}*, {i8*, i8*, void (i8*, i8*, i16*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*)*}, {i8*, i8*, void (i8*, i8*, i16*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i16*)*}, {i8*, i8*, void (i8*, i8*, i16*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i16*)*,  void (i8*, i8*, i16*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i16* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw348 = hidden constant [41 x i8] c"print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd\00"
@gsxtmglfw349 = hidden constant [48 x i8] c"{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd__1126(i8* %_impz,i8* %_impenv, %GLFWgammaramp* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1155 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***}*
%print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***}, {{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr = load {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**** %print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr_

; setup arguments
%xPtr = alloca %GLFWgammaramp*
store %GLFWgammaramp* %x, %GLFWgammaramp** %xPtr


%val1157 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
%val1158 = icmp eq %GLFWgammaramp* %val1157, null
br i1 %val1158, label %then1156, label %else1156

then1156:
%var1159 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1160 = bitcast [21 x i8]* @gsxtmglfw340 to i8*

%val1161 = call i32 (i8*, ...) @printf(i8* %var1159, i8* %var1160)
br label %ifcont1156

else1156:
%var1163 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1164 = bitcast [16 x i8]* @gsxtmglfw341 to i8*

%val1165 = call i32 (i8*, ...) @printf(i8* %var1163, i8* %var1164)
%val1166 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1167 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1166, i64 0, i32 0
%val1168 = load i16*, i16** %val1167
call fastcc void @print_poly_W3ZvaWQsaTE2Kl0q(i16* %val1168)
%var1170 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1171 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val1172 = call i32 (i8*, ...) @printf(i8* %var1170, i8* %var1171)
%val1173 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1174 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1173, i64 0, i32 1
%val1175 = load i16*, i16** %val1174
call fastcc void @print_poly_W3ZvaWQsaTE2Kl0q(i16* %val1175)
%var1177 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1178 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val1179 = call i32 (i8*, ...) @printf(i8* %var1177, i8* %var1178)
%val1180 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1181 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1180, i64 0, i32 2
%val1182 = load i16*, i16** %val1181
call fastcc void @print_poly_W3ZvaWQsaTE2Kl0q(i16* %val1182)
%var1184 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1185 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val1186 = call i32 (i8*, ...) @printf(i8* %var1184, i8* %var1185)
%val1187 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1188 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1187, i64 0, i32 3
%val1189 = load i32, i32* %val1188
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val1189)
%var1191 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1192 = bitcast [2 x i8]* @gsxtmglfw311 to i8*

%val1193 = call i32 (i8*, ...) @printf(i8* %var1191, i8* %var1192)
br label %ifcont1156

ifcont1156:
ret void
}
@gsxtmglfw350 = hidden constant [94 x i8] c"print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1215 = load i8*, i8** %_impzPtr
%zone1216 = bitcast i8* %tzone1215 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd
%dat_print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd = call i8* @llvm_zone_malloc(%mzone* %zone1216, i64 8)
%print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd to { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***
%tzone1196 = load i8*, i8** %_impzPtr
%zone1197 = bitcast i8* %tzone1196 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1197)
; malloc closure structure
%clsptr1198 = call i8* @llvm_zone_malloc(%mzone* %zone1197, i64 24)
%closure1199 = bitcast i8* %clsptr1198 to { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*

; malloc environment structure
%envptr1200 = call i8* @llvm_zone_malloc(%mzone* %zone1197, i64 8)
%environment1201 = bitcast i8* %envptr1200 to {{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***}*

; malloc closure address table
%addytable1202 = call %clsvar* @new_address_table()
%var1203 = bitcast [41 x i8]* @gsxtmglfw348 to i8*
%var1204 = bitcast [48 x i8]* @gsxtmglfw349 to i8*
%addytable1205 = call %clsvar* @add_address_table(%mzone* %zone1197, i8* %var1203, i32 0, i8* %var1204, i32 3, %clsvar* %addytable1202)
%address-table1206 = bitcast %clsvar* %addytable1205 to i8*

; insert table, function and environment into closure struct
%closure.table1209 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure1199, i32 0, i32 0
store i8* %address-table1206, i8** %closure.table1209
%closure.env1210 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure1199, i32 0, i32 1
store i8* %envptr1200, i8** %closure.env1210
%closure.func1211 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure1199, i32 0, i32 2
store void (i8*, i8*, %GLFWgammaramp*)* @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd__1126, void (i8*, i8*, %GLFWgammaramp*)** %closure.func1211
%closure_size1212 = call i64 @llvm_zone_mark_size(%mzone* %zone1197)
call void @llvm_zone_ptr_set_size(i8* %clsptr1198, i64 %closure_size1212)
%wrapper_ptr1213 = call i8* @llvm_zone_malloc(%mzone* %zone1197, i64 8)
%closure_wrapper1214 = bitcast i8* %wrapper_ptr1213 to { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**
store { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure1199, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_wrapper1214

; let value assignment
%print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_wrapper1214, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_wrapper1214
store { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*** %print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd
%tmp_envptr1208 = getelementptr {{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***}, {{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***}* %environment1201, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*** %print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**** %tmp_envptr1208


%val1217 = load {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*** %print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr
ret {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %val1217
}


@print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd(%GLFWgammaramp* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWgammaramp*)*,  void (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_native(%GLFWgammaramp* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWgammaramp*)*,  void (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1218 = bitcast [94 x i8]* @gsxtmglfw350 to i8*
call i32 (i8*, ...) @printf(i8* %var1218)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWgammaramp*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWgammaramp*)*,  void (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWgammaramp*}*
%arg_p_0 = getelementptr {%GLFWgammaramp*}, {%GLFWgammaramp*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWgammaramp*, %GLFWgammaramp** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWgammaramp*)*,  void (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw351 = hidden constant [71 x i8] c"GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ\00"
@gsxtmglfw352 = hidden constant [64 x i8] c"{i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}**\00"
define dllexport fastcc %GLFWgammaramp @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ__1219(i8* %_impz,i8* %_impenv, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1220 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}***}*
%GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQPtr_ = getelementptr {{i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}***}, {{i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}***}* %impenv, i32 0, i32 0
%GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQPtr = load {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}***, {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}**** %GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca i16*
store i16* %arg_0, i16** %arg_0Ptr
%arg_1Ptr = alloca i16*
store i16* %arg_1, i16** %arg_1Ptr
%arg_2Ptr = alloca i16*
store i16* %arg_2, i16** %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr


%tzone1222 = load i8*, i8** %_impzPtr
%zone1223 = bitcast i8* %tzone1222 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWgammaramp*
%dat1221 = alloca %GLFWgammaramp, align 16

; let value assignment
%obj = select i1 true, %GLFWgammaramp* %dat1221, %GLFWgammaramp* %dat1221
store %GLFWgammaramp* %obj, %GLFWgammaramp** %objPtr

%val1224 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1225 = load i16*, i16** %arg_0Ptr
; set tuple
%val1226 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1224, i64 0, i32 0
store i16* %val1225, i16** %val1226
%val1227 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1228 = load i16*, i16** %arg_1Ptr
; set tuple
%val1229 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1227, i64 0, i32 1
store i16* %val1228, i16** %val1229
%val1230 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1231 = load i16*, i16** %arg_2Ptr
; set tuple
%val1232 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1230, i64 0, i32 2
store i16* %val1231, i16** %val1232
%val1233 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1234 = load i32, i32* %arg_3Ptr
; set tuple
%val1235 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1233, i64 0, i32 3
store i32 %val1234, i32* %val1235
%val1236 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
; pointer ref
%val1237 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1236, i64 0
%val1238 = load %GLFWgammaramp, %GLFWgammaramp* %val1237
ret %GLFWgammaramp %val1238
}
@gsxtmglfw353 = hidden constant [124 x i8] c"GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}** @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1258 = load i8*, i8** %_impzPtr
%zone1259 = bitcast i8* %tzone1258 to %mzone*

; let assign value to symbol GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ
%dat_GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone1259, i64 8)
%GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQPtr = bitcast i8* %dat_GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ to { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}***
%tzone1239 = load i8*, i8** %_impzPtr
%zone1240 = bitcast i8* %tzone1239 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1240)
; malloc closure structure
%clsptr1241 = call i8* @llvm_zone_malloc(%mzone* %zone1240, i64 24)
%closure1242 = bitcast i8* %clsptr1241 to { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}*

; malloc environment structure
%envptr1243 = call i8* @llvm_zone_malloc(%mzone* %zone1240, i64 8)
%environment1244 = bitcast i8* %envptr1243 to {{i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}***}*

; malloc closure address table
%addytable1245 = call %clsvar* @new_address_table()
%var1246 = bitcast [71 x i8]* @gsxtmglfw351 to i8*
%var1247 = bitcast [64 x i8]* @gsxtmglfw352 to i8*
%addytable1248 = call %clsvar* @add_address_table(%mzone* %zone1240, i8* %var1246, i32 0, i8* %var1247, i32 3, %clsvar* %addytable1245)
%address-table1249 = bitcast %clsvar* %addytable1248 to i8*

; insert table, function and environment into closure struct
%closure.table1252 = getelementptr { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}, { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure1242, i32 0, i32 0
store i8* %address-table1249, i8** %closure.table1252
%closure.env1253 = getelementptr { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}, { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure1242, i32 0, i32 1
store i8* %envptr1243, i8** %closure.env1253
%closure.func1254 = getelementptr { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}, { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure1242, i32 0, i32 2
store %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)* @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ__1219, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)** %closure.func1254
%closure_size1255 = call i64 @llvm_zone_mark_size(%mzone* %zone1240)
call void @llvm_zone_ptr_set_size(i8* %clsptr1241, i64 %closure_size1255)
%wrapper_ptr1256 = call i8* @llvm_zone_malloc(%mzone* %zone1240, i64 8)
%closure_wrapper1257 = bitcast i8* %wrapper_ptr1256 to { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}**
store { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure1242, { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_wrapper1257

; let value assignment
%GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ = select i1 true, { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_wrapper1257, { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_wrapper1257
store { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}** %GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ, { i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}*** %GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQPtr

; add data to environment
; don't need to alloc for env var GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ
%tmp_envptr1251 = getelementptr {{i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}***}, {{i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}***}* %environment1244, i32 0, i32 0
store {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}*** %GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQPtr, {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}**** %tmp_envptr1251


%val1260 = load {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}**, {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}*** %GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQPtr
ret {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}** %val1260
}


@GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}** @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWgammaramp @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ(i16* %arg_0,i16* %arg_1,i16* %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
ret %GLFWgammaramp %result
}


define dllexport ccc %GLFWgammaramp @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_native(i16* %arg_0,i16* %arg_1,i16* %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
ret %GLFWgammaramp %result
}


define dllexport ccc void @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i16*, i16*, i16*, i32}*
%arg_p_0 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i16*, i16** %arg_p_0
%arg_p_1 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i16*, i16** %arg_p_1
%arg_p_2 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i16*, i16** %arg_p_2
%arg_p_3 = getelementptr {i16*, i16*, i16*, i32}, {i16*, i16*, i16*, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWgammaramp_val_adhoc_W0dMRldnYW1tYXJhbXAsaTE2KixpMTYqLGkxNiosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}**
%closure = load {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}*, {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}, {i8*, i8*, %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)*,  %GLFWgammaramp (i8*, i8*, i16*, i16*, i16*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp %ff(i8* %_impz, i8* %ee, i16* %arg_0, i16* %arg_1, i16* %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw354 = hidden constant [55 x i8] c"hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ\00"
@gsxtmglfw355 = hidden constant [59 x i8] c"{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}**\00"
define dllexport fastcc %GLFWgammaramp* @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ__1265(i8* %_impz,i8* %_impenv, %GLFWgammaramp* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1266 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}***}*
%hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQPtr_ = getelementptr {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}***}, {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQPtr = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}***, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}**** %hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQPtr_

; setup arguments
%xPtr = alloca %GLFWgammaramp*
store %GLFWgammaramp* %x, %GLFWgammaramp** %xPtr


%tzone1269 = load i8*, i8** %_impzPtr
%zone1270 = bitcast i8* %tzone1269 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWgammaramp*
%dat1267 = call i8* @malloc(i64 32)
call i8* @memset(i8* %dat1267, i32 0, i64 32)
%val1268 = bitcast i8* %dat1267 to %GLFWgammaramp*

; let value assignment
%obj = select i1 true, %GLFWgammaramp* %val1268, %GLFWgammaramp* %val1268
store %GLFWgammaramp* %obj, %GLFWgammaramp** %objPtr

%val1271 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1272 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1273 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1272, i64 0, i32 0
%val1274 = load i16*, i16** %val1273
; set tuple
%val1275 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1271, i64 0, i32 0
store i16* %val1274, i16** %val1275
%val1276 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1277 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1278 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1277, i64 0, i32 1
%val1279 = load i16*, i16** %val1278
; set tuple
%val1280 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1276, i64 0, i32 1
store i16* %val1279, i16** %val1280
%val1281 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1282 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1283 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1282, i64 0, i32 2
%val1284 = load i16*, i16** %val1283
; set tuple
%val1285 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1281, i64 0, i32 2
store i16* %val1284, i16** %val1285
%val1286 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1287 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1288 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1287, i64 0, i32 3
%val1289 = load i32, i32* %val1288
; set tuple
%val1290 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1286, i64 0, i32 3
store i32 %val1289, i32* %val1290
%val1291 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
ret %GLFWgammaramp* %val1291
}
@gsxtmglfw356 = hidden constant [108 x i8] c"hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}** @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1311 = load i8*, i8** %_impzPtr
%zone1312 = bitcast i8* %tzone1311 to %mzone*

; let assign value to symbol hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ
%dat_hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1312, i64 8)
%hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQPtr = bitcast i8* %dat_hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}***
%tzone1292 = load i8*, i8** %_impzPtr
%zone1293 = bitcast i8* %tzone1292 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1293)
; malloc closure structure
%clsptr1294 = call i8* @llvm_zone_malloc(%mzone* %zone1293, i64 24)
%closure1295 = bitcast i8* %clsptr1294 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}*

; malloc environment structure
%envptr1296 = call i8* @llvm_zone_malloc(%mzone* %zone1293, i64 8)
%environment1297 = bitcast i8* %envptr1296 to {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}***}*

; malloc closure address table
%addytable1298 = call %clsvar* @new_address_table()
%var1299 = bitcast [55 x i8]* @gsxtmglfw354 to i8*
%var1300 = bitcast [59 x i8]* @gsxtmglfw355 to i8*
%addytable1301 = call %clsvar* @add_address_table(%mzone* %zone1293, i8* %var1299, i32 0, i8* %var1300, i32 3, %clsvar* %addytable1298)
%address-table1302 = bitcast %clsvar* %addytable1301 to i8*

; insert table, function and environment into closure struct
%closure.table1305 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}* %closure1295, i32 0, i32 0
store i8* %address-table1302, i8** %closure.table1305
%closure.env1306 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}* %closure1295, i32 0, i32 1
store i8* %envptr1296, i8** %closure.env1306
%closure.func1307 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}* %closure1295, i32 0, i32 2
store %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)* @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ__1265, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)** %closure.func1307
%closure_size1308 = call i64 @llvm_zone_mark_size(%mzone* %zone1293)
call void @llvm_zone_ptr_set_size(i8* %clsptr1294, i64 %closure_size1308)
%wrapper_ptr1309 = call i8* @llvm_zone_malloc(%mzone* %zone1293, i64 8)
%closure_wrapper1310 = bitcast i8* %wrapper_ptr1309 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}**
store { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}* %closure1295, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}** %closure_wrapper1310

; let value assignment
%hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ = select i1 true, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}** %closure_wrapper1310, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}** %closure_wrapper1310
store { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}** %hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}*** %hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ
%tmp_envptr1304 = getelementptr {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}***}, {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}***}* %environment1297, i32 0, i32 0
store {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}*** %hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQPtr, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}**** %tmp_envptr1304


%val1313 = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}**, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}*** %hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQPtr
ret {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}** %val1313
}


@hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}** @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWgammaramp* @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ(%GLFWgammaramp* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*,  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
ret %GLFWgammaramp* %result
}


define dllexport ccc %GLFWgammaramp* @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_native(%GLFWgammaramp* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*,  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
ret %GLFWgammaramp* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1314 = bitcast [108 x i8]* @gsxtmglfw356 to i8*
call i32 (i8*, ...) @printf(i8* %var1314)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWgammaramp*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*,  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
%tmpres = bitcast %GLFWgammaramp* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWgammaramp*}*
%arg_p_0 = getelementptr {%GLFWgammaramp*}, {%GLFWgammaramp*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWgammaramp*, %GLFWgammaramp** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)*,  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw357 = hidden constant [41 x i8] c"hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd__1315(i8* %_impz,i8* %_impenv, %GLFWgammaramp* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1316 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***}*
%hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***}, {{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr = load {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**** %hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr_

; setup arguments
%xPtr = alloca %GLFWgammaramp*
store %GLFWgammaramp* %x, %GLFWgammaramp** %xPtr


%val1317 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
%val1318 = bitcast %GLFWgammaramp* %val1317 to i8*
call ccc void @free(i8* %val1318)
ret void
}
@gsxtmglfw358 = hidden constant [94 x i8] c"hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1340 = load i8*, i8** %_impzPtr
%zone1341 = bitcast i8* %tzone1340 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd
%dat_hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd = call i8* @llvm_zone_malloc(%mzone* %zone1341, i64 8)
%hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd to { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***
%tzone1321 = load i8*, i8** %_impzPtr
%zone1322 = bitcast i8* %tzone1321 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1322)
; malloc closure structure
%clsptr1323 = call i8* @llvm_zone_malloc(%mzone* %zone1322, i64 24)
%closure1324 = bitcast i8* %clsptr1323 to { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*

; malloc environment structure
%envptr1325 = call i8* @llvm_zone_malloc(%mzone* %zone1322, i64 8)
%environment1326 = bitcast i8* %envptr1325 to {{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***}*

; malloc closure address table
%addytable1327 = call %clsvar* @new_address_table()
%var1328 = bitcast [41 x i8]* @gsxtmglfw357 to i8*
%var1329 = bitcast [48 x i8]* @gsxtmglfw349 to i8*
%addytable1330 = call %clsvar* @add_address_table(%mzone* %zone1322, i8* %var1328, i32 0, i8* %var1329, i32 3, %clsvar* %addytable1327)
%address-table1331 = bitcast %clsvar* %addytable1330 to i8*

; insert table, function and environment into closure struct
%closure.table1334 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure1324, i32 0, i32 0
store i8* %address-table1331, i8** %closure.table1334
%closure.env1335 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure1324, i32 0, i32 1
store i8* %envptr1325, i8** %closure.env1335
%closure.func1336 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure1324, i32 0, i32 2
store void (i8*, i8*, %GLFWgammaramp*)* @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd__1315, void (i8*, i8*, %GLFWgammaramp*)** %closure.func1336
%closure_size1337 = call i64 @llvm_zone_mark_size(%mzone* %zone1322)
call void @llvm_zone_ptr_set_size(i8* %clsptr1323, i64 %closure_size1337)
%wrapper_ptr1338 = call i8* @llvm_zone_malloc(%mzone* %zone1322, i64 8)
%closure_wrapper1339 = bitcast i8* %wrapper_ptr1338 to { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**
store { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure1324, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_wrapper1339

; let value assignment
%hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_wrapper1339, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_wrapper1339
store { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd, { i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*** %hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd
%tmp_envptr1333 = getelementptr {{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***}, {{i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}***}* %environment1326, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*** %hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**** %tmp_envptr1333


%val1342 = load {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*** %hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpdPtr
ret {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %val1342
}


@hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd(%GLFWgammaramp* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWgammaramp*)*,  void (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_native(%GLFWgammaramp* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWgammaramp*)*,  void (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1343 = bitcast [94 x i8]* @gsxtmglfw358 to i8*
call i32 (i8*, ...) @printf(i8* %var1343)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWgammaramp*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWgammaramp*)*,  void (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWgammaramp*}*
%arg_p_0 = getelementptr {%GLFWgammaramp*}, {%GLFWgammaramp*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWgammaramp*, %GLFWgammaramp** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2dhbW1hcmFtcCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}, {i8*, i8*, void (i8*, i8*, %GLFWgammaramp*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWgammaramp*)*,  void (i8*, i8*, %GLFWgammaramp*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw359 = hidden constant [73 x i8] c"zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd\00"
@gsxtmglfw360 = hidden constant [77 x i8] c"{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %GLFWgammaramp* @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd__1344(i8* %_impz,i8* %_impenv, %GLFWgammaramp* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1345 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}***, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %GLFWgammaramp*
store %GLFWgammaramp* %x, %GLFWgammaramp** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val1347 = load %mzone*, %mzone** %fromzPtr
%val1348 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
%val1349 = bitcast %GLFWgammaramp* %val1348 to i8*
%res1350 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1347, i8* %val1349)
br i1 %res1350, label %then1346, label %else1346

then1346:
%val1351 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val1351)
%zone_ptr1352 = bitcast %mzone* %val1351 to i8*
store i8* %zone_ptr1352, i8** %_impzPtr
%tzone1358 = load i8*, i8** %_impzPtr
%zone1359 = bitcast i8* %tzone1358 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWgammaramp*
%tzone1354 = load i8*, i8** %_impzPtr
%zone1355 = bitcast i8* %tzone1354 to %mzone*
%dat1356 = call i8* @llvm_zone_malloc(%mzone* %zone1355, i64 32)
call i8* @memset(i8* %dat1356, i32 0, i64 32)
%val1357 = bitcast i8* %dat1356 to %GLFWgammaramp*

; let value assignment
%obj = select i1 true, %GLFWgammaramp* %val1357, %GLFWgammaramp* %val1357
store %GLFWgammaramp* %obj, %GLFWgammaramp** %objPtr

; promote local stack var allocations
%tzone1456 = load i8*, i8** %_impzPtr
%zone1457 = bitcast i8* %tzone1456 to %mzone*
%ifptr1418 = alloca i16*
%ifptr1389 = alloca i16*
%ifptr1360 = alloca i16*
%val1361 = load %mzone*, %mzone** %fromzPtr
%val1362 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1363 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1362, i64 0, i32 0
%val1364 = load i16*, i16** %val1363
%val1365 = bitcast i16* %val1364 to i8*
%res1366 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1361, i8* %val1365)
br i1 %res1366, label %then1360, label %else1360

then1360:
%tzone1371 = load i8*, i8** %_impzPtr
%zone1372 = bitcast i8* %tzone1371 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i16*
%tzone1367 = load i8*, i8** %_impzPtr
%zone1368 = bitcast i8* %tzone1367 to %mzone*
%dat1369 = call i8* @llvm_zone_malloc(%mzone* %zone1368, i64 2)
call i8* @memset(i8* %dat1369, i32 0, i64 2)
%val1370 = bitcast i8* %dat1369 to i16*

; let value assignment
%newptr = select i1 true, i16* %val1370, i16* %val1370
store i16* %newptr, i16** %newptrPtr

%val1373 = load i16*, i16** %newptrPtr
%val1374 = bitcast i16* %val1373 to i8*
%val1375 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1376 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1375, i64 0, i32 0
%val1377 = load i16*, i16** %val1376
%val1378 = bitcast i16* %val1377 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val1374, i8* %val1378, i64 2, i32 1, i1 0)
%val1380 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1381 = load i16*, i16** %newptrPtr
; set tuple
%val1382 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1380, i64 0, i32 0
store i16* %val1381, i16** %val1382
store i16* %val1381, i16** %ifptr1360
br label %ifcont1360

else1360:
%val1383 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1384 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1385 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1384, i64 0, i32 0
%val1386 = load i16*, i16** %val1385
; set tuple
%val1387 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1383, i64 0, i32 0
store i16* %val1386, i16** %val1387
store i16* %val1386, i16** %ifptr1360
br label %ifcont1360

ifcont1360:
%ifres1388 = load i16*, i16** %ifptr1360

%val1390 = load %mzone*, %mzone** %fromzPtr
%val1391 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1392 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1391, i64 0, i32 1
%val1393 = load i16*, i16** %val1392
%val1394 = bitcast i16* %val1393 to i8*
%res1395 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1390, i8* %val1394)
br i1 %res1395, label %then1389, label %else1389

then1389:
%tzone1400 = load i8*, i8** %_impzPtr
%zone1401 = bitcast i8* %tzone1400 to %mzone*

; let assign value to symbol newptr_s_17
%newptr_s_17Ptr = alloca i16*
%tzone1396 = load i8*, i8** %_impzPtr
%zone1397 = bitcast i8* %tzone1396 to %mzone*
%dat1398 = call i8* @llvm_zone_malloc(%mzone* %zone1397, i64 2)
call i8* @memset(i8* %dat1398, i32 0, i64 2)
%val1399 = bitcast i8* %dat1398 to i16*

; let value assignment
%newptr_s_17 = select i1 true, i16* %val1399, i16* %val1399
store i16* %newptr_s_17, i16** %newptr_s_17Ptr

%val1402 = load i16*, i16** %newptr_s_17Ptr
%val1403 = bitcast i16* %val1402 to i8*
%val1404 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1405 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1404, i64 0, i32 1
%val1406 = load i16*, i16** %val1405
%val1407 = bitcast i16* %val1406 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val1403, i8* %val1407, i64 2, i32 1, i1 0)
%val1409 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1410 = load i16*, i16** %newptr_s_17Ptr
; set tuple
%val1411 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1409, i64 0, i32 1
store i16* %val1410, i16** %val1411
store i16* %val1410, i16** %ifptr1389
br label %ifcont1389

else1389:
%val1412 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1413 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1414 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1413, i64 0, i32 1
%val1415 = load i16*, i16** %val1414
; set tuple
%val1416 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1412, i64 0, i32 1
store i16* %val1415, i16** %val1416
store i16* %val1415, i16** %ifptr1389
br label %ifcont1389

ifcont1389:
%ifres1417 = load i16*, i16** %ifptr1389

%val1419 = load %mzone*, %mzone** %fromzPtr
%val1420 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1421 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1420, i64 0, i32 2
%val1422 = load i16*, i16** %val1421
%val1423 = bitcast i16* %val1422 to i8*
%res1424 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1419, i8* %val1423)
br i1 %res1424, label %then1418, label %else1418

then1418:
%tzone1429 = load i8*, i8** %_impzPtr
%zone1430 = bitcast i8* %tzone1429 to %mzone*

; let assign value to symbol newptr_s_18
%newptr_s_18Ptr = alloca i16*
%tzone1425 = load i8*, i8** %_impzPtr
%zone1426 = bitcast i8* %tzone1425 to %mzone*
%dat1427 = call i8* @llvm_zone_malloc(%mzone* %zone1426, i64 2)
call i8* @memset(i8* %dat1427, i32 0, i64 2)
%val1428 = bitcast i8* %dat1427 to i16*

; let value assignment
%newptr_s_18 = select i1 true, i16* %val1428, i16* %val1428
store i16* %newptr_s_18, i16** %newptr_s_18Ptr

%val1431 = load i16*, i16** %newptr_s_18Ptr
%val1432 = bitcast i16* %val1431 to i8*
%val1433 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1434 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1433, i64 0, i32 2
%val1435 = load i16*, i16** %val1434
%val1436 = bitcast i16* %val1435 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val1432, i8* %val1436, i64 2, i32 1, i1 0)
%val1438 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1439 = load i16*, i16** %newptr_s_18Ptr
; set tuple
%val1440 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1438, i64 0, i32 2
store i16* %val1439, i16** %val1440
store i16* %val1439, i16** %ifptr1418
br label %ifcont1418

else1418:
%val1441 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1442 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1443 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1442, i64 0, i32 2
%val1444 = load i16*, i16** %val1443
; set tuple
%val1445 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1441, i64 0, i32 2
store i16* %val1444, i16** %val1445
store i16* %val1444, i16** %ifptr1418
br label %ifcont1418

ifcont1418:
%ifres1446 = load i16*, i16** %ifptr1418

%val1447 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
%val1448 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
; tuple ref
%val1449 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1448, i64 0, i32 3
%val1450 = load i32, i32* %val1449
; set tuple
%val1451 = getelementptr %GLFWgammaramp, %GLFWgammaramp* %val1447, i64 0, i32 3
store i32 %val1450, i32* %val1451
%oldzone1452 = call %mzone* @llvm_pop_zone_stack()
%newzone1453 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1454 = bitcast %mzone* %newzone1453 to i8*
store i8* %zone_ptr1454, i8** %_impzPtr
%val1455 = load %GLFWgammaramp*, %GLFWgammaramp** %objPtr
ret %GLFWgammaramp* %val1455

else1346:
%val1458 = load %GLFWgammaramp*, %GLFWgammaramp** %xPtr
ret %GLFWgammaramp* %val1458
}
@gsxtmglfw361 = hidden constant [126 x i8] c"zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1478 = load i8*, i8** %_impzPtr
%zone1479 = bitcast i8* %tzone1478 to %mzone*

; let assign value to symbol zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone1479, i64 8)
%zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}***
%tzone1459 = load i8*, i8** %_impzPtr
%zone1460 = bitcast i8* %tzone1459 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1460)
; malloc closure structure
%clsptr1461 = call i8* @llvm_zone_malloc(%mzone* %zone1460, i64 24)
%closure1462 = bitcast i8* %clsptr1461 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr1463 = call i8* @llvm_zone_malloc(%mzone* %zone1460, i64 8)
%environment1464 = bitcast i8* %envptr1463 to {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable1465 = call %clsvar* @new_address_table()
%var1466 = bitcast [73 x i8]* @gsxtmglfw359 to i8*
%var1467 = bitcast [77 x i8]* @gsxtmglfw360 to i8*
%addytable1468 = call %clsvar* @add_address_table(%mzone* %zone1460, i8* %var1466, i32 0, i8* %var1467, i32 3, %clsvar* %addytable1465)
%address-table1469 = bitcast %clsvar* %addytable1468 to i8*

; insert table, function and environment into closure struct
%closure.table1472 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}* %closure1462, i32 0, i32 0
store i8* %address-table1469, i8** %closure.table1472
%closure.env1473 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}* %closure1462, i32 0, i32 1
store i8* %envptr1463, i8** %closure.env1473
%closure.func1474 = getelementptr { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}* %closure1462, i32 0, i32 2
store %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)* @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd__1344, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)** %closure.func1474
%closure_size1475 = call i64 @llvm_zone_mark_size(%mzone* %zone1460)
call void @llvm_zone_ptr_set_size(i8* %clsptr1461, i64 %closure_size1475)
%wrapper_ptr1476 = call i8* @llvm_zone_malloc(%mzone* %zone1460, i64 8)
%closure_wrapper1477 = bitcast i8* %wrapper_ptr1476 to { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}**
store { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}* %closure1462, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}** %closure_wrapper1477

; let value assignment
%zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}** %closure_wrapper1477, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}** %closure_wrapper1477
store { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}** %zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd, { i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd
%tmp_envptr1471 = getelementptr {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}***}* %environment1464, i32 0, i32 0
store {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}**** %tmp_envptr1471


%val1480 = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}**, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}** %val1480
}


@zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWgammaramp* @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd(%GLFWgammaramp* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*,  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %GLFWgammaramp* %result
}


define dllexport ccc %GLFWgammaramp* @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_native(%GLFWgammaramp* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*,  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %GLFWgammaramp* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1481 = bitcast [126 x i8]* @gsxtmglfw361 to i8*
call i32 (i8*, ...) @printf(i8* %var1481)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWgammaramp*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1482 = bitcast [126 x i8]* @gsxtmglfw361 to i8*
call i32 (i8*, ...) @printf(i8* %var1482)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1483 = bitcast [126 x i8]* @gsxtmglfw361 to i8*
call i32 (i8*, ...) @printf(i8* %var1483)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*,  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %GLFWgammaramp* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWgammaramp*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%GLFWgammaramp*, %mzone*, %mzone*}, {%GLFWgammaramp*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWgammaramp*, %GLFWgammaramp** %arg_p_0
%arg_p_1 = getelementptr {%GLFWgammaramp*, %mzone*, %mzone*}, {%GLFWgammaramp*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%GLFWgammaramp*, %mzone*, %mzone*}, {%GLFWgammaramp*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRldnYW1tYXJhbXAqLEdMRldnYW1tYXJhbXAqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}*, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)*,  %GLFWgammaramp* (i8*, i8*, %GLFWgammaramp*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWgammaramp* %ff(i8* %_impz, i8* %ee, %GLFWgammaramp* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%GLFWimage = type {i32,i32,i8*}
@gsxtmglfw362 = hidden constant [49 x i8] c"GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd\00"
@gsxtmglfw363 = hidden constant [53 x i8] c"{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**\00"
define dllexport fastcc %GLFWimage* @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd__1484(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i8* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1485 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}*
%GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr_ = getelementptr {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}, {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}* %impenv, i32 0, i32 0
%GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**** %GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr


%tzone1490 = load i8*, i8** %_impzPtr
%zone1491 = bitcast i8* %tzone1490 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWimage*
%tzone1486 = load i8*, i8** %_impzPtr
%zone1487 = bitcast i8* %tzone1486 to %mzone*
%dat1488 = call i8* @llvm_zone_malloc(%mzone* %zone1487, i64 16)
call i8* @memset(i8* %dat1488, i32 0, i64 16)
%val1489 = bitcast i8* %dat1488 to %GLFWimage*

; let value assignment
%obj = select i1 true, %GLFWimage* %val1489, %GLFWimage* %val1489
store %GLFWimage* %obj, %GLFWimage** %objPtr

%val1492 = load %GLFWimage*, %GLFWimage** %objPtr
%val1493 = load i32, i32* %arg_0Ptr
; set tuple
%val1494 = getelementptr %GLFWimage, %GLFWimage* %val1492, i64 0, i32 0
store i32 %val1493, i32* %val1494
%val1495 = load %GLFWimage*, %GLFWimage** %objPtr
%val1496 = load i32, i32* %arg_1Ptr
; set tuple
%val1497 = getelementptr %GLFWimage, %GLFWimage* %val1495, i64 0, i32 1
store i32 %val1496, i32* %val1497
%val1498 = load %GLFWimage*, %GLFWimage** %objPtr
%val1499 = load i8*, i8** %arg_2Ptr
; set tuple
%val1500 = getelementptr %GLFWimage, %GLFWimage* %val1498, i64 0, i32 2
store i8* %val1499, i8** %val1500
%val1501 = load %GLFWimage*, %GLFWimage** %objPtr
ret %GLFWimage* %val1501
}
@gsxtmglfw364 = hidden constant [102 x i8] c"GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1521 = load i8*, i8** %_impzPtr
%zone1522 = bitcast i8* %tzone1521 to %mzone*

; let assign value to symbol GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd
%dat_GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone1522, i64 8)
%GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr = bitcast i8* %dat_GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd to { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***
%tzone1502 = load i8*, i8** %_impzPtr
%zone1503 = bitcast i8* %tzone1502 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1503)
; malloc closure structure
%clsptr1504 = call i8* @llvm_zone_malloc(%mzone* %zone1503, i64 24)
%closure1505 = bitcast i8* %clsptr1504 to { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*

; malloc environment structure
%envptr1506 = call i8* @llvm_zone_malloc(%mzone* %zone1503, i64 8)
%environment1507 = bitcast i8* %envptr1506 to {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}*

; malloc closure address table
%addytable1508 = call %clsvar* @new_address_table()
%var1509 = bitcast [49 x i8]* @gsxtmglfw362 to i8*
%var1510 = bitcast [53 x i8]* @gsxtmglfw363 to i8*
%addytable1511 = call %clsvar* @add_address_table(%mzone* %zone1503, i8* %var1509, i32 0, i8* %var1510, i32 3, %clsvar* %addytable1508)
%address-table1512 = bitcast %clsvar* %addytable1511 to i8*

; insert table, function and environment into closure struct
%closure.table1515 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure1505, i32 0, i32 0
store i8* %address-table1512, i8** %closure.table1515
%closure.env1516 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure1505, i32 0, i32 1
store i8* %envptr1506, i8** %closure.env1516
%closure.func1517 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure1505, i32 0, i32 2
store %GLFWimage* (i8*, i8*, i32, i32, i8*)* @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd__1484, %GLFWimage* (i8*, i8*, i32, i32, i8*)** %closure.func1517
%closure_size1518 = call i64 @llvm_zone_mark_size(%mzone* %zone1503)
call void @llvm_zone_ptr_set_size(i8* %clsptr1504, i64 %closure_size1518)
%wrapper_ptr1519 = call i8* @llvm_zone_malloc(%mzone* %zone1503, i64 8)
%closure_wrapper1520 = bitcast i8* %wrapper_ptr1519 to { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
store { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure1505, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_wrapper1520

; let value assignment
%GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd = select i1 true, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_wrapper1520, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_wrapper1520
store { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*** %GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr

; add data to environment
; don't need to alloc for env var GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd
%tmp_envptr1514 = getelementptr {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}, {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}* %environment1507, i32 0, i32 0
store {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*** %GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**** %tmp_envptr1514


%val1523 = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*** %GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr
ret {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %val1523
}


@GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWimage* @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd(i32 %arg_0,i32 %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, i32, i32, i8*)*,  %GLFWimage* (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
ret %GLFWimage* %result
}


define dllexport ccc %GLFWimage* @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_native(i32 %arg_0,i32 %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, i32, i32, i8*)*,  %GLFWimage* (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
ret %GLFWimage* %result
}


define dllexport ccc i8*  @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1524 = bitcast [102 x i8]* @gsxtmglfw364 to i8*
call i32 (i8*, ...) @printf(i8* %var1524)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1525 = bitcast [102 x i8]* @gsxtmglfw364 to i8*
call i32 (i8*, ...) @printf(i8* %var1525)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1526 = bitcast [102 x i8]* @gsxtmglfw364 to i8*
call i32 (i8*, ...) @printf(i8* %var1526)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, i32, i32, i8*)*,  %GLFWimage* (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
%tmpres = bitcast %GLFWimage* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i8*}*
%arg_p_0 = getelementptr {i32, i32, i8*}, {i32, i32, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i8*}, {i32, i32, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i8*}, {i32, i32, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, i32, i32, i8*)*,  %GLFWimage* (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw365 = hidden constant [51 x i8] c"GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd\00"
define dllexport fastcc %GLFWimage* @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd__1527(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i8* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1528 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}*
%GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr_ = getelementptr {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}, {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}* %impenv, i32 0, i32 0
%GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**** %GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr


%tzone1533 = load i8*, i8** %_impzPtr
%zone1534 = bitcast i8* %tzone1533 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWimage*
%tzone1529 = load i8*, i8** %_impzPtr
%zone1530 = bitcast i8* %tzone1529 to %mzone*
%dat1531 = call i8* @llvm_zone_malloc(%mzone* %zone1530, i64 16)
call i8* @memset(i8* %dat1531, i32 0, i64 16)
%val1532 = bitcast i8* %dat1531 to %GLFWimage*

; let value assignment
%obj = select i1 true, %GLFWimage* %val1532, %GLFWimage* %val1532
store %GLFWimage* %obj, %GLFWimage** %objPtr

%val1535 = load %GLFWimage*, %GLFWimage** %objPtr
%val1536 = load i32, i32* %arg_0Ptr
; set tuple
%val1537 = getelementptr %GLFWimage, %GLFWimage* %val1535, i64 0, i32 0
store i32 %val1536, i32* %val1537
%val1538 = load %GLFWimage*, %GLFWimage** %objPtr
%val1539 = load i32, i32* %arg_1Ptr
; set tuple
%val1540 = getelementptr %GLFWimage, %GLFWimage* %val1538, i64 0, i32 1
store i32 %val1539, i32* %val1540
%val1541 = load %GLFWimage*, %GLFWimage** %objPtr
%val1542 = load i8*, i8** %arg_2Ptr
; set tuple
%val1543 = getelementptr %GLFWimage, %GLFWimage* %val1541, i64 0, i32 2
store i8* %val1542, i8** %val1543
%val1544 = load %GLFWimage*, %GLFWimage** %objPtr
ret %GLFWimage* %val1544
}
@gsxtmglfw366 = hidden constant [104 x i8] c"GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1564 = load i8*, i8** %_impzPtr
%zone1565 = bitcast i8* %tzone1564 to %mzone*

; let assign value to symbol GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd
%dat_GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone1565, i64 8)
%GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr = bitcast i8* %dat_GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd to { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***
%tzone1545 = load i8*, i8** %_impzPtr
%zone1546 = bitcast i8* %tzone1545 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1546)
; malloc closure structure
%clsptr1547 = call i8* @llvm_zone_malloc(%mzone* %zone1546, i64 24)
%closure1548 = bitcast i8* %clsptr1547 to { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*

; malloc environment structure
%envptr1549 = call i8* @llvm_zone_malloc(%mzone* %zone1546, i64 8)
%environment1550 = bitcast i8* %envptr1549 to {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}*

; malloc closure address table
%addytable1551 = call %clsvar* @new_address_table()
%var1552 = bitcast [51 x i8]* @gsxtmglfw365 to i8*
%var1553 = bitcast [53 x i8]* @gsxtmglfw363 to i8*
%addytable1554 = call %clsvar* @add_address_table(%mzone* %zone1546, i8* %var1552, i32 0, i8* %var1553, i32 3, %clsvar* %addytable1551)
%address-table1555 = bitcast %clsvar* %addytable1554 to i8*

; insert table, function and environment into closure struct
%closure.table1558 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure1548, i32 0, i32 0
store i8* %address-table1555, i8** %closure.table1558
%closure.env1559 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure1548, i32 0, i32 1
store i8* %envptr1549, i8** %closure.env1559
%closure.func1560 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure1548, i32 0, i32 2
store %GLFWimage* (i8*, i8*, i32, i32, i8*)* @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd__1527, %GLFWimage* (i8*, i8*, i32, i32, i8*)** %closure.func1560
%closure_size1561 = call i64 @llvm_zone_mark_size(%mzone* %zone1546)
call void @llvm_zone_ptr_set_size(i8* %clsptr1547, i64 %closure_size1561)
%wrapper_ptr1562 = call i8* @llvm_zone_malloc(%mzone* %zone1546, i64 8)
%closure_wrapper1563 = bitcast i8* %wrapper_ptr1562 to { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
store { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure1548, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_wrapper1563

; let value assignment
%GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd = select i1 true, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_wrapper1563, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_wrapper1563
store { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*** %GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr

; add data to environment
; don't need to alloc for env var GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd
%tmp_envptr1557 = getelementptr {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}, {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}* %environment1550, i32 0, i32 0
store {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*** %GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**** %tmp_envptr1557


%val1566 = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*** %GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr
ret {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %val1566
}


@GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWimage* @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd(i32 %arg_0,i32 %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, i32, i32, i8*)*,  %GLFWimage* (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
ret %GLFWimage* %result
}


define dllexport ccc %GLFWimage* @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_native(i32 %arg_0,i32 %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, i32, i32, i8*)*,  %GLFWimage* (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
ret %GLFWimage* %result
}


define dllexport ccc i8*  @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1567 = bitcast [104 x i8]* @gsxtmglfw366 to i8*
call i32 (i8*, ...) @printf(i8* %var1567)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1568 = bitcast [104 x i8]* @gsxtmglfw366 to i8*
call i32 (i8*, ...) @printf(i8* %var1568)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1569 = bitcast [104 x i8]* @gsxtmglfw366 to i8*
call i32 (i8*, ...) @printf(i8* %var1569)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, i32, i32, i8*)*,  %GLFWimage* (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
%tmpres = bitcast %GLFWimage* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i8*}*
%arg_p_0 = getelementptr {i32, i32, i8*}, {i32, i32, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i8*}, {i32, i32, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i8*}, {i32, i32, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_z_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, i32, i32, i8*)*,  %GLFWimage* (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw367 = hidden constant [51 x i8] c"GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd\00"
define dllexport fastcc %GLFWimage* @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd__1570(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i8* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1571 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}*
%GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr_ = getelementptr {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}, {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}* %impenv, i32 0, i32 0
%GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**** %GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr


%tzone1574 = load i8*, i8** %_impzPtr
%zone1575 = bitcast i8* %tzone1574 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWimage*
%dat1572 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat1572, i32 0, i64 16)
%val1573 = bitcast i8* %dat1572 to %GLFWimage*

; let value assignment
%obj = select i1 true, %GLFWimage* %val1573, %GLFWimage* %val1573
store %GLFWimage* %obj, %GLFWimage** %objPtr

%val1576 = load %GLFWimage*, %GLFWimage** %objPtr
%val1577 = load i32, i32* %arg_0Ptr
; set tuple
%val1578 = getelementptr %GLFWimage, %GLFWimage* %val1576, i64 0, i32 0
store i32 %val1577, i32* %val1578
%val1579 = load %GLFWimage*, %GLFWimage** %objPtr
%val1580 = load i32, i32* %arg_1Ptr
; set tuple
%val1581 = getelementptr %GLFWimage, %GLFWimage* %val1579, i64 0, i32 1
store i32 %val1580, i32* %val1581
%val1582 = load %GLFWimage*, %GLFWimage** %objPtr
%val1583 = load i8*, i8** %arg_2Ptr
; set tuple
%val1584 = getelementptr %GLFWimage, %GLFWimage* %val1582, i64 0, i32 2
store i8* %val1583, i8** %val1584
%val1585 = load %GLFWimage*, %GLFWimage** %objPtr
ret %GLFWimage* %val1585
}
@gsxtmglfw368 = hidden constant [104 x i8] c"GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1605 = load i8*, i8** %_impzPtr
%zone1606 = bitcast i8* %tzone1605 to %mzone*

; let assign value to symbol GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd
%dat_GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone1606, i64 8)
%GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr = bitcast i8* %dat_GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd to { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***
%tzone1586 = load i8*, i8** %_impzPtr
%zone1587 = bitcast i8* %tzone1586 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1587)
; malloc closure structure
%clsptr1588 = call i8* @llvm_zone_malloc(%mzone* %zone1587, i64 24)
%closure1589 = bitcast i8* %clsptr1588 to { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*

; malloc environment structure
%envptr1590 = call i8* @llvm_zone_malloc(%mzone* %zone1587, i64 8)
%environment1591 = bitcast i8* %envptr1590 to {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}*

; malloc closure address table
%addytable1592 = call %clsvar* @new_address_table()
%var1593 = bitcast [51 x i8]* @gsxtmglfw367 to i8*
%var1594 = bitcast [53 x i8]* @gsxtmglfw363 to i8*
%addytable1595 = call %clsvar* @add_address_table(%mzone* %zone1587, i8* %var1593, i32 0, i8* %var1594, i32 3, %clsvar* %addytable1592)
%address-table1596 = bitcast %clsvar* %addytable1595 to i8*

; insert table, function and environment into closure struct
%closure.table1599 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure1589, i32 0, i32 0
store i8* %address-table1596, i8** %closure.table1599
%closure.env1600 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure1589, i32 0, i32 1
store i8* %envptr1590, i8** %closure.env1600
%closure.func1601 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure1589, i32 0, i32 2
store %GLFWimage* (i8*, i8*, i32, i32, i8*)* @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd__1570, %GLFWimage* (i8*, i8*, i32, i32, i8*)** %closure.func1601
%closure_size1602 = call i64 @llvm_zone_mark_size(%mzone* %zone1587)
call void @llvm_zone_ptr_set_size(i8* %clsptr1588, i64 %closure_size1602)
%wrapper_ptr1603 = call i8* @llvm_zone_malloc(%mzone* %zone1587, i64 8)
%closure_wrapper1604 = bitcast i8* %wrapper_ptr1603 to { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
store { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure1589, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_wrapper1604

; let value assignment
%GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd = select i1 true, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_wrapper1604, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_wrapper1604
store { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd, { i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*** %GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr

; add data to environment
; don't need to alloc for env var GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd
%tmp_envptr1598 = getelementptr {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}, {{i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}***}* %environment1591, i32 0, i32 0
store {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*** %GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**** %tmp_envptr1598


%val1607 = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*** %GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpdPtr
ret {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %val1607
}


@GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWimage* @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd(i32 %arg_0,i32 %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, i32, i32, i8*)*,  %GLFWimage* (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
ret %GLFWimage* %result
}


define dllexport ccc %GLFWimage* @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_native(i32 %arg_0,i32 %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, i32, i32, i8*)*,  %GLFWimage* (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
ret %GLFWimage* %result
}


define dllexport ccc i8*  @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1608 = bitcast [104 x i8]* @gsxtmglfw368 to i8*
call i32 (i8*, ...) @printf(i8* %var1608)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1609 = bitcast [104 x i8]* @gsxtmglfw368 to i8*
call i32 (i8*, ...) @printf(i8* %var1609)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1610 = bitcast [104 x i8]* @gsxtmglfw368 to i8*
call i32 (i8*, ...) @printf(i8* %var1610)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, i32, i32, i8*)*,  %GLFWimage* (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
%tmpres = bitcast %GLFWimage* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i8*}*
%arg_p_0 = getelementptr {i32, i32, i8*}, {i32, i32, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i8*}, {i32, i32, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i8*}, {i32, i32, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_h_adhoc_W0dMRldpbWFnZSosaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, i32, i32, i8*)*,  %GLFWimage* (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw369 = hidden constant [17 x i8] c"<GLFWimage:null>\00"
@gsxtmglfw370 = hidden constant [12 x i8] c"<GLFWimage:\00"
@gsxtmglfw371 = hidden constant [43 x i8] c"toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0\00"
@gsxtmglfw372 = hidden constant [48 x i8] c"{i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0__1611(i8* %_impz,i8* %_impenv, %GLFWimage* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1612 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}***}*
%toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}***, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}**** %toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0Ptr_

; setup arguments
%xPtr = alloca %GLFWimage*
store %GLFWimage* %x, %GLFWimage** %xPtr


%val1614 = load %GLFWimage*, %GLFWimage** %xPtr
%val1615 = icmp eq %GLFWimage* %val1614, null
br i1 %val1615, label %then1613, label %else1613

then1613:
%zone1616 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone1616)
%zone_ptr1617 = bitcast %mzone* %zone1616 to i8*
store i8* %zone_ptr1617, i8** %_impzPtr
%tzone1627 = load i8*, i8** %_impzPtr
%zone1628 = bitcast i8* %tzone1627 to %mzone*

; let assign value to symbol res4
%res4Ptr = alloca %String*
%tzone1632 = load i8*, i8** %_impzPtr
%zone1633 = bitcast i8* %tzone1632 to %mzone*

; let assign value to symbol zone4
%zone4Ptr = alloca %mzone*
%tzone1635 = load i8*, i8** %_impzPtr
%zone1636 = bitcast i8* %tzone1635 to %mzone*

; let assign value to symbol newz4
%newz4Ptr = alloca %mzone*
%tzone1619 = load i8*, i8** %_impzPtr
%zone1620 = bitcast i8* %tzone1619 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat1618 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat1618, i8* %dat1618
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val1621 = load i8*, i8** %xx_t_mstPtr
%var1622 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1623 = bitcast [17 x i8]* @gsxtmglfw369 to i8*

%val1624 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1621, i8* %var1622, i8* %var1623)
%val1625 = load i8*, i8** %xx_t_mstPtr
%res1626 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1625)

; let value assignment
%res4 = select i1 true, %String* %res1626, %String* %res1626
store %String* %res4, %String** %res4Ptr

%oldzone1629 = call %mzone* @llvm_pop_zone_stack()
%newzone1630 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1631 = bitcast %mzone* %newzone1630 to i8*
store i8* %zone_ptr1631, i8** %_impzPtr

; let value assignment
%zone4 = select i1 true, %mzone* %oldzone1629, %mzone* %oldzone1629
store %mzone* %zone4, %mzone** %zone4Ptr

%res1634 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz4 = select i1 true, %mzone* %res1634, %mzone* %res1634
store %mzone* %newz4, %mzone** %newz4Ptr

%tzone1641 = load i8*, i8** %_impzPtr
%zone1642 = bitcast i8* %tzone1641 to %mzone*

; let assign value to symbol rescopy4
%rescopy4Ptr = alloca %String*
%tzone1647 = load i8*, i8** %_impzPtr
%zone1648 = bitcast i8* %tzone1647 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone1650 = load i8*, i8** %_impzPtr
%zone1651 = bitcast i8* %tzone1650 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val1637 = load %String*, %String** %res4Ptr
%val1638 = load %mzone*, %mzone** %zone4Ptr
%val1639 = load %mzone*, %mzone** %newz4Ptr
%res1640 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val1637, %mzone* %val1638, %mzone* %val1639)

; let value assignment
%rescopy4 = select i1 true, %String* %res1640, %String* %res1640
store %String* %rescopy4, %String** %rescopy4Ptr

%val1643 = load %mzone*, %mzone** %zone4Ptr
; tuple ref
%val1644 = getelementptr %mzone, %mzone* %val1643, i64 0, i32 4
%val1645 = load i8*, i8** %val1644
%val1646 = bitcast i8* %val1645 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val1646, {i64,i8*,i8*}* %val1646
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null1649 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null1649, {i8*, i8*, void (i8*, i8*)*}** %null1649
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone1687 = load i8*, i8** %_impzPtr
%zone1688 = bitcast i8* %tzone1687 to %mzone*
%ifptr1677 = alloca i1
%ifptr1653 = alloca i1
; while loop
%val1654 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1655 = icmp eq {i64,i8*,i8*}* %val1654, null
br i1 %val1655, label %then1653, label %else1653

then1653:
%res1656 = call ccc i1 @impc_false()
store i1 %res1656, i1* %ifptr1653
br label %ifcont1653

else1653:
%res1657 = call ccc i1 @impc_true()
store i1 %res1657, i1* %ifptr1653
br label %ifcont1653

ifcont1653:
%ifres1658 = load i1, i1* %ifptr1653

br i1 %ifres1658, label %loop1652, label %after1652

loop1652:
; do set!
%val1659 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val1660 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1659, i64 0, i32 1
%val1661 = load i8*, i8** %val1660
%val1662 = bitcast i8* %val1661 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val1662, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval1663 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val1664 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval1663
%fPtr1665 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1664, i32 0, i32 2
%ePtr1666 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1664, i32 0, i32 1
%f1667 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr1665
%e1668 = load i8*, i8** %ePtr1666
%tzone1669 = load i8*, i8** %_impzPtr
%zone1670 = bitcast i8* %tzone1669 to %mzone*
%z1671 = bitcast %mzone* %zone1670 to i8*
tail call fastcc void %f1667(i8* %z1671, i8* %e1668)
; do set!
%val1673 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val1674 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1673, i64 0, i32 2
%val1675 = load i8*, i8** %val1674
%val1676 = bitcast i8* %val1675 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val1676, {i64,i8*,i8*}** %hookPtr
%val1678 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1679 = icmp eq {i64,i8*,i8*}* %val1678, null
br i1 %val1679, label %then1677, label %else1677

then1677:
%res1680 = call ccc i1 @impc_false()
store i1 %res1680, i1* %ifptr1677
br label %ifcont1677

else1677:
%res1681 = call ccc i1 @impc_true()
store i1 %res1681, i1* %ifptr1677
br label %ifcont1677

ifcont1677:
%ifres1682 = load i1, i1* %ifptr1677

br i1 %ifres1682, label %loop1652, label %after1652

after1652:
%val1684 = load %mzone*, %mzone** %zone4Ptr
call ccc void @llvm_zone_destroy(%mzone* %val1684)
%val1686 = load %String*, %String** %rescopy4Ptr
ret %String* %val1686

else1613:
%zone1689 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone1689)
%zone_ptr1690 = bitcast %mzone* %zone1689 to i8*
store i8* %zone_ptr1690, i8** %_impzPtr
%tzone1745 = load i8*, i8** %_impzPtr
%zone1746 = bitcast i8* %tzone1745 to %mzone*

; let assign value to symbol res5
%res5Ptr = alloca %String*
%tzone1750 = load i8*, i8** %_impzPtr
%zone1751 = bitcast i8* %tzone1750 to %mzone*

; let assign value to symbol zone5
%zone5Ptr = alloca %mzone*
%tzone1753 = load i8*, i8** %_impzPtr
%zone1754 = bitcast i8* %tzone1753 to %mzone*

; let assign value to symbol newz5
%newz5Ptr = alloca %mzone*
%tzone1692 = load i8*, i8** %_impzPtr
%zone1693 = bitcast i8* %tzone1692 to %mzone*

; let assign value to symbol xx_t_mst_s_19
%xx_t_mst_s_19Ptr = alloca i8*
%dat1691 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_19 = select i1 true, i8* %dat1691, i8* %dat1691
store i8* %xx_t_mst_s_19, i8** %xx_t_mst_s_19Ptr

%val1694 = load i8*, i8** %xx_t_mst_s_19Ptr
%var1695 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1696 = bitcast [12 x i8]* @gsxtmglfw370 to i8*

%val1697 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1694, i8* %var1695, i8* %var1696)
%val1698 = load i8*, i8** %xx_t_mst_s_19Ptr
%res1699 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1698)
%val1700 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val1701 = getelementptr %GLFWimage, %GLFWimage* %val1700, i64 0, i32 0
%val1702 = load i32, i32* %val1701
%res1703 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val1702)
%res1704 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1699, %String* %res1703)
%tzone1706 = load i8*, i8** %_impzPtr
%zone1707 = bitcast i8* %tzone1706 to %mzone*

; let assign value to symbol xx_t_mst_s_20
%xx_t_mst_s_20Ptr = alloca i8*
%dat1705 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_20 = select i1 true, i8* %dat1705, i8* %dat1705
store i8* %xx_t_mst_s_20, i8** %xx_t_mst_s_20Ptr

%val1708 = load i8*, i8** %xx_t_mst_s_20Ptr
%var1709 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1710 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val1711 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1708, i8* %var1709, i8* %var1710)
%val1712 = load i8*, i8** %xx_t_mst_s_20Ptr
%res1713 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1712)
%res1714 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1704, %String* %res1713)
%val1715 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val1716 = getelementptr %GLFWimage, %GLFWimage* %val1715, i64 0, i32 1
%val1717 = load i32, i32* %val1716
%res1718 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val1717)
%res1719 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1714, %String* %res1718)
%tzone1721 = load i8*, i8** %_impzPtr
%zone1722 = bitcast i8* %tzone1721 to %mzone*

; let assign value to symbol xx_t_mst_s_21
%xx_t_mst_s_21Ptr = alloca i8*
%dat1720 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_21 = select i1 true, i8* %dat1720, i8* %dat1720
store i8* %xx_t_mst_s_21, i8** %xx_t_mst_s_21Ptr

%val1723 = load i8*, i8** %xx_t_mst_s_21Ptr
%var1724 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1725 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val1726 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1723, i8* %var1724, i8* %var1725)
%val1727 = load i8*, i8** %xx_t_mst_s_21Ptr
%res1728 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1727)
%res1729 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1719, %String* %res1728)
%val1730 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val1731 = getelementptr %GLFWimage, %GLFWimage* %val1730, i64 0, i32 2
%val1732 = load i8*, i8** %val1731
%res1733 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1732)
%res1734 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1729, %String* %res1733)
%tzone1736 = load i8*, i8** %_impzPtr
%zone1737 = bitcast i8* %tzone1736 to %mzone*

; let assign value to symbol xx_t_mst_s_22
%xx_t_mst_s_22Ptr = alloca i8*
%dat1735 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_22 = select i1 true, i8* %dat1735, i8* %dat1735
store i8* %xx_t_mst_s_22, i8** %xx_t_mst_s_22Ptr

%val1738 = load i8*, i8** %xx_t_mst_s_22Ptr
%var1739 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1740 = bitcast [2 x i8]* @gsxtmglfw311 to i8*

%val1741 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1738, i8* %var1739, i8* %var1740)
%val1742 = load i8*, i8** %xx_t_mst_s_22Ptr
%res1743 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1742)
%res1744 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1734, %String* %res1743)

; let value assignment
%res5 = select i1 true, %String* %res1744, %String* %res1744
store %String* %res5, %String** %res5Ptr

%oldzone1747 = call %mzone* @llvm_pop_zone_stack()
%newzone1748 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1749 = bitcast %mzone* %newzone1748 to i8*
store i8* %zone_ptr1749, i8** %_impzPtr

; let value assignment
%zone5 = select i1 true, %mzone* %oldzone1747, %mzone* %oldzone1747
store %mzone* %zone5, %mzone** %zone5Ptr

%res1752 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz5 = select i1 true, %mzone* %res1752, %mzone* %res1752
store %mzone* %newz5, %mzone** %newz5Ptr

%tzone1759 = load i8*, i8** %_impzPtr
%zone1760 = bitcast i8* %tzone1759 to %mzone*

; let assign value to symbol rescopy5
%rescopy5Ptr = alloca %String*
%tzone1765 = load i8*, i8** %_impzPtr
%zone1766 = bitcast i8* %tzone1765 to %mzone*

; let assign value to symbol hook_s_23
%hook_s_23Ptr = alloca {i64,i8*,i8*}*
%tzone1768 = load i8*, i8** %_impzPtr
%zone1769 = bitcast i8* %tzone1768 to %mzone*

; let assign value to symbol f_s_24
%f_s_24Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val1755 = load %String*, %String** %res5Ptr
%val1756 = load %mzone*, %mzone** %zone5Ptr
%val1757 = load %mzone*, %mzone** %newz5Ptr
%res1758 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val1755, %mzone* %val1756, %mzone* %val1757)

; let value assignment
%rescopy5 = select i1 true, %String* %res1758, %String* %res1758
store %String* %rescopy5, %String** %rescopy5Ptr

%val1761 = load %mzone*, %mzone** %zone5Ptr
; tuple ref
%val1762 = getelementptr %mzone, %mzone* %val1761, i64 0, i32 4
%val1763 = load i8*, i8** %val1762
%val1764 = bitcast i8* %val1763 to {i64,i8*,i8*}*

; let value assignment
%hook_s_23 = select i1 true, {i64,i8*,i8*}* %val1764, {i64,i8*,i8*}* %val1764
store {i64,i8*,i8*}* %hook_s_23, {i64,i8*,i8*}** %hook_s_23Ptr

%null1767 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_24 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null1767, {i8*, i8*, void (i8*, i8*)*}** %null1767
store {i8*, i8*, void (i8*, i8*)*}** %f_s_24, {i8*, i8*, void (i8*, i8*)*}*** %f_s_24Ptr

; promote local stack var allocations
%tzone1805 = load i8*, i8** %_impzPtr
%zone1806 = bitcast i8* %tzone1805 to %mzone*
%ifptr1795 = alloca i1
%ifptr1771 = alloca i1
; while loop
%val1772 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_23Ptr
%val1773 = icmp eq {i64,i8*,i8*}* %val1772, null
br i1 %val1773, label %then1771, label %else1771

then1771:
%res1774 = call ccc i1 @impc_false()
store i1 %res1774, i1* %ifptr1771
br label %ifcont1771

else1771:
%res1775 = call ccc i1 @impc_true()
store i1 %res1775, i1* %ifptr1771
br label %ifcont1771

ifcont1771:
%ifres1776 = load i1, i1* %ifptr1771

br i1 %ifres1776, label %loop1770, label %after1770

loop1770:
; do set!
%val1777 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_23Ptr
; tuple ref
%val1778 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1777, i64 0, i32 1
%val1779 = load i8*, i8** %val1778
%val1780 = bitcast i8* %val1779 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val1780, {i8*, i8*, void (i8*, i8*)*}*** %f_s_24Ptr

; apply closure 
%vval1781 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_24Ptr
%val1782 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval1781
%fPtr1783 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1782, i32 0, i32 2
%ePtr1784 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1782, i32 0, i32 1
%f1785 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr1783
%e1786 = load i8*, i8** %ePtr1784
%tzone1787 = load i8*, i8** %_impzPtr
%zone1788 = bitcast i8* %tzone1787 to %mzone*
%z1789 = bitcast %mzone* %zone1788 to i8*
tail call fastcc void %f1785(i8* %z1789, i8* %e1786)
; do set!
%val1791 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_23Ptr
; tuple ref
%val1792 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1791, i64 0, i32 2
%val1793 = load i8*, i8** %val1792
%val1794 = bitcast i8* %val1793 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val1794, {i64,i8*,i8*}** %hook_s_23Ptr
%val1796 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_23Ptr
%val1797 = icmp eq {i64,i8*,i8*}* %val1796, null
br i1 %val1797, label %then1795, label %else1795

then1795:
%res1798 = call ccc i1 @impc_false()
store i1 %res1798, i1* %ifptr1795
br label %ifcont1795

else1795:
%res1799 = call ccc i1 @impc_true()
store i1 %res1799, i1* %ifptr1795
br label %ifcont1795

ifcont1795:
%ifres1800 = load i1, i1* %ifptr1795

br i1 %ifres1800, label %loop1770, label %after1770

after1770:
%val1802 = load %mzone*, %mzone** %zone5Ptr
call ccc void @llvm_zone_destroy(%mzone* %val1802)
%val1804 = load %String*, %String** %rescopy5Ptr
ret %String* %val1804
}
@gsxtmglfw373 = hidden constant [96 x i8] c"toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}** @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1826 = load i8*, i8** %_impzPtr
%zone1827 = bitcast i8* %tzone1826 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0
%dat_toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1827, i64 8)
%toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0 to { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}***
%tzone1807 = load i8*, i8** %_impzPtr
%zone1808 = bitcast i8* %tzone1807 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1808)
; malloc closure structure
%clsptr1809 = call i8* @llvm_zone_malloc(%mzone* %zone1808, i64 24)
%closure1810 = bitcast i8* %clsptr1809 to { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}*

; malloc environment structure
%envptr1811 = call i8* @llvm_zone_malloc(%mzone* %zone1808, i64 8)
%environment1812 = bitcast i8* %envptr1811 to {{i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}***}*

; malloc closure address table
%addytable1813 = call %clsvar* @new_address_table()
%var1814 = bitcast [43 x i8]* @gsxtmglfw371 to i8*
%var1815 = bitcast [48 x i8]* @gsxtmglfw372 to i8*
%addytable1816 = call %clsvar* @add_address_table(%mzone* %zone1808, i8* %var1814, i32 0, i8* %var1815, i32 3, %clsvar* %addytable1813)
%address-table1817 = bitcast %clsvar* %addytable1816 to i8*

; insert table, function and environment into closure struct
%closure.table1820 = getelementptr { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}, { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}* %closure1810, i32 0, i32 0
store i8* %address-table1817, i8** %closure.table1820
%closure.env1821 = getelementptr { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}, { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}* %closure1810, i32 0, i32 1
store i8* %envptr1811, i8** %closure.env1821
%closure.func1822 = getelementptr { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}, { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}* %closure1810, i32 0, i32 2
store %String* (i8*, i8*, %GLFWimage*)* @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0__1611, %String* (i8*, i8*, %GLFWimage*)** %closure.func1822
%closure_size1823 = call i64 @llvm_zone_mark_size(%mzone* %zone1808)
call void @llvm_zone_ptr_set_size(i8* %clsptr1809, i64 %closure_size1823)
%wrapper_ptr1824 = call i8* @llvm_zone_malloc(%mzone* %zone1808, i64 8)
%closure_wrapper1825 = bitcast i8* %wrapper_ptr1824 to { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}**
store { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}* %closure1810, { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}** %closure_wrapper1825

; let value assignment
%toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}** %closure_wrapper1825, { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}** %closure_wrapper1825
store { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}** %toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0, { i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}*** %toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0
%tmp_envptr1819 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}***}* %environment1812, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}*** %toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}**** %tmp_envptr1819


%val1828 = load {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}**, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}*** %toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}** %val1828
}


@toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}** @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0(%GLFWimage* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %GLFWimage*)*,  %String* (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_native(%GLFWimage* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %GLFWimage*)*,  %String* (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1829 = bitcast [96 x i8]* @gsxtmglfw373 to i8*
call i32 (i8*, ...) @printf(i8* %var1829)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWimage*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %GLFWimage*)*,  %String* (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWimage*}*
%arg_p_0 = getelementptr {%GLFWimage*}, {%GLFWimage*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWimage*, %GLFWimage** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %String* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %GLFWimage*)*,  %String* (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw374 = hidden constant [36 x i8] c"print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0\00"
@gsxtmglfw375 = hidden constant [44 x i8] c"{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0__1830(i8* %_impz,i8* %_impenv, %GLFWimage* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1831 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***}*
%print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***}, {{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr = load {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**** %print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr_

; setup arguments
%xPtr = alloca %GLFWimage*
store %GLFWimage* %x, %GLFWimage** %xPtr


%val1833 = load %GLFWimage*, %GLFWimage** %xPtr
%val1834 = icmp eq %GLFWimage* %val1833, null
br i1 %val1834, label %then1832, label %else1832

then1832:
%var1835 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1836 = bitcast [17 x i8]* @gsxtmglfw369 to i8*

%val1837 = call i32 (i8*, ...) @printf(i8* %var1835, i8* %var1836)
br label %ifcont1832

else1832:
%var1839 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1840 = bitcast [12 x i8]* @gsxtmglfw370 to i8*

%val1841 = call i32 (i8*, ...) @printf(i8* %var1839, i8* %var1840)
%val1842 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val1843 = getelementptr %GLFWimage, %GLFWimage* %val1842, i64 0, i32 0
%val1844 = load i32, i32* %val1843
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val1844)
%var1846 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1847 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val1848 = call i32 (i8*, ...) @printf(i8* %var1846, i8* %var1847)
%val1849 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val1850 = getelementptr %GLFWimage, %GLFWimage* %val1849, i64 0, i32 1
%val1851 = load i32, i32* %val1850
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val1851)
%var1853 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1854 = bitcast [2 x i8]* @gsxtmglfw310 to i8*

%val1855 = call i32 (i8*, ...) @printf(i8* %var1853, i8* %var1854)
%val1856 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val1857 = getelementptr %GLFWimage, %GLFWimage* %val1856, i64 0, i32 2
%val1858 = load i8*, i8** %val1857
call fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %val1858)
%var1860 = bitcast [3 x i8]* @gsxtmglfw37 to i8*
%var1861 = bitcast [2 x i8]* @gsxtmglfw311 to i8*

%val1862 = call i32 (i8*, ...) @printf(i8* %var1860, i8* %var1861)
br label %ifcont1832

ifcont1832:
ret void
}
@gsxtmglfw376 = hidden constant [89 x i8] c"print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1884 = load i8*, i8** %_impzPtr
%zone1885 = bitcast i8* %tzone1884 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0
%dat_print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1885, i64 8)
%print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0 to { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***
%tzone1865 = load i8*, i8** %_impzPtr
%zone1866 = bitcast i8* %tzone1865 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1866)
; malloc closure structure
%clsptr1867 = call i8* @llvm_zone_malloc(%mzone* %zone1866, i64 24)
%closure1868 = bitcast i8* %clsptr1867 to { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*

; malloc environment structure
%envptr1869 = call i8* @llvm_zone_malloc(%mzone* %zone1866, i64 8)
%environment1870 = bitcast i8* %envptr1869 to {{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***}*

; malloc closure address table
%addytable1871 = call %clsvar* @new_address_table()
%var1872 = bitcast [36 x i8]* @gsxtmglfw374 to i8*
%var1873 = bitcast [44 x i8]* @gsxtmglfw375 to i8*
%addytable1874 = call %clsvar* @add_address_table(%mzone* %zone1866, i8* %var1872, i32 0, i8* %var1873, i32 3, %clsvar* %addytable1871)
%address-table1875 = bitcast %clsvar* %addytable1874 to i8*

; insert table, function and environment into closure struct
%closure.table1878 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure1868, i32 0, i32 0
store i8* %address-table1875, i8** %closure.table1878
%closure.env1879 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure1868, i32 0, i32 1
store i8* %envptr1869, i8** %closure.env1879
%closure.func1880 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure1868, i32 0, i32 2
store void (i8*, i8*, %GLFWimage*)* @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0__1830, void (i8*, i8*, %GLFWimage*)** %closure.func1880
%closure_size1881 = call i64 @llvm_zone_mark_size(%mzone* %zone1866)
call void @llvm_zone_ptr_set_size(i8* %clsptr1867, i64 %closure_size1881)
%wrapper_ptr1882 = call i8* @llvm_zone_malloc(%mzone* %zone1866, i64 8)
%closure_wrapper1883 = bitcast i8* %wrapper_ptr1882 to { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**
store { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure1868, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_wrapper1883

; let value assignment
%print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_wrapper1883, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_wrapper1883
store { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*** %print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0
%tmp_envptr1877 = getelementptr {{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***}, {{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***}* %environment1870, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*** %print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**** %tmp_envptr1877


%val1886 = load {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*** %print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %val1886
}


@print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0(%GLFWimage* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWimage*)*,  void (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_native(%GLFWimage* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWimage*)*,  void (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1887 = bitcast [89 x i8]* @gsxtmglfw376 to i8*
call i32 (i8*, ...) @printf(i8* %var1887)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWimage*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWimage*)*,  void (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWimage*}*
%arg_p_0 = getelementptr {%GLFWimage*}, {%GLFWimage*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWimage*, %GLFWimage** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWimage*)*,  void (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw377 = hidden constant [52 x i8] c"GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0\00"
@gsxtmglfw378 = hidden constant [52 x i8] c"{i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}**\00"
define dllexport fastcc %GLFWimage @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0__1888(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i8* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1889 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}***}*
%GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}***}, {{i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}***}* %impenv, i32 0, i32 0
%GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0Ptr = load {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}***, {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}**** %GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr


%tzone1891 = load i8*, i8** %_impzPtr
%zone1892 = bitcast i8* %tzone1891 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWimage*
%dat1890 = alloca %GLFWimage, align 16

; let value assignment
%obj = select i1 true, %GLFWimage* %dat1890, %GLFWimage* %dat1890
store %GLFWimage* %obj, %GLFWimage** %objPtr

%val1893 = load %GLFWimage*, %GLFWimage** %objPtr
%val1894 = load i32, i32* %arg_0Ptr
; set tuple
%val1895 = getelementptr %GLFWimage, %GLFWimage* %val1893, i64 0, i32 0
store i32 %val1894, i32* %val1895
%val1896 = load %GLFWimage*, %GLFWimage** %objPtr
%val1897 = load i32, i32* %arg_1Ptr
; set tuple
%val1898 = getelementptr %GLFWimage, %GLFWimage* %val1896, i64 0, i32 1
store i32 %val1897, i32* %val1898
%val1899 = load %GLFWimage*, %GLFWimage** %objPtr
%val1900 = load i8*, i8** %arg_2Ptr
; set tuple
%val1901 = getelementptr %GLFWimage, %GLFWimage* %val1899, i64 0, i32 2
store i8* %val1900, i8** %val1901
%val1902 = load %GLFWimage*, %GLFWimage** %objPtr
; pointer ref
%val1903 = getelementptr %GLFWimage, %GLFWimage* %val1902, i64 0
%val1904 = load %GLFWimage, %GLFWimage* %val1903
ret %GLFWimage %val1904
}
@gsxtmglfw379 = hidden constant [105 x i8] c"GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}** @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1924 = load i8*, i8** %_impzPtr
%zone1925 = bitcast i8* %tzone1924 to %mzone*

; let assign value to symbol GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0
%dat_GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone1925, i64 8)
%GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0Ptr = bitcast i8* %dat_GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0 to { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}***
%tzone1905 = load i8*, i8** %_impzPtr
%zone1906 = bitcast i8* %tzone1905 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1906)
; malloc closure structure
%clsptr1907 = call i8* @llvm_zone_malloc(%mzone* %zone1906, i64 24)
%closure1908 = bitcast i8* %clsptr1907 to { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}*

; malloc environment structure
%envptr1909 = call i8* @llvm_zone_malloc(%mzone* %zone1906, i64 8)
%environment1910 = bitcast i8* %envptr1909 to {{i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}***}*

; malloc closure address table
%addytable1911 = call %clsvar* @new_address_table()
%var1912 = bitcast [52 x i8]* @gsxtmglfw377 to i8*
%var1913 = bitcast [52 x i8]* @gsxtmglfw378 to i8*
%addytable1914 = call %clsvar* @add_address_table(%mzone* %zone1906, i8* %var1912, i32 0, i8* %var1913, i32 3, %clsvar* %addytable1911)
%address-table1915 = bitcast %clsvar* %addytable1914 to i8*

; insert table, function and environment into closure struct
%closure.table1918 = getelementptr { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}, { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}* %closure1908, i32 0, i32 0
store i8* %address-table1915, i8** %closure.table1918
%closure.env1919 = getelementptr { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}, { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}* %closure1908, i32 0, i32 1
store i8* %envptr1909, i8** %closure.env1919
%closure.func1920 = getelementptr { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}, { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}* %closure1908, i32 0, i32 2
store %GLFWimage (i8*, i8*, i32, i32, i8*)* @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0__1888, %GLFWimage (i8*, i8*, i32, i32, i8*)** %closure.func1920
%closure_size1921 = call i64 @llvm_zone_mark_size(%mzone* %zone1906)
call void @llvm_zone_ptr_set_size(i8* %clsptr1907, i64 %closure_size1921)
%wrapper_ptr1922 = call i8* @llvm_zone_malloc(%mzone* %zone1906, i64 8)
%closure_wrapper1923 = bitcast i8* %wrapper_ptr1922 to { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}**
store { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}* %closure1908, { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}** %closure_wrapper1923

; let value assignment
%GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0 = select i1 true, { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}** %closure_wrapper1923, { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}** %closure_wrapper1923
store { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}** %GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0, { i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}*** %GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0
%tmp_envptr1917 = getelementptr {{i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}***}, {{i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}***}* %environment1910, i32 0, i32 0
store {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}*** %GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0Ptr, {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}**** %tmp_envptr1917


%val1926 = load {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}**, {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}*** %GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0Ptr
ret {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}** %val1926
}


@GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}** @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWimage @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0(i32 %arg_0,i32 %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage (i8*, i8*, i32, i32, i8*)*,  %GLFWimage (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
ret %GLFWimage %result
}


define dllexport ccc %GLFWimage @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_native(i32 %arg_0,i32 %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage (i8*, i8*, i32, i32, i8*)*,  %GLFWimage (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
ret %GLFWimage %result
}


define dllexport ccc void @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i8*}*
%arg_p_0 = getelementptr {i32, i32, i8*}, {i32, i32, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i8*}, {i32, i32, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i8*}, {i32, i32, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @GLFWimage_val_adhoc_W0dMRldpbWFnZSxpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}*, {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}, {i8*, i8*, %GLFWimage (i8*, i8*, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage (i8*, i8*, i32, i32, i8*)*,  %GLFWimage (i8*, i8*, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw380 = hidden constant [44 x i8] c"hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0\00"
@gsxtmglfw381 = hidden constant [51 x i8] c"{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}**\00"
define dllexport fastcc %GLFWimage* @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0__1930(i8* %_impz,i8* %_impenv, %GLFWimage* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1931 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}***}*
%hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0Ptr_ = getelementptr {{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}***}, {{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0Ptr = load {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}***, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}**** %hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0Ptr_

; setup arguments
%xPtr = alloca %GLFWimage*
store %GLFWimage* %x, %GLFWimage** %xPtr


%tzone1934 = load i8*, i8** %_impzPtr
%zone1935 = bitcast i8* %tzone1934 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWimage*
%dat1932 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat1932, i32 0, i64 16)
%val1933 = bitcast i8* %dat1932 to %GLFWimage*

; let value assignment
%obj = select i1 true, %GLFWimage* %val1933, %GLFWimage* %val1933
store %GLFWimage* %obj, %GLFWimage** %objPtr

%val1936 = load %GLFWimage*, %GLFWimage** %objPtr
%val1937 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val1938 = getelementptr %GLFWimage, %GLFWimage* %val1937, i64 0, i32 0
%val1939 = load i32, i32* %val1938
; set tuple
%val1940 = getelementptr %GLFWimage, %GLFWimage* %val1936, i64 0, i32 0
store i32 %val1939, i32* %val1940
%val1941 = load %GLFWimage*, %GLFWimage** %objPtr
%val1942 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val1943 = getelementptr %GLFWimage, %GLFWimage* %val1942, i64 0, i32 1
%val1944 = load i32, i32* %val1943
; set tuple
%val1945 = getelementptr %GLFWimage, %GLFWimage* %val1941, i64 0, i32 1
store i32 %val1944, i32* %val1945
%val1946 = load %GLFWimage*, %GLFWimage** %objPtr
%val1947 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val1948 = getelementptr %GLFWimage, %GLFWimage* %val1947, i64 0, i32 2
%val1949 = load i8*, i8** %val1948
; set tuple
%val1950 = getelementptr %GLFWimage, %GLFWimage* %val1946, i64 0, i32 2
store i8* %val1949, i8** %val1950
%val1951 = load %GLFWimage*, %GLFWimage** %objPtr
ret %GLFWimage* %val1951
}
@gsxtmglfw382 = hidden constant [97 x i8] c"hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}** @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1971 = load i8*, i8** %_impzPtr
%zone1972 = bitcast i8* %tzone1971 to %mzone*

; let assign value to symbol hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0
%dat_hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1972, i64 8)
%hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0 to { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}***
%tzone1952 = load i8*, i8** %_impzPtr
%zone1953 = bitcast i8* %tzone1952 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1953)
; malloc closure structure
%clsptr1954 = call i8* @llvm_zone_malloc(%mzone* %zone1953, i64 24)
%closure1955 = bitcast i8* %clsptr1954 to { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}*

; malloc environment structure
%envptr1956 = call i8* @llvm_zone_malloc(%mzone* %zone1953, i64 8)
%environment1957 = bitcast i8* %envptr1956 to {{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}***}*

; malloc closure address table
%addytable1958 = call %clsvar* @new_address_table()
%var1959 = bitcast [44 x i8]* @gsxtmglfw380 to i8*
%var1960 = bitcast [51 x i8]* @gsxtmglfw381 to i8*
%addytable1961 = call %clsvar* @add_address_table(%mzone* %zone1953, i8* %var1959, i32 0, i8* %var1960, i32 3, %clsvar* %addytable1958)
%address-table1962 = bitcast %clsvar* %addytable1961 to i8*

; insert table, function and environment into closure struct
%closure.table1965 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}* %closure1955, i32 0, i32 0
store i8* %address-table1962, i8** %closure.table1965
%closure.env1966 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}* %closure1955, i32 0, i32 1
store i8* %envptr1956, i8** %closure.env1966
%closure.func1967 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}* %closure1955, i32 0, i32 2
store %GLFWimage* (i8*, i8*, %GLFWimage*)* @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0__1930, %GLFWimage* (i8*, i8*, %GLFWimage*)** %closure.func1967
%closure_size1968 = call i64 @llvm_zone_mark_size(%mzone* %zone1953)
call void @llvm_zone_ptr_set_size(i8* %clsptr1954, i64 %closure_size1968)
%wrapper_ptr1969 = call i8* @llvm_zone_malloc(%mzone* %zone1953, i64 8)
%closure_wrapper1970 = bitcast i8* %wrapper_ptr1969 to { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}**
store { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}* %closure1955, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}** %closure_wrapper1970

; let value assignment
%hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0 = select i1 true, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}** %closure_wrapper1970, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}** %closure_wrapper1970
store { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}** %hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}*** %hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0
%tmp_envptr1964 = getelementptr {{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}***}, {{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}***}* %environment1957, i32 0, i32 0
store {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}*** %hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0Ptr, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}**** %tmp_envptr1964


%val1973 = load {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}**, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}*** %hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0Ptr
ret {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}** %val1973
}


@hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}** @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWimage* @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0(%GLFWimage* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, %GLFWimage*)*,  %GLFWimage* (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
ret %GLFWimage* %result
}


define dllexport ccc %GLFWimage* @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_native(%GLFWimage* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, %GLFWimage*)*,  %GLFWimage* (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
ret %GLFWimage* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1974 = bitcast [97 x i8]* @gsxtmglfw382 to i8*
call i32 (i8*, ...) @printf(i8* %var1974)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWimage*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, %GLFWimage*)*,  %GLFWimage* (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
%tmpres = bitcast %GLFWimage* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWimage*}*
%arg_p_0 = getelementptr {%GLFWimage*}, {%GLFWimage*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWimage*, %GLFWimage** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, %GLFWimage*)*,  %GLFWimage* (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw383 = hidden constant [36 x i8] c"hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0__1975(i8* %_impz,i8* %_impenv, %GLFWimage* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1976 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***}*
%hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***}, {{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr = load {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**** %hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr_

; setup arguments
%xPtr = alloca %GLFWimage*
store %GLFWimage* %x, %GLFWimage** %xPtr


%val1977 = load %GLFWimage*, %GLFWimage** %xPtr
%val1978 = bitcast %GLFWimage* %val1977 to i8*
call ccc void @free(i8* %val1978)
ret void
}
@gsxtmglfw384 = hidden constant [89 x i8] c"hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2000 = load i8*, i8** %_impzPtr
%zone2001 = bitcast i8* %tzone2000 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0
%dat_hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2001, i64 8)
%hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0 to { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***
%tzone1981 = load i8*, i8** %_impzPtr
%zone1982 = bitcast i8* %tzone1981 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1982)
; malloc closure structure
%clsptr1983 = call i8* @llvm_zone_malloc(%mzone* %zone1982, i64 24)
%closure1984 = bitcast i8* %clsptr1983 to { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*

; malloc environment structure
%envptr1985 = call i8* @llvm_zone_malloc(%mzone* %zone1982, i64 8)
%environment1986 = bitcast i8* %envptr1985 to {{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***}*

; malloc closure address table
%addytable1987 = call %clsvar* @new_address_table()
%var1988 = bitcast [36 x i8]* @gsxtmglfw383 to i8*
%var1989 = bitcast [44 x i8]* @gsxtmglfw375 to i8*
%addytable1990 = call %clsvar* @add_address_table(%mzone* %zone1982, i8* %var1988, i32 0, i8* %var1989, i32 3, %clsvar* %addytable1987)
%address-table1991 = bitcast %clsvar* %addytable1990 to i8*

; insert table, function and environment into closure struct
%closure.table1994 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure1984, i32 0, i32 0
store i8* %address-table1991, i8** %closure.table1994
%closure.env1995 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure1984, i32 0, i32 1
store i8* %envptr1985, i8** %closure.env1995
%closure.func1996 = getelementptr { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure1984, i32 0, i32 2
store void (i8*, i8*, %GLFWimage*)* @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0__1975, void (i8*, i8*, %GLFWimage*)** %closure.func1996
%closure_size1997 = call i64 @llvm_zone_mark_size(%mzone* %zone1982)
call void @llvm_zone_ptr_set_size(i8* %clsptr1983, i64 %closure_size1997)
%wrapper_ptr1998 = call i8* @llvm_zone_malloc(%mzone* %zone1982, i64 8)
%closure_wrapper1999 = bitcast i8* %wrapper_ptr1998 to { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**
store { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure1984, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_wrapper1999

; let value assignment
%hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_wrapper1999, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_wrapper1999
store { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0, { i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*** %hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0
%tmp_envptr1993 = getelementptr {{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***}, {{i8*, i8*, void (i8*, i8*, %GLFWimage*)*}***}* %environment1986, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*** %hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**** %tmp_envptr1993


%val2002 = load {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*** %hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %val2002
}


@hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0(%GLFWimage* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWimage*)*,  void (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_native(%GLFWimage* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWimage*)*,  void (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2003 = bitcast [89 x i8]* @gsxtmglfw384 to i8*
call i32 (i8*, ...) @printf(i8* %var2003)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWimage*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWimage*)*,  void (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWimage*}*
%arg_p_0 = getelementptr {%GLFWimage*}, {%GLFWimage*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWimage*, %GLFWimage** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsR0xGV2ltYWdlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}*, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}, {i8*, i8*, void (i8*, i8*, %GLFWimage*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %GLFWimage*)*,  void (i8*, i8*, %GLFWimage*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw385 = hidden constant [63 x i8] c"zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmglfw386 = hidden constant [69 x i8] c"{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %GLFWimage* @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ__2004(i8* %_impz,i8* %_impenv, %GLFWimage* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2005 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}***, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %GLFWimage*
store %GLFWimage* %x, %GLFWimage** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val2007 = load %mzone*, %mzone** %fromzPtr
%val2008 = load %GLFWimage*, %GLFWimage** %xPtr
%val2009 = bitcast %GLFWimage* %val2008 to i8*
%res2010 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val2007, i8* %val2009)
br i1 %res2010, label %then2006, label %else2006

then2006:
%val2011 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val2011)
%zone_ptr2012 = bitcast %mzone* %val2011 to i8*
store i8* %zone_ptr2012, i8** %_impzPtr
%tzone2018 = load i8*, i8** %_impzPtr
%zone2019 = bitcast i8* %tzone2018 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %GLFWimage*
%tzone2014 = load i8*, i8** %_impzPtr
%zone2015 = bitcast i8* %tzone2014 to %mzone*
%dat2016 = call i8* @llvm_zone_malloc(%mzone* %zone2015, i64 16)
call i8* @memset(i8* %dat2016, i32 0, i64 16)
%val2017 = bitcast i8* %dat2016 to %GLFWimage*

; let value assignment
%obj = select i1 true, %GLFWimage* %val2017, %GLFWimage* %val2017
store %GLFWimage* %obj, %GLFWimage** %objPtr

; promote local stack var allocations
%tzone2063 = load i8*, i8** %_impzPtr
%zone2064 = bitcast i8* %tzone2063 to %mzone*
%ifptr2030 = alloca i8*
%val2020 = load %GLFWimage*, %GLFWimage** %objPtr
%val2021 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val2022 = getelementptr %GLFWimage, %GLFWimage* %val2021, i64 0, i32 0
%val2023 = load i32, i32* %val2022
; set tuple
%val2024 = getelementptr %GLFWimage, %GLFWimage* %val2020, i64 0, i32 0
store i32 %val2023, i32* %val2024
%val2025 = load %GLFWimage*, %GLFWimage** %objPtr
%val2026 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val2027 = getelementptr %GLFWimage, %GLFWimage* %val2026, i64 0, i32 1
%val2028 = load i32, i32* %val2027
; set tuple
%val2029 = getelementptr %GLFWimage, %GLFWimage* %val2025, i64 0, i32 1
store i32 %val2028, i32* %val2029
%val2031 = load %mzone*, %mzone** %fromzPtr
%val2032 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val2033 = getelementptr %GLFWimage, %GLFWimage* %val2032, i64 0, i32 2
%val2034 = load i8*, i8** %val2033
%val2035 = bitcast i8* %val2034 to i8*
%res2036 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val2031, i8* %val2035)
br i1 %res2036, label %then2030, label %else2030

then2030:
%tzone2041 = load i8*, i8** %_impzPtr
%zone2042 = bitcast i8* %tzone2041 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i8*
%tzone2037 = load i8*, i8** %_impzPtr
%zone2038 = bitcast i8* %tzone2037 to %mzone*
%dat2039 = call i8* @llvm_zone_malloc(%mzone* %zone2038, i64 1)
call i8* @memset(i8* %dat2039, i32 0, i64 1)
%val2040 = bitcast i8* %dat2039 to i8*

; let value assignment
%newptr = select i1 true, i8* %val2040, i8* %val2040
store i8* %newptr, i8** %newptrPtr

%val2043 = load i8*, i8** %newptrPtr
%val2044 = bitcast i8* %val2043 to i8*
%val2045 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val2046 = getelementptr %GLFWimage, %GLFWimage* %val2045, i64 0, i32 2
%val2047 = load i8*, i8** %val2046
%val2048 = bitcast i8* %val2047 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val2044, i8* %val2048, i64 1, i32 1, i1 0)
%val2050 = load %GLFWimage*, %GLFWimage** %objPtr
%val2051 = load i8*, i8** %newptrPtr
; set tuple
%val2052 = getelementptr %GLFWimage, %GLFWimage* %val2050, i64 0, i32 2
store i8* %val2051, i8** %val2052
store i8* %val2051, i8** %ifptr2030
br label %ifcont2030

else2030:
%val2053 = load %GLFWimage*, %GLFWimage** %objPtr
%val2054 = load %GLFWimage*, %GLFWimage** %xPtr
; tuple ref
%val2055 = getelementptr %GLFWimage, %GLFWimage* %val2054, i64 0, i32 2
%val2056 = load i8*, i8** %val2055
; set tuple
%val2057 = getelementptr %GLFWimage, %GLFWimage* %val2053, i64 0, i32 2
store i8* %val2056, i8** %val2057
store i8* %val2056, i8** %ifptr2030
br label %ifcont2030

ifcont2030:
%ifres2058 = load i8*, i8** %ifptr2030

%oldzone2059 = call %mzone* @llvm_pop_zone_stack()
%newzone2060 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2061 = bitcast %mzone* %newzone2060 to i8*
store i8* %zone_ptr2061, i8** %_impzPtr
%val2062 = load %GLFWimage*, %GLFWimage** %objPtr
ret %GLFWimage* %val2062

else2006:
%val2065 = load %GLFWimage*, %GLFWimage** %xPtr
ret %GLFWimage* %val2065
}
@gsxtmglfw387 = hidden constant [116 x i8] c"zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2085 = load i8*, i8** %_impzPtr
%zone2086 = bitcast i8* %tzone2085 to %mzone*

; let assign value to symbol zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2086, i64 8)
%zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}***
%tzone2066 = load i8*, i8** %_impzPtr
%zone2067 = bitcast i8* %tzone2066 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2067)
; malloc closure structure
%clsptr2068 = call i8* @llvm_zone_malloc(%mzone* %zone2067, i64 24)
%closure2069 = bitcast i8* %clsptr2068 to { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr2070 = call i8* @llvm_zone_malloc(%mzone* %zone2067, i64 8)
%environment2071 = bitcast i8* %envptr2070 to {{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable2072 = call %clsvar* @new_address_table()
%var2073 = bitcast [63 x i8]* @gsxtmglfw385 to i8*
%var2074 = bitcast [69 x i8]* @gsxtmglfw386 to i8*
%addytable2075 = call %clsvar* @add_address_table(%mzone* %zone2067, i8* %var2073, i32 0, i8* %var2074, i32 3, %clsvar* %addytable2072)
%address-table2076 = bitcast %clsvar* %addytable2075 to i8*

; insert table, function and environment into closure struct
%closure.table2079 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}* %closure2069, i32 0, i32 0
store i8* %address-table2076, i8** %closure.table2079
%closure.env2080 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}* %closure2069, i32 0, i32 1
store i8* %envptr2070, i8** %closure.env2080
%closure.func2081 = getelementptr { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}* %closure2069, i32 0, i32 2
store %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)* @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ__2004, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)** %closure.func2081
%closure_size2082 = call i64 @llvm_zone_mark_size(%mzone* %zone2067)
call void @llvm_zone_ptr_set_size(i8* %clsptr2068, i64 %closure_size2082)
%wrapper_ptr2083 = call i8* @llvm_zone_malloc(%mzone* %zone2067, i64 8)
%closure_wrapper2084 = bitcast i8* %wrapper_ptr2083 to { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}**
store { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}* %closure2069, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}** %closure_wrapper2084

; let value assignment
%zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}** %closure_wrapper2084, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}** %closure_wrapper2084
store { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}** %zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ
%tmp_envptr2078 = getelementptr {{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}***}* %environment2071, i32 0, i32 0
store {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}**** %tmp_envptr2078


%val2087 = load {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}**, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}** %val2087
}


@zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %GLFWimage* @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ(%GLFWimage* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*,  %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %GLFWimage* %result
}


define dllexport ccc %GLFWimage* @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_native(%GLFWimage* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*,  %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %GLFWimage* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2088 = bitcast [116 x i8]* @gsxtmglfw387 to i8*
call i32 (i8*, ...) @printf(i8* %var2088)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWimage*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2089 = bitcast [116 x i8]* @gsxtmglfw387 to i8*
call i32 (i8*, ...) @printf(i8* %var2089)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2090 = bitcast [116 x i8]* @gsxtmglfw387 to i8*
call i32 (i8*, ...) @printf(i8* %var2090)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*,  %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %GLFWimage* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWimage*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%GLFWimage*, %mzone*, %mzone*}, {%GLFWimage*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWimage*, %GLFWimage** %arg_p_0
%arg_p_1 = getelementptr {%GLFWimage*, %mzone*, %mzone*}, {%GLFWimage*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%GLFWimage*, %mzone*, %mzone*}, {%GLFWimage*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0dMRldpbWFnZSosR0xGV2ltYWdlKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}*, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}, {i8*, i8*, %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)*,  %GLFWimage* (i8*, i8*, %GLFWimage*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %GLFWimage* %ff(i8* %_impz, i8* %ee, %GLFWimage* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


declare cc 0 i32 @glfwInit() nounwind
declare cc 0 void @glfwTerminate() nounwind
declare cc 0 void @glfwGetVersion(i32*,i32*,i32*) nounwind
declare cc 0 i8* @glfwGetVersionString() nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i32, i8*)*}** @glfwSetErrorCallback({i8*, i8*, void (i8*, i8*, i32, i8*)*}**) nounwind
declare cc 0 i8** @glfwGetMonitors(i32*) nounwind
declare cc 0 i8* @glfwGetPrimaryMonitor() nounwind
declare cc 0 void @glfwGetMonitorPos(i8*,i32*,i32*) nounwind
declare cc 0 void @glfwGetMonitorPhysicalSize(i8*,i32*,i32*) nounwind
declare cc 0 i8* @glfwGetMonitorName(i8*) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, i32)*}** @glfwSetMonitorCallback({i8*, i8*, void (i8*, i8*, i8*, i32)*}**) nounwind
declare cc 0 %GLFWvidmode* @glfwGetVideoModes(i8*,i32*) nounwind
declare cc 0 %GLFWvidmode* @glfwGetVideoMode(i8*) nounwind
declare cc 0 void @glfwSetGamma(i8*,float) nounwind
declare cc 0 %GLFWgammaramp* @glfwGetGammaRamp(i8*) nounwind
declare cc 0 void @glfwSetGammaRamp(i8*,%GLFWgammaramp*) nounwind
declare cc 0 void @glfwDefaultWindowHints() nounwind
declare cc 0 void @glfwWindowHint(i32,i32) nounwind
declare cc 0 i8* @glfwCreateWindow(i32,i32,i8*,i8*,i8*) nounwind
declare cc 0 void @glfwDestroyWindow(i8*) nounwind
declare cc 0 i32 @glfwWindowShouldClose(i8*) nounwind
declare cc 0 void @glfwSetWindowShouldClose(i8*,i32) nounwind
declare cc 0 void @glfwSetWindowTitle(i8*,i8*) nounwind
declare cc 0 void @glfwSetWindowIcon(i8*,i32,%GLFWimage*) nounwind
declare cc 0 void @glfwGetWindowPos(i8*,i32*,i32*) nounwind
declare cc 0 void @glfwSetWindowPos(i8*,i32,i32) nounwind
declare cc 0 void @glfwGetWindowSize(i8*,i32*,i32*) nounwind
declare cc 0 void @glfwSetWindowSizeLimits(i8*,i32,i32,i32,i32) nounwind
declare cc 0 void @glfwSetWindowAspectRatio(i8*,i32,i32) nounwind
declare cc 0 void @glfwSetWindowSize(i8*,i32,i32) nounwind
declare cc 0 void @glfwGetFramebufferSize(i8*,i32*,i32*) nounwind
declare cc 0 void @glfwGetWindowFrameSize(i8*,i32*,i32*,i32*,i32*) nounwind
declare cc 0 void @glfwIconifyWindow(i8*) nounwind
declare cc 0 void @glfwRestoreWindow(i8*) nounwind
declare cc 0 void @glfwMaximizeWindow(i8*) nounwind
declare cc 0 void @glfwShowWindow(i8*) nounwind
declare cc 0 void @glfwHideWindow(i8*) nounwind
declare cc 0 void @glfwFocusWindow(i8*) nounwind
declare cc 0 i8* @glfwGetWindowMonitor(i8*) nounwind
declare cc 0 void @glfwSetWindowMonitor(i8*,i8*,i32,i32,i32,i32,i32) nounwind
declare cc 0 i32 @glfwGetWindowAttrib(i8*,i32) nounwind
declare cc 0 void @glfwSetWindowUserPointer(i8*,i8*) nounwind
declare cc 0 void @glfwGetWindowUserPointer(i8*) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** @glfwSetWindowPosCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** @glfwSetWindowSizeCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*)*}** @glfwSetWindowCloseCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*)*}** @glfwSetWindowRefreshCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, i32)*}** @glfwSetWindowFocusCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, i32)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, i32)*}** @glfwSetWindowIconifyCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, i32)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** @glfwSetFramebufferSizeCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**) nounwind
declare cc 0 void @glfwPollEvents() nounwind
declare cc 0 void @glfwWaitEvents() nounwind
declare cc 0 void @glfwWaitEventsTimeout(double) nounwind
declare cc 0 void @glfwPostEmptyEvent() nounwind
declare cc 0 i32 @glfwGetInputMode(i8*,i32) nounwind
declare cc 0 void @glfwSetInputMode(i8*,i32,i32) nounwind
declare cc 0 i8* @glfwGetKeyName(i32,i32) nounwind
declare cc 0 i32 @glfwGetKey(i8*,i32) nounwind
declare cc 0 i32 @glfwGetMouseButton(i8*,i32) nounwind
declare cc 0 void @glfwGetCursorPos(i8*,double*,double*) nounwind
declare cc 0 void @glfwSetCursorPos(i8*,double,double) nounwind
declare cc 0 i8* @glfwCreateCursor(%GLFWimage*,i32,i32) nounwind
declare cc 0 i8* @glfwCreateStandardCursor(i32) nounwind
declare cc 0 void @glfwDestroyCursor(i8*) nounwind
declare cc 0 void @glfwSetCursor(i8*,i8*) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** @glfwSetKeyCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, i32)*}** @glfwSetCharCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, i32)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** @glfwSetCharModsCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** @glfwSetMouseButtonCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, double, double)*}** @glfwSetCursorPosCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, double, double)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, i32)*}** @glfwSetCursorEnterCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, i32)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, double, double)*}** @glfwSetScrollCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, double, double)*}**) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i8*, i32, i8**)*}** @glfwSetDropCallback(i8*,{i8*, i8*, void (i8*, i8*, i8*, i32, i8**)*}**) nounwind
declare cc 0 i32 @glfwJoystickPresent(i32) nounwind
declare cc 0 float* @glfwGetJoystickAxes(i32,i32*) nounwind
declare cc 0 i8* @glfwGetJoystickButtons(i32,i32*) nounwind
declare cc 0 i8* @glfwGetJoystickName(i32) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*, i32, i32)*}** @glfwSetJoystickCallback({i8*, i8*, void (i8*, i8*, i32, i32)*}**) nounwind
declare cc 0 void @glfwSetClipboardString(i8*,i8*) nounwind
declare cc 0 i8* @glfwGetClipboardString(i8*) nounwind
declare cc 0 double @glfwGetTime() nounwind
declare cc 0 void @glfwSetTime(double) nounwind
declare cc 0 i64 @glfwGetTimerValue() nounwind
declare cc 0 i64 @glfwGetTimerFrequency() nounwind
declare cc 0 void @glfwMakeContextCurrent(i8*) nounwind
declare cc 0 i8* @glfwGetCurrentContext() nounwind
declare cc 0 void @glfwSwapBuffers(i8*) nounwind
declare cc 0 void @glfwSwapInterval(i32) nounwind
declare cc 0 i32 @glfwExtensionSupported(i8*) nounwind
declare cc 0 {i8*, i8*, void (i8*, i8*)*}** @glfwGetProcAddress(i8*) nounwind
declare cc 0 i32 @glfwVulkanSupported() nounwind
declare cc 0 i8** @glfwGetRequiredInstanceExtensions(i32*) nounwind
@gsxtmglfw388 = hidden constant [19 x i8] c"GLFW error %d: %s
\00"
@gsxtmglfw389 = hidden constant [46 x i8] c"glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0\00"
@gsxtmglfw390 = hidden constant [41 x i8] c"{i8*, i8*, void (i8*, i8*, i32, i8*)*}**\00"
define dllexport fastcc void @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0__2091(i8* %_impz,i8* %_impenv, i32 %err, i8* %description) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2092 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32, i8*)*}***}*
%glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i32, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0Ptr = load {i8*, i8*, void (i8*, i8*, i32, i8*)*}***, {i8*, i8*, void (i8*, i8*, i32, i8*)*}**** %glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0Ptr_

; setup arguments
%errPtr = alloca i32
store i32 %err, i32* %errPtr
%descriptionPtr = alloca i8*
store i8* %description, i8** %descriptionPtr


%var2093 = bitcast [19 x i8]* @gsxtmglfw388 to i8*
%val2094 = load i32, i32* %errPtr
%val2095 = load i8*, i8** %descriptionPtr

%val2096 = call i32 (i8*, ...) @printf(i8* %var2093, i32 %val2094, i8* %val2095)
ret void
}
@gsxtmglfw391 = hidden constant [99 x i8] c"glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32, i8*)*}** @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2117 = load i8*, i8** %_impzPtr
%zone2118 = bitcast i8* %tzone2117 to %mzone*

; let assign value to symbol glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0
%dat_glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone2118, i64 8)
%glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0Ptr = bitcast i8* %dat_glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0 to { i8*, i8*, void (i8*, i8*, i32, i8*)*}***
%tzone2098 = load i8*, i8** %_impzPtr
%zone2099 = bitcast i8* %tzone2098 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2099)
; malloc closure structure
%clsptr2100 = call i8* @llvm_zone_malloc(%mzone* %zone2099, i64 24)
%closure2101 = bitcast i8* %clsptr2100 to { i8*, i8*, void (i8*, i8*, i32, i8*)*}*

; malloc environment structure
%envptr2102 = call i8* @llvm_zone_malloc(%mzone* %zone2099, i64 8)
%environment2103 = bitcast i8* %envptr2102 to {{i8*, i8*, void (i8*, i8*, i32, i8*)*}***}*

; malloc closure address table
%addytable2104 = call %clsvar* @new_address_table()
%var2105 = bitcast [46 x i8]* @gsxtmglfw389 to i8*
%var2106 = bitcast [41 x i8]* @gsxtmglfw390 to i8*
%addytable2107 = call %clsvar* @add_address_table(%mzone* %zone2099, i8* %var2105, i32 0, i8* %var2106, i32 3, %clsvar* %addytable2104)
%address-table2108 = bitcast %clsvar* %addytable2107 to i8*

; insert table, function and environment into closure struct
%closure.table2111 = getelementptr { i8*, i8*, void (i8*, i8*, i32, i8*)*}, { i8*, i8*, void (i8*, i8*, i32, i8*)*}* %closure2101, i32 0, i32 0
store i8* %address-table2108, i8** %closure.table2111
%closure.env2112 = getelementptr { i8*, i8*, void (i8*, i8*, i32, i8*)*}, { i8*, i8*, void (i8*, i8*, i32, i8*)*}* %closure2101, i32 0, i32 1
store i8* %envptr2102, i8** %closure.env2112
%closure.func2113 = getelementptr { i8*, i8*, void (i8*, i8*, i32, i8*)*}, { i8*, i8*, void (i8*, i8*, i32, i8*)*}* %closure2101, i32 0, i32 2
store void (i8*, i8*, i32, i8*)* @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0__2091, void (i8*, i8*, i32, i8*)** %closure.func2113
%closure_size2114 = call i64 @llvm_zone_mark_size(%mzone* %zone2099)
call void @llvm_zone_ptr_set_size(i8* %clsptr2100, i64 %closure_size2114)
%wrapper_ptr2115 = call i8* @llvm_zone_malloc(%mzone* %zone2099, i64 8)
%closure_wrapper2116 = bitcast i8* %wrapper_ptr2115 to { i8*, i8*, void (i8*, i8*, i32, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i32, i8*)*}* %closure2101, { i8*, i8*, void (i8*, i8*, i32, i8*)*}** %closure_wrapper2116

; let value assignment
%glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i32, i8*)*}** %closure_wrapper2116, { i8*, i8*, void (i8*, i8*, i32, i8*)*}** %closure_wrapper2116
store { i8*, i8*, void (i8*, i8*, i32, i8*)*}** %glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0, { i8*, i8*, void (i8*, i8*, i32, i8*)*}*** %glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0
%tmp_envptr2110 = getelementptr {{i8*, i8*, void (i8*, i8*, i32, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i32, i8*)*}***}* %environment2103, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32, i8*)*}*** %glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0Ptr, {i8*, i8*, void (i8*, i8*, i32, i8*)*}**** %tmp_envptr2110


%val2119 = load {i8*, i8*, void (i8*, i8*, i32, i8*)*}**, {i8*, i8*, void (i8*, i8*, i32, i8*)*}*** %glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0Ptr
ret {i8*, i8*, void (i8*, i8*, i32, i8*)*}** %val2119
}


@glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32, i8*)*}** @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0(i32 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, i8*)*}*, {i8*, i8*, void (i8*, i8*, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i8*)*}, {i8*, i8*, void (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i8*)*}, {i8*, i8*, void (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, i8*)*,  void (i8*, i8*, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc void @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_native(i32 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, i8*)*}*, {i8*, i8*, void (i8*, i8*, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i8*)*}, {i8*, i8*, void (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i8*)*}, {i8*, i8*, void (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, i8*)*,  void (i8*, i8*, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1)
ret void
}


define dllexport ccc i8*  @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2120 = bitcast [99 x i8]* @gsxtmglfw391 to i8*
call i32 (i8*, ...) @printf(i8* %var2120)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2121 = bitcast [99 x i8]* @gsxtmglfw391 to i8*
call i32 (i8*, ...) @printf(i8* %var2121)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, i8*)*}*, {i8*, i8*, void (i8*, i8*, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i8*)*}, {i8*, i8*, void (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i8*)*}, {i8*, i8*, void (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, i8*)*,  void (i8*, i8*, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i8*}*
%arg_p_0 = getelementptr {i32, i8*}, {i32, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i8*}, {i32, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32, i8*)*}*, {i8*, i8*, void (i8*, i8*, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i8*)*}, {i8*, i8*, void (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32, i8*)*}, {i8*, i8*, void (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32, i8*)*,  void (i8*, i8*, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw392 = hidden constant [53 x i8] c"glfw_error_callback_adhoc_W3ZvaWQsaTMyLGk4Kl0_native\00"
@gsxtmglfw393 = hidden constant [24 x i8] c"glfw_init_adhoc_W2kzMl0\00"
@gsxtmglfw394 = hidden constant [30 x i8] c"{i8*, i8*, i32 (i8*, i8*)*}**\00"
define dllexport fastcc i32 @glfw_init_adhoc_W2kzMl0__2122(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2123 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*)*}***}*
%glfw_init_adhoc_W2kzMl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_init_adhoc_W2kzMl0Ptr = load {i8*, i8*, i32 (i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*)*}**** %glfw_init_adhoc_W2kzMl0Ptr_

; setup arguments


%tzone2125 = load i8*, i8** %_impzPtr
%zone2126 = bitcast i8* %tzone2125 to %mzone*

; let assign value to symbol res
%resPtr = alloca i32
%res2124 = call ccc i32 @glfwInit()

; let value assignment
%res = select i1 true, i32 %res2124, i32 %res2124
store i32 %res, i32* %resPtr

%val2128 = load i32, i32* %resPtr
%cmp2129 = icmp eq i32 %val2128, 1
br i1 %cmp2129, label %then2127, label %else2127

then2127:
%var2130 = bitcast [53 x i8]* @gsxtmglfw392 to i8*
%res2131 = call ccc i8* @llvm_get_function_ptr(i8* %var2130)
%val2132 = bitcast i8* %res2131 to {i8*, i8*, void (i8*, i8*, i32, i8*)*}**
%res2133 = call ccc {i8*, i8*, void (i8*, i8*, i32, i8*)*}** @glfwSetErrorCallback({i8*, i8*, void (i8*, i8*, i32, i8*)*}** %val2132)
%val2134 = load i32, i32* %resPtr
ret i32 %val2134

else2127:
%val2135 = load i32, i32* %resPtr
ret i32 %val2135
}
define dllexport ccc {i8*, i8*, i32 (i8*, i8*)*}** @glfw_init_adhoc_W2kzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2155 = load i8*, i8** %_impzPtr
%zone2156 = bitcast i8* %tzone2155 to %mzone*

; let assign value to symbol glfw_init_adhoc_W2kzMl0
%dat_glfw_init_adhoc_W2kzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2156, i64 8)
%glfw_init_adhoc_W2kzMl0Ptr = bitcast i8* %dat_glfw_init_adhoc_W2kzMl0 to { i8*, i8*, i32 (i8*, i8*)*}***
%tzone2136 = load i8*, i8** %_impzPtr
%zone2137 = bitcast i8* %tzone2136 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2137)
; malloc closure structure
%clsptr2138 = call i8* @llvm_zone_malloc(%mzone* %zone2137, i64 24)
%closure2139 = bitcast i8* %clsptr2138 to { i8*, i8*, i32 (i8*, i8*)*}*

; malloc environment structure
%envptr2140 = call i8* @llvm_zone_malloc(%mzone* %zone2137, i64 8)
%environment2141 = bitcast i8* %envptr2140 to {{i8*, i8*, i32 (i8*, i8*)*}***}*

; malloc closure address table
%addytable2142 = call %clsvar* @new_address_table()
%var2143 = bitcast [24 x i8]* @gsxtmglfw393 to i8*
%var2144 = bitcast [30 x i8]* @gsxtmglfw394 to i8*
%addytable2145 = call %clsvar* @add_address_table(%mzone* %zone2137, i8* %var2143, i32 0, i8* %var2144, i32 3, %clsvar* %addytable2142)
%address-table2146 = bitcast %clsvar* %addytable2145 to i8*

; insert table, function and environment into closure struct
%closure.table2149 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure2139, i32 0, i32 0
store i8* %address-table2146, i8** %closure.table2149
%closure.env2150 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure2139, i32 0, i32 1
store i8* %envptr2140, i8** %closure.env2150
%closure.func2151 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure2139, i32 0, i32 2
store i32 (i8*, i8*)* @glfw_init_adhoc_W2kzMl0__2122, i32 (i8*, i8*)** %closure.func2151
%closure_size2152 = call i64 @llvm_zone_mark_size(%mzone* %zone2137)
call void @llvm_zone_ptr_set_size(i8* %clsptr2138, i64 %closure_size2152)
%wrapper_ptr2153 = call i8* @llvm_zone_malloc(%mzone* %zone2137, i64 8)
%closure_wrapper2154 = bitcast i8* %wrapper_ptr2153 to { i8*, i8*, i32 (i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*)*}* %closure2139, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper2154

; let value assignment
%glfw_init_adhoc_W2kzMl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper2154, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper2154
store { i8*, i8*, i32 (i8*, i8*)*}** %glfw_init_adhoc_W2kzMl0, { i8*, i8*, i32 (i8*, i8*)*}*** %glfw_init_adhoc_W2kzMl0Ptr

; add data to environment
; don't need to alloc for env var glfw_init_adhoc_W2kzMl0
%tmp_envptr2148 = getelementptr {{i8*, i8*, i32 (i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*)*}***}* %environment2141, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*)*}*** %glfw_init_adhoc_W2kzMl0Ptr, {i8*, i8*, i32 (i8*, i8*)*}**** %tmp_envptr2148


%val2157 = load {i8*, i8*, i32 (i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*)*}*** %glfw_init_adhoc_W2kzMl0Ptr
ret {i8*, i8*, i32 (i8*, i8*)*}** %val2157
}


@glfw_init_adhoc_W2kzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_init_adhoc_W2kzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_init_adhoc_W2kzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_adhoc_W2kzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*)*}** @glfw_init_adhoc_W2kzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_init_adhoc_W2kzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_init_adhoc_W2kzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_adhoc_W2kzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @glfw_init_adhoc_W2kzMl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
ret i32 %result
}


define dllexport ccc i32 @glfw_init_adhoc_W2kzMl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
ret i32 %result
}


define dllexport ccc i8*  @glfw_init_adhoc_W2kzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @glfw_init_adhoc_W2kzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw395 = hidden constant [30 x i8] c"glfw_terminate_adhoc_W3ZvaWRd\00"
@gsxtmglfw396 = hidden constant [31 x i8] c"{i8*, i8*, void (i8*, i8*)*}**\00"
define dllexport fastcc void @glfw_terminate_adhoc_W3ZvaWRd__2158(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2159 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%glfw_terminate_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_terminate_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %glfw_terminate_adhoc_W3ZvaWRdPtr_

; setup arguments


call ccc void @glfwTerminate()
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @glfw_terminate_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2180 = load i8*, i8** %_impzPtr
%zone2181 = bitcast i8* %tzone2180 to %mzone*

; let assign value to symbol glfw_terminate_adhoc_W3ZvaWRd
%dat_glfw_terminate_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone2181, i64 8)
%glfw_terminate_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_glfw_terminate_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone2161 = load i8*, i8** %_impzPtr
%zone2162 = bitcast i8* %tzone2161 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2162)
; malloc closure structure
%clsptr2163 = call i8* @llvm_zone_malloc(%mzone* %zone2162, i64 24)
%closure2164 = bitcast i8* %clsptr2163 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr2165 = call i8* @llvm_zone_malloc(%mzone* %zone2162, i64 8)
%environment2166 = bitcast i8* %envptr2165 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable2167 = call %clsvar* @new_address_table()
%var2168 = bitcast [30 x i8]* @gsxtmglfw395 to i8*
%var2169 = bitcast [31 x i8]* @gsxtmglfw396 to i8*
%addytable2170 = call %clsvar* @add_address_table(%mzone* %zone2162, i8* %var2168, i32 0, i8* %var2169, i32 3, %clsvar* %addytable2167)
%address-table2171 = bitcast %clsvar* %addytable2170 to i8*

; insert table, function and environment into closure struct
%closure.table2174 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2164, i32 0, i32 0
store i8* %address-table2171, i8** %closure.table2174
%closure.env2175 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2164, i32 0, i32 1
store i8* %envptr2165, i8** %closure.env2175
%closure.func2176 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2164, i32 0, i32 2
store void (i8*, i8*)* @glfw_terminate_adhoc_W3ZvaWRd__2158, void (i8*, i8*)** %closure.func2176
%closure_size2177 = call i64 @llvm_zone_mark_size(%mzone* %zone2162)
call void @llvm_zone_ptr_set_size(i8* %clsptr2163, i64 %closure_size2177)
%wrapper_ptr2178 = call i8* @llvm_zone_malloc(%mzone* %zone2162, i64 8)
%closure_wrapper2179 = bitcast i8* %wrapper_ptr2178 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure2164, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2179

; let value assignment
%glfw_terminate_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2179, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2179
store { i8*, i8*, void (i8*, i8*)*}** %glfw_terminate_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %glfw_terminate_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var glfw_terminate_adhoc_W3ZvaWRd
%tmp_envptr2173 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment2166, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %glfw_terminate_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr2173


%val2182 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %glfw_terminate_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val2182
}


@glfw_terminate_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_terminate_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_terminate_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_terminate_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @glfw_terminate_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_terminate_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_terminate_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_terminate_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_terminate_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_terminate_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @glfw_terminate_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_terminate_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @glfw_terminate_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_terminate_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_terminate_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_terminate_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw397 = hidden constant [4 x i8] c"%s
\00"
@gsxtmglfw398 = hidden constant [40 x i8] c"glfw_print_version_string_adhoc_W2kzMl0\00"
define dllexport fastcc i32 @glfw_print_version_string_adhoc_W2kzMl0__2183(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2184 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*)*}***}*
%glfw_print_version_string_adhoc_W2kzMl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_print_version_string_adhoc_W2kzMl0Ptr = load {i8*, i8*, i32 (i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*)*}**** %glfw_print_version_string_adhoc_W2kzMl0Ptr_

; setup arguments


%var2185 = bitcast [4 x i8]* @gsxtmglfw397 to i8*
%res2186 = call ccc i8* @glfwGetVersionString()

%val2187 = call i32 (i8*, ...) @printf(i8* %var2185, i8* %res2186)
ret i32 %val2187
}
define dllexport ccc {i8*, i8*, i32 (i8*, i8*)*}** @glfw_print_version_string_adhoc_W2kzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2207 = load i8*, i8** %_impzPtr
%zone2208 = bitcast i8* %tzone2207 to %mzone*

; let assign value to symbol glfw_print_version_string_adhoc_W2kzMl0
%dat_glfw_print_version_string_adhoc_W2kzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2208, i64 8)
%glfw_print_version_string_adhoc_W2kzMl0Ptr = bitcast i8* %dat_glfw_print_version_string_adhoc_W2kzMl0 to { i8*, i8*, i32 (i8*, i8*)*}***
%tzone2188 = load i8*, i8** %_impzPtr
%zone2189 = bitcast i8* %tzone2188 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2189)
; malloc closure structure
%clsptr2190 = call i8* @llvm_zone_malloc(%mzone* %zone2189, i64 24)
%closure2191 = bitcast i8* %clsptr2190 to { i8*, i8*, i32 (i8*, i8*)*}*

; malloc environment structure
%envptr2192 = call i8* @llvm_zone_malloc(%mzone* %zone2189, i64 8)
%environment2193 = bitcast i8* %envptr2192 to {{i8*, i8*, i32 (i8*, i8*)*}***}*

; malloc closure address table
%addytable2194 = call %clsvar* @new_address_table()
%var2195 = bitcast [40 x i8]* @gsxtmglfw398 to i8*
%var2196 = bitcast [30 x i8]* @gsxtmglfw394 to i8*
%addytable2197 = call %clsvar* @add_address_table(%mzone* %zone2189, i8* %var2195, i32 0, i8* %var2196, i32 3, %clsvar* %addytable2194)
%address-table2198 = bitcast %clsvar* %addytable2197 to i8*

; insert table, function and environment into closure struct
%closure.table2201 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure2191, i32 0, i32 0
store i8* %address-table2198, i8** %closure.table2201
%closure.env2202 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure2191, i32 0, i32 1
store i8* %envptr2192, i8** %closure.env2202
%closure.func2203 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure2191, i32 0, i32 2
store i32 (i8*, i8*)* @glfw_print_version_string_adhoc_W2kzMl0__2183, i32 (i8*, i8*)** %closure.func2203
%closure_size2204 = call i64 @llvm_zone_mark_size(%mzone* %zone2189)
call void @llvm_zone_ptr_set_size(i8* %clsptr2190, i64 %closure_size2204)
%wrapper_ptr2205 = call i8* @llvm_zone_malloc(%mzone* %zone2189, i64 8)
%closure_wrapper2206 = bitcast i8* %wrapper_ptr2205 to { i8*, i8*, i32 (i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*)*}* %closure2191, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper2206

; let value assignment
%glfw_print_version_string_adhoc_W2kzMl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper2206, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper2206
store { i8*, i8*, i32 (i8*, i8*)*}** %glfw_print_version_string_adhoc_W2kzMl0, { i8*, i8*, i32 (i8*, i8*)*}*** %glfw_print_version_string_adhoc_W2kzMl0Ptr

; add data to environment
; don't need to alloc for env var glfw_print_version_string_adhoc_W2kzMl0
%tmp_envptr2200 = getelementptr {{i8*, i8*, i32 (i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*)*}***}* %environment2193, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*)*}*** %glfw_print_version_string_adhoc_W2kzMl0Ptr, {i8*, i8*, i32 (i8*, i8*)*}**** %tmp_envptr2200


%val2209 = load {i8*, i8*, i32 (i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*)*}*** %glfw_print_version_string_adhoc_W2kzMl0Ptr
ret {i8*, i8*, i32 (i8*, i8*)*}** %val2209
}


@glfw_print_version_string_adhoc_W2kzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_print_version_string_adhoc_W2kzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_print_version_string_adhoc_W2kzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_version_string_adhoc_W2kzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*)*}** @glfw_print_version_string_adhoc_W2kzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_print_version_string_adhoc_W2kzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_print_version_string_adhoc_W2kzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_version_string_adhoc_W2kzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @glfw_print_version_string_adhoc_W2kzMl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_version_string_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
ret i32 %result
}


define dllexport ccc i32 @glfw_print_version_string_adhoc_W2kzMl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_version_string_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
ret i32 %result
}


define dllexport ccc i8*  @glfw_print_version_string_adhoc_W2kzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_version_string_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @glfw_print_version_string_adhoc_W2kzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_version_string_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw399 = hidden constant [24 x i8] c"Extempore OpenGL Window\00"
@gsxtmglfw3100 = hidden constant [49 x i8] c"glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd\00"
@gsxtmglfw3101 = hidden constant [35 x i8] c"{i8*, i8*, i8* (i8*, i8*, i8*)*}**\00"
@gsxtmglfw3102 = hidden constant [13 x i8] c"window_title\00"
@gsxtmglfw3103 = hidden constant [4 x i8] c"i8*\00"
@gsxtmglfw3104 = hidden constant [15 x i8] c"_anon_lambda_1\00"
define dllexport fastcc i8* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd__2210(i8* %_impz,i8* %_impenv, i8* %mon) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2219 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}*
%glfw_create_fullscreen_window_adhoc_W2k4KixpOCpdPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_create_fullscreen_window_adhoc_W2k4KixpOCpdPtr = load {i8*, i8*, i8* (i8*, i8*, i8*)*}***, {i8*, i8*, i8* (i8*, i8*, i8*)*}**** %glfw_create_fullscreen_window_adhoc_W2k4KixpOCpdPtr_
%window_titlePtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 1
%window_titlePtr = load i8**, i8*** %window_titlePtr_
%_anon_lambda_1Ptr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_1Ptr = load {i8*, i8*, i8* (i8*, i8*, i8*)*}***, {i8*, i8*, i8* (i8*, i8*, i8*)*}**** %_anon_lambda_1Ptr_

; setup arguments
%monPtr = alloca i8*
store i8* %mon, i8** %monPtr


%val2220 = load i8*, i8** %window_titlePtr
%var2221 = bitcast [24 x i8]* @gsxtmglfw399 to i8*

%val2222 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2220, i8* %var2221)
%tzone2224 = load i8*, i8** %_impzPtr
%zone2225 = bitcast i8* %tzone2224 to %mzone*

; let assign value to symbol monitor
%monitorPtr = alloca i8*
%tzone2228 = load i8*, i8** %_impzPtr
%zone2229 = bitcast i8* %tzone2228 to %mzone*

; let assign value to symbol vidmode
%vidmodePtr = alloca %GLFWvidmode*
%tzone2233 = load i8*, i8** %_impzPtr
%zone2234 = bitcast i8* %tzone2233 to %mzone*

; let assign value to symbol width
%widthPtr = alloca i32
%tzone2238 = load i8*, i8** %_impzPtr
%zone2239 = bitcast i8* %tzone2238 to %mzone*

; let assign value to symbol height
%heightPtr = alloca i32
%tzone2241 = load i8*, i8** %_impzPtr
%zone2242 = bitcast i8* %tzone2241 to %mzone*

; let assign value to symbol res
%resPtr = alloca i8*
%val2223 = load i8*, i8** %monPtr

; let value assignment
%monitor = select i1 true, i8* %val2223, i8* %val2223
store i8* %monitor, i8** %monitorPtr

%val2226 = load i8*, i8** %monitorPtr
%res2227 = call ccc %GLFWvidmode* @glfwGetVideoMode(i8* %val2226)

; let value assignment
%vidmode = select i1 true, %GLFWvidmode* %res2227, %GLFWvidmode* %res2227
store %GLFWvidmode* %vidmode, %GLFWvidmode** %vidmodePtr

%val2230 = load %GLFWvidmode*, %GLFWvidmode** %vidmodePtr
; tuple ref
%val2231 = getelementptr %GLFWvidmode, %GLFWvidmode* %val2230, i64 0, i32 0
%val2232 = load i32, i32* %val2231

; let value assignment
%width = select i1 true, i32 %val2232, i32 %val2232
store i32 %width, i32* %widthPtr

%val2235 = load %GLFWvidmode*, %GLFWvidmode** %vidmodePtr
; tuple ref
%val2236 = getelementptr %GLFWvidmode, %GLFWvidmode* %val2235, i64 0, i32 1
%val2237 = load i32, i32* %val2236

; let value assignment
%height = select i1 true, i32 %val2237, i32 %val2237
store i32 %height, i32* %heightPtr

%null2240 = bitcast i8* null to i8*

; let value assignment
%res = select i1 true, i8* %null2240, i8* %null2240
store i8* %res, i8** %resPtr

%val2243 = load i32, i32* @GLFW_DECORATED
call ccc void @glfwWindowHint(i32 %val2243, i32 0)
%val2245 = load i32, i32* @GLFW_AUTO_ICONIFY
call ccc void @glfwWindowHint(i32 %val2245, i32 1)
; do set!
%val2247 = load i32, i32* %widthPtr
%val2248 = load i32, i32* %heightPtr
%val2249 = load i8*, i8** %window_titlePtr
%val2250 = load i8*, i8** %monitorPtr
%null2251 = bitcast i8* null to i8*
%res2252 = call ccc i8* @glfwCreateWindow(i32 %val2247, i32 %val2248, i8* %val2249, i8* %val2250, i8* %null2251)
store i8* %res2252, i8** %resPtr
%val2253 = load i8*, i8** %resPtr
call ccc void @glfwSetWindowPos(i8* %val2253, i32 0, i32 0)
%val2255 = load i8*, i8** %resPtr
ret i8* %val2255
}
@gsxtmglfw3105 = hidden constant [102 x i8] c"glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i8*)*}** @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2288 = load i8*, i8** %_impzPtr
%zone2289 = bitcast i8* %tzone2288 to %mzone*

; let assign value to symbol glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd
%dat_glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone2289, i64 8)
%glfw_create_fullscreen_window_adhoc_W2k4KixpOCpdPtr = bitcast i8* %dat_glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd to {i8*, i8*, i8* (i8*, i8*, i8*)*}***
%tzone2217 = load i8*, i8** %_impzPtr
%zone2218 = bitcast i8* %tzone2217 to %mzone*

; let assign value to symbol window_title
%dat_window_title = call i8* @llvm_zone_malloc(%mzone* %zone2218, i64 8)
%window_titlePtr = bitcast i8* %dat_window_title to i8**
%val2211 = getelementptr i64, i64* null, i32 1
%zonesize2212 = mul i64 1, 128
%tzone2213 = load i8*, i8** %_impzPtr
%zone2214 = bitcast i8* %tzone2213 to %mzone*
%dat2215 = call i8* @llvm_zone_malloc(%mzone* %zone2214, i64 %zonesize2212)
call i8* @memset(i8* %dat2215, i32 0, i64 %zonesize2212)
%val2216 = bitcast i8* %dat2215 to i8*

; let value assignment
%window_title = select i1 true, i8* %val2216, i8* %val2216
store i8* %window_title, i8** %window_titlePtr

%tzone2285 = load i8*, i8** %_impzPtr
%zone2286 = bitcast i8* %tzone2285 to %mzone*

; let assign value to symbol _anon_lambda_1
%dat__anon_lambda_1 = call i8* @llvm_zone_malloc(%mzone* %zone2286, i64 8)
%_anon_lambda_1Ptr = bitcast i8* %dat__anon_lambda_1 to { i8*, i8*, i8* (i8*, i8*, i8*)*}***
%tzone2256 = load i8*, i8** %_impzPtr
%zone2257 = bitcast i8* %tzone2256 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2257)
; malloc closure structure
%clsptr2258 = call i8* @llvm_zone_malloc(%mzone* %zone2257, i64 24)
%closure2259 = bitcast i8* %clsptr2258 to { i8*, i8*, i8* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2260 = call i8* @llvm_zone_malloc(%mzone* %zone2257, i64 24)
%environment2261 = bitcast i8* %envptr2260 to {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2262 = call %clsvar* @new_address_table()
%var2263 = bitcast [49 x i8]* @gsxtmglfw3100 to i8*
%var2264 = bitcast [35 x i8]* @gsxtmglfw3101 to i8*
%addytable2265 = call %clsvar* @add_address_table(%mzone* %zone2257, i8* %var2263, i32 0, i8* %var2264, i32 3, %clsvar* %addytable2262)
%var2266 = bitcast [13 x i8]* @gsxtmglfw3102 to i8*
%var2267 = bitcast [4 x i8]* @gsxtmglfw3103 to i8*
%addytable2268 = call %clsvar* @add_address_table(%mzone* %zone2257, i8* %var2266, i32 8, i8* %var2267, i32 3, %clsvar* %addytable2265)
%var2269 = bitcast [15 x i8]* @gsxtmglfw3104 to i8*
%var2270 = bitcast [35 x i8]* @gsxtmglfw3101 to i8*
%addytable2271 = call %clsvar* @add_address_table(%mzone* %zone2257, i8* %var2269, i32 16, i8* %var2270, i32 3, %clsvar* %addytable2268)
%address-table2272 = bitcast %clsvar* %addytable2271 to i8*

; insert table, function and environment into closure struct
%closure.table2279 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure2259, i32 0, i32 0
store i8* %address-table2272, i8** %closure.table2279
%closure.env2280 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure2259, i32 0, i32 1
store i8* %envptr2260, i8** %closure.env2280
%closure.func2281 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure2259, i32 0, i32 2
store i8* (i8*, i8*, i8*)* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd__2210, i8* (i8*, i8*, i8*)** %closure.func2281
%closure_size2282 = call i64 @llvm_zone_mark_size(%mzone* %zone2257)
call void @llvm_zone_ptr_set_size(i8* %clsptr2258, i64 %closure_size2282)
%wrapper_ptr2283 = call i8* @llvm_zone_malloc(%mzone* %zone2257, i64 8)
%closure_wrapper2284 = bitcast i8* %wrapper_ptr2283 to { i8*, i8*, i8* (i8*, i8*, i8*)*}**
store { i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure2259, { i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_wrapper2284

; let value assignment
%_anon_lambda_1 = select i1 true, { i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_wrapper2284, { i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_wrapper2284
store { i8*, i8*, i8* (i8*, i8*, i8*)*}** %_anon_lambda_1, { i8*, i8*, i8* (i8*, i8*, i8*)*}*** %_anon_lambda_1Ptr

; add data to environment
; don't need to alloc for env var glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd
%tmp_envptr2274 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}* %environment2261, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i8*)*}*** %glfw_create_fullscreen_window_adhoc_W2k4KixpOCpdPtr, {i8*, i8*, i8* (i8*, i8*, i8*)*}**** %tmp_envptr2274

; don't need to alloc for env var window_title
%tmp_envptr2276 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}* %environment2261, i32 0, i32 1
store i8** %window_titlePtr, i8*** %tmp_envptr2276

; don't need to alloc for env var _anon_lambda_1
%tmp_envptr2278 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}* %environment2261, i32 0, i32 2
store {i8*, i8*, i8* (i8*, i8*, i8*)*}*** %_anon_lambda_1Ptr, {i8*, i8*, i8* (i8*, i8*, i8*)*}**** %tmp_envptr2278


%val2287 = load {i8*, i8*, i8* (i8*, i8*, i8*)*}**, {i8*, i8*, i8* (i8*, i8*, i8*)*}*** %_anon_lambda_1Ptr

; let value assignment
%glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd = select i1 true, {i8*, i8*, i8* (i8*, i8*, i8*)*}** %val2287, {i8*, i8*, i8* (i8*, i8*, i8*)*}** %val2287
store {i8*, i8*, i8* (i8*, i8*, i8*)*}** %glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd, {i8*, i8*, i8* (i8*, i8*, i8*)*}*** %glfw_create_fullscreen_window_adhoc_W2k4KixpOCpdPtr

%val2290 = load {i8*, i8*, i8* (i8*, i8*, i8*)*}**, {i8*, i8*, i8* (i8*, i8*, i8*)*}*** %glfw_create_fullscreen_window_adhoc_W2k4KixpOCpdPtr
ret {i8*, i8*, i8* (i8*, i8*, i8*)*}** %val2290
}


@glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i8*)*}** @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*)*,  i8* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i8* %result
}


define dllexport ccc i8* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*)*,  i8* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2291 = bitcast [102 x i8]* @gsxtmglfw3105 to i8*
call i32 (i8*, ...) @printf(i8* %var2291)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*)*,  i8* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*)*,  i8* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3106 = hidden constant [44 x i8] c"glfw_create_fullscreen_window_adhoc_W2k4Kl0\00"
@gsxtmglfw3107 = hidden constant [30 x i8] c"{i8*, i8*, i8* (i8*, i8*)*}**\00"
define dllexport fastcc i8* @glfw_create_fullscreen_window_adhoc_W2k4Kl0__2292(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2293 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*)*}***}*
%glfw_create_fullscreen_window_adhoc_W2k4Kl0Ptr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_create_fullscreen_window_adhoc_W2k4Kl0Ptr = load {i8*, i8*, i8* (i8*, i8*)*}***, {i8*, i8*, i8* (i8*, i8*)*}**** %glfw_create_fullscreen_window_adhoc_W2k4Kl0Ptr_

; setup arguments


%res2294 = call ccc i8* @glfwGetPrimaryMonitor()
%res2295 = call fastcc i8* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd(i8* %res2294)
ret i8* %res2295
}
define dllexport ccc {i8*, i8*, i8* (i8*, i8*)*}** @glfw_create_fullscreen_window_adhoc_W2k4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2315 = load i8*, i8** %_impzPtr
%zone2316 = bitcast i8* %tzone2315 to %mzone*

; let assign value to symbol glfw_create_fullscreen_window_adhoc_W2k4Kl0
%dat_glfw_create_fullscreen_window_adhoc_W2k4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone2316, i64 8)
%glfw_create_fullscreen_window_adhoc_W2k4Kl0Ptr = bitcast i8* %dat_glfw_create_fullscreen_window_adhoc_W2k4Kl0 to { i8*, i8*, i8* (i8*, i8*)*}***
%tzone2296 = load i8*, i8** %_impzPtr
%zone2297 = bitcast i8* %tzone2296 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2297)
; malloc closure structure
%clsptr2298 = call i8* @llvm_zone_malloc(%mzone* %zone2297, i64 24)
%closure2299 = bitcast i8* %clsptr2298 to { i8*, i8*, i8* (i8*, i8*)*}*

; malloc environment structure
%envptr2300 = call i8* @llvm_zone_malloc(%mzone* %zone2297, i64 8)
%environment2301 = bitcast i8* %envptr2300 to {{i8*, i8*, i8* (i8*, i8*)*}***}*

; malloc closure address table
%addytable2302 = call %clsvar* @new_address_table()
%var2303 = bitcast [44 x i8]* @gsxtmglfw3106 to i8*
%var2304 = bitcast [30 x i8]* @gsxtmglfw3107 to i8*
%addytable2305 = call %clsvar* @add_address_table(%mzone* %zone2297, i8* %var2303, i32 0, i8* %var2304, i32 3, %clsvar* %addytable2302)
%address-table2306 = bitcast %clsvar* %addytable2305 to i8*

; insert table, function and environment into closure struct
%closure.table2309 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure2299, i32 0, i32 0
store i8* %address-table2306, i8** %closure.table2309
%closure.env2310 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure2299, i32 0, i32 1
store i8* %envptr2300, i8** %closure.env2310
%closure.func2311 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure2299, i32 0, i32 2
store i8* (i8*, i8*)* @glfw_create_fullscreen_window_adhoc_W2k4Kl0__2292, i8* (i8*, i8*)** %closure.func2311
%closure_size2312 = call i64 @llvm_zone_mark_size(%mzone* %zone2297)
call void @llvm_zone_ptr_set_size(i8* %clsptr2298, i64 %closure_size2312)
%wrapper_ptr2313 = call i8* @llvm_zone_malloc(%mzone* %zone2297, i64 8)
%closure_wrapper2314 = bitcast i8* %wrapper_ptr2313 to { i8*, i8*, i8* (i8*, i8*)*}**
store { i8*, i8*, i8* (i8*, i8*)*}* %closure2299, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper2314

; let value assignment
%glfw_create_fullscreen_window_adhoc_W2k4Kl0 = select i1 true, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper2314, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper2314
store { i8*, i8*, i8* (i8*, i8*)*}** %glfw_create_fullscreen_window_adhoc_W2k4Kl0, { i8*, i8*, i8* (i8*, i8*)*}*** %glfw_create_fullscreen_window_adhoc_W2k4Kl0Ptr

; add data to environment
; don't need to alloc for env var glfw_create_fullscreen_window_adhoc_W2k4Kl0
%tmp_envptr2308 = getelementptr {{i8*, i8*, i8* (i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*)*}***}* %environment2301, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*)*}*** %glfw_create_fullscreen_window_adhoc_W2k4Kl0Ptr, {i8*, i8*, i8* (i8*, i8*)*}**** %tmp_envptr2308


%val2317 = load {i8*, i8*, i8* (i8*, i8*)*}**, {i8*, i8*, i8* (i8*, i8*)*}*** %glfw_create_fullscreen_window_adhoc_W2k4Kl0Ptr
ret {i8*, i8*, i8* (i8*, i8*)*}** %val2317
}


@glfw_create_fullscreen_window_adhoc_W2k4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_create_fullscreen_window_adhoc_W2k4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_create_fullscreen_window_adhoc_W2k4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*)*}** @glfw_create_fullscreen_window_adhoc_W2k4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_create_fullscreen_window_adhoc_W2k4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_create_fullscreen_window_adhoc_W2k4Kl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
ret i8* %result
}


define dllexport ccc i8* @glfw_create_fullscreen_window_adhoc_W2k4Kl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
ret i8* %result
}


define dllexport ccc i8*  @glfw_create_fullscreen_window_adhoc_W2k4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_create_fullscreen_window_adhoc_W2k4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3108 = hidden constant [61 x i8] c"glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd\00"
@gsxtmglfw3109 = hidden constant [15 x i8] c"_anon_lambda_2\00"
define dllexport fastcc i8* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd__2318(i8* %_impz,i8* %_impenv, i8* %mon) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2327 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}*
%glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpdPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpdPtr = load {i8*, i8*, i8* (i8*, i8*, i8*)*}***, {i8*, i8*, i8* (i8*, i8*, i8*)*}**** %glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpdPtr_
%window_titlePtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 1
%window_titlePtr = load i8**, i8*** %window_titlePtr_
%_anon_lambda_2Ptr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_2Ptr = load {i8*, i8*, i8* (i8*, i8*, i8*)*}***, {i8*, i8*, i8* (i8*, i8*, i8*)*}**** %_anon_lambda_2Ptr_

; setup arguments
%monPtr = alloca i8*
store i8* %mon, i8** %monPtr


%val2328 = load i8*, i8** %window_titlePtr
%var2329 = bitcast [24 x i8]* @gsxtmglfw399 to i8*

%val2330 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2328, i8* %var2329)
%tzone2332 = load i8*, i8** %_impzPtr
%zone2333 = bitcast i8* %tzone2332 to %mzone*

; let assign value to symbol monitor
%monitorPtr = alloca i8*
%tzone2336 = load i8*, i8** %_impzPtr
%zone2337 = bitcast i8* %tzone2336 to %mzone*

; let assign value to symbol vidmode
%vidmodePtr = alloca %GLFWvidmode*
%tzone2341 = load i8*, i8** %_impzPtr
%zone2342 = bitcast i8* %tzone2341 to %mzone*

; let assign value to symbol width
%widthPtr = alloca i32
%tzone2346 = load i8*, i8** %_impzPtr
%zone2347 = bitcast i8* %tzone2346 to %mzone*

; let assign value to symbol height
%heightPtr = alloca i32
%tzone2349 = load i8*, i8** %_impzPtr
%zone2350 = bitcast i8* %tzone2349 to %mzone*

; let assign value to symbol res
%resPtr = alloca i8*
%val2331 = load i8*, i8** %monPtr

; let value assignment
%monitor = select i1 true, i8* %val2331, i8* %val2331
store i8* %monitor, i8** %monitorPtr

%val2334 = load i8*, i8** %monitorPtr
%res2335 = call ccc %GLFWvidmode* @glfwGetVideoMode(i8* %val2334)

; let value assignment
%vidmode = select i1 true, %GLFWvidmode* %res2335, %GLFWvidmode* %res2335
store %GLFWvidmode* %vidmode, %GLFWvidmode** %vidmodePtr

%val2338 = load %GLFWvidmode*, %GLFWvidmode** %vidmodePtr
; tuple ref
%val2339 = getelementptr %GLFWvidmode, %GLFWvidmode* %val2338, i64 0, i32 0
%val2340 = load i32, i32* %val2339

; let value assignment
%width = select i1 true, i32 %val2340, i32 %val2340
store i32 %width, i32* %widthPtr

%val2343 = load %GLFWvidmode*, %GLFWvidmode** %vidmodePtr
; tuple ref
%val2344 = getelementptr %GLFWvidmode, %GLFWvidmode* %val2343, i64 0, i32 1
%val2345 = load i32, i32* %val2344

; let value assignment
%height = select i1 true, i32 %val2345, i32 %val2345
store i32 %height, i32* %heightPtr

%null2348 = bitcast i8* null to i8*

; let value assignment
%res = select i1 true, i8* %null2348, i8* %null2348
store i8* %res, i8** %resPtr

%val2351 = load i32, i32* @GLFW_DECORATED
call ccc void @glfwWindowHint(i32 %val2351, i32 0)
%val2353 = load i32, i32* @GLFW_AUTO_ICONIFY
call ccc void @glfwWindowHint(i32 %val2353, i32 1)
%res2355 = call ccc i32 @register_for_window_events()
; do set!
%val2356 = load i32, i32* %widthPtr
%val2357 = load i32, i32* %heightPtr
%val2358 = load i8*, i8** %window_titlePtr
%val2359 = load i8*, i8** %monitorPtr
%null2360 = bitcast i8* null to i8*
%res2361 = call ccc i8* @glfwCreateWindow(i32 %val2356, i32 %val2357, i8* %val2358, i8* %val2359, i8* %null2360)
store i8* %res2361, i8** %resPtr
%val2362 = load i8*, i8** %resPtr
call ccc void @glfwSetWindowPos(i8* %val2362, i32 0, i32 0)
%val2364 = load i8*, i8** %resPtr
ret i8* %val2364
}
@gsxtmglfw3110 = hidden constant [114 x i8] c"glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i8*)*}** @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2397 = load i8*, i8** %_impzPtr
%zone2398 = bitcast i8* %tzone2397 to %mzone*

; let assign value to symbol glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd
%dat_glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone2398, i64 8)
%glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpdPtr = bitcast i8* %dat_glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd to {i8*, i8*, i8* (i8*, i8*, i8*)*}***
%tzone2325 = load i8*, i8** %_impzPtr
%zone2326 = bitcast i8* %tzone2325 to %mzone*

; let assign value to symbol window_title
%dat_window_title = call i8* @llvm_zone_malloc(%mzone* %zone2326, i64 8)
%window_titlePtr = bitcast i8* %dat_window_title to i8**
%val2319 = getelementptr i64, i64* null, i32 1
%zonesize2320 = mul i64 1, 128
%tzone2321 = load i8*, i8** %_impzPtr
%zone2322 = bitcast i8* %tzone2321 to %mzone*
%dat2323 = call i8* @llvm_zone_malloc(%mzone* %zone2322, i64 %zonesize2320)
call i8* @memset(i8* %dat2323, i32 0, i64 %zonesize2320)
%val2324 = bitcast i8* %dat2323 to i8*

; let value assignment
%window_title = select i1 true, i8* %val2324, i8* %val2324
store i8* %window_title, i8** %window_titlePtr

%tzone2394 = load i8*, i8** %_impzPtr
%zone2395 = bitcast i8* %tzone2394 to %mzone*

; let assign value to symbol _anon_lambda_2
%dat__anon_lambda_2 = call i8* @llvm_zone_malloc(%mzone* %zone2395, i64 8)
%_anon_lambda_2Ptr = bitcast i8* %dat__anon_lambda_2 to { i8*, i8*, i8* (i8*, i8*, i8*)*}***
%tzone2365 = load i8*, i8** %_impzPtr
%zone2366 = bitcast i8* %tzone2365 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2366)
; malloc closure structure
%clsptr2367 = call i8* @llvm_zone_malloc(%mzone* %zone2366, i64 24)
%closure2368 = bitcast i8* %clsptr2367 to { i8*, i8*, i8* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2369 = call i8* @llvm_zone_malloc(%mzone* %zone2366, i64 24)
%environment2370 = bitcast i8* %envptr2369 to {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2371 = call %clsvar* @new_address_table()
%var2372 = bitcast [61 x i8]* @gsxtmglfw3108 to i8*
%var2373 = bitcast [35 x i8]* @gsxtmglfw3101 to i8*
%addytable2374 = call %clsvar* @add_address_table(%mzone* %zone2366, i8* %var2372, i32 0, i8* %var2373, i32 3, %clsvar* %addytable2371)
%var2375 = bitcast [13 x i8]* @gsxtmglfw3102 to i8*
%var2376 = bitcast [4 x i8]* @gsxtmglfw3103 to i8*
%addytable2377 = call %clsvar* @add_address_table(%mzone* %zone2366, i8* %var2375, i32 8, i8* %var2376, i32 3, %clsvar* %addytable2374)
%var2378 = bitcast [15 x i8]* @gsxtmglfw3109 to i8*
%var2379 = bitcast [35 x i8]* @gsxtmglfw3101 to i8*
%addytable2380 = call %clsvar* @add_address_table(%mzone* %zone2366, i8* %var2378, i32 16, i8* %var2379, i32 3, %clsvar* %addytable2377)
%address-table2381 = bitcast %clsvar* %addytable2380 to i8*

; insert table, function and environment into closure struct
%closure.table2388 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure2368, i32 0, i32 0
store i8* %address-table2381, i8** %closure.table2388
%closure.env2389 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure2368, i32 0, i32 1
store i8* %envptr2369, i8** %closure.env2389
%closure.func2390 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure2368, i32 0, i32 2
store i8* (i8*, i8*, i8*)* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd__2318, i8* (i8*, i8*, i8*)** %closure.func2390
%closure_size2391 = call i64 @llvm_zone_mark_size(%mzone* %zone2366)
call void @llvm_zone_ptr_set_size(i8* %clsptr2367, i64 %closure_size2391)
%wrapper_ptr2392 = call i8* @llvm_zone_malloc(%mzone* %zone2366, i64 8)
%closure_wrapper2393 = bitcast i8* %wrapper_ptr2392 to { i8*, i8*, i8* (i8*, i8*, i8*)*}**
store { i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure2368, { i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_wrapper2393

; let value assignment
%_anon_lambda_2 = select i1 true, { i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_wrapper2393, { i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_wrapper2393
store { i8*, i8*, i8* (i8*, i8*, i8*)*}** %_anon_lambda_2, { i8*, i8*, i8* (i8*, i8*, i8*)*}*** %_anon_lambda_2Ptr

; add data to environment
; don't need to alloc for env var glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd
%tmp_envptr2383 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}* %environment2370, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i8*)*}*** %glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpdPtr, {i8*, i8*, i8* (i8*, i8*, i8*)*}**** %tmp_envptr2383

; don't need to alloc for env var window_title
%tmp_envptr2385 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}* %environment2370, i32 0, i32 1
store i8** %window_titlePtr, i8*** %tmp_envptr2385

; don't need to alloc for env var _anon_lambda_2
%tmp_envptr2387 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i8*)*}***}* %environment2370, i32 0, i32 2
store {i8*, i8*, i8* (i8*, i8*, i8*)*}*** %_anon_lambda_2Ptr, {i8*, i8*, i8* (i8*, i8*, i8*)*}**** %tmp_envptr2387


%val2396 = load {i8*, i8*, i8* (i8*, i8*, i8*)*}**, {i8*, i8*, i8* (i8*, i8*, i8*)*}*** %_anon_lambda_2Ptr

; let value assignment
%glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd = select i1 true, {i8*, i8*, i8* (i8*, i8*, i8*)*}** %val2396, {i8*, i8*, i8* (i8*, i8*, i8*)*}** %val2396
store {i8*, i8*, i8* (i8*, i8*, i8*)*}** %glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd, {i8*, i8*, i8* (i8*, i8*, i8*)*}*** %glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpdPtr

%val2399 = load {i8*, i8*, i8* (i8*, i8*, i8*)*}**, {i8*, i8*, i8* (i8*, i8*, i8*)*}*** %glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpdPtr
ret {i8*, i8*, i8* (i8*, i8*, i8*)*}** %val2399
}


@glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i8*)*}** @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*)*,  i8* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i8* %result
}


define dllexport ccc i8* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*)*,  i8* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2400 = bitcast [114 x i8]* @gsxtmglfw3110 to i8*
call i32 (i8*, ...) @printf(i8* %var2400)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*)*,  i8* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*)*,  i8* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3111 = hidden constant [56 x i8] c"glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0\00"
define dllexport fastcc i8* @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0__2401(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2402 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*)*}***}*
%glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr = load {i8*, i8*, i8* (i8*, i8*)*}***, {i8*, i8*, i8* (i8*, i8*)*}**** %glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr_

; setup arguments


%res2403 = call ccc i8* @glfwGetPrimaryMonitor()
%res2404 = call fastcc i8* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd(i8* %res2403)
ret i8* %res2404
}
define dllexport ccc {i8*, i8*, i8* (i8*, i8*)*}** @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2424 = load i8*, i8** %_impzPtr
%zone2425 = bitcast i8* %tzone2424 to %mzone*

; let assign value to symbol glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0
%dat_glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone2425, i64 8)
%glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr = bitcast i8* %dat_glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0 to { i8*, i8*, i8* (i8*, i8*)*}***
%tzone2405 = load i8*, i8** %_impzPtr
%zone2406 = bitcast i8* %tzone2405 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2406)
; malloc closure structure
%clsptr2407 = call i8* @llvm_zone_malloc(%mzone* %zone2406, i64 24)
%closure2408 = bitcast i8* %clsptr2407 to { i8*, i8*, i8* (i8*, i8*)*}*

; malloc environment structure
%envptr2409 = call i8* @llvm_zone_malloc(%mzone* %zone2406, i64 8)
%environment2410 = bitcast i8* %envptr2409 to {{i8*, i8*, i8* (i8*, i8*)*}***}*

; malloc closure address table
%addytable2411 = call %clsvar* @new_address_table()
%var2412 = bitcast [56 x i8]* @gsxtmglfw3111 to i8*
%var2413 = bitcast [30 x i8]* @gsxtmglfw3107 to i8*
%addytable2414 = call %clsvar* @add_address_table(%mzone* %zone2406, i8* %var2412, i32 0, i8* %var2413, i32 3, %clsvar* %addytable2411)
%address-table2415 = bitcast %clsvar* %addytable2414 to i8*

; insert table, function and environment into closure struct
%closure.table2418 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure2408, i32 0, i32 0
store i8* %address-table2415, i8** %closure.table2418
%closure.env2419 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure2408, i32 0, i32 1
store i8* %envptr2409, i8** %closure.env2419
%closure.func2420 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure2408, i32 0, i32 2
store i8* (i8*, i8*)* @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0__2401, i8* (i8*, i8*)** %closure.func2420
%closure_size2421 = call i64 @llvm_zone_mark_size(%mzone* %zone2406)
call void @llvm_zone_ptr_set_size(i8* %clsptr2407, i64 %closure_size2421)
%wrapper_ptr2422 = call i8* @llvm_zone_malloc(%mzone* %zone2406, i64 8)
%closure_wrapper2423 = bitcast i8* %wrapper_ptr2422 to { i8*, i8*, i8* (i8*, i8*)*}**
store { i8*, i8*, i8* (i8*, i8*)*}* %closure2408, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper2423

; let value assignment
%glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0 = select i1 true, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper2423, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper2423
store { i8*, i8*, i8* (i8*, i8*)*}** %glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0, { i8*, i8*, i8* (i8*, i8*)*}*** %glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr

; add data to environment
; don't need to alloc for env var glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0
%tmp_envptr2417 = getelementptr {{i8*, i8*, i8* (i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*)*}***}* %environment2410, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*)*}*** %glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr, {i8*, i8*, i8* (i8*, i8*)*}**** %tmp_envptr2417


%val2426 = load {i8*, i8*, i8* (i8*, i8*)*}**, {i8*, i8*, i8* (i8*, i8*)*}*** %glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr
ret {i8*, i8*, i8* (i8*, i8*)*}** %val2426
}


@glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*)*}** @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
ret i8* %result
}


define dllexport ccc i8* @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
ret i8* %result
}


define dllexport ccc i8*  @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3112 = hidden constant [44 x i8] c"glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ\00"
@gsxtmglfw3113 = hidden constant [40 x i8] c"{i8*, i8*, i8* (i8*, i8*, i32, i32)*}**\00"
@gsxtmglfw3114 = hidden constant [15 x i8] c"_anon_lambda_3\00"
define dllexport fastcc i8* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ__2427(i8* %_impz,i8* %_impenv, i32 %width, i32 %height) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2436 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}*
%glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr_
%window_titlePtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 1
%window_titlePtr = load i8**, i8*** %window_titlePtr_
%_anon_lambda_3Ptr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_3Ptr = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %_anon_lambda_3Ptr_

; setup arguments
%widthPtr = alloca i32
store i32 %width, i32* %widthPtr
%heightPtr = alloca i32
store i32 %height, i32* %heightPtr


%val2437 = load i8*, i8** %window_titlePtr
%var2438 = bitcast [24 x i8]* @gsxtmglfw399 to i8*

%val2439 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2437, i8* %var2438)
%val2440 = load i32, i32* %widthPtr
%val2441 = load i32, i32* %heightPtr
%val2442 = load i8*, i8** %window_titlePtr
%null2443 = bitcast i8* null to i8*
%null2444 = bitcast i8* null to i8*
%res2445 = call ccc i8* @glfwCreateWindow(i32 %val2440, i32 %val2441, i8* %val2442, i8* %null2443, i8* %null2444)
ret i8* %res2445
}
@gsxtmglfw3115 = hidden constant [97 x i8] c"glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2478 = load i8*, i8** %_impzPtr
%zone2479 = bitcast i8* %tzone2478 to %mzone*

; let assign value to symbol glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ
%dat_glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone2479, i64 8)
%glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr = bitcast i8* %dat_glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***
%tzone2434 = load i8*, i8** %_impzPtr
%zone2435 = bitcast i8* %tzone2434 to %mzone*

; let assign value to symbol window_title
%dat_window_title = call i8* @llvm_zone_malloc(%mzone* %zone2435, i64 8)
%window_titlePtr = bitcast i8* %dat_window_title to i8**
%val2428 = getelementptr i64, i64* null, i32 1
%zonesize2429 = mul i64 1, 128
%tzone2430 = load i8*, i8** %_impzPtr
%zone2431 = bitcast i8* %tzone2430 to %mzone*
%dat2432 = call i8* @llvm_zone_malloc(%mzone* %zone2431, i64 %zonesize2429)
call i8* @memset(i8* %dat2432, i32 0, i64 %zonesize2429)
%val2433 = bitcast i8* %dat2432 to i8*

; let value assignment
%window_title = select i1 true, i8* %val2433, i8* %val2433
store i8* %window_title, i8** %window_titlePtr

%tzone2475 = load i8*, i8** %_impzPtr
%zone2476 = bitcast i8* %tzone2475 to %mzone*

; let assign value to symbol _anon_lambda_3
%dat__anon_lambda_3 = call i8* @llvm_zone_malloc(%mzone* %zone2476, i64 8)
%_anon_lambda_3Ptr = bitcast i8* %dat__anon_lambda_3 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}***
%tzone2446 = load i8*, i8** %_impzPtr
%zone2447 = bitcast i8* %tzone2446 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2447)
; malloc closure structure
%clsptr2448 = call i8* @llvm_zone_malloc(%mzone* %zone2447, i64 24)
%closure2449 = bitcast i8* %clsptr2448 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr2450 = call i8* @llvm_zone_malloc(%mzone* %zone2447, i64 24)
%environment2451 = bitcast i8* %envptr2450 to {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable2452 = call %clsvar* @new_address_table()
%var2453 = bitcast [44 x i8]* @gsxtmglfw3112 to i8*
%var2454 = bitcast [40 x i8]* @gsxtmglfw3113 to i8*
%addytable2455 = call %clsvar* @add_address_table(%mzone* %zone2447, i8* %var2453, i32 0, i8* %var2454, i32 3, %clsvar* %addytable2452)
%var2456 = bitcast [13 x i8]* @gsxtmglfw3102 to i8*
%var2457 = bitcast [4 x i8]* @gsxtmglfw3103 to i8*
%addytable2458 = call %clsvar* @add_address_table(%mzone* %zone2447, i8* %var2456, i32 8, i8* %var2457, i32 3, %clsvar* %addytable2455)
%var2459 = bitcast [15 x i8]* @gsxtmglfw3114 to i8*
%var2460 = bitcast [40 x i8]* @gsxtmglfw3113 to i8*
%addytable2461 = call %clsvar* @add_address_table(%mzone* %zone2447, i8* %var2459, i32 16, i8* %var2460, i32 3, %clsvar* %addytable2458)
%address-table2462 = bitcast %clsvar* %addytable2461 to i8*

; insert table, function and environment into closure struct
%closure.table2469 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure2449, i32 0, i32 0
store i8* %address-table2462, i8** %closure.table2469
%closure.env2470 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure2449, i32 0, i32 1
store i8* %envptr2450, i8** %closure.env2470
%closure.func2471 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure2449, i32 0, i32 2
store i8* (i8*, i8*, i32, i32)* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ__2427, i8* (i8*, i8*, i32, i32)** %closure.func2471
%closure_size2472 = call i64 @llvm_zone_mark_size(%mzone* %zone2447)
call void @llvm_zone_ptr_set_size(i8* %clsptr2448, i64 %closure_size2472)
%wrapper_ptr2473 = call i8* @llvm_zone_malloc(%mzone* %zone2447, i64 8)
%closure_wrapper2474 = bitcast i8* %wrapper_ptr2473 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure2449, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper2474

; let value assignment
%_anon_lambda_3 = select i1 true, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper2474, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper2474
store { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %_anon_lambda_3, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %_anon_lambda_3Ptr

; add data to environment
; don't need to alloc for env var glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ
%tmp_envptr2464 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %environment2451, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %tmp_envptr2464

; don't need to alloc for env var window_title
%tmp_envptr2466 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %environment2451, i32 0, i32 1
store i8** %window_titlePtr, i8*** %tmp_envptr2466

; don't need to alloc for env var _anon_lambda_3
%tmp_envptr2468 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %environment2451, i32 0, i32 2
store {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %_anon_lambda_3Ptr, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %tmp_envptr2468


%val2477 = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %_anon_lambda_3Ptr

; let value assignment
%glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ = select i1 true, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %val2477, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %val2477
store {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr

%val2480 = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr
ret {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %val2480
}


@glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i8* %result
}


define dllexport ccc i8* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i8* %result
}


define dllexport ccc i8*  @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2481 = bitcast [97 x i8]* @gsxtmglfw3115 to i8*
call i32 (i8*, ...) @printf(i8* %var2481)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2482 = bitcast [97 x i8]* @gsxtmglfw3115 to i8*
call i32 (i8*, ...) @printf(i8* %var2482)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3116 = hidden constant [56 x i8] c"glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ\00"
@gsxtmglfw3117 = hidden constant [15 x i8] c"_anon_lambda_4\00"
define dllexport fastcc i8* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ__2483(i8* %_impz,i8* %_impenv, i32 %width, i32 %height) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2492 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}*
%glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr_
%window_titlePtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 1
%window_titlePtr = load i8**, i8*** %window_titlePtr_
%_anon_lambda_4Ptr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_4Ptr = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %_anon_lambda_4Ptr_

; setup arguments
%widthPtr = alloca i32
store i32 %width, i32* %widthPtr
%heightPtr = alloca i32
store i32 %height, i32* %heightPtr


%val2493 = load i8*, i8** %window_titlePtr
%var2494 = bitcast [24 x i8]* @gsxtmglfw399 to i8*

%val2495 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2493, i8* %var2494)
%res2496 = call ccc i32 @register_for_window_events()
%val2497 = load i32, i32* %widthPtr
%val2498 = load i32, i32* %heightPtr
%val2499 = load i8*, i8** %window_titlePtr
%null2500 = bitcast i8* null to i8*
%null2501 = bitcast i8* null to i8*
%res2502 = call ccc i8* @glfwCreateWindow(i32 %val2497, i32 %val2498, i8* %val2499, i8* %null2500, i8* %null2501)
ret i8* %res2502
}
@gsxtmglfw3118 = hidden constant [109 x i8] c"glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2535 = load i8*, i8** %_impzPtr
%zone2536 = bitcast i8* %tzone2535 to %mzone*

; let assign value to symbol glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ
%dat_glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone2536, i64 8)
%glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr = bitcast i8* %dat_glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***
%tzone2490 = load i8*, i8** %_impzPtr
%zone2491 = bitcast i8* %tzone2490 to %mzone*

; let assign value to symbol window_title
%dat_window_title = call i8* @llvm_zone_malloc(%mzone* %zone2491, i64 8)
%window_titlePtr = bitcast i8* %dat_window_title to i8**
%val2484 = getelementptr i64, i64* null, i32 1
%zonesize2485 = mul i64 1, 128
%tzone2486 = load i8*, i8** %_impzPtr
%zone2487 = bitcast i8* %tzone2486 to %mzone*
%dat2488 = call i8* @llvm_zone_malloc(%mzone* %zone2487, i64 %zonesize2485)
call i8* @memset(i8* %dat2488, i32 0, i64 %zonesize2485)
%val2489 = bitcast i8* %dat2488 to i8*

; let value assignment
%window_title = select i1 true, i8* %val2489, i8* %val2489
store i8* %window_title, i8** %window_titlePtr

%tzone2532 = load i8*, i8** %_impzPtr
%zone2533 = bitcast i8* %tzone2532 to %mzone*

; let assign value to symbol _anon_lambda_4
%dat__anon_lambda_4 = call i8* @llvm_zone_malloc(%mzone* %zone2533, i64 8)
%_anon_lambda_4Ptr = bitcast i8* %dat__anon_lambda_4 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}***
%tzone2503 = load i8*, i8** %_impzPtr
%zone2504 = bitcast i8* %tzone2503 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2504)
; malloc closure structure
%clsptr2505 = call i8* @llvm_zone_malloc(%mzone* %zone2504, i64 24)
%closure2506 = bitcast i8* %clsptr2505 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr2507 = call i8* @llvm_zone_malloc(%mzone* %zone2504, i64 24)
%environment2508 = bitcast i8* %envptr2507 to {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable2509 = call %clsvar* @new_address_table()
%var2510 = bitcast [56 x i8]* @gsxtmglfw3116 to i8*
%var2511 = bitcast [40 x i8]* @gsxtmglfw3113 to i8*
%addytable2512 = call %clsvar* @add_address_table(%mzone* %zone2504, i8* %var2510, i32 0, i8* %var2511, i32 3, %clsvar* %addytable2509)
%var2513 = bitcast [13 x i8]* @gsxtmglfw3102 to i8*
%var2514 = bitcast [4 x i8]* @gsxtmglfw3103 to i8*
%addytable2515 = call %clsvar* @add_address_table(%mzone* %zone2504, i8* %var2513, i32 8, i8* %var2514, i32 3, %clsvar* %addytable2512)
%var2516 = bitcast [15 x i8]* @gsxtmglfw3117 to i8*
%var2517 = bitcast [40 x i8]* @gsxtmglfw3113 to i8*
%addytable2518 = call %clsvar* @add_address_table(%mzone* %zone2504, i8* %var2516, i32 16, i8* %var2517, i32 3, %clsvar* %addytable2515)
%address-table2519 = bitcast %clsvar* %addytable2518 to i8*

; insert table, function and environment into closure struct
%closure.table2526 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure2506, i32 0, i32 0
store i8* %address-table2519, i8** %closure.table2526
%closure.env2527 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure2506, i32 0, i32 1
store i8* %envptr2507, i8** %closure.env2527
%closure.func2528 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure2506, i32 0, i32 2
store i8* (i8*, i8*, i32, i32)* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ__2483, i8* (i8*, i8*, i32, i32)** %closure.func2528
%closure_size2529 = call i64 @llvm_zone_mark_size(%mzone* %zone2504)
call void @llvm_zone_ptr_set_size(i8* %clsptr2505, i64 %closure_size2529)
%wrapper_ptr2530 = call i8* @llvm_zone_malloc(%mzone* %zone2504, i64 8)
%closure_wrapper2531 = bitcast i8* %wrapper_ptr2530 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure2506, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper2531

; let value assignment
%_anon_lambda_4 = select i1 true, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper2531, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper2531
store { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %_anon_lambda_4, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %_anon_lambda_4Ptr

; add data to environment
; don't need to alloc for env var glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ
%tmp_envptr2521 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %environment2508, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %tmp_envptr2521

; don't need to alloc for env var window_title
%tmp_envptr2523 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %environment2508, i32 0, i32 1
store i8** %window_titlePtr, i8*** %tmp_envptr2523

; don't need to alloc for env var _anon_lambda_4
%tmp_envptr2525 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, i8**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %environment2508, i32 0, i32 2
store {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %_anon_lambda_4Ptr, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %tmp_envptr2525


%val2534 = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %_anon_lambda_4Ptr

; let value assignment
%glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ = select i1 true, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %val2534, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %val2534
store {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr

%val2537 = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr
ret {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %val2537
}


@glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i8* %result
}


define dllexport ccc i8* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i8* %result
}


define dllexport ccc i8*  @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2538 = bitcast [109 x i8]* @gsxtmglfw3118 to i8*
call i32 (i8*, ...) @printf(i8* %var2538)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2539 = bitcast [109 x i8]* @gsxtmglfw3118 to i8*
call i32 (i8*, ...) @printf(i8* %var2539)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3119 = hidden constant [44 x i8] c"glfw_window_should_close_adhoc_W2kzMixpOCpd\00"
@gsxtmglfw3120 = hidden constant [35 x i8] c"{i8*, i8*, i32 (i8*, i8*, i8*)*}**\00"
define dllexport fastcc i32 @glfw_window_should_close_adhoc_W2kzMixpOCpd__2540(i8* %_impz,i8* %_impenv, i8* %window) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2541 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}*
%glfw_window_should_close_adhoc_W2kzMixpOCpdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_window_should_close_adhoc_W2kzMixpOCpdPtr = load {i8*, i8*, i32 (i8*, i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %glfw_window_should_close_adhoc_W2kzMixpOCpdPtr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr


%val2542 = load i8*, i8** %windowPtr
%res2543 = call ccc i32 @glfwWindowShouldClose(i8* %val2542)
ret i32 %res2543
}
@gsxtmglfw3121 = hidden constant [97 x i8] c"glfw_window_should_close_adhoc_W2kzMixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i8*)*}** @glfw_window_should_close_adhoc_W2kzMixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2563 = load i8*, i8** %_impzPtr
%zone2564 = bitcast i8* %tzone2563 to %mzone*

; let assign value to symbol glfw_window_should_close_adhoc_W2kzMixpOCpd
%dat_glfw_window_should_close_adhoc_W2kzMixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone2564, i64 8)
%glfw_window_should_close_adhoc_W2kzMixpOCpdPtr = bitcast i8* %dat_glfw_window_should_close_adhoc_W2kzMixpOCpd to { i8*, i8*, i32 (i8*, i8*, i8*)*}***
%tzone2544 = load i8*, i8** %_impzPtr
%zone2545 = bitcast i8* %tzone2544 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2545)
; malloc closure structure
%clsptr2546 = call i8* @llvm_zone_malloc(%mzone* %zone2545, i64 24)
%closure2547 = bitcast i8* %clsptr2546 to { i8*, i8*, i32 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2548 = call i8* @llvm_zone_malloc(%mzone* %zone2545, i64 8)
%environment2549 = bitcast i8* %envptr2548 to {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2550 = call %clsvar* @new_address_table()
%var2551 = bitcast [44 x i8]* @gsxtmglfw3119 to i8*
%var2552 = bitcast [35 x i8]* @gsxtmglfw3120 to i8*
%addytable2553 = call %clsvar* @add_address_table(%mzone* %zone2545, i8* %var2551, i32 0, i8* %var2552, i32 3, %clsvar* %addytable2550)
%address-table2554 = bitcast %clsvar* %addytable2553 to i8*

; insert table, function and environment into closure struct
%closure.table2557 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure2547, i32 0, i32 0
store i8* %address-table2554, i8** %closure.table2557
%closure.env2558 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure2547, i32 0, i32 1
store i8* %envptr2548, i8** %closure.env2558
%closure.func2559 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure2547, i32 0, i32 2
store i32 (i8*, i8*, i8*)* @glfw_window_should_close_adhoc_W2kzMixpOCpd__2540, i32 (i8*, i8*, i8*)** %closure.func2559
%closure_size2560 = call i64 @llvm_zone_mark_size(%mzone* %zone2545)
call void @llvm_zone_ptr_set_size(i8* %clsptr2546, i64 %closure_size2560)
%wrapper_ptr2561 = call i8* @llvm_zone_malloc(%mzone* %zone2545, i64 8)
%closure_wrapper2562 = bitcast i8* %wrapper_ptr2561 to { i8*, i8*, i32 (i8*, i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure2547, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper2562

; let value assignment
%glfw_window_should_close_adhoc_W2kzMixpOCpd = select i1 true, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper2562, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper2562
store { i8*, i8*, i32 (i8*, i8*, i8*)*}** %glfw_window_should_close_adhoc_W2kzMixpOCpd, { i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_window_should_close_adhoc_W2kzMixpOCpdPtr

; add data to environment
; don't need to alloc for env var glfw_window_should_close_adhoc_W2kzMixpOCpd
%tmp_envptr2556 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}* %environment2549, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_window_should_close_adhoc_W2kzMixpOCpdPtr, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %tmp_envptr2556


%val2565 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_window_should_close_adhoc_W2kzMixpOCpdPtr
ret {i8*, i8*, i32 (i8*, i8*, i8*)*}** %val2565
}


@glfw_window_should_close_adhoc_W2kzMixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_window_should_close_adhoc_W2kzMixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_window_should_close_adhoc_W2kzMixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_should_close_adhoc_W2kzMixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i8*)*}** @glfw_window_should_close_adhoc_W2kzMixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_window_should_close_adhoc_W2kzMixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_window_should_close_adhoc_W2kzMixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_should_close_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @glfw_window_should_close_adhoc_W2kzMixpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_should_close_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @glfw_window_should_close_adhoc_W2kzMixpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_should_close_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @glfw_window_should_close_adhoc_W2kzMixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2566 = bitcast [97 x i8]* @gsxtmglfw3121 to i8*
call i32 (i8*, ...) @printf(i8* %var2566)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_should_close_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @glfw_window_should_close_adhoc_W2kzMixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_should_close_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3122 = hidden constant [47 x i8] c"glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ\00"
@gsxtmglfw3123 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i8*)*}**\00"
define dllexport fastcc void @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ__2567(i8* %_impz,i8* %_impenv, i8* %window) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2568 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*
%glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQPtr = load {i8*, i8*, void (i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*)*}**** %glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQPtr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr


%val2569 = load i8*, i8** %windowPtr
call ccc void @glfwMakeContextCurrent(i8* %val2569)
ret void
}
@gsxtmglfw3124 = hidden constant [100 x i8] c"glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2590 = load i8*, i8** %_impzPtr
%zone2591 = bitcast i8* %tzone2590 to %mzone*

; let assign value to symbol glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ
%dat_glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2591, i64 8)
%glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQPtr = bitcast i8* %dat_glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ to { i8*, i8*, void (i8*, i8*, i8*)*}***
%tzone2571 = load i8*, i8** %_impzPtr
%zone2572 = bitcast i8* %tzone2571 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2572)
; malloc closure structure
%clsptr2573 = call i8* @llvm_zone_malloc(%mzone* %zone2572, i64 24)
%closure2574 = bitcast i8* %clsptr2573 to { i8*, i8*, void (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2575 = call i8* @llvm_zone_malloc(%mzone* %zone2572, i64 8)
%environment2576 = bitcast i8* %envptr2575 to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2577 = call %clsvar* @new_address_table()
%var2578 = bitcast [47 x i8]* @gsxtmglfw3122 to i8*
%var2579 = bitcast [36 x i8]* @gsxtmglfw3123 to i8*
%addytable2580 = call %clsvar* @add_address_table(%mzone* %zone2572, i8* %var2578, i32 0, i8* %var2579, i32 3, %clsvar* %addytable2577)
%address-table2581 = bitcast %clsvar* %addytable2580 to i8*

; insert table, function and environment into closure struct
%closure.table2584 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2574, i32 0, i32 0
store i8* %address-table2581, i8** %closure.table2584
%closure.env2585 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2574, i32 0, i32 1
store i8* %envptr2575, i8** %closure.env2585
%closure.func2586 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2574, i32 0, i32 2
store void (i8*, i8*, i8*)* @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ__2567, void (i8*, i8*, i8*)** %closure.func2586
%closure_size2587 = call i64 @llvm_zone_mark_size(%mzone* %zone2572)
call void @llvm_zone_ptr_set_size(i8* %clsptr2573, i64 %closure_size2587)
%wrapper_ptr2588 = call i8* @llvm_zone_malloc(%mzone* %zone2572, i64 8)
%closure_wrapper2589 = bitcast i8* %wrapper_ptr2588 to { i8*, i8*, void (i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2574, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2589

; let value assignment
%glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2589, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2589
store { i8*, i8*, void (i8*, i8*, i8*)*}** %glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ, { i8*, i8*, void (i8*, i8*, i8*)*}*** %glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ
%tmp_envptr2583 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %environment2576, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*)*}*** %glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQPtr, {i8*, i8*, void (i8*, i8*, i8*)*}**** %tmp_envptr2583


%val2592 = load {i8*, i8*, void (i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*)*}*** %glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQPtr
ret {i8*, i8*, void (i8*, i8*, i8*)*}** %val2592
}


@glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc void @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc i8*  @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2593 = bitcast [100 x i8]* @gsxtmglfw3124 to i8*
call i32 (i8*, ...) @printf(i8* %var2593)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_make_context_current_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3125 = hidden constant [32 x i8] c"Error: Window pointer is NULL.
\00"
@gsxtmglfw3126 = hidden constant [41 x i8] c"glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ\00"
define dllexport fastcc void @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ__2594(i8* %_impz,i8* %_impenv, i8* %window) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2595 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*
%glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQPtr = load {i8*, i8*, void (i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*)*}**** %glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQPtr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr

; promote local stack var allocations
%tzone2609 = load i8*, i8** %_impzPtr
%zone2610 = bitcast i8* %tzone2609 to %mzone*
%ifptr2597 = alloca i1

%val2598 = load i8*, i8** %windowPtr
%val2599 = icmp eq i8* %val2598, null
br i1 %val2599, label %then2597, label %else2597

then2597:
%res2600 = call ccc i1 @impc_false()
store i1 %res2600, i1* %ifptr2597
br label %ifcont2597

else2597:
%res2601 = call ccc i1 @impc_true()
store i1 %res2601, i1* %ifptr2597
br label %ifcont2597

ifcont2597:
%ifres2602 = load i1, i1* %ifptr2597

br i1 %ifres2602, label %then2596, label %else2596

then2596:
%val2603 = load i8*, i8** %windowPtr
call ccc void @glfwDestroyWindow(i8* %val2603)
br label %ifcont2596

else2596:
%var2605 = bitcast [32 x i8]* @gsxtmglfw3125 to i8*

%val2606 = call i32 (i8*, ...) @printf(i8* %var2605)
br label %ifcont2596

ifcont2596:
ret void
}
@gsxtmglfw3127 = hidden constant [94 x i8] c"glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2630 = load i8*, i8** %_impzPtr
%zone2631 = bitcast i8* %tzone2630 to %mzone*

; let assign value to symbol glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ
%dat_glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2631, i64 8)
%glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQPtr = bitcast i8* %dat_glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ to { i8*, i8*, void (i8*, i8*, i8*)*}***
%tzone2611 = load i8*, i8** %_impzPtr
%zone2612 = bitcast i8* %tzone2611 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2612)
; malloc closure structure
%clsptr2613 = call i8* @llvm_zone_malloc(%mzone* %zone2612, i64 24)
%closure2614 = bitcast i8* %clsptr2613 to { i8*, i8*, void (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2615 = call i8* @llvm_zone_malloc(%mzone* %zone2612, i64 8)
%environment2616 = bitcast i8* %envptr2615 to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2617 = call %clsvar* @new_address_table()
%var2618 = bitcast [41 x i8]* @gsxtmglfw3126 to i8*
%var2619 = bitcast [36 x i8]* @gsxtmglfw3123 to i8*
%addytable2620 = call %clsvar* @add_address_table(%mzone* %zone2612, i8* %var2618, i32 0, i8* %var2619, i32 3, %clsvar* %addytable2617)
%address-table2621 = bitcast %clsvar* %addytable2620 to i8*

; insert table, function and environment into closure struct
%closure.table2624 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2614, i32 0, i32 0
store i8* %address-table2621, i8** %closure.table2624
%closure.env2625 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2614, i32 0, i32 1
store i8* %envptr2615, i8** %closure.env2625
%closure.func2626 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2614, i32 0, i32 2
store void (i8*, i8*, i8*)* @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ__2594, void (i8*, i8*, i8*)** %closure.func2626
%closure_size2627 = call i64 @llvm_zone_mark_size(%mzone* %zone2612)
call void @llvm_zone_ptr_set_size(i8* %clsptr2613, i64 %closure_size2627)
%wrapper_ptr2628 = call i8* @llvm_zone_malloc(%mzone* %zone2612, i64 8)
%closure_wrapper2629 = bitcast i8* %wrapper_ptr2628 to { i8*, i8*, void (i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2614, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2629

; let value assignment
%glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2629, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2629
store { i8*, i8*, void (i8*, i8*, i8*)*}** %glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ, { i8*, i8*, void (i8*, i8*, i8*)*}*** %glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ
%tmp_envptr2623 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %environment2616, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*)*}*** %glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQPtr, {i8*, i8*, void (i8*, i8*, i8*)*}**** %tmp_envptr2623


%val2632 = load {i8*, i8*, void (i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*)*}*** %glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQPtr
ret {i8*, i8*, void (i8*, i8*, i8*)*}** %val2632
}


@glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc void @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc i8*  @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2633 = bitcast [94 x i8]* @gsxtmglfw3127 to i8*
call i32 (i8*, ...) @printf(i8* %var2633)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_destroy_window_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3128 = hidden constant [39 x i8] c"glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ\00"
define dllexport fastcc void @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ__2634(i8* %_impz,i8* %_impenv, i8* %window) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2635 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*
%glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQPtr = load {i8*, i8*, void (i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*)*}**** %glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQPtr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr


%val2636 = load i8*, i8** %windowPtr
call ccc void @glfwSwapBuffers(i8* %val2636)
ret void
}
@gsxtmglfw3129 = hidden constant [92 x i8] c"glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2657 = load i8*, i8** %_impzPtr
%zone2658 = bitcast i8* %tzone2657 to %mzone*

; let assign value to symbol glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ
%dat_glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2658, i64 8)
%glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQPtr = bitcast i8* %dat_glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ to { i8*, i8*, void (i8*, i8*, i8*)*}***
%tzone2638 = load i8*, i8** %_impzPtr
%zone2639 = bitcast i8* %tzone2638 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2639)
; malloc closure structure
%clsptr2640 = call i8* @llvm_zone_malloc(%mzone* %zone2639, i64 24)
%closure2641 = bitcast i8* %clsptr2640 to { i8*, i8*, void (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr2642 = call i8* @llvm_zone_malloc(%mzone* %zone2639, i64 8)
%environment2643 = bitcast i8* %envptr2642 to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable2644 = call %clsvar* @new_address_table()
%var2645 = bitcast [39 x i8]* @gsxtmglfw3128 to i8*
%var2646 = bitcast [36 x i8]* @gsxtmglfw3123 to i8*
%addytable2647 = call %clsvar* @add_address_table(%mzone* %zone2639, i8* %var2645, i32 0, i8* %var2646, i32 3, %clsvar* %addytable2644)
%address-table2648 = bitcast %clsvar* %addytable2647 to i8*

; insert table, function and environment into closure struct
%closure.table2651 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2641, i32 0, i32 0
store i8* %address-table2648, i8** %closure.table2651
%closure.env2652 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2641, i32 0, i32 1
store i8* %envptr2642, i8** %closure.env2652
%closure.func2653 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2641, i32 0, i32 2
store void (i8*, i8*, i8*)* @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ__2634, void (i8*, i8*, i8*)** %closure.func2653
%closure_size2654 = call i64 @llvm_zone_mark_size(%mzone* %zone2639)
call void @llvm_zone_ptr_set_size(i8* %clsptr2640, i64 %closure_size2654)
%wrapper_ptr2655 = call i8* @llvm_zone_malloc(%mzone* %zone2639, i64 8)
%closure_wrapper2656 = bitcast i8* %wrapper_ptr2655 to { i8*, i8*, void (i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*)*}* %closure2641, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2656

; let value assignment
%glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2656, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper2656
store { i8*, i8*, void (i8*, i8*, i8*)*}** %glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ, { i8*, i8*, void (i8*, i8*, i8*)*}*** %glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ
%tmp_envptr2650 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %environment2643, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*)*}*** %glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQPtr, {i8*, i8*, void (i8*, i8*, i8*)*}**** %tmp_envptr2650


%val2659 = load {i8*, i8*, void (i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*)*}*** %glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQPtr
ret {i8*, i8*, void (i8*, i8*, i8*)*}** %val2659
}


@glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc void @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc i8*  @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2660 = bitcast [92 x i8]* @gsxtmglfw3129 to i8*
call i32 (i8*, ...) @printf(i8* %var2660)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_swap_buffers_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3130 = hidden constant [32 x i8] c"glfw_poll_events_adhoc_W3ZvaWRd\00"
define dllexport fastcc void @glfw_poll_events_adhoc_W3ZvaWRd__2661(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2662 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%glfw_poll_events_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_poll_events_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %glfw_poll_events_adhoc_W3ZvaWRdPtr_

; setup arguments


call ccc void @glfwPollEvents()
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @glfw_poll_events_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2683 = load i8*, i8** %_impzPtr
%zone2684 = bitcast i8* %tzone2683 to %mzone*

; let assign value to symbol glfw_poll_events_adhoc_W3ZvaWRd
%dat_glfw_poll_events_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone2684, i64 8)
%glfw_poll_events_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_glfw_poll_events_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone2664 = load i8*, i8** %_impzPtr
%zone2665 = bitcast i8* %tzone2664 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2665)
; malloc closure structure
%clsptr2666 = call i8* @llvm_zone_malloc(%mzone* %zone2665, i64 24)
%closure2667 = bitcast i8* %clsptr2666 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr2668 = call i8* @llvm_zone_malloc(%mzone* %zone2665, i64 8)
%environment2669 = bitcast i8* %envptr2668 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable2670 = call %clsvar* @new_address_table()
%var2671 = bitcast [32 x i8]* @gsxtmglfw3130 to i8*
%var2672 = bitcast [31 x i8]* @gsxtmglfw396 to i8*
%addytable2673 = call %clsvar* @add_address_table(%mzone* %zone2665, i8* %var2671, i32 0, i8* %var2672, i32 3, %clsvar* %addytable2670)
%address-table2674 = bitcast %clsvar* %addytable2673 to i8*

; insert table, function and environment into closure struct
%closure.table2677 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2667, i32 0, i32 0
store i8* %address-table2674, i8** %closure.table2677
%closure.env2678 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2667, i32 0, i32 1
store i8* %envptr2668, i8** %closure.env2678
%closure.func2679 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2667, i32 0, i32 2
store void (i8*, i8*)* @glfw_poll_events_adhoc_W3ZvaWRd__2661, void (i8*, i8*)** %closure.func2679
%closure_size2680 = call i64 @llvm_zone_mark_size(%mzone* %zone2665)
call void @llvm_zone_ptr_set_size(i8* %clsptr2666, i64 %closure_size2680)
%wrapper_ptr2681 = call i8* @llvm_zone_malloc(%mzone* %zone2665, i64 8)
%closure_wrapper2682 = bitcast i8* %wrapper_ptr2681 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure2667, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2682

; let value assignment
%glfw_poll_events_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2682, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2682
store { i8*, i8*, void (i8*, i8*)*}** %glfw_poll_events_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %glfw_poll_events_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var glfw_poll_events_adhoc_W3ZvaWRd
%tmp_envptr2676 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment2669, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %glfw_poll_events_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr2676


%val2685 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %glfw_poll_events_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val2685
}


@glfw_poll_events_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_poll_events_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_poll_events_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_poll_events_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @glfw_poll_events_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_poll_events_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_poll_events_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_poll_events_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_poll_events_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_poll_events_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @glfw_poll_events_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_poll_events_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @glfw_poll_events_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_poll_events_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_poll_events_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_poll_events_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3131 = hidden constant [97 x i8] c"      width: %i
     height: %i
    redBits: %i
  greenBits: %i
   blueBits: %i
refreshRate: %i
\00"
@gsxtmglfw3132 = hidden constant [61 x i8] c"glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd\00"
@gsxtmglfw3133 = hidden constant [45 x i8] c"{i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}**\00"
define dllexport fastcc i32 @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd__2686(i8* %_impz,i8* %_impenv, %GLFWvidmode* %vidmode) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2687 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}***}*
%glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}***}* %impenv, i32 0, i32 0
%glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpdPtr = load {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}***, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}**** %glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpdPtr_

; setup arguments
%vidmodePtr = alloca %GLFWvidmode*
store %GLFWvidmode* %vidmode, %GLFWvidmode** %vidmodePtr


%var2688 = bitcast [97 x i8]* @gsxtmglfw3131 to i8*
%val2689 = load %GLFWvidmode*, %GLFWvidmode** %vidmodePtr
; tuple ref
%val2690 = getelementptr %GLFWvidmode, %GLFWvidmode* %val2689, i64 0, i32 0
%val2691 = load i32, i32* %val2690
%val2692 = load %GLFWvidmode*, %GLFWvidmode** %vidmodePtr
; tuple ref
%val2693 = getelementptr %GLFWvidmode, %GLFWvidmode* %val2692, i64 0, i32 1
%val2694 = load i32, i32* %val2693
%val2695 = load %GLFWvidmode*, %GLFWvidmode** %vidmodePtr
; tuple ref
%val2696 = getelementptr %GLFWvidmode, %GLFWvidmode* %val2695, i64 0, i32 2
%val2697 = load i32, i32* %val2696
%val2698 = load %GLFWvidmode*, %GLFWvidmode** %vidmodePtr
; tuple ref
%val2699 = getelementptr %GLFWvidmode, %GLFWvidmode* %val2698, i64 0, i32 3
%val2700 = load i32, i32* %val2699
%val2701 = load %GLFWvidmode*, %GLFWvidmode** %vidmodePtr
; tuple ref
%val2702 = getelementptr %GLFWvidmode, %GLFWvidmode* %val2701, i64 0, i32 4
%val2703 = load i32, i32* %val2702
%val2704 = load %GLFWvidmode*, %GLFWvidmode** %vidmodePtr
; tuple ref
%val2705 = getelementptr %GLFWvidmode, %GLFWvidmode* %val2704, i64 0, i32 5
%val2706 = load i32, i32* %val2705

%val2707 = call i32 (i8*, ...) @printf(i8* %var2688, i32 %val2691, i32 %val2694, i32 %val2697, i32 %val2700, i32 %val2703, i32 %val2706)
ret i32 %val2707
}
@gsxtmglfw3134 = hidden constant [114 x i8] c"glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}** @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2727 = load i8*, i8** %_impzPtr
%zone2728 = bitcast i8* %tzone2727 to %mzone*

; let assign value to symbol glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd
%dat_glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd = call i8* @llvm_zone_malloc(%mzone* %zone2728, i64 8)
%glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpdPtr = bitcast i8* %dat_glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd to { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}***
%tzone2708 = load i8*, i8** %_impzPtr
%zone2709 = bitcast i8* %tzone2708 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2709)
; malloc closure structure
%clsptr2710 = call i8* @llvm_zone_malloc(%mzone* %zone2709, i64 24)
%closure2711 = bitcast i8* %clsptr2710 to { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}*

; malloc environment structure
%envptr2712 = call i8* @llvm_zone_malloc(%mzone* %zone2709, i64 8)
%environment2713 = bitcast i8* %envptr2712 to {{i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}***}*

; malloc closure address table
%addytable2714 = call %clsvar* @new_address_table()
%var2715 = bitcast [61 x i8]* @gsxtmglfw3132 to i8*
%var2716 = bitcast [45 x i8]* @gsxtmglfw3133 to i8*
%addytable2717 = call %clsvar* @add_address_table(%mzone* %zone2709, i8* %var2715, i32 0, i8* %var2716, i32 3, %clsvar* %addytable2714)
%address-table2718 = bitcast %clsvar* %addytable2717 to i8*

; insert table, function and environment into closure struct
%closure.table2721 = getelementptr { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}* %closure2711, i32 0, i32 0
store i8* %address-table2718, i8** %closure.table2721
%closure.env2722 = getelementptr { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}* %closure2711, i32 0, i32 1
store i8* %envptr2712, i8** %closure.env2722
%closure.func2723 = getelementptr { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}, { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}* %closure2711, i32 0, i32 2
store i32 (i8*, i8*, %GLFWvidmode*)* @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd__2686, i32 (i8*, i8*, %GLFWvidmode*)** %closure.func2723
%closure_size2724 = call i64 @llvm_zone_mark_size(%mzone* %zone2709)
call void @llvm_zone_ptr_set_size(i8* %clsptr2710, i64 %closure_size2724)
%wrapper_ptr2725 = call i8* @llvm_zone_malloc(%mzone* %zone2709, i64 8)
%closure_wrapper2726 = bitcast i8* %wrapper_ptr2725 to { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}**
store { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}* %closure2711, { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper2726

; let value assignment
%glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper2726, { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}** %closure_wrapper2726
store { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}** %glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd, { i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}*** %glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpdPtr

; add data to environment
; don't need to alloc for env var glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd
%tmp_envptr2720 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}***}* %environment2713, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}*** %glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpdPtr, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}**** %tmp_envptr2720


%val2729 = load {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}**, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}*** %glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpdPtr
ret {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}** %val2729
}


@glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}** @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd(%GLFWvidmode* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %GLFWvidmode*)*,  i32 (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_native(%GLFWvidmode* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %GLFWvidmode*)*,  i32 (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2730 = bitcast [114 x i8]* @gsxtmglfw3134 to i8*
call i32 (i8*, ...) @printf(i8* %var2730)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %GLFWvidmode*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %GLFWvidmode*)*,  i32 (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%GLFWvidmode*}*
%arg_p_0 = getelementptr {%GLFWvidmode*}, {%GLFWvidmode*}* %fstruct, i32 0, i32 0
%arg_0 = load %GLFWvidmode*, %GLFWvidmode** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}*, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}, {i8*, i8*, i32 (i8*, i8*, %GLFWvidmode*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %GLFWvidmode*)*,  i32 (i8*, i8*, %GLFWvidmode*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %GLFWvidmode* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3135 = hidden constant [33 x i8] c"Error: Monitor pointer is NULL.
\00"
@gsxtmglfw3136 = hidden constant [49 x i8] c"glfw_print_primary_monitor_details_adhoc_W2kzMl0\00"
define dllexport fastcc i32 @glfw_print_primary_monitor_details_adhoc_W2kzMl0__2731(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2732 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*)*}***}*
%glfw_print_primary_monitor_details_adhoc_W2kzMl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_print_primary_monitor_details_adhoc_W2kzMl0Ptr = load {i8*, i8*, i32 (i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*)*}**** %glfw_print_primary_monitor_details_adhoc_W2kzMl0Ptr_

; setup arguments


%tzone2734 = load i8*, i8** %_impzPtr
%zone2735 = bitcast i8* %tzone2734 to %mzone*

; let assign value to symbol monitor
%monitorPtr = alloca i8*
%res2733 = call ccc i8* @glfwGetPrimaryMonitor()

; let value assignment
%monitor = select i1 true, i8* %res2733, i8* %res2733
store i8* %monitor, i8** %monitorPtr

; promote local stack var allocations
%tzone2748 = load i8*, i8** %_impzPtr
%zone2749 = bitcast i8* %tzone2748 to %mzone*
%ifptr2737 = alloca i1
%val2738 = load i8*, i8** %monitorPtr
%val2739 = icmp eq i8* %val2738, null
br i1 %val2739, label %then2737, label %else2737

then2737:
%res2740 = call ccc i1 @impc_false()
store i1 %res2740, i1* %ifptr2737
br label %ifcont2737

else2737:
%res2741 = call ccc i1 @impc_true()
store i1 %res2741, i1* %ifptr2737
br label %ifcont2737

ifcont2737:
%ifres2742 = load i1, i1* %ifptr2737

br i1 %ifres2742, label %then2736, label %else2736

then2736:
%val2743 = load i8*, i8** %monitorPtr
%res2744 = call ccc %GLFWvidmode* @glfwGetVideoMode(i8* %val2743)
%res2745 = call fastcc i32 @glfw_print_video_mode_details_adhoc_W2kzMixHTEZXdmlkbW9kZSpd(%GLFWvidmode* %res2744)
ret i32 %res2745

else2736:
%var2746 = bitcast [33 x i8]* @gsxtmglfw3135 to i8*

%val2747 = call i32 (i8*, ...) @printf(i8* %var2746)
ret i32 %val2747
}
define dllexport ccc {i8*, i8*, i32 (i8*, i8*)*}** @glfw_print_primary_monitor_details_adhoc_W2kzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2769 = load i8*, i8** %_impzPtr
%zone2770 = bitcast i8* %tzone2769 to %mzone*

; let assign value to symbol glfw_print_primary_monitor_details_adhoc_W2kzMl0
%dat_glfw_print_primary_monitor_details_adhoc_W2kzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2770, i64 8)
%glfw_print_primary_monitor_details_adhoc_W2kzMl0Ptr = bitcast i8* %dat_glfw_print_primary_monitor_details_adhoc_W2kzMl0 to { i8*, i8*, i32 (i8*, i8*)*}***
%tzone2750 = load i8*, i8** %_impzPtr
%zone2751 = bitcast i8* %tzone2750 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2751)
; malloc closure structure
%clsptr2752 = call i8* @llvm_zone_malloc(%mzone* %zone2751, i64 24)
%closure2753 = bitcast i8* %clsptr2752 to { i8*, i8*, i32 (i8*, i8*)*}*

; malloc environment structure
%envptr2754 = call i8* @llvm_zone_malloc(%mzone* %zone2751, i64 8)
%environment2755 = bitcast i8* %envptr2754 to {{i8*, i8*, i32 (i8*, i8*)*}***}*

; malloc closure address table
%addytable2756 = call %clsvar* @new_address_table()
%var2757 = bitcast [49 x i8]* @gsxtmglfw3136 to i8*
%var2758 = bitcast [30 x i8]* @gsxtmglfw394 to i8*
%addytable2759 = call %clsvar* @add_address_table(%mzone* %zone2751, i8* %var2757, i32 0, i8* %var2758, i32 3, %clsvar* %addytable2756)
%address-table2760 = bitcast %clsvar* %addytable2759 to i8*

; insert table, function and environment into closure struct
%closure.table2763 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure2753, i32 0, i32 0
store i8* %address-table2760, i8** %closure.table2763
%closure.env2764 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure2753, i32 0, i32 1
store i8* %envptr2754, i8** %closure.env2764
%closure.func2765 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure2753, i32 0, i32 2
store i32 (i8*, i8*)* @glfw_print_primary_monitor_details_adhoc_W2kzMl0__2731, i32 (i8*, i8*)** %closure.func2765
%closure_size2766 = call i64 @llvm_zone_mark_size(%mzone* %zone2751)
call void @llvm_zone_ptr_set_size(i8* %clsptr2752, i64 %closure_size2766)
%wrapper_ptr2767 = call i8* @llvm_zone_malloc(%mzone* %zone2751, i64 8)
%closure_wrapper2768 = bitcast i8* %wrapper_ptr2767 to { i8*, i8*, i32 (i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*)*}* %closure2753, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper2768

; let value assignment
%glfw_print_primary_monitor_details_adhoc_W2kzMl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper2768, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper2768
store { i8*, i8*, i32 (i8*, i8*)*}** %glfw_print_primary_monitor_details_adhoc_W2kzMl0, { i8*, i8*, i32 (i8*, i8*)*}*** %glfw_print_primary_monitor_details_adhoc_W2kzMl0Ptr

; add data to environment
; don't need to alloc for env var glfw_print_primary_monitor_details_adhoc_W2kzMl0
%tmp_envptr2762 = getelementptr {{i8*, i8*, i32 (i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*)*}***}* %environment2755, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*)*}*** %glfw_print_primary_monitor_details_adhoc_W2kzMl0Ptr, {i8*, i8*, i32 (i8*, i8*)*}**** %tmp_envptr2762


%val2771 = load {i8*, i8*, i32 (i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*)*}*** %glfw_print_primary_monitor_details_adhoc_W2kzMl0Ptr
ret {i8*, i8*, i32 (i8*, i8*)*}** %val2771
}


@glfw_print_primary_monitor_details_adhoc_W2kzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_print_primary_monitor_details_adhoc_W2kzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_print_primary_monitor_details_adhoc_W2kzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_primary_monitor_details_adhoc_W2kzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*)*}** @glfw_print_primary_monitor_details_adhoc_W2kzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_print_primary_monitor_details_adhoc_W2kzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_print_primary_monitor_details_adhoc_W2kzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_primary_monitor_details_adhoc_W2kzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @glfw_print_primary_monitor_details_adhoc_W2kzMl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_primary_monitor_details_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
ret i32 %result
}


define dllexport ccc i32 @glfw_print_primary_monitor_details_adhoc_W2kzMl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_primary_monitor_details_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
ret i32 %result
}


define dllexport ccc i8*  @glfw_print_primary_monitor_details_adhoc_W2kzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_primary_monitor_details_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @glfw_print_primary_monitor_details_adhoc_W2kzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_print_primary_monitor_details_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3137 = hidden constant [37 x i8] c"glfw_set_core_profile_adhoc_W3ZvaWRd\00"
define dllexport fastcc void @glfw_set_core_profile_adhoc_W3ZvaWRd__2772(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2773 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%glfw_set_core_profile_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_set_core_profile_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %glfw_set_core_profile_adhoc_W3ZvaWRdPtr_

; setup arguments


%val2774 = load i32, i32* @GLFW_CONTEXT_VERSION_MAJOR
call ccc void @glfwWindowHint(i32 %val2774, i32 3)
%val2776 = load i32, i32* @GLFW_CONTEXT_VERSION_MINOR
call ccc void @glfwWindowHint(i32 %val2776, i32 2)
%val2778 = load i32, i32* @GLFW_OPENGL_FORWARD_COMPAT
%val2779 = trunc i64 1 to i32
call ccc void @glfwWindowHint(i32 %val2778, i32 %val2779)
%val2781 = load i32, i32* @GLFW_OPENGL_PROFILE
%val2782 = load i32, i32* @GLFW_OPENGL_CORE_PROFILE
call ccc void @glfwWindowHint(i32 %val2781, i32 %val2782)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @glfw_set_core_profile_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2803 = load i8*, i8** %_impzPtr
%zone2804 = bitcast i8* %tzone2803 to %mzone*

; let assign value to symbol glfw_set_core_profile_adhoc_W3ZvaWRd
%dat_glfw_set_core_profile_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone2804, i64 8)
%glfw_set_core_profile_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_glfw_set_core_profile_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone2784 = load i8*, i8** %_impzPtr
%zone2785 = bitcast i8* %tzone2784 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2785)
; malloc closure structure
%clsptr2786 = call i8* @llvm_zone_malloc(%mzone* %zone2785, i64 24)
%closure2787 = bitcast i8* %clsptr2786 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr2788 = call i8* @llvm_zone_malloc(%mzone* %zone2785, i64 8)
%environment2789 = bitcast i8* %envptr2788 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable2790 = call %clsvar* @new_address_table()
%var2791 = bitcast [37 x i8]* @gsxtmglfw3137 to i8*
%var2792 = bitcast [31 x i8]* @gsxtmglfw396 to i8*
%addytable2793 = call %clsvar* @add_address_table(%mzone* %zone2785, i8* %var2791, i32 0, i8* %var2792, i32 3, %clsvar* %addytable2790)
%address-table2794 = bitcast %clsvar* %addytable2793 to i8*

; insert table, function and environment into closure struct
%closure.table2797 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2787, i32 0, i32 0
store i8* %address-table2794, i8** %closure.table2797
%closure.env2798 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2787, i32 0, i32 1
store i8* %envptr2788, i8** %closure.env2798
%closure.func2799 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2787, i32 0, i32 2
store void (i8*, i8*)* @glfw_set_core_profile_adhoc_W3ZvaWRd__2772, void (i8*, i8*)** %closure.func2799
%closure_size2800 = call i64 @llvm_zone_mark_size(%mzone* %zone2785)
call void @llvm_zone_ptr_set_size(i8* %clsptr2786, i64 %closure_size2800)
%wrapper_ptr2801 = call i8* @llvm_zone_malloc(%mzone* %zone2785, i64 8)
%closure_wrapper2802 = bitcast i8* %wrapper_ptr2801 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure2787, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2802

; let value assignment
%glfw_set_core_profile_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2802, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2802
store { i8*, i8*, void (i8*, i8*)*}** %glfw_set_core_profile_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %glfw_set_core_profile_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var glfw_set_core_profile_adhoc_W3ZvaWRd
%tmp_envptr2796 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment2789, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %glfw_set_core_profile_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr2796


%val2805 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %glfw_set_core_profile_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val2805
}


@glfw_set_core_profile_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_set_core_profile_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_set_core_profile_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_set_core_profile_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @glfw_set_core_profile_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_set_core_profile_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_set_core_profile_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_set_core_profile_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_set_core_profile_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_set_core_profile_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @glfw_set_core_profile_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_set_core_profile_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @glfw_set_core_profile_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_set_core_profile_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_set_core_profile_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_set_core_profile_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3138 = hidden constant [46 x i8] c"glfw_set_compatibility_profile_adhoc_W3ZvaWRd\00"
define dllexport fastcc void @glfw_set_compatibility_profile_adhoc_W3ZvaWRd__2806(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2807 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%glfw_set_compatibility_profile_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_set_compatibility_profile_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %glfw_set_compatibility_profile_adhoc_W3ZvaWRdPtr_

; setup arguments


%val2808 = load i32, i32* @GLFW_CONTEXT_VERSION_MAJOR
call ccc void @glfwWindowHint(i32 %val2808, i32 3)
%val2810 = load i32, i32* @GLFW_CONTEXT_VERSION_MINOR
call ccc void @glfwWindowHint(i32 %val2810, i32 1)
%val2812 = load i32, i32* @GLFW_OPENGL_FORWARD_COMPAT
%val2813 = trunc i64 0 to i32
call ccc void @glfwWindowHint(i32 %val2812, i32 %val2813)
%val2815 = load i32, i32* @GLFW_OPENGL_PROFILE
%val2816 = load i32, i32* @GLFW_OPENGL_COMPAT_PROFILE
call ccc void @glfwWindowHint(i32 %val2815, i32 %val2816)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2837 = load i8*, i8** %_impzPtr
%zone2838 = bitcast i8* %tzone2837 to %mzone*

; let assign value to symbol glfw_set_compatibility_profile_adhoc_W3ZvaWRd
%dat_glfw_set_compatibility_profile_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone2838, i64 8)
%glfw_set_compatibility_profile_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_glfw_set_compatibility_profile_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone2818 = load i8*, i8** %_impzPtr
%zone2819 = bitcast i8* %tzone2818 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2819)
; malloc closure structure
%clsptr2820 = call i8* @llvm_zone_malloc(%mzone* %zone2819, i64 24)
%closure2821 = bitcast i8* %clsptr2820 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr2822 = call i8* @llvm_zone_malloc(%mzone* %zone2819, i64 8)
%environment2823 = bitcast i8* %envptr2822 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable2824 = call %clsvar* @new_address_table()
%var2825 = bitcast [46 x i8]* @gsxtmglfw3138 to i8*
%var2826 = bitcast [31 x i8]* @gsxtmglfw396 to i8*
%addytable2827 = call %clsvar* @add_address_table(%mzone* %zone2819, i8* %var2825, i32 0, i8* %var2826, i32 3, %clsvar* %addytable2824)
%address-table2828 = bitcast %clsvar* %addytable2827 to i8*

; insert table, function and environment into closure struct
%closure.table2831 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2821, i32 0, i32 0
store i8* %address-table2828, i8** %closure.table2831
%closure.env2832 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2821, i32 0, i32 1
store i8* %envptr2822, i8** %closure.env2832
%closure.func2833 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2821, i32 0, i32 2
store void (i8*, i8*)* @glfw_set_compatibility_profile_adhoc_W3ZvaWRd__2806, void (i8*, i8*)** %closure.func2833
%closure_size2834 = call i64 @llvm_zone_mark_size(%mzone* %zone2819)
call void @llvm_zone_ptr_set_size(i8* %clsptr2820, i64 %closure_size2834)
%wrapper_ptr2835 = call i8* @llvm_zone_malloc(%mzone* %zone2819, i64 8)
%closure_wrapper2836 = bitcast i8* %wrapper_ptr2835 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure2821, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2836

; let value assignment
%glfw_set_compatibility_profile_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2836, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2836
store { i8*, i8*, void (i8*, i8*)*}** %glfw_set_compatibility_profile_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %glfw_set_compatibility_profile_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var glfw_set_compatibility_profile_adhoc_W3ZvaWRd
%tmp_envptr2830 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment2823, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %glfw_set_compatibility_profile_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr2830


%val2839 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %glfw_set_compatibility_profile_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val2839
}


@glfw_set_compatibility_profile_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_set_compatibility_profile_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_set_compatibility_profile_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_set_compatibility_profile_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3139 = hidden constant [53 x i8] c"window: %p key: %d scancode: %d action: %d mods: %d
\00"
@gsxtmglfw3140 = hidden constant [60 x i8] c"glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0\00"
@gsxtmglfw3141 = hidden constant [56 x i8] c"{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}**\00"
define dllexport fastcc void @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0__2840(i8* %_impz,i8* %_impenv, i8* %window, i32 %key, i32 %scancode, i32 %action, i32 %mods) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2841 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}***}*
%glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}**** %glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr
%keyPtr = alloca i32
store i32 %key, i32* %keyPtr
%scancodePtr = alloca i32
store i32 %scancode, i32* %scancodePtr
%actionPtr = alloca i32
store i32 %action, i32* %actionPtr
%modsPtr = alloca i32
store i32 %mods, i32* %modsPtr


%var2842 = bitcast [53 x i8]* @gsxtmglfw3139 to i8*
%val2843 = load i8*, i8** %windowPtr
%val2844 = load i32, i32* %keyPtr
%val2845 = load i32, i32* %scancodePtr
%val2846 = load i32, i32* %actionPtr
%val2847 = load i32, i32* %modsPtr

%val2848 = call i32 (i8*, ...) @printf(i8* %var2842, i8* %val2843, i32 %val2844, i32 %val2845, i32 %val2846, i32 %val2847)
ret void
}
@gsxtmglfw3142 = hidden constant [113 x i8] c"glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2869 = load i8*, i8** %_impzPtr
%zone2870 = bitcast i8* %tzone2869 to %mzone*

; let assign value to symbol glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0
%dat_glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2870, i64 8)
%glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0 to { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}***
%tzone2850 = load i8*, i8** %_impzPtr
%zone2851 = bitcast i8* %tzone2850 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2851)
; malloc closure structure
%clsptr2852 = call i8* @llvm_zone_malloc(%mzone* %zone2851, i64 24)
%closure2853 = bitcast i8* %clsptr2852 to { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr2854 = call i8* @llvm_zone_malloc(%mzone* %zone2851, i64 8)
%environment2855 = bitcast i8* %envptr2854 to {{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable2856 = call %clsvar* @new_address_table()
%var2857 = bitcast [60 x i8]* @gsxtmglfw3140 to i8*
%var2858 = bitcast [56 x i8]* @gsxtmglfw3141 to i8*
%addytable2859 = call %clsvar* @add_address_table(%mzone* %zone2851, i8* %var2857, i32 0, i8* %var2858, i32 3, %clsvar* %addytable2856)
%address-table2860 = bitcast %clsvar* %addytable2859 to i8*

; insert table, function and environment into closure struct
%closure.table2863 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}* %closure2853, i32 0, i32 0
store i8* %address-table2860, i8** %closure.table2863
%closure.env2864 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}* %closure2853, i32 0, i32 1
store i8* %envptr2854, i8** %closure.env2864
%closure.func2865 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}* %closure2853, i32 0, i32 2
store void (i8*, i8*, i8*, i32, i32, i32, i32)* @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0__2840, void (i8*, i8*, i8*, i32, i32, i32, i32)** %closure.func2865
%closure_size2866 = call i64 @llvm_zone_mark_size(%mzone* %zone2851)
call void @llvm_zone_ptr_set_size(i8* %clsptr2852, i64 %closure_size2866)
%wrapper_ptr2867 = call i8* @llvm_zone_malloc(%mzone* %zone2851, i64 8)
%closure_wrapper2868 = bitcast i8* %wrapper_ptr2867 to { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}* %closure2853, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper2868

; let value assignment
%glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper2868, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** %closure_wrapper2868
store { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** %glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}*** %glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0
%tmp_envptr2862 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}***}* %environment2855, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}*** %glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}**** %tmp_envptr2862


%val2871 = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}*** %glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** %val2871
}


@glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0(i8* %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32, i32, i32, i32)*,  void (i8*, i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
ret void
}


define dllexport ccc void @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_native(i8* %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32, i32, i32, i32)*,  void (i8*, i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
ret void
}


define dllexport ccc i8*  @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2872 = bitcast [113 x i8]* @gsxtmglfw3142 to i8*
call i32 (i8*, ...) @printf(i8* %var2872)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2873 = bitcast [113 x i8]* @gsxtmglfw3142 to i8*
call i32 (i8*, ...) @printf(i8* %var2873)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2874 = bitcast [113 x i8]* @gsxtmglfw3142 to i8*
call i32 (i8*, ...) @printf(i8* %var2874)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2875 = bitcast [113 x i8]* @gsxtmglfw3142 to i8*
call i32 (i8*, ...) @printf(i8* %var2875)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2876 = bitcast [113 x i8]* @gsxtmglfw3142 to i8*
call i32 (i8*, ...) @printf(i8* %var2876)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32, i32, i32, i32)*,  void (i8*, i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i8*, i32, i32, i32, i32}, {i8*, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i32, i32, i32, i32}, {i8*, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i8*, i32, i32, i32, i32}, {i8*, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i8*, i32, i32, i32, i32}, {i8*, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i8*, i32, i32, i32, i32}, {i8*, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_key_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32, i32, i32, i32)*,  void (i8*, i8*, i8*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3143 = hidden constant [26 x i8] c"window: %p codepoint: %c
\00"
@gsxtmglfw3144 = hidden constant [45 x i8] c"glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0\00"
@gsxtmglfw3145 = hidden constant [41 x i8] c"{i8*, i8*, void (i8*, i8*, i8*, i32)*}**\00"
define dllexport fastcc void @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0__2877(i8* %_impz,i8* %_impenv, i8* %window, i32 %codepoint) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2878 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i32)*}***}*
%glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr = load {i8*, i8*, void (i8*, i8*, i8*, i32)*}***, {i8*, i8*, void (i8*, i8*, i8*, i32)*}**** %glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr
%codepointPtr = alloca i32
store i32 %codepoint, i32* %codepointPtr


%var2879 = bitcast [26 x i8]* @gsxtmglfw3143 to i8*
%val2880 = load i8*, i8** %windowPtr
%val2881 = load i32, i32* %codepointPtr

%val2882 = call i32 (i8*, ...) @printf(i8* %var2879, i8* %val2880, i32 %val2881)
ret void
}
@gsxtmglfw3146 = hidden constant [98 x i8] c"glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i32)*}** @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2903 = load i8*, i8** %_impzPtr
%zone2904 = bitcast i8* %tzone2903 to %mzone*

; let assign value to symbol glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0
%dat_glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2904, i64 8)
%glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr = bitcast i8* %dat_glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0 to { i8*, i8*, void (i8*, i8*, i8*, i32)*}***
%tzone2884 = load i8*, i8** %_impzPtr
%zone2885 = bitcast i8* %tzone2884 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2885)
; malloc closure structure
%clsptr2886 = call i8* @llvm_zone_malloc(%mzone* %zone2885, i64 24)
%closure2887 = bitcast i8* %clsptr2886 to { i8*, i8*, void (i8*, i8*, i8*, i32)*}*

; malloc environment structure
%envptr2888 = call i8* @llvm_zone_malloc(%mzone* %zone2885, i64 8)
%environment2889 = bitcast i8* %envptr2888 to {{i8*, i8*, void (i8*, i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable2890 = call %clsvar* @new_address_table()
%var2891 = bitcast [45 x i8]* @gsxtmglfw3144 to i8*
%var2892 = bitcast [41 x i8]* @gsxtmglfw3145 to i8*
%addytable2893 = call %clsvar* @add_address_table(%mzone* %zone2885, i8* %var2891, i32 0, i8* %var2892, i32 3, %clsvar* %addytable2890)
%address-table2894 = bitcast %clsvar* %addytable2893 to i8*

; insert table, function and environment into closure struct
%closure.table2897 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure2887, i32 0, i32 0
store i8* %address-table2894, i8** %closure.table2897
%closure.env2898 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure2887, i32 0, i32 1
store i8* %envptr2888, i8** %closure.env2898
%closure.func2899 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure2887, i32 0, i32 2
store void (i8*, i8*, i8*, i32)* @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0__2877, void (i8*, i8*, i8*, i32)** %closure.func2899
%closure_size2900 = call i64 @llvm_zone_mark_size(%mzone* %zone2885)
call void @llvm_zone_ptr_set_size(i8* %clsptr2886, i64 %closure_size2900)
%wrapper_ptr2901 = call i8* @llvm_zone_malloc(%mzone* %zone2885, i64 8)
%closure_wrapper2902 = bitcast i8* %wrapper_ptr2901 to { i8*, i8*, void (i8*, i8*, i8*, i32)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure2887, { i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_wrapper2902

; let value assignment
%glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_wrapper2902, { i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_wrapper2902
store { i8*, i8*, void (i8*, i8*, i8*, i32)*}** %glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0, { i8*, i8*, void (i8*, i8*, i8*, i32)*}*** %glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0
%tmp_envptr2896 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i32)*}***}* %environment2889, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i32)*}*** %glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr, {i8*, i8*, void (i8*, i8*, i8*, i32)*}**** %tmp_envptr2896


%val2905 = load {i8*, i8*, void (i8*, i8*, i8*, i32)*}**, {i8*, i8*, void (i8*, i8*, i8*, i32)*}*** %glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr
ret {i8*, i8*, void (i8*, i8*, i8*, i32)*}** %val2905
}


@glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i32)*}** @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0(i8* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32)*,  void (i8*, i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc void @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_native(i8* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32)*,  void (i8*, i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc i8*  @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2906 = bitcast [98 x i8]* @gsxtmglfw3146 to i8*
call i32 (i8*, ...) @printf(i8* %var2906)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2907 = bitcast [98 x i8]* @gsxtmglfw3146 to i8*
call i32 (i8*, ...) @printf(i8* %var2907)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32)*,  void (i8*, i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i32}*
%arg_p_0 = getelementptr {i8*, i32}, {i8*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i32}, {i8*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_char_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32)*,  void (i8*, i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3147 = hidden constant [29 x i8] c"window position x: %d y: %d
\00"
@gsxtmglfw3148 = hidden constant [61 x i8] c"glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd\00"
@gsxtmglfw3149 = hidden constant [46 x i8] c"{i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**\00"
define dllexport fastcc void @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd__2908(i8* %_impz,i8* %_impenv, i8* %window, i32 %xpos, i32 %ypos) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2909 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}***}*
%glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJdPtr = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**** %glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJdPtr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr
%xposPtr = alloca i32
store i32 %xpos, i32* %xposPtr
%yposPtr = alloca i32
store i32 %ypos, i32* %yposPtr


%var2910 = bitcast [29 x i8]* @gsxtmglfw3147 to i8*
%val2911 = load i32, i32* %xposPtr
%val2912 = load i32, i32* %yposPtr

%val2913 = call i32 (i8*, ...) @printf(i8* %var2910, i32 %val2911, i32 %val2912)
ret void
}
@gsxtmglfw3150 = hidden constant [114 x i8] c"glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2934 = load i8*, i8** %_impzPtr
%zone2935 = bitcast i8* %tzone2934 to %mzone*

; let assign value to symbol glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd
%dat_glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone2935, i64 8)
%glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJdPtr = bitcast i8* %dat_glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd to { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}***
%tzone2915 = load i8*, i8** %_impzPtr
%zone2916 = bitcast i8* %tzone2915 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2916)
; malloc closure structure
%clsptr2917 = call i8* @llvm_zone_malloc(%mzone* %zone2916, i64 24)
%closure2918 = bitcast i8* %clsptr2917 to { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr2919 = call i8* @llvm_zone_malloc(%mzone* %zone2916, i64 8)
%environment2920 = bitcast i8* %envptr2919 to {{i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable2921 = call %clsvar* @new_address_table()
%var2922 = bitcast [61 x i8]* @gsxtmglfw3148 to i8*
%var2923 = bitcast [46 x i8]* @gsxtmglfw3149 to i8*
%addytable2924 = call %clsvar* @add_address_table(%mzone* %zone2916, i8* %var2922, i32 0, i8* %var2923, i32 3, %clsvar* %addytable2921)
%address-table2925 = bitcast %clsvar* %addytable2924 to i8*

; insert table, function and environment into closure struct
%closure.table2928 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}* %closure2918, i32 0, i32 0
store i8* %address-table2925, i8** %closure.table2928
%closure.env2929 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}* %closure2918, i32 0, i32 1
store i8* %envptr2919, i8** %closure.env2929
%closure.func2930 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}* %closure2918, i32 0, i32 2
store void (i8*, i8*, i8*, i32, i32)* @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd__2908, void (i8*, i8*, i8*, i32, i32)** %closure.func2930
%closure_size2931 = call i64 @llvm_zone_mark_size(%mzone* %zone2916)
call void @llvm_zone_ptr_set_size(i8* %clsptr2917, i64 %closure_size2931)
%wrapper_ptr2932 = call i8* @llvm_zone_malloc(%mzone* %zone2916, i64 8)
%closure_wrapper2933 = bitcast i8* %wrapper_ptr2932 to { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}* %closure2918, { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** %closure_wrapper2933

; let value assignment
%glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** %closure_wrapper2933, { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** %closure_wrapper2933
store { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** %glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd, { i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}*** %glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd
%tmp_envptr2927 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}***}* %environment2920, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}*** %glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJdPtr, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**** %tmp_envptr2927


%val2936 = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}*** %glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJdPtr
ret {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** %val2936
}


@glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd(i8* %arg_0,i32 %arg_1,i32 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32, i32)*,  void (i8*, i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1, i32 %arg_2)
ret void
}


define dllexport ccc void @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_native(i8* %arg_0,i32 %arg_1,i32 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32, i32)*,  void (i8*, i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1, i32 %arg_2)
ret void
}


define dllexport ccc i8*  @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2937 = bitcast [114 x i8]* @gsxtmglfw3150 to i8*
call i32 (i8*, ...) @printf(i8* %var2937)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2938 = bitcast [114 x i8]* @gsxtmglfw3150 to i8*
call i32 (i8*, ...) @printf(i8* %var2938)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2939 = bitcast [114 x i8]* @gsxtmglfw3150 to i8*
call i32 (i8*, ...) @printf(i8* %var2939)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32, i32)*,  void (i8*, i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1, i32 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i32, i32}*
%arg_p_0 = getelementptr {i8*, i32, i32}, {i8*, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i32, i32}, {i8*, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i8*, i32, i32}, {i8*, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_position_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32, i32)*,  void (i8*, i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1, i32 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3151 = hidden constant [24 x i8] c"window %p gained focus
\00"
@gsxtmglfw3152 = hidden constant [22 x i8] c"window %p lost focus
\00"
@gsxtmglfw3153 = hidden constant [53 x i8] c"glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0\00"
define dllexport fastcc void @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0__2940(i8* %_impz,i8* %_impenv, i8* %window, i32 %focused) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2941 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i32)*}***}*
%glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr = load {i8*, i8*, void (i8*, i8*, i8*, i32)*}***, {i8*, i8*, void (i8*, i8*, i8*, i32)*}**** %glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr
%focusedPtr = alloca i32
store i32 %focused, i32* %focusedPtr

; promote local stack var allocations
%tzone2954 = load i8*, i8** %_impzPtr
%zone2955 = bitcast i8* %tzone2954 to %mzone*
%ifptr2942 = alloca i32

%val2943 = load i32, i32* %focusedPtr
%val2944 = trunc i64 1 to i32
%cmp2945 = icmp eq i32 %val2943, %val2944
br i1 %cmp2945, label %then2942, label %else2942

then2942:
%var2946 = bitcast [24 x i8]* @gsxtmglfw3151 to i8*
%val2947 = load i8*, i8** %windowPtr

%val2948 = call i32 (i8*, ...) @printf(i8* %var2946, i8* %val2947)
store i32 %val2948, i32* %ifptr2942
br label %ifcont2942

else2942:
%var2949 = bitcast [22 x i8]* @gsxtmglfw3152 to i8*
%val2950 = load i8*, i8** %windowPtr

%val2951 = call i32 (i8*, ...) @printf(i8* %var2949, i8* %val2950)
store i32 %val2951, i32* %ifptr2942
br label %ifcont2942

ifcont2942:
%ifres2952 = load i32, i32* %ifptr2942

ret void
}
@gsxtmglfw3154 = hidden constant [106 x i8] c"glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i32)*}** @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2975 = load i8*, i8** %_impzPtr
%zone2976 = bitcast i8* %tzone2975 to %mzone*

; let assign value to symbol glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0
%dat_glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2976, i64 8)
%glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr = bitcast i8* %dat_glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0 to { i8*, i8*, void (i8*, i8*, i8*, i32)*}***
%tzone2956 = load i8*, i8** %_impzPtr
%zone2957 = bitcast i8* %tzone2956 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2957)
; malloc closure structure
%clsptr2958 = call i8* @llvm_zone_malloc(%mzone* %zone2957, i64 24)
%closure2959 = bitcast i8* %clsptr2958 to { i8*, i8*, void (i8*, i8*, i8*, i32)*}*

; malloc environment structure
%envptr2960 = call i8* @llvm_zone_malloc(%mzone* %zone2957, i64 8)
%environment2961 = bitcast i8* %envptr2960 to {{i8*, i8*, void (i8*, i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable2962 = call %clsvar* @new_address_table()
%var2963 = bitcast [53 x i8]* @gsxtmglfw3153 to i8*
%var2964 = bitcast [41 x i8]* @gsxtmglfw3145 to i8*
%addytable2965 = call %clsvar* @add_address_table(%mzone* %zone2957, i8* %var2963, i32 0, i8* %var2964, i32 3, %clsvar* %addytable2962)
%address-table2966 = bitcast %clsvar* %addytable2965 to i8*

; insert table, function and environment into closure struct
%closure.table2969 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure2959, i32 0, i32 0
store i8* %address-table2966, i8** %closure.table2969
%closure.env2970 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure2959, i32 0, i32 1
store i8* %envptr2960, i8** %closure.env2970
%closure.func2971 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure2959, i32 0, i32 2
store void (i8*, i8*, i8*, i32)* @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0__2940, void (i8*, i8*, i8*, i32)** %closure.func2971
%closure_size2972 = call i64 @llvm_zone_mark_size(%mzone* %zone2957)
call void @llvm_zone_ptr_set_size(i8* %clsptr2958, i64 %closure_size2972)
%wrapper_ptr2973 = call i8* @llvm_zone_malloc(%mzone* %zone2957, i64 8)
%closure_wrapper2974 = bitcast i8* %wrapper_ptr2973 to { i8*, i8*, void (i8*, i8*, i8*, i32)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure2959, { i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_wrapper2974

; let value assignment
%glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_wrapper2974, { i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_wrapper2974
store { i8*, i8*, void (i8*, i8*, i8*, i32)*}** %glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0, { i8*, i8*, void (i8*, i8*, i8*, i32)*}*** %glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0
%tmp_envptr2968 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i32)*}***}* %environment2961, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i32)*}*** %glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr, {i8*, i8*, void (i8*, i8*, i8*, i32)*}**** %tmp_envptr2968


%val2977 = load {i8*, i8*, void (i8*, i8*, i8*, i32)*}**, {i8*, i8*, void (i8*, i8*, i8*, i32)*}*** %glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0Ptr
ret {i8*, i8*, void (i8*, i8*, i8*, i32)*}** %val2977
}


@glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i32)*}** @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0(i8* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32)*,  void (i8*, i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc void @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_native(i8* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32)*,  void (i8*, i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc i8*  @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2978 = bitcast [106 x i8]* @gsxtmglfw3154 to i8*
call i32 (i8*, ...) @printf(i8* %var2978)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2979 = bitcast [106 x i8]* @gsxtmglfw3154 to i8*
call i32 (i8*, ...) @printf(i8* %var2979)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32)*,  void (i8*, i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i32}*
%arg_p_0 = getelementptr {i8*, i32}, {i8*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i32}, {i8*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_window_focus_callback_adhoc_W3ZvaWQsaTgqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32)*,  void (i8*, i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3155 = hidden constant [29 x i8] c"cursor position x: %f y: %f
\00"
@gsxtmglfw3156 = hidden constant [69 x i8] c"glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd\00"
@gsxtmglfw3157 = hidden constant [52 x i8] c"{i8*, i8*, void (i8*, i8*, i8*, double, double)*}**\00"
define dllexport fastcc void @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd__2980(i8* %_impz,i8* %_impenv, i8* %window, double %xpos, double %ypos) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2981 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, double, double)*}***}*
%glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, double, double)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, double, double)*}***}* %impenv, i32 0, i32 0
%glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVdPtr = load {i8*, i8*, void (i8*, i8*, i8*, double, double)*}***, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}**** %glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVdPtr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr
%xposPtr = alloca double
store double %xpos, double* %xposPtr
%yposPtr = alloca double
store double %ypos, double* %yposPtr


%var2982 = bitcast [29 x i8]* @gsxtmglfw3155 to i8*
%val2983 = load double, double* %xposPtr
%val2984 = load double, double* %yposPtr

%val2985 = call i32 (i8*, ...) @printf(i8* %var2982, double %val2983, double %val2984)
ret void
}
@gsxtmglfw3158 = hidden constant [122 x i8] c"glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, double, double)*}** @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3006 = load i8*, i8** %_impzPtr
%zone3007 = bitcast i8* %tzone3006 to %mzone*

; let assign value to symbol glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd
%dat_glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone3007, i64 8)
%glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVdPtr = bitcast i8* %dat_glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd to { i8*, i8*, void (i8*, i8*, i8*, double, double)*}***
%tzone2987 = load i8*, i8** %_impzPtr
%zone2988 = bitcast i8* %tzone2987 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2988)
; malloc closure structure
%clsptr2989 = call i8* @llvm_zone_malloc(%mzone* %zone2988, i64 24)
%closure2990 = bitcast i8* %clsptr2989 to { i8*, i8*, void (i8*, i8*, i8*, double, double)*}*

; malloc environment structure
%envptr2991 = call i8* @llvm_zone_malloc(%mzone* %zone2988, i64 8)
%environment2992 = bitcast i8* %envptr2991 to {{i8*, i8*, void (i8*, i8*, i8*, double, double)*}***}*

; malloc closure address table
%addytable2993 = call %clsvar* @new_address_table()
%var2994 = bitcast [69 x i8]* @gsxtmglfw3156 to i8*
%var2995 = bitcast [52 x i8]* @gsxtmglfw3157 to i8*
%addytable2996 = call %clsvar* @add_address_table(%mzone* %zone2988, i8* %var2994, i32 0, i8* %var2995, i32 3, %clsvar* %addytable2993)
%address-table2997 = bitcast %clsvar* %addytable2996 to i8*

; insert table, function and environment into closure struct
%closure.table3000 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, double, double)*}, { i8*, i8*, void (i8*, i8*, i8*, double, double)*}* %closure2990, i32 0, i32 0
store i8* %address-table2997, i8** %closure.table3000
%closure.env3001 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, double, double)*}, { i8*, i8*, void (i8*, i8*, i8*, double, double)*}* %closure2990, i32 0, i32 1
store i8* %envptr2991, i8** %closure.env3001
%closure.func3002 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, double, double)*}, { i8*, i8*, void (i8*, i8*, i8*, double, double)*}* %closure2990, i32 0, i32 2
store void (i8*, i8*, i8*, double, double)* @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd__2980, void (i8*, i8*, i8*, double, double)** %closure.func3002
%closure_size3003 = call i64 @llvm_zone_mark_size(%mzone* %zone2988)
call void @llvm_zone_ptr_set_size(i8* %clsptr2989, i64 %closure_size3003)
%wrapper_ptr3004 = call i8* @llvm_zone_malloc(%mzone* %zone2988, i64 8)
%closure_wrapper3005 = bitcast i8* %wrapper_ptr3004 to { i8*, i8*, void (i8*, i8*, i8*, double, double)*}**
store { i8*, i8*, void (i8*, i8*, i8*, double, double)*}* %closure2990, { i8*, i8*, void (i8*, i8*, i8*, double, double)*}** %closure_wrapper3005

; let value assignment
%glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, double, double)*}** %closure_wrapper3005, { i8*, i8*, void (i8*, i8*, i8*, double, double)*}** %closure_wrapper3005
store { i8*, i8*, void (i8*, i8*, i8*, double, double)*}** %glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd, { i8*, i8*, void (i8*, i8*, i8*, double, double)*}*** %glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd
%tmp_envptr2999 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, double, double)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, double, double)*}***}* %environment2992, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, double, double)*}*** %glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVdPtr, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}**** %tmp_envptr2999


%val3008 = load {i8*, i8*, void (i8*, i8*, i8*, double, double)*}**, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}*** %glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVdPtr
ret {i8*, i8*, void (i8*, i8*, i8*, double, double)*}** %val3008
}


@glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, double, double)*}** @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, double, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd(i8* %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, double, double)*}*, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, double, double)*}, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, double, double)*}, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, double, double)*,  void (i8*, i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, double %arg_1, double %arg_2)
ret void
}


define dllexport ccc void @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_native(i8* %arg_0,double %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, double, double)*}*, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, double, double)*}, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, double, double)*}, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, double, double)*,  void (i8*, i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, double %arg_1, double %arg_2)
ret void
}


define dllexport ccc i8*  @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3009 = bitcast [122 x i8]* @gsxtmglfw3158 to i8*
call i32 (i8*, ...) @printf(i8* %var3009)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3010 = bitcast [122 x i8]* @gsxtmglfw3158 to i8*
call i32 (i8*, ...) @printf(i8* %var3010)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3011 = bitcast [122 x i8]* @gsxtmglfw3158 to i8*
call i32 (i8*, ...) @printf(i8* %var3011)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, double, double)*}*, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, double, double)*}, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, double, double)*}, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, double, double)*,  void (i8*, i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, double %arg_1, double %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, double, double}*
%arg_p_0 = getelementptr {i8*, double, double}, {i8*, double, double}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, double, double}, {i8*, double, double}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {i8*, double, double}, {i8*, double, double}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_cursor_position_callback_adhoc_W3ZvaWQsaTgqLGRvdWJsZSxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, double, double)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, double, double)*}*, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, double, double)*}, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, double, double)*}, {i8*, i8*, void (i8*, i8*, i8*, double, double)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, double, double)*,  void (i8*, i8*, i8*, double, double)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, double %arg_1, double %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3159 = hidden constant [40 x i8] c"window: %p button %d action %d mods %d
\00"
@gsxtmglfw3160 = hidden constant [64 x i8] c"glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ\00"
@gsxtmglfw3161 = hidden constant [51 x i8] c"{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}**\00"
define dllexport fastcc void @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ__3012(i8* %_impz,i8* %_impenv, i8* %window, i32 %button, i32 %action, i32 %mods) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3013 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}***}*
%glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQPtr = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}**** %glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQPtr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr
%buttonPtr = alloca i32
store i32 %button, i32* %buttonPtr
%actionPtr = alloca i32
store i32 %action, i32* %actionPtr
%modsPtr = alloca i32
store i32 %mods, i32* %modsPtr


%var3014 = bitcast [40 x i8]* @gsxtmglfw3159 to i8*
%val3015 = load i8*, i8** %windowPtr
%val3016 = load i32, i32* %buttonPtr
%val3017 = load i32, i32* %actionPtr
%val3018 = load i32, i32* %modsPtr

%val3019 = call i32 (i8*, ...) @printf(i8* %var3014, i8* %val3015, i32 %val3016, i32 %val3017, i32 %val3018)
ret void
}
@gsxtmglfw3162 = hidden constant [117 x i8] c"glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3040 = load i8*, i8** %_impzPtr
%zone3041 = bitcast i8* %tzone3040 to %mzone*

; let assign value to symbol glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ
%dat_glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone3041, i64 8)
%glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQPtr = bitcast i8* %dat_glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ to { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}***
%tzone3021 = load i8*, i8** %_impzPtr
%zone3022 = bitcast i8* %tzone3021 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3022)
; malloc closure structure
%clsptr3023 = call i8* @llvm_zone_malloc(%mzone* %zone3022, i64 24)
%closure3024 = bitcast i8* %clsptr3023 to { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}*

; malloc environment structure
%envptr3025 = call i8* @llvm_zone_malloc(%mzone* %zone3022, i64 8)
%environment3026 = bitcast i8* %envptr3025 to {{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}***}*

; malloc closure address table
%addytable3027 = call %clsvar* @new_address_table()
%var3028 = bitcast [64 x i8]* @gsxtmglfw3160 to i8*
%var3029 = bitcast [51 x i8]* @gsxtmglfw3161 to i8*
%addytable3030 = call %clsvar* @add_address_table(%mzone* %zone3022, i8* %var3028, i32 0, i8* %var3029, i32 3, %clsvar* %addytable3027)
%address-table3031 = bitcast %clsvar* %addytable3030 to i8*

; insert table, function and environment into closure struct
%closure.table3034 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}* %closure3024, i32 0, i32 0
store i8* %address-table3031, i8** %closure.table3034
%closure.env3035 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}* %closure3024, i32 0, i32 1
store i8* %envptr3025, i8** %closure.env3035
%closure.func3036 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}* %closure3024, i32 0, i32 2
store void (i8*, i8*, i8*, i32, i32, i32)* @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ__3012, void (i8*, i8*, i8*, i32, i32, i32)** %closure.func3036
%closure_size3037 = call i64 @llvm_zone_mark_size(%mzone* %zone3022)
call void @llvm_zone_ptr_set_size(i8* %clsptr3023, i64 %closure_size3037)
%wrapper_ptr3038 = call i8* @llvm_zone_malloc(%mzone* %zone3022, i64 8)
%closure_wrapper3039 = bitcast i8* %wrapper_ptr3038 to { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}* %closure3024, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** %closure_wrapper3039

; let value assignment
%glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** %closure_wrapper3039, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** %closure_wrapper3039
store { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** %glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ, { i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}*** %glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ
%tmp_envptr3033 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}***}* %environment3026, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}*** %glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQPtr, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}**** %tmp_envptr3033


%val3042 = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}*** %glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQPtr
ret {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** %val3042
}


@glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ(i8* %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32, i32, i32)*,  void (i8*, i8*, i8*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret void
}


define dllexport ccc void @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_native(i8* %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32, i32, i32)*,  void (i8*, i8*, i8*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret void
}


define dllexport ccc i8*  @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3043 = bitcast [117 x i8]* @gsxtmglfw3162 to i8*
call i32 (i8*, ...) @printf(i8* %var3043)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3044 = bitcast [117 x i8]* @gsxtmglfw3162 to i8*
call i32 (i8*, ...) @printf(i8* %var3044)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3045 = bitcast [117 x i8]* @gsxtmglfw3162 to i8*
call i32 (i8*, ...) @printf(i8* %var3045)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3046 = bitcast [117 x i8]* @gsxtmglfw3162 to i8*
call i32 (i8*, ...) @printf(i8* %var3046)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32, i32, i32)*,  void (i8*, i8*, i8*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i32, i32, i32}*
%arg_p_0 = getelementptr {i8*, i32, i32, i32}, {i8*, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i32, i32, i32}, {i8*, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i8*, i32, i32, i32}, {i8*, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i8*, i32, i32, i32}, {i8*, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_mouse_button_callback_adhoc_W3ZvaWQsaTgqLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i32, i32, i32)*,  void (i8*, i8*, i8*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3163 = hidden constant [53 x i8] c"glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ\00"
define dllexport fastcc i8* @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ__3047(i8* %_impz,i8* %_impenv, i32 %width, i32 %height) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3048 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}*
%glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr_

; setup arguments
%widthPtr = alloca i32
store i32 %width, i32* %widthPtr
%heightPtr = alloca i32
store i32 %height, i32* %heightPtr


%res3049 = call fastcc i32 @glfw_init_adhoc_W2kzMl0()
call fastcc void @glfw_set_core_profile_adhoc_W3ZvaWRd()
%tzone3054 = load i8*, i8** %_impzPtr
%zone3055 = bitcast i8* %tzone3054 to %mzone*

; let assign value to symbol window
%windowPtr = alloca i8*
%val3051 = load i32, i32* %widthPtr
%val3052 = load i32, i32* %heightPtr
%res3053 = call fastcc i8* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ(i32 %val3051, i32 %val3052)

; let value assignment
%window = select i1 true, i8* %res3053, i8* %res3053
store i8* %window, i8** %windowPtr

%val3056 = load i8*, i8** %windowPtr
call ccc void @glfwShowWindow(i8* %val3056)
%val3058 = load i8*, i8** %windowPtr
call ccc void @glfwMakeContextCurrent(i8* %val3058)
call ccc void @glfwSwapInterval(i32 1)
%val3061 = load i8*, i8** %windowPtr
call ccc void @glfwSwapBuffers(i8* %val3061)
%val3063 = load i8*, i8** %windowPtr
ret i8* %val3063
}
@gsxtmglfw3164 = hidden constant [106 x i8] c"glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3083 = load i8*, i8** %_impzPtr
%zone3084 = bitcast i8* %tzone3083 to %mzone*

; let assign value to symbol glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ
%dat_glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone3084, i64 8)
%glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr = bitcast i8* %dat_glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}***
%tzone3064 = load i8*, i8** %_impzPtr
%zone3065 = bitcast i8* %tzone3064 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3065)
; malloc closure structure
%clsptr3066 = call i8* @llvm_zone_malloc(%mzone* %zone3065, i64 24)
%closure3067 = bitcast i8* %clsptr3066 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr3068 = call i8* @llvm_zone_malloc(%mzone* %zone3065, i64 8)
%environment3069 = bitcast i8* %envptr3068 to {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable3070 = call %clsvar* @new_address_table()
%var3071 = bitcast [53 x i8]* @gsxtmglfw3163 to i8*
%var3072 = bitcast [40 x i8]* @gsxtmglfw3113 to i8*
%addytable3073 = call %clsvar* @add_address_table(%mzone* %zone3065, i8* %var3071, i32 0, i8* %var3072, i32 3, %clsvar* %addytable3070)
%address-table3074 = bitcast %clsvar* %addytable3073 to i8*

; insert table, function and environment into closure struct
%closure.table3077 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3067, i32 0, i32 0
store i8* %address-table3074, i8** %closure.table3077
%closure.env3078 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3067, i32 0, i32 1
store i8* %envptr3068, i8** %closure.env3078
%closure.func3079 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3067, i32 0, i32 2
store i8* (i8*, i8*, i32, i32)* @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ__3047, i8* (i8*, i8*, i32, i32)** %closure.func3079
%closure_size3080 = call i64 @llvm_zone_mark_size(%mzone* %zone3065)
call void @llvm_zone_ptr_set_size(i8* %clsptr3066, i64 %closure_size3080)
%wrapper_ptr3081 = call i8* @llvm_zone_malloc(%mzone* %zone3065, i64 8)
%closure_wrapper3082 = bitcast i8* %wrapper_ptr3081 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3067, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper3082

; let value assignment
%glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper3082, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper3082
store { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ
%tmp_envptr3076 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %environment3069, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %tmp_envptr3076


%val3085 = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQPtr
ret {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %val3085
}


@glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i8* %result
}


define dllexport ccc i8* @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i8* %result
}


define dllexport ccc i8*  @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3086 = bitcast [106 x i8]* @gsxtmglfw3164 to i8*
call i32 (i8*, ...) @printf(i8* %var3086)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3087 = bitcast [106 x i8]* @gsxtmglfw3164 to i8*
call i32 (i8*, ...) @printf(i8* %var3087)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3165 = hidden constant [67 x i8] c"glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ\00"
define dllexport fastcc i8* @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ__3088(i8* %_impz,i8* %_impenv, i32 %width, i32 %height) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3089 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}*
%glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr_

; setup arguments
%widthPtr = alloca i32
store i32 %width, i32* %widthPtr
%heightPtr = alloca i32
store i32 %height, i32* %heightPtr


%res3090 = call fastcc i32 @glfw_init_adhoc_W2kzMl0()
%tzone3094 = load i8*, i8** %_impzPtr
%zone3095 = bitcast i8* %tzone3094 to %mzone*

; let assign value to symbol window
%windowPtr = alloca i8*
%val3091 = load i32, i32* %widthPtr
%val3092 = load i32, i32* %heightPtr
%res3093 = call fastcc i8* @glfw_create_window_adhoc_W2k4KixpMzIsaTMyXQ(i32 %val3091, i32 %val3092)

; let value assignment
%window = select i1 true, i8* %res3093, i8* %res3093
store i8* %window, i8** %windowPtr

%val3096 = load i8*, i8** %windowPtr
call ccc void @glfwShowWindow(i8* %val3096)
%val3098 = load i8*, i8** %windowPtr
call ccc void @glfwMakeContextCurrent(i8* %val3098)
call ccc void @glfwSwapInterval(i32 1)
%val3101 = load i8*, i8** %windowPtr
call ccc void @glfwSwapBuffers(i8* %val3101)
%val3103 = load i8*, i8** %windowPtr
ret i8* %val3103
}
@gsxtmglfw3166 = hidden constant [120 x i8] c"glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3123 = load i8*, i8** %_impzPtr
%zone3124 = bitcast i8* %tzone3123 to %mzone*

; let assign value to symbol glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ
%dat_glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone3124, i64 8)
%glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr = bitcast i8* %dat_glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}***
%tzone3104 = load i8*, i8** %_impzPtr
%zone3105 = bitcast i8* %tzone3104 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3105)
; malloc closure structure
%clsptr3106 = call i8* @llvm_zone_malloc(%mzone* %zone3105, i64 24)
%closure3107 = bitcast i8* %clsptr3106 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr3108 = call i8* @llvm_zone_malloc(%mzone* %zone3105, i64 8)
%environment3109 = bitcast i8* %envptr3108 to {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable3110 = call %clsvar* @new_address_table()
%var3111 = bitcast [67 x i8]* @gsxtmglfw3165 to i8*
%var3112 = bitcast [40 x i8]* @gsxtmglfw3113 to i8*
%addytable3113 = call %clsvar* @add_address_table(%mzone* %zone3105, i8* %var3111, i32 0, i8* %var3112, i32 3, %clsvar* %addytable3110)
%address-table3114 = bitcast %clsvar* %addytable3113 to i8*

; insert table, function and environment into closure struct
%closure.table3117 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3107, i32 0, i32 0
store i8* %address-table3114, i8** %closure.table3117
%closure.env3118 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3107, i32 0, i32 1
store i8* %envptr3108, i8** %closure.env3118
%closure.func3119 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3107, i32 0, i32 2
store i8* (i8*, i8*, i32, i32)* @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ__3088, i8* (i8*, i8*, i32, i32)** %closure.func3119
%closure_size3120 = call i64 @llvm_zone_mark_size(%mzone* %zone3105)
call void @llvm_zone_ptr_set_size(i8* %clsptr3106, i64 %closure_size3120)
%wrapper_ptr3121 = call i8* @llvm_zone_malloc(%mzone* %zone3105, i64 8)
%closure_wrapper3122 = bitcast i8* %wrapper_ptr3121 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3107, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper3122

; let value assignment
%glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper3122, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper3122
store { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ
%tmp_envptr3116 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %environment3109, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %tmp_envptr3116


%val3125 = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr
ret {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %val3125
}


@glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i8* %result
}


define dllexport ccc i8* @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i8* %result
}


define dllexport ccc i8*  @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3126 = bitcast [120 x i8]* @gsxtmglfw3166 to i8*
call i32 (i8*, ...) @printf(i8* %var3126)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3127 = bitcast [120 x i8]* @gsxtmglfw3166 to i8*
call i32 (i8*, ...) @printf(i8* %var3127)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3167 = hidden constant [65 x i8] c"glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ\00"
define dllexport fastcc i8* @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ__3128(i8* %_impz,i8* %_impenv, i32 %width, i32 %height) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3129 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}*
%glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr_

; setup arguments
%widthPtr = alloca i32
store i32 %width, i32* %widthPtr
%heightPtr = alloca i32
store i32 %height, i32* %heightPtr


%res3130 = call fastcc i32 @glfw_init_adhoc_W2kzMl0()
call fastcc void @glfw_set_core_profile_adhoc_W3ZvaWRd()
%tzone3135 = load i8*, i8** %_impzPtr
%zone3136 = bitcast i8* %tzone3135 to %mzone*

; let assign value to symbol window
%windowPtr = alloca i8*
%val3132 = load i32, i32* %widthPtr
%val3133 = load i32, i32* %heightPtr
%res3134 = call fastcc i8* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ(i32 %val3132, i32 %val3133)

; let value assignment
%window = select i1 true, i8* %res3134, i8* %res3134
store i8* %window, i8** %windowPtr

%val3137 = load i8*, i8** %windowPtr
call ccc void @glfwShowWindow(i8* %val3137)
%val3139 = load i8*, i8** %windowPtr
call ccc void @glfwMakeContextCurrent(i8* %val3139)
call ccc void @glfwSwapInterval(i32 1)
%val3142 = load i8*, i8** %windowPtr
call ccc void @glfwSwapBuffers(i8* %val3142)
%val3144 = load i8*, i8** %windowPtr
ret i8* %val3144
}
@gsxtmglfw3168 = hidden constant [118 x i8] c"glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3164 = load i8*, i8** %_impzPtr
%zone3165 = bitcast i8* %tzone3164 to %mzone*

; let assign value to symbol glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ
%dat_glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone3165, i64 8)
%glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr = bitcast i8* %dat_glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}***
%tzone3145 = load i8*, i8** %_impzPtr
%zone3146 = bitcast i8* %tzone3145 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3146)
; malloc closure structure
%clsptr3147 = call i8* @llvm_zone_malloc(%mzone* %zone3146, i64 24)
%closure3148 = bitcast i8* %clsptr3147 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr3149 = call i8* @llvm_zone_malloc(%mzone* %zone3146, i64 8)
%environment3150 = bitcast i8* %envptr3149 to {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable3151 = call %clsvar* @new_address_table()
%var3152 = bitcast [65 x i8]* @gsxtmglfw3167 to i8*
%var3153 = bitcast [40 x i8]* @gsxtmglfw3113 to i8*
%addytable3154 = call %clsvar* @add_address_table(%mzone* %zone3146, i8* %var3152, i32 0, i8* %var3153, i32 3, %clsvar* %addytable3151)
%address-table3155 = bitcast %clsvar* %addytable3154 to i8*

; insert table, function and environment into closure struct
%closure.table3158 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3148, i32 0, i32 0
store i8* %address-table3155, i8** %closure.table3158
%closure.env3159 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3148, i32 0, i32 1
store i8* %envptr3149, i8** %closure.env3159
%closure.func3160 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3148, i32 0, i32 2
store i8* (i8*, i8*, i32, i32)* @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ__3128, i8* (i8*, i8*, i32, i32)** %closure.func3160
%closure_size3161 = call i64 @llvm_zone_mark_size(%mzone* %zone3146)
call void @llvm_zone_ptr_set_size(i8* %clsptr3147, i64 %closure_size3161)
%wrapper_ptr3162 = call i8* @llvm_zone_malloc(%mzone* %zone3146, i64 8)
%closure_wrapper3163 = bitcast i8* %wrapper_ptr3162 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3148, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper3163

; let value assignment
%glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper3163, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper3163
store { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ
%tmp_envptr3157 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %environment3150, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %tmp_envptr3157


%val3166 = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQPtr
ret {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %val3166
}


@glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i8* %result
}


define dllexport ccc i8* @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i8* %result
}


define dllexport ccc i8*  @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3167 = bitcast [118 x i8]* @gsxtmglfw3168 to i8*
call i32 (i8*, ...) @printf(i8* %var3167)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3168 = bitcast [118 x i8]* @gsxtmglfw3168 to i8*
call i32 (i8*, ...) @printf(i8* %var3168)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3169 = hidden constant [79 x i8] c"glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ\00"
define dllexport fastcc i8* @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ__3169(i8* %_impz,i8* %_impenv, i32 %width, i32 %height) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3170 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}*
%glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}***, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr_

; setup arguments
%widthPtr = alloca i32
store i32 %width, i32* %widthPtr
%heightPtr = alloca i32
store i32 %height, i32* %heightPtr


%res3171 = call fastcc i32 @glfw_init_adhoc_W2kzMl0()
%tzone3175 = load i8*, i8** %_impzPtr
%zone3176 = bitcast i8* %tzone3175 to %mzone*

; let assign value to symbol window
%windowPtr = alloca i8*
%val3172 = load i32, i32* %widthPtr
%val3173 = load i32, i32* %heightPtr
%res3174 = call fastcc i8* @glfw_create_interaction_window_adhoc_W2k4KixpMzIsaTMyXQ(i32 %val3172, i32 %val3173)

; let value assignment
%window = select i1 true, i8* %res3174, i8* %res3174
store i8* %window, i8** %windowPtr

%val3177 = load i8*, i8** %windowPtr
call ccc void @glfwShowWindow(i8* %val3177)
%val3179 = load i8*, i8** %windowPtr
call ccc void @glfwMakeContextCurrent(i8* %val3179)
call ccc void @glfwSwapInterval(i32 1)
%val3182 = load i8*, i8** %windowPtr
call ccc void @glfwSwapBuffers(i8* %val3182)
%val3184 = load i8*, i8** %windowPtr
ret i8* %val3184
}
@gsxtmglfw3170 = hidden constant [132 x i8] c"glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3204 = load i8*, i8** %_impzPtr
%zone3205 = bitcast i8* %tzone3204 to %mzone*

; let assign value to symbol glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ
%dat_glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone3205, i64 8)
%glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr = bitcast i8* %dat_glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}***
%tzone3185 = load i8*, i8** %_impzPtr
%zone3186 = bitcast i8* %tzone3185 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3186)
; malloc closure structure
%clsptr3187 = call i8* @llvm_zone_malloc(%mzone* %zone3186, i64 24)
%closure3188 = bitcast i8* %clsptr3187 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr3189 = call i8* @llvm_zone_malloc(%mzone* %zone3186, i64 8)
%environment3190 = bitcast i8* %envptr3189 to {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable3191 = call %clsvar* @new_address_table()
%var3192 = bitcast [79 x i8]* @gsxtmglfw3169 to i8*
%var3193 = bitcast [40 x i8]* @gsxtmglfw3113 to i8*
%addytable3194 = call %clsvar* @add_address_table(%mzone* %zone3186, i8* %var3192, i32 0, i8* %var3193, i32 3, %clsvar* %addytable3191)
%address-table3195 = bitcast %clsvar* %addytable3194 to i8*

; insert table, function and environment into closure struct
%closure.table3198 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3188, i32 0, i32 0
store i8* %address-table3195, i8** %closure.table3198
%closure.env3199 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3188, i32 0, i32 1
store i8* %envptr3189, i8** %closure.env3199
%closure.func3200 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3188, i32 0, i32 2
store i8* (i8*, i8*, i32, i32)* @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ__3169, i8* (i8*, i8*, i32, i32)** %closure.func3200
%closure_size3201 = call i64 @llvm_zone_mark_size(%mzone* %zone3186)
call void @llvm_zone_ptr_set_size(i8* %clsptr3187, i64 %closure_size3201)
%wrapper_ptr3202 = call i8* @llvm_zone_malloc(%mzone* %zone3186, i64 8)
%closure_wrapper3203 = bitcast i8* %wrapper_ptr3202 to { i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure3188, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper3203

; let value assignment
%glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper3203, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_wrapper3203
store { i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ, { i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ
%tmp_envptr3197 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32, i32)*}***}* %environment3190, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**** %tmp_envptr3197


%val3206 = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*** %glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQPtr
ret {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %val3206
}


@glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i8* %result
}


define dllexport ccc i8* @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i8* %result
}


define dllexport ccc i8*  @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3207 = bitcast [132 x i8]* @gsxtmglfw3170 to i8*
call i32 (i8*, ...) @printf(i8* %var3207)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3208 = bitcast [132 x i8]* @gsxtmglfw3170 to i8*
call i32 (i8*, ...) @printf(i8* %var3208)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_interaction_compatibility_window_adhoc_W2k4KixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32, i32)*,  i8* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3171 = hidden constant [58 x i8] c"glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd\00"
@gsxtmglfw3172 = hidden constant [35 x i8] c"{i8*, i8*, i8* (i8*, i8*, i32)*}**\00"
define dllexport fastcc i8* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd__3209(i8* %_impz,i8* %_impenv, i32 %monitor_idx) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3210 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i32)*}***}*
%glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJdPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJdPtr = load {i8*, i8*, i8* (i8*, i8*, i32)*}***, {i8*, i8*, i8* (i8*, i8*, i32)*}**** %glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJdPtr_

; setup arguments
%monitor_idxPtr = alloca i32
store i32 %monitor_idx, i32* %monitor_idxPtr

; promote local stack var allocations
%tzone3245 = load i8*, i8** %_impzPtr
%zone3246 = bitcast i8* %tzone3245 to %mzone*
%ifptr3220 = alloca i8*

%res3211 = call fastcc i32 @glfw_init_adhoc_W2kzMl0()
call fastcc void @glfw_set_core_profile_adhoc_W3ZvaWRd()
%tzone3214 = load i8*, i8** %_impzPtr
%zone3215 = bitcast i8* %tzone3214 to %mzone*

; let assign value to symbol num
%numPtr = alloca i32*
%tzone3218 = load i8*, i8** %_impzPtr
%zone3219 = bitcast i8* %tzone3218 to %mzone*

; let assign value to symbol monitors
%monitorsPtr = alloca i8**
%tzone3235 = load i8*, i8** %_impzPtr
%zone3236 = bitcast i8* %tzone3235 to %mzone*

; let assign value to symbol window
%windowPtr = alloca i8*
%dat3213 = alloca i32, align 16

; let value assignment
%num = select i1 true, i32* %dat3213, i32* %dat3213
store i32* %num, i32** %numPtr

%val3216 = load i32*, i32** %numPtr
%res3217 = call ccc i8** @glfwGetMonitors(i32* %val3216)

; let value assignment
%monitors = select i1 true, i8** %res3217, i8** %res3217
store i8** %monitors, i8*** %monitorsPtr

%val3221 = load i32, i32* %monitor_idxPtr
%val3222 = load i32*, i32** %numPtr
; pointer ref
%val3223 = getelementptr i32, i32* %val3222, i64 0
%val3224 = load i32, i32* %val3223
%cmp3225 = icmp slt i32 %val3221, %val3224
br i1 %cmp3225, label %then3220, label %else3220

then3220:
%val3226 = load i32, i32* %monitor_idxPtr
%val3227 = load i8**, i8*** %monitorsPtr
; pointer ref
%val3228 = getelementptr i8*, i8** %val3227, i32 %val3226
%val3229 = load i8*, i8** %val3228
store i8* %val3229, i8** %ifptr3220
br label %ifcont3220

else3220:
%val3230 = load i8**, i8*** %monitorsPtr
; pointer ref
%val3231 = getelementptr i8*, i8** %val3230, i64 0
%val3232 = load i8*, i8** %val3231
store i8* %val3232, i8** %ifptr3220
br label %ifcont3220

ifcont3220:
%ifres3233 = load i8*, i8** %ifptr3220

%res3234 = call fastcc i8* @glfw_create_fullscreen_window_adhoc_W2k4KixpOCpd(i8* %ifres3233)

; let value assignment
%window = select i1 true, i8* %res3234, i8* %res3234
store i8* %window, i8** %windowPtr

%val3237 = load i8*, i8** %windowPtr
call ccc void @glfwShowWindow(i8* %val3237)
%val3239 = load i8*, i8** %windowPtr
call ccc void @glfwMakeContextCurrent(i8* %val3239)
call ccc void @glfwSwapInterval(i32 1)
%val3242 = load i8*, i8** %windowPtr
call ccc void @glfwSwapBuffers(i8* %val3242)
%val3244 = load i8*, i8** %windowPtr
ret i8* %val3244
}
@gsxtmglfw3173 = hidden constant [111 x i8] c"glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i32)*}** @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3266 = load i8*, i8** %_impzPtr
%zone3267 = bitcast i8* %tzone3266 to %mzone*

; let assign value to symbol glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd
%dat_glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone3267, i64 8)
%glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJdPtr = bitcast i8* %dat_glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd to { i8*, i8*, i8* (i8*, i8*, i32)*}***
%tzone3247 = load i8*, i8** %_impzPtr
%zone3248 = bitcast i8* %tzone3247 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3248)
; malloc closure structure
%clsptr3249 = call i8* @llvm_zone_malloc(%mzone* %zone3248, i64 24)
%closure3250 = bitcast i8* %clsptr3249 to { i8*, i8*, i8* (i8*, i8*, i32)*}*

; malloc environment structure
%envptr3251 = call i8* @llvm_zone_malloc(%mzone* %zone3248, i64 8)
%environment3252 = bitcast i8* %envptr3251 to {{i8*, i8*, i8* (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable3253 = call %clsvar* @new_address_table()
%var3254 = bitcast [58 x i8]* @gsxtmglfw3171 to i8*
%var3255 = bitcast [35 x i8]* @gsxtmglfw3172 to i8*
%addytable3256 = call %clsvar* @add_address_table(%mzone* %zone3248, i8* %var3254, i32 0, i8* %var3255, i32 3, %clsvar* %addytable3253)
%address-table3257 = bitcast %clsvar* %addytable3256 to i8*

; insert table, function and environment into closure struct
%closure.table3260 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32)*}* %closure3250, i32 0, i32 0
store i8* %address-table3257, i8** %closure.table3260
%closure.env3261 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32)*}* %closure3250, i32 0, i32 1
store i8* %envptr3251, i8** %closure.env3261
%closure.func3262 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32)*}* %closure3250, i32 0, i32 2
store i8* (i8*, i8*, i32)* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd__3209, i8* (i8*, i8*, i32)** %closure.func3262
%closure_size3263 = call i64 @llvm_zone_mark_size(%mzone* %zone3248)
call void @llvm_zone_ptr_set_size(i8* %clsptr3249, i64 %closure_size3263)
%wrapper_ptr3264 = call i8* @llvm_zone_malloc(%mzone* %zone3248, i64 8)
%closure_wrapper3265 = bitcast i8* %wrapper_ptr3264 to { i8*, i8*, i8* (i8*, i8*, i32)*}**
store { i8*, i8*, i8* (i8*, i8*, i32)*}* %closure3250, { i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_wrapper3265

; let value assignment
%glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd = select i1 true, { i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_wrapper3265, { i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_wrapper3265
store { i8*, i8*, i8* (i8*, i8*, i32)*}** %glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd, { i8*, i8*, i8* (i8*, i8*, i32)*}*** %glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJdPtr

; add data to environment
; don't need to alloc for env var glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd
%tmp_envptr3259 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32)*}***}* %environment3252, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i32)*}*** %glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJdPtr, {i8*, i8*, i8* (i8*, i8*, i32)*}**** %tmp_envptr3259


%val3268 = load {i8*, i8*, i8* (i8*, i8*, i32)*}**, {i8*, i8*, i8* (i8*, i8*, i32)*}*** %glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJdPtr
ret {i8*, i8*, i8* (i8*, i8*, i32)*}** %val3268
}


@glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i32)*}** @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32)*,  i8* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret i8* %result
}


define dllexport ccc i8* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32)*,  i8* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3269 = bitcast [111 x i8]* @gsxtmglfw3173 to i8*
call i32 (i8*, ...) @printf(i8* %var3269)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32)*,  i8* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32)*,  i8* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3174 = hidden constant [53 x i8] c"glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0\00"
define dllexport fastcc i8* @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0__3270(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3271 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*)*}***}*
%glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0Ptr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0Ptr = load {i8*, i8*, i8* (i8*, i8*)*}***, {i8*, i8*, i8* (i8*, i8*)*}**** %glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0Ptr_

; setup arguments


%val3272 = trunc i64 0 to i32
%res3273 = call fastcc i8* @glfw_init_and_create_fullscreen_window_adhoc_W2k4KixpMzJd(i32 %val3272)
ret i8* %res3273
}
define dllexport ccc {i8*, i8*, i8* (i8*, i8*)*}** @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3293 = load i8*, i8** %_impzPtr
%zone3294 = bitcast i8* %tzone3293 to %mzone*

; let assign value to symbol glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0
%dat_glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3294, i64 8)
%glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0Ptr = bitcast i8* %dat_glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0 to { i8*, i8*, i8* (i8*, i8*)*}***
%tzone3274 = load i8*, i8** %_impzPtr
%zone3275 = bitcast i8* %tzone3274 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3275)
; malloc closure structure
%clsptr3276 = call i8* @llvm_zone_malloc(%mzone* %zone3275, i64 24)
%closure3277 = bitcast i8* %clsptr3276 to { i8*, i8*, i8* (i8*, i8*)*}*

; malloc environment structure
%envptr3278 = call i8* @llvm_zone_malloc(%mzone* %zone3275, i64 8)
%environment3279 = bitcast i8* %envptr3278 to {{i8*, i8*, i8* (i8*, i8*)*}***}*

; malloc closure address table
%addytable3280 = call %clsvar* @new_address_table()
%var3281 = bitcast [53 x i8]* @gsxtmglfw3174 to i8*
%var3282 = bitcast [30 x i8]* @gsxtmglfw3107 to i8*
%addytable3283 = call %clsvar* @add_address_table(%mzone* %zone3275, i8* %var3281, i32 0, i8* %var3282, i32 3, %clsvar* %addytable3280)
%address-table3284 = bitcast %clsvar* %addytable3283 to i8*

; insert table, function and environment into closure struct
%closure.table3287 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure3277, i32 0, i32 0
store i8* %address-table3284, i8** %closure.table3287
%closure.env3288 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure3277, i32 0, i32 1
store i8* %envptr3278, i8** %closure.env3288
%closure.func3289 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure3277, i32 0, i32 2
store i8* (i8*, i8*)* @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0__3270, i8* (i8*, i8*)** %closure.func3289
%closure_size3290 = call i64 @llvm_zone_mark_size(%mzone* %zone3275)
call void @llvm_zone_ptr_set_size(i8* %clsptr3276, i64 %closure_size3290)
%wrapper_ptr3291 = call i8* @llvm_zone_malloc(%mzone* %zone3275, i64 8)
%closure_wrapper3292 = bitcast i8* %wrapper_ptr3291 to { i8*, i8*, i8* (i8*, i8*)*}**
store { i8*, i8*, i8* (i8*, i8*)*}* %closure3277, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper3292

; let value assignment
%glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0 = select i1 true, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper3292, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper3292
store { i8*, i8*, i8* (i8*, i8*)*}** %glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0, { i8*, i8*, i8* (i8*, i8*)*}*** %glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0Ptr

; add data to environment
; don't need to alloc for env var glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0
%tmp_envptr3286 = getelementptr {{i8*, i8*, i8* (i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*)*}***}* %environment3279, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*)*}*** %glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0Ptr, {i8*, i8*, i8* (i8*, i8*)*}**** %tmp_envptr3286


%val3295 = load {i8*, i8*, i8* (i8*, i8*)*}**, {i8*, i8*, i8* (i8*, i8*)*}*** %glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0Ptr
ret {i8*, i8*, i8* (i8*, i8*)*}** %val3295
}


@glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*)*}** @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
ret i8* %result
}


define dllexport ccc i8* @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
ret i8* %result
}


define dllexport ccc i8*  @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3175 = hidden constant [70 x i8] c"glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd\00"
define dllexport fastcc i8* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd__3296(i8* %_impz,i8* %_impenv, i32 %monitor_idx) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3297 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i32)*}***}*
%glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJdPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJdPtr = load {i8*, i8*, i8* (i8*, i8*, i32)*}***, {i8*, i8*, i8* (i8*, i8*, i32)*}**** %glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJdPtr_

; setup arguments
%monitor_idxPtr = alloca i32
store i32 %monitor_idx, i32* %monitor_idxPtr

; promote local stack var allocations
%tzone3332 = load i8*, i8** %_impzPtr
%zone3333 = bitcast i8* %tzone3332 to %mzone*
%ifptr3307 = alloca i8*

%res3298 = call fastcc i32 @glfw_init_adhoc_W2kzMl0()
call fastcc void @glfw_set_core_profile_adhoc_W3ZvaWRd()
%tzone3301 = load i8*, i8** %_impzPtr
%zone3302 = bitcast i8* %tzone3301 to %mzone*

; let assign value to symbol num
%numPtr = alloca i32*
%tzone3305 = load i8*, i8** %_impzPtr
%zone3306 = bitcast i8* %tzone3305 to %mzone*

; let assign value to symbol monitors
%monitorsPtr = alloca i8**
%tzone3322 = load i8*, i8** %_impzPtr
%zone3323 = bitcast i8* %tzone3322 to %mzone*

; let assign value to symbol window
%windowPtr = alloca i8*
%dat3300 = alloca i32, align 16

; let value assignment
%num = select i1 true, i32* %dat3300, i32* %dat3300
store i32* %num, i32** %numPtr

%val3303 = load i32*, i32** %numPtr
%res3304 = call ccc i8** @glfwGetMonitors(i32* %val3303)

; let value assignment
%monitors = select i1 true, i8** %res3304, i8** %res3304
store i8** %monitors, i8*** %monitorsPtr

%val3308 = load i32, i32* %monitor_idxPtr
%val3309 = load i32*, i32** %numPtr
; pointer ref
%val3310 = getelementptr i32, i32* %val3309, i64 0
%val3311 = load i32, i32* %val3310
%cmp3312 = icmp slt i32 %val3308, %val3311
br i1 %cmp3312, label %then3307, label %else3307

then3307:
%val3313 = load i32, i32* %monitor_idxPtr
%val3314 = load i8**, i8*** %monitorsPtr
; pointer ref
%val3315 = getelementptr i8*, i8** %val3314, i32 %val3313
%val3316 = load i8*, i8** %val3315
store i8* %val3316, i8** %ifptr3307
br label %ifcont3307

else3307:
%val3317 = load i8**, i8*** %monitorsPtr
; pointer ref
%val3318 = getelementptr i8*, i8** %val3317, i64 0
%val3319 = load i8*, i8** %val3318
store i8* %val3319, i8** %ifptr3307
br label %ifcont3307

ifcont3307:
%ifres3320 = load i8*, i8** %ifptr3307

%res3321 = call fastcc i8* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd(i8* %ifres3320)

; let value assignment
%window = select i1 true, i8* %res3321, i8* %res3321
store i8* %window, i8** %windowPtr

%val3324 = load i8*, i8** %windowPtr
call ccc void @glfwShowWindow(i8* %val3324)
%val3326 = load i8*, i8** %windowPtr
call ccc void @glfwMakeContextCurrent(i8* %val3326)
call ccc void @glfwSwapInterval(i32 1)
%val3329 = load i8*, i8** %windowPtr
call ccc void @glfwSwapBuffers(i8* %val3329)
%val3331 = load i8*, i8** %windowPtr
ret i8* %val3331
}
@gsxtmglfw3176 = hidden constant [123 x i8] c"glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i32)*}** @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3353 = load i8*, i8** %_impzPtr
%zone3354 = bitcast i8* %tzone3353 to %mzone*

; let assign value to symbol glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd
%dat_glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone3354, i64 8)
%glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJdPtr = bitcast i8* %dat_glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd to { i8*, i8*, i8* (i8*, i8*, i32)*}***
%tzone3334 = load i8*, i8** %_impzPtr
%zone3335 = bitcast i8* %tzone3334 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3335)
; malloc closure structure
%clsptr3336 = call i8* @llvm_zone_malloc(%mzone* %zone3335, i64 24)
%closure3337 = bitcast i8* %clsptr3336 to { i8*, i8*, i8* (i8*, i8*, i32)*}*

; malloc environment structure
%envptr3338 = call i8* @llvm_zone_malloc(%mzone* %zone3335, i64 8)
%environment3339 = bitcast i8* %envptr3338 to {{i8*, i8*, i8* (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable3340 = call %clsvar* @new_address_table()
%var3341 = bitcast [70 x i8]* @gsxtmglfw3175 to i8*
%var3342 = bitcast [35 x i8]* @gsxtmglfw3172 to i8*
%addytable3343 = call %clsvar* @add_address_table(%mzone* %zone3335, i8* %var3341, i32 0, i8* %var3342, i32 3, %clsvar* %addytable3340)
%address-table3344 = bitcast %clsvar* %addytable3343 to i8*

; insert table, function and environment into closure struct
%closure.table3347 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32)*}* %closure3337, i32 0, i32 0
store i8* %address-table3344, i8** %closure.table3347
%closure.env3348 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32)*}* %closure3337, i32 0, i32 1
store i8* %envptr3338, i8** %closure.env3348
%closure.func3349 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32)*}* %closure3337, i32 0, i32 2
store i8* (i8*, i8*, i32)* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd__3296, i8* (i8*, i8*, i32)** %closure.func3349
%closure_size3350 = call i64 @llvm_zone_mark_size(%mzone* %zone3335)
call void @llvm_zone_ptr_set_size(i8* %clsptr3336, i64 %closure_size3350)
%wrapper_ptr3351 = call i8* @llvm_zone_malloc(%mzone* %zone3335, i64 8)
%closure_wrapper3352 = bitcast i8* %wrapper_ptr3351 to { i8*, i8*, i8* (i8*, i8*, i32)*}**
store { i8*, i8*, i8* (i8*, i8*, i32)*}* %closure3337, { i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_wrapper3352

; let value assignment
%glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd = select i1 true, { i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_wrapper3352, { i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_wrapper3352
store { i8*, i8*, i8* (i8*, i8*, i32)*}** %glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd, { i8*, i8*, i8* (i8*, i8*, i32)*}*** %glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJdPtr

; add data to environment
; don't need to alloc for env var glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd
%tmp_envptr3346 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32)*}***}* %environment3339, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i32)*}*** %glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJdPtr, {i8*, i8*, i8* (i8*, i8*, i32)*}**** %tmp_envptr3346


%val3355 = load {i8*, i8*, i8* (i8*, i8*, i32)*}**, {i8*, i8*, i8* (i8*, i8*, i32)*}*** %glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJdPtr
ret {i8*, i8*, i8* (i8*, i8*, i32)*}** %val3355
}


@glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i32)*}** @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32)*,  i8* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret i8* %result
}


define dllexport ccc i8* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32)*,  i8* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3356 = bitcast [123 x i8]* @gsxtmglfw3176 to i8*
call i32 (i8*, ...) @printf(i8* %var3356)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32)*,  i8* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32)*,  i8* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3177 = hidden constant [84 x i8] c"glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd\00"
define dllexport fastcc i8* @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd__3357(i8* %_impz,i8* %_impenv, i32 %monitor_idx) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3358 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i32)*}***}*
%glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJdPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJdPtr = load {i8*, i8*, i8* (i8*, i8*, i32)*}***, {i8*, i8*, i8* (i8*, i8*, i32)*}**** %glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJdPtr_

; setup arguments
%monitor_idxPtr = alloca i32
store i32 %monitor_idx, i32* %monitor_idxPtr

; promote local stack var allocations
%tzone3392 = load i8*, i8** %_impzPtr
%zone3393 = bitcast i8* %tzone3392 to %mzone*
%ifptr3367 = alloca i8*

%res3359 = call fastcc i32 @glfw_init_adhoc_W2kzMl0()
%tzone3361 = load i8*, i8** %_impzPtr
%zone3362 = bitcast i8* %tzone3361 to %mzone*

; let assign value to symbol num
%numPtr = alloca i32*
%tzone3365 = load i8*, i8** %_impzPtr
%zone3366 = bitcast i8* %tzone3365 to %mzone*

; let assign value to symbol monitors
%monitorsPtr = alloca i8**
%tzone3382 = load i8*, i8** %_impzPtr
%zone3383 = bitcast i8* %tzone3382 to %mzone*

; let assign value to symbol window
%windowPtr = alloca i8*
%dat3360 = alloca i32, align 16

; let value assignment
%num = select i1 true, i32* %dat3360, i32* %dat3360
store i32* %num, i32** %numPtr

%val3363 = load i32*, i32** %numPtr
%res3364 = call ccc i8** @glfwGetMonitors(i32* %val3363)

; let value assignment
%monitors = select i1 true, i8** %res3364, i8** %res3364
store i8** %monitors, i8*** %monitorsPtr

%val3368 = load i32, i32* %monitor_idxPtr
%val3369 = load i32*, i32** %numPtr
; pointer ref
%val3370 = getelementptr i32, i32* %val3369, i64 0
%val3371 = load i32, i32* %val3370
%cmp3372 = icmp slt i32 %val3368, %val3371
br i1 %cmp3372, label %then3367, label %else3367

then3367:
%val3373 = load i32, i32* %monitor_idxPtr
%val3374 = load i8**, i8*** %monitorsPtr
; pointer ref
%val3375 = getelementptr i8*, i8** %val3374, i32 %val3373
%val3376 = load i8*, i8** %val3375
store i8* %val3376, i8** %ifptr3367
br label %ifcont3367

else3367:
%val3377 = load i8**, i8*** %monitorsPtr
; pointer ref
%val3378 = getelementptr i8*, i8** %val3377, i64 0
%val3379 = load i8*, i8** %val3378
store i8* %val3379, i8** %ifptr3367
br label %ifcont3367

ifcont3367:
%ifres3380 = load i8*, i8** %ifptr3367

%res3381 = call fastcc i8* @glfw_create_fullscreen_interaction_window_adhoc_W2k4KixpOCpd(i8* %ifres3380)

; let value assignment
%window = select i1 true, i8* %res3381, i8* %res3381
store i8* %window, i8** %windowPtr

%val3384 = load i8*, i8** %windowPtr
call ccc void @glfwShowWindow(i8* %val3384)
%val3386 = load i8*, i8** %windowPtr
call ccc void @glfwMakeContextCurrent(i8* %val3386)
call ccc void @glfwSwapInterval(i32 1)
%val3389 = load i8*, i8** %windowPtr
call ccc void @glfwSwapBuffers(i8* %val3389)
%val3391 = load i8*, i8** %windowPtr
ret i8* %val3391
}
@gsxtmglfw3178 = hidden constant [137 x i8] c"glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i32)*}** @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3413 = load i8*, i8** %_impzPtr
%zone3414 = bitcast i8* %tzone3413 to %mzone*

; let assign value to symbol glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd
%dat_glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone3414, i64 8)
%glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJdPtr = bitcast i8* %dat_glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd to { i8*, i8*, i8* (i8*, i8*, i32)*}***
%tzone3394 = load i8*, i8** %_impzPtr
%zone3395 = bitcast i8* %tzone3394 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3395)
; malloc closure structure
%clsptr3396 = call i8* @llvm_zone_malloc(%mzone* %zone3395, i64 24)
%closure3397 = bitcast i8* %clsptr3396 to { i8*, i8*, i8* (i8*, i8*, i32)*}*

; malloc environment structure
%envptr3398 = call i8* @llvm_zone_malloc(%mzone* %zone3395, i64 8)
%environment3399 = bitcast i8* %envptr3398 to {{i8*, i8*, i8* (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable3400 = call %clsvar* @new_address_table()
%var3401 = bitcast [84 x i8]* @gsxtmglfw3177 to i8*
%var3402 = bitcast [35 x i8]* @gsxtmglfw3172 to i8*
%addytable3403 = call %clsvar* @add_address_table(%mzone* %zone3395, i8* %var3401, i32 0, i8* %var3402, i32 3, %clsvar* %addytable3400)
%address-table3404 = bitcast %clsvar* %addytable3403 to i8*

; insert table, function and environment into closure struct
%closure.table3407 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32)*}* %closure3397, i32 0, i32 0
store i8* %address-table3404, i8** %closure.table3407
%closure.env3408 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32)*}* %closure3397, i32 0, i32 1
store i8* %envptr3398, i8** %closure.env3408
%closure.func3409 = getelementptr { i8*, i8*, i8* (i8*, i8*, i32)*}, { i8*, i8*, i8* (i8*, i8*, i32)*}* %closure3397, i32 0, i32 2
store i8* (i8*, i8*, i32)* @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd__3357, i8* (i8*, i8*, i32)** %closure.func3409
%closure_size3410 = call i64 @llvm_zone_mark_size(%mzone* %zone3395)
call void @llvm_zone_ptr_set_size(i8* %clsptr3396, i64 %closure_size3410)
%wrapper_ptr3411 = call i8* @llvm_zone_malloc(%mzone* %zone3395, i64 8)
%closure_wrapper3412 = bitcast i8* %wrapper_ptr3411 to { i8*, i8*, i8* (i8*, i8*, i32)*}**
store { i8*, i8*, i8* (i8*, i8*, i32)*}* %closure3397, { i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_wrapper3412

; let value assignment
%glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd = select i1 true, { i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_wrapper3412, { i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_wrapper3412
store { i8*, i8*, i8* (i8*, i8*, i32)*}** %glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd, { i8*, i8*, i8* (i8*, i8*, i32)*}*** %glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJdPtr

; add data to environment
; don't need to alloc for env var glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd
%tmp_envptr3406 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i32)*}***}, {{i8*, i8*, i8* (i8*, i8*, i32)*}***}* %environment3399, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i32)*}*** %glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJdPtr, {i8*, i8*, i8* (i8*, i8*, i32)*}**** %tmp_envptr3406


%val3415 = load {i8*, i8*, i8* (i8*, i8*, i32)*}**, {i8*, i8*, i8* (i8*, i8*, i32)*}*** %glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJdPtr
ret {i8*, i8*, i8* (i8*, i8*, i32)*}** %val3415
}


@glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i32)*}** @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32)*,  i8* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret i8* %result
}


define dllexport ccc i8* @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32)*,  i8* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3416 = bitcast [137 x i8]* @gsxtmglfw3178 to i8*
call i32 (i8*, ...) @printf(i8* %var3416)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32)*,  i8* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_compatibility_window_adhoc_W2k4KixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i32)*}*, {i8*, i8*, i8* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i32)*}, {i8*, i8*, i8* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i32)*,  i8* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3179 = hidden constant [65 x i8] c"glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0\00"
define dllexport fastcc i8* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0__3417(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3418 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*)*}***}*
%glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr = load {i8*, i8*, i8* (i8*, i8*)*}***, {i8*, i8*, i8* (i8*, i8*)*}**** %glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr_

; setup arguments


%val3419 = trunc i64 0 to i32
%res3420 = call fastcc i8* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4KixpMzJd(i32 %val3419)
ret i8* %res3420
}
define dllexport ccc {i8*, i8*, i8* (i8*, i8*)*}** @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3440 = load i8*, i8** %_impzPtr
%zone3441 = bitcast i8* %tzone3440 to %mzone*

; let assign value to symbol glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0
%dat_glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3441, i64 8)
%glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr = bitcast i8* %dat_glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0 to { i8*, i8*, i8* (i8*, i8*)*}***
%tzone3421 = load i8*, i8** %_impzPtr
%zone3422 = bitcast i8* %tzone3421 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3422)
; malloc closure structure
%clsptr3423 = call i8* @llvm_zone_malloc(%mzone* %zone3422, i64 24)
%closure3424 = bitcast i8* %clsptr3423 to { i8*, i8*, i8* (i8*, i8*)*}*

; malloc environment structure
%envptr3425 = call i8* @llvm_zone_malloc(%mzone* %zone3422, i64 8)
%environment3426 = bitcast i8* %envptr3425 to {{i8*, i8*, i8* (i8*, i8*)*}***}*

; malloc closure address table
%addytable3427 = call %clsvar* @new_address_table()
%var3428 = bitcast [65 x i8]* @gsxtmglfw3179 to i8*
%var3429 = bitcast [30 x i8]* @gsxtmglfw3107 to i8*
%addytable3430 = call %clsvar* @add_address_table(%mzone* %zone3422, i8* %var3428, i32 0, i8* %var3429, i32 3, %clsvar* %addytable3427)
%address-table3431 = bitcast %clsvar* %addytable3430 to i8*

; insert table, function and environment into closure struct
%closure.table3434 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure3424, i32 0, i32 0
store i8* %address-table3431, i8** %closure.table3434
%closure.env3435 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure3424, i32 0, i32 1
store i8* %envptr3425, i8** %closure.env3435
%closure.func3436 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure3424, i32 0, i32 2
store i8* (i8*, i8*)* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0__3417, i8* (i8*, i8*)** %closure.func3436
%closure_size3437 = call i64 @llvm_zone_mark_size(%mzone* %zone3422)
call void @llvm_zone_ptr_set_size(i8* %clsptr3423, i64 %closure_size3437)
%wrapper_ptr3438 = call i8* @llvm_zone_malloc(%mzone* %zone3422, i64 8)
%closure_wrapper3439 = bitcast i8* %wrapper_ptr3438 to { i8*, i8*, i8* (i8*, i8*)*}**
store { i8*, i8*, i8* (i8*, i8*)*}* %closure3424, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper3439

; let value assignment
%glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0 = select i1 true, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper3439, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper3439
store { i8*, i8*, i8* (i8*, i8*)*}** %glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0, { i8*, i8*, i8* (i8*, i8*)*}*** %glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr

; add data to environment
; don't need to alloc for env var glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0
%tmp_envptr3433 = getelementptr {{i8*, i8*, i8* (i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*)*}***}* %environment3426, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*)*}*** %glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr, {i8*, i8*, i8* (i8*, i8*)*}**** %tmp_envptr3433


%val3442 = load {i8*, i8*, i8* (i8*, i8*)*}**, {i8*, i8*, i8* (i8*, i8*)*}*** %glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0Ptr
ret {i8*, i8*, i8* (i8*, i8*)*}** %val3442
}


@glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*)*}** @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
ret i8* %result
}


define dllexport ccc i8* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
ret i8* %result
}


define dllexport ccc i8*  @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_interaction_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3180 = hidden constant [67 x i8] c"glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0\00"
define dllexport fastcc i8* @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0__3443(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3444 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*)*}***}*
%glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0Ptr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0Ptr = load {i8*, i8*, i8* (i8*, i8*)*}***, {i8*, i8*, i8* (i8*, i8*)*}**** %glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0Ptr_

; setup arguments


%res3445 = call fastcc i32 @glfw_init_adhoc_W2kzMl0()
%tzone3447 = load i8*, i8** %_impzPtr
%zone3448 = bitcast i8* %tzone3447 to %mzone*

; let assign value to symbol window
%windowPtr = alloca i8*
%res3446 = call fastcc i8* @glfw_create_fullscreen_window_adhoc_W2k4Kl0()

; let value assignment
%window = select i1 true, i8* %res3446, i8* %res3446
store i8* %window, i8** %windowPtr

%val3449 = load i8*, i8** %windowPtr
call ccc void @glfwShowWindow(i8* %val3449)
%val3451 = load i8*, i8** %windowPtr
call ccc void @glfwMakeContextCurrent(i8* %val3451)
call ccc void @glfwSwapInterval(i32 1)
%val3454 = load i8*, i8** %windowPtr
call ccc void @glfwSwapBuffers(i8* %val3454)
%val3456 = load i8*, i8** %windowPtr
ret i8* %val3456
}
define dllexport ccc {i8*, i8*, i8* (i8*, i8*)*}** @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3476 = load i8*, i8** %_impzPtr
%zone3477 = bitcast i8* %tzone3476 to %mzone*

; let assign value to symbol glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0
%dat_glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3477, i64 8)
%glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0Ptr = bitcast i8* %dat_glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0 to { i8*, i8*, i8* (i8*, i8*)*}***
%tzone3457 = load i8*, i8** %_impzPtr
%zone3458 = bitcast i8* %tzone3457 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3458)
; malloc closure structure
%clsptr3459 = call i8* @llvm_zone_malloc(%mzone* %zone3458, i64 24)
%closure3460 = bitcast i8* %clsptr3459 to { i8*, i8*, i8* (i8*, i8*)*}*

; malloc environment structure
%envptr3461 = call i8* @llvm_zone_malloc(%mzone* %zone3458, i64 8)
%environment3462 = bitcast i8* %envptr3461 to {{i8*, i8*, i8* (i8*, i8*)*}***}*

; malloc closure address table
%addytable3463 = call %clsvar* @new_address_table()
%var3464 = bitcast [67 x i8]* @gsxtmglfw3180 to i8*
%var3465 = bitcast [30 x i8]* @gsxtmglfw3107 to i8*
%addytable3466 = call %clsvar* @add_address_table(%mzone* %zone3458, i8* %var3464, i32 0, i8* %var3465, i32 3, %clsvar* %addytable3463)
%address-table3467 = bitcast %clsvar* %addytable3466 to i8*

; insert table, function and environment into closure struct
%closure.table3470 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure3460, i32 0, i32 0
store i8* %address-table3467, i8** %closure.table3470
%closure.env3471 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure3460, i32 0, i32 1
store i8* %envptr3461, i8** %closure.env3471
%closure.func3472 = getelementptr { i8*, i8*, i8* (i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*)*}* %closure3460, i32 0, i32 2
store i8* (i8*, i8*)* @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0__3443, i8* (i8*, i8*)** %closure.func3472
%closure_size3473 = call i64 @llvm_zone_mark_size(%mzone* %zone3458)
call void @llvm_zone_ptr_set_size(i8* %clsptr3459, i64 %closure_size3473)
%wrapper_ptr3474 = call i8* @llvm_zone_malloc(%mzone* %zone3458, i64 8)
%closure_wrapper3475 = bitcast i8* %wrapper_ptr3474 to { i8*, i8*, i8* (i8*, i8*)*}**
store { i8*, i8*, i8* (i8*, i8*)*}* %closure3460, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper3475

; let value assignment
%glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0 = select i1 true, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper3475, { i8*, i8*, i8* (i8*, i8*)*}** %closure_wrapper3475
store { i8*, i8*, i8* (i8*, i8*)*}** %glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0, { i8*, i8*, i8* (i8*, i8*)*}*** %glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0Ptr

; add data to environment
; don't need to alloc for env var glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0
%tmp_envptr3469 = getelementptr {{i8*, i8*, i8* (i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*)*}***}* %environment3462, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*)*}*** %glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0Ptr, {i8*, i8*, i8* (i8*, i8*)*}**** %tmp_envptr3469


%val3478 = load {i8*, i8*, i8* (i8*, i8*)*}**, {i8*, i8*, i8* (i8*, i8*)*}*** %glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0Ptr
ret {i8*, i8*, i8* (i8*, i8*)*}** %val3478
}


@glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*)*}** @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
ret i8* %result
}


define dllexport ccc i8* @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
ret i8* %result
}


define dllexport ccc i8*  @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_init_and_create_fullscreen_compatibility_window_adhoc_W2k4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*)*,  i8* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3181 = hidden constant [41 x i8] c"glfw_get_window_width_adhoc_W2kzMixpOCpd\00"
define dllexport fastcc i32 @glfw_get_window_width_adhoc_W2kzMixpOCpd__3479(i8* %_impz,i8* %_impenv, i8* %window) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3480 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}*
%glfw_get_window_width_adhoc_W2kzMixpOCpdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_get_window_width_adhoc_W2kzMixpOCpdPtr = load {i8*, i8*, i32 (i8*, i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %glfw_get_window_width_adhoc_W2kzMixpOCpdPtr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr


%tzone3482 = load i8*, i8** %_impzPtr
%zone3483 = bitcast i8* %tzone3482 to %mzone*

; let assign value to symbol width_ptr
%width_ptrPtr = alloca i32*
%dat3481 = alloca i32, align 16

; let value assignment
%width_ptr = select i1 true, i32* %dat3481, i32* %dat3481
store i32* %width_ptr, i32** %width_ptrPtr

%val3484 = load i8*, i8** %windowPtr
%val3485 = load i32*, i32** %width_ptrPtr
%null3486 = bitcast i8* null to i32*
call ccc void @glfwGetWindowSize(i8* %val3484, i32* %val3485, i32* %null3486)
%val3488 = load i32*, i32** %width_ptrPtr
; pointer ref
%val3489 = getelementptr i32, i32* %val3488, i64 0
%val3490 = load i32, i32* %val3489
ret i32 %val3490
}
@gsxtmglfw3182 = hidden constant [94 x i8] c"glfw_get_window_width_adhoc_W2kzMixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i8*)*}** @glfw_get_window_width_adhoc_W2kzMixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3510 = load i8*, i8** %_impzPtr
%zone3511 = bitcast i8* %tzone3510 to %mzone*

; let assign value to symbol glfw_get_window_width_adhoc_W2kzMixpOCpd
%dat_glfw_get_window_width_adhoc_W2kzMixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone3511, i64 8)
%glfw_get_window_width_adhoc_W2kzMixpOCpdPtr = bitcast i8* %dat_glfw_get_window_width_adhoc_W2kzMixpOCpd to { i8*, i8*, i32 (i8*, i8*, i8*)*}***
%tzone3491 = load i8*, i8** %_impzPtr
%zone3492 = bitcast i8* %tzone3491 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3492)
; malloc closure structure
%clsptr3493 = call i8* @llvm_zone_malloc(%mzone* %zone3492, i64 24)
%closure3494 = bitcast i8* %clsptr3493 to { i8*, i8*, i32 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3495 = call i8* @llvm_zone_malloc(%mzone* %zone3492, i64 8)
%environment3496 = bitcast i8* %envptr3495 to {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3497 = call %clsvar* @new_address_table()
%var3498 = bitcast [41 x i8]* @gsxtmglfw3181 to i8*
%var3499 = bitcast [35 x i8]* @gsxtmglfw3120 to i8*
%addytable3500 = call %clsvar* @add_address_table(%mzone* %zone3492, i8* %var3498, i32 0, i8* %var3499, i32 3, %clsvar* %addytable3497)
%address-table3501 = bitcast %clsvar* %addytable3500 to i8*

; insert table, function and environment into closure struct
%closure.table3504 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3494, i32 0, i32 0
store i8* %address-table3501, i8** %closure.table3504
%closure.env3505 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3494, i32 0, i32 1
store i8* %envptr3495, i8** %closure.env3505
%closure.func3506 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3494, i32 0, i32 2
store i32 (i8*, i8*, i8*)* @glfw_get_window_width_adhoc_W2kzMixpOCpd__3479, i32 (i8*, i8*, i8*)** %closure.func3506
%closure_size3507 = call i64 @llvm_zone_mark_size(%mzone* %zone3492)
call void @llvm_zone_ptr_set_size(i8* %clsptr3493, i64 %closure_size3507)
%wrapper_ptr3508 = call i8* @llvm_zone_malloc(%mzone* %zone3492, i64 8)
%closure_wrapper3509 = bitcast i8* %wrapper_ptr3508 to { i8*, i8*, i32 (i8*, i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3494, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper3509

; let value assignment
%glfw_get_window_width_adhoc_W2kzMixpOCpd = select i1 true, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper3509, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper3509
store { i8*, i8*, i32 (i8*, i8*, i8*)*}** %glfw_get_window_width_adhoc_W2kzMixpOCpd, { i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_get_window_width_adhoc_W2kzMixpOCpdPtr

; add data to environment
; don't need to alloc for env var glfw_get_window_width_adhoc_W2kzMixpOCpd
%tmp_envptr3503 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}* %environment3496, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_get_window_width_adhoc_W2kzMixpOCpdPtr, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %tmp_envptr3503


%val3512 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_get_window_width_adhoc_W2kzMixpOCpdPtr
ret {i8*, i8*, i32 (i8*, i8*, i8*)*}** %val3512
}


@glfw_get_window_width_adhoc_W2kzMixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_get_window_width_adhoc_W2kzMixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_get_window_width_adhoc_W2kzMixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_window_width_adhoc_W2kzMixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i8*)*}** @glfw_get_window_width_adhoc_W2kzMixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_get_window_width_adhoc_W2kzMixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_get_window_width_adhoc_W2kzMixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_window_width_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @glfw_get_window_width_adhoc_W2kzMixpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_window_width_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @glfw_get_window_width_adhoc_W2kzMixpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_window_width_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @glfw_get_window_width_adhoc_W2kzMixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3513 = bitcast [94 x i8]* @gsxtmglfw3182 to i8*
call i32 (i8*, ...) @printf(i8* %var3513)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_window_width_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @glfw_get_window_width_adhoc_W2kzMixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_window_width_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3183 = hidden constant [42 x i8] c"glfw_get_window_height_adhoc_W2kzMixpOCpd\00"
define dllexport fastcc i32 @glfw_get_window_height_adhoc_W2kzMixpOCpd__3514(i8* %_impz,i8* %_impenv, i8* %window) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3515 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}*
%glfw_get_window_height_adhoc_W2kzMixpOCpdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_get_window_height_adhoc_W2kzMixpOCpdPtr = load {i8*, i8*, i32 (i8*, i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %glfw_get_window_height_adhoc_W2kzMixpOCpdPtr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr


%tzone3517 = load i8*, i8** %_impzPtr
%zone3518 = bitcast i8* %tzone3517 to %mzone*

; let assign value to symbol height_ptr
%height_ptrPtr = alloca i32*
%dat3516 = alloca i32, align 16

; let value assignment
%height_ptr = select i1 true, i32* %dat3516, i32* %dat3516
store i32* %height_ptr, i32** %height_ptrPtr

%val3519 = load i8*, i8** %windowPtr
%null3520 = bitcast i8* null to i32*
%val3521 = load i32*, i32** %height_ptrPtr
call ccc void @glfwGetWindowSize(i8* %val3519, i32* %null3520, i32* %val3521)
%val3523 = load i32*, i32** %height_ptrPtr
; pointer ref
%val3524 = getelementptr i32, i32* %val3523, i64 0
%val3525 = load i32, i32* %val3524
ret i32 %val3525
}
@gsxtmglfw3184 = hidden constant [95 x i8] c"glfw_get_window_height_adhoc_W2kzMixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i8*)*}** @glfw_get_window_height_adhoc_W2kzMixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3545 = load i8*, i8** %_impzPtr
%zone3546 = bitcast i8* %tzone3545 to %mzone*

; let assign value to symbol glfw_get_window_height_adhoc_W2kzMixpOCpd
%dat_glfw_get_window_height_adhoc_W2kzMixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone3546, i64 8)
%glfw_get_window_height_adhoc_W2kzMixpOCpdPtr = bitcast i8* %dat_glfw_get_window_height_adhoc_W2kzMixpOCpd to { i8*, i8*, i32 (i8*, i8*, i8*)*}***
%tzone3526 = load i8*, i8** %_impzPtr
%zone3527 = bitcast i8* %tzone3526 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3527)
; malloc closure structure
%clsptr3528 = call i8* @llvm_zone_malloc(%mzone* %zone3527, i64 24)
%closure3529 = bitcast i8* %clsptr3528 to { i8*, i8*, i32 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3530 = call i8* @llvm_zone_malloc(%mzone* %zone3527, i64 8)
%environment3531 = bitcast i8* %envptr3530 to {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3532 = call %clsvar* @new_address_table()
%var3533 = bitcast [42 x i8]* @gsxtmglfw3183 to i8*
%var3534 = bitcast [35 x i8]* @gsxtmglfw3120 to i8*
%addytable3535 = call %clsvar* @add_address_table(%mzone* %zone3527, i8* %var3533, i32 0, i8* %var3534, i32 3, %clsvar* %addytable3532)
%address-table3536 = bitcast %clsvar* %addytable3535 to i8*

; insert table, function and environment into closure struct
%closure.table3539 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3529, i32 0, i32 0
store i8* %address-table3536, i8** %closure.table3539
%closure.env3540 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3529, i32 0, i32 1
store i8* %envptr3530, i8** %closure.env3540
%closure.func3541 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3529, i32 0, i32 2
store i32 (i8*, i8*, i8*)* @glfw_get_window_height_adhoc_W2kzMixpOCpd__3514, i32 (i8*, i8*, i8*)** %closure.func3541
%closure_size3542 = call i64 @llvm_zone_mark_size(%mzone* %zone3527)
call void @llvm_zone_ptr_set_size(i8* %clsptr3528, i64 %closure_size3542)
%wrapper_ptr3543 = call i8* @llvm_zone_malloc(%mzone* %zone3527, i64 8)
%closure_wrapper3544 = bitcast i8* %wrapper_ptr3543 to { i8*, i8*, i32 (i8*, i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3529, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper3544

; let value assignment
%glfw_get_window_height_adhoc_W2kzMixpOCpd = select i1 true, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper3544, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper3544
store { i8*, i8*, i32 (i8*, i8*, i8*)*}** %glfw_get_window_height_adhoc_W2kzMixpOCpd, { i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_get_window_height_adhoc_W2kzMixpOCpdPtr

; add data to environment
; don't need to alloc for env var glfw_get_window_height_adhoc_W2kzMixpOCpd
%tmp_envptr3538 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}* %environment3531, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_get_window_height_adhoc_W2kzMixpOCpdPtr, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %tmp_envptr3538


%val3547 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_get_window_height_adhoc_W2kzMixpOCpdPtr
ret {i8*, i8*, i32 (i8*, i8*, i8*)*}** %val3547
}


@glfw_get_window_height_adhoc_W2kzMixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_get_window_height_adhoc_W2kzMixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_get_window_height_adhoc_W2kzMixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_window_height_adhoc_W2kzMixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i8*)*}** @glfw_get_window_height_adhoc_W2kzMixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_get_window_height_adhoc_W2kzMixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_get_window_height_adhoc_W2kzMixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_window_height_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @glfw_get_window_height_adhoc_W2kzMixpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_window_height_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @glfw_get_window_height_adhoc_W2kzMixpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_window_height_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @glfw_get_window_height_adhoc_W2kzMixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3548 = bitcast [95 x i8]* @gsxtmglfw3184 to i8*
call i32 (i8*, ...) @printf(i8* %var3548)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_window_height_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @glfw_get_window_height_adhoc_W2kzMixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_window_height_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3185 = hidden constant [46 x i8] c"glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd\00"
define dllexport fastcc i32 @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd__3549(i8* %_impz,i8* %_impenv, i8* %window) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3550 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}*
%glfw_get_framebuffer_width_adhoc_W2kzMixpOCpdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_get_framebuffer_width_adhoc_W2kzMixpOCpdPtr = load {i8*, i8*, i32 (i8*, i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %glfw_get_framebuffer_width_adhoc_W2kzMixpOCpdPtr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr


%tzone3552 = load i8*, i8** %_impzPtr
%zone3553 = bitcast i8* %tzone3552 to %mzone*

; let assign value to symbol width_ptr
%width_ptrPtr = alloca i32*
%dat3551 = alloca i32, align 16

; let value assignment
%width_ptr = select i1 true, i32* %dat3551, i32* %dat3551
store i32* %width_ptr, i32** %width_ptrPtr

%val3554 = load i8*, i8** %windowPtr
%val3555 = load i32*, i32** %width_ptrPtr
%null3556 = bitcast i8* null to i32*
call ccc void @glfwGetFramebufferSize(i8* %val3554, i32* %val3555, i32* %null3556)
%val3558 = load i32*, i32** %width_ptrPtr
; pointer ref
%val3559 = getelementptr i32, i32* %val3558, i64 0
%val3560 = load i32, i32* %val3559
ret i32 %val3560
}
@gsxtmglfw3186 = hidden constant [99 x i8] c"glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i8*)*}** @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3580 = load i8*, i8** %_impzPtr
%zone3581 = bitcast i8* %tzone3580 to %mzone*

; let assign value to symbol glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd
%dat_glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone3581, i64 8)
%glfw_get_framebuffer_width_adhoc_W2kzMixpOCpdPtr = bitcast i8* %dat_glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd to { i8*, i8*, i32 (i8*, i8*, i8*)*}***
%tzone3561 = load i8*, i8** %_impzPtr
%zone3562 = bitcast i8* %tzone3561 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3562)
; malloc closure structure
%clsptr3563 = call i8* @llvm_zone_malloc(%mzone* %zone3562, i64 24)
%closure3564 = bitcast i8* %clsptr3563 to { i8*, i8*, i32 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3565 = call i8* @llvm_zone_malloc(%mzone* %zone3562, i64 8)
%environment3566 = bitcast i8* %envptr3565 to {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3567 = call %clsvar* @new_address_table()
%var3568 = bitcast [46 x i8]* @gsxtmglfw3185 to i8*
%var3569 = bitcast [35 x i8]* @gsxtmglfw3120 to i8*
%addytable3570 = call %clsvar* @add_address_table(%mzone* %zone3562, i8* %var3568, i32 0, i8* %var3569, i32 3, %clsvar* %addytable3567)
%address-table3571 = bitcast %clsvar* %addytable3570 to i8*

; insert table, function and environment into closure struct
%closure.table3574 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3564, i32 0, i32 0
store i8* %address-table3571, i8** %closure.table3574
%closure.env3575 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3564, i32 0, i32 1
store i8* %envptr3565, i8** %closure.env3575
%closure.func3576 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3564, i32 0, i32 2
store i32 (i8*, i8*, i8*)* @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd__3549, i32 (i8*, i8*, i8*)** %closure.func3576
%closure_size3577 = call i64 @llvm_zone_mark_size(%mzone* %zone3562)
call void @llvm_zone_ptr_set_size(i8* %clsptr3563, i64 %closure_size3577)
%wrapper_ptr3578 = call i8* @llvm_zone_malloc(%mzone* %zone3562, i64 8)
%closure_wrapper3579 = bitcast i8* %wrapper_ptr3578 to { i8*, i8*, i32 (i8*, i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3564, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper3579

; let value assignment
%glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd = select i1 true, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper3579, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper3579
store { i8*, i8*, i32 (i8*, i8*, i8*)*}** %glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd, { i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_get_framebuffer_width_adhoc_W2kzMixpOCpdPtr

; add data to environment
; don't need to alloc for env var glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd
%tmp_envptr3573 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}* %environment3566, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_get_framebuffer_width_adhoc_W2kzMixpOCpdPtr, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %tmp_envptr3573


%val3582 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_get_framebuffer_width_adhoc_W2kzMixpOCpdPtr
ret {i8*, i8*, i32 (i8*, i8*, i8*)*}** %val3582
}


@glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i8*)*}** @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3583 = bitcast [99 x i8]* @gsxtmglfw3186 to i8*
call i32 (i8*, ...) @printf(i8* %var3583)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_framebuffer_width_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3187 = hidden constant [47 x i8] c"glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd\00"
define dllexport fastcc i32 @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd__3584(i8* %_impz,i8* %_impenv, i8* %window) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3585 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}*
%glfw_get_framebuffer_height_adhoc_W2kzMixpOCpdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_get_framebuffer_height_adhoc_W2kzMixpOCpdPtr = load {i8*, i8*, i32 (i8*, i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %glfw_get_framebuffer_height_adhoc_W2kzMixpOCpdPtr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr


%tzone3587 = load i8*, i8** %_impzPtr
%zone3588 = bitcast i8* %tzone3587 to %mzone*

; let assign value to symbol height_ptr
%height_ptrPtr = alloca i32*
%dat3586 = alloca i32, align 16

; let value assignment
%height_ptr = select i1 true, i32* %dat3586, i32* %dat3586
store i32* %height_ptr, i32** %height_ptrPtr

%val3589 = load i8*, i8** %windowPtr
%null3590 = bitcast i8* null to i32*
%val3591 = load i32*, i32** %height_ptrPtr
call ccc void @glfwGetFramebufferSize(i8* %val3589, i32* %null3590, i32* %val3591)
%val3593 = load i32*, i32** %height_ptrPtr
; pointer ref
%val3594 = getelementptr i32, i32* %val3593, i64 0
%val3595 = load i32, i32* %val3594
ret i32 %val3595
}
@gsxtmglfw3188 = hidden constant [100 x i8] c"glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i8*)*}** @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3615 = load i8*, i8** %_impzPtr
%zone3616 = bitcast i8* %tzone3615 to %mzone*

; let assign value to symbol glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd
%dat_glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone3616, i64 8)
%glfw_get_framebuffer_height_adhoc_W2kzMixpOCpdPtr = bitcast i8* %dat_glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd to { i8*, i8*, i32 (i8*, i8*, i8*)*}***
%tzone3596 = load i8*, i8** %_impzPtr
%zone3597 = bitcast i8* %tzone3596 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3597)
; malloc closure structure
%clsptr3598 = call i8* @llvm_zone_malloc(%mzone* %zone3597, i64 24)
%closure3599 = bitcast i8* %clsptr3598 to { i8*, i8*, i32 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3600 = call i8* @llvm_zone_malloc(%mzone* %zone3597, i64 8)
%environment3601 = bitcast i8* %envptr3600 to {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3602 = call %clsvar* @new_address_table()
%var3603 = bitcast [47 x i8]* @gsxtmglfw3187 to i8*
%var3604 = bitcast [35 x i8]* @gsxtmglfw3120 to i8*
%addytable3605 = call %clsvar* @add_address_table(%mzone* %zone3597, i8* %var3603, i32 0, i8* %var3604, i32 3, %clsvar* %addytable3602)
%address-table3606 = bitcast %clsvar* %addytable3605 to i8*

; insert table, function and environment into closure struct
%closure.table3609 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3599, i32 0, i32 0
store i8* %address-table3606, i8** %closure.table3609
%closure.env3610 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3599, i32 0, i32 1
store i8* %envptr3600, i8** %closure.env3610
%closure.func3611 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3599, i32 0, i32 2
store i32 (i8*, i8*, i8*)* @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd__3584, i32 (i8*, i8*, i8*)** %closure.func3611
%closure_size3612 = call i64 @llvm_zone_mark_size(%mzone* %zone3597)
call void @llvm_zone_ptr_set_size(i8* %clsptr3598, i64 %closure_size3612)
%wrapper_ptr3613 = call i8* @llvm_zone_malloc(%mzone* %zone3597, i64 8)
%closure_wrapper3614 = bitcast i8* %wrapper_ptr3613 to { i8*, i8*, i32 (i8*, i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure3599, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper3614

; let value assignment
%glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd = select i1 true, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper3614, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper3614
store { i8*, i8*, i32 (i8*, i8*, i8*)*}** %glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd, { i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_get_framebuffer_height_adhoc_W2kzMixpOCpdPtr

; add data to environment
; don't need to alloc for env var glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd
%tmp_envptr3608 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}* %environment3601, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_get_framebuffer_height_adhoc_W2kzMixpOCpdPtr, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %tmp_envptr3608


%val3617 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %glfw_get_framebuffer_height_adhoc_W2kzMixpOCpdPtr
ret {i8*, i8*, i32 (i8*, i8*, i8*)*}** %val3617
}


@glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i8*)*}** @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3618 = bitcast [100 x i8]* @gsxtmglfw3188 to i8*
call i32 (i8*, ...) @printf(i8* %var3618)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_framebuffer_height_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmglfw3189 = hidden constant [43 x i8] c"glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0\00"
@gsxtmglfw3190 = hidden constant [37 x i8] c"{i8*, i8*, float (i8*, i8*, i8*)*}**\00"
define dllexport fastcc float @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0__3619(i8* %_impz,i8* %_impenv, i8* %window) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3620 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, i8*)*}***}*
%glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0Ptr_ = getelementptr {{i8*, i8*, float (i8*, i8*, i8*)*}***}, {{i8*, i8*, float (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0Ptr = load {i8*, i8*, float (i8*, i8*, i8*)*}***, {i8*, i8*, float (i8*, i8*, i8*)*}**** %glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0Ptr_

; setup arguments
%windowPtr = alloca i8*
store i8* %window, i8** %windowPtr


%tzone3625 = load i8*, i8** %_impzPtr
%zone3626 = bitcast i8* %tzone3625 to %mzone*

; let assign value to symbol ww
%wwPtr = alloca i32*
%tzone3631 = load i8*, i8** %_impzPtr
%zone3632 = bitcast i8* %tzone3631 to %mzone*

; let assign value to symbol wh
%whPtr = alloca i32*
%tzone3637 = load i8*, i8** %_impzPtr
%zone3638 = bitcast i8* %tzone3637 to %mzone*

; let assign value to symbol fbw
%fbwPtr = alloca i32*
%tzone3643 = load i8*, i8** %_impzPtr
%zone3644 = bitcast i8* %tzone3643 to %mzone*

; let assign value to symbol fbh
%fbhPtr = alloca i32*
%tzone3621 = load i8*, i8** %_impzPtr
%zone3622 = bitcast i8* %tzone3621 to %mzone*
%dat3623 = call i8* @llvm_zone_malloc(%mzone* %zone3622, i64 4)
call i8* @memset(i8* %dat3623, i32 0, i64 4)
%val3624 = bitcast i8* %dat3623 to i32*

; let value assignment
%ww = select i1 true, i32* %val3624, i32* %val3624
store i32* %ww, i32** %wwPtr

%tzone3627 = load i8*, i8** %_impzPtr
%zone3628 = bitcast i8* %tzone3627 to %mzone*
%dat3629 = call i8* @llvm_zone_malloc(%mzone* %zone3628, i64 4)
call i8* @memset(i8* %dat3629, i32 0, i64 4)
%val3630 = bitcast i8* %dat3629 to i32*

; let value assignment
%wh = select i1 true, i32* %val3630, i32* %val3630
store i32* %wh, i32** %whPtr

%tzone3633 = load i8*, i8** %_impzPtr
%zone3634 = bitcast i8* %tzone3633 to %mzone*
%dat3635 = call i8* @llvm_zone_malloc(%mzone* %zone3634, i64 4)
call i8* @memset(i8* %dat3635, i32 0, i64 4)
%val3636 = bitcast i8* %dat3635 to i32*

; let value assignment
%fbw = select i1 true, i32* %val3636, i32* %val3636
store i32* %fbw, i32** %fbwPtr

%tzone3639 = load i8*, i8** %_impzPtr
%zone3640 = bitcast i8* %tzone3639 to %mzone*
%dat3641 = call i8* @llvm_zone_malloc(%mzone* %zone3640, i64 4)
call i8* @memset(i8* %dat3641, i32 0, i64 4)
%val3642 = bitcast i8* %dat3641 to i32*

; let value assignment
%fbh = select i1 true, i32* %val3642, i32* %val3642
store i32* %fbh, i32** %fbhPtr

%val3645 = load i8*, i8** %windowPtr
%val3646 = load i32*, i32** %wwPtr
%val3647 = load i32*, i32** %whPtr
call ccc void @glfwGetWindowSize(i8* %val3645, i32* %val3646, i32* %val3647)
%val3649 = load i8*, i8** %windowPtr
%val3650 = load i32*, i32** %fbwPtr
%val3651 = load i32*, i32** %fbhPtr
call ccc void @glfwGetFramebufferSize(i8* %val3649, i32* %val3650, i32* %val3651)
%val3653 = load i32*, i32** %fbwPtr
%val13654 = ptrtoint i32* %val3653 to i64
%val3655 = sitofp i64 %val13654 to float
%val3656 = load i32*, i32** %wwPtr
%val13657 = ptrtoint i32* %val3656 to i64
%val3658 = sitofp i64 %val13657 to float
%val3659 = fdiv float %val3655, %val3658
ret float %val3659
}
@gsxtmglfw3191 = hidden constant [96 x i8] c"glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, i8*)*}** @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3679 = load i8*, i8** %_impzPtr
%zone3680 = bitcast i8* %tzone3679 to %mzone*

; let assign value to symbol glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0
%dat_glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3680, i64 8)
%glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0Ptr = bitcast i8* %dat_glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0 to { i8*, i8*, float (i8*, i8*, i8*)*}***
%tzone3660 = load i8*, i8** %_impzPtr
%zone3661 = bitcast i8* %tzone3660 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3661)
; malloc closure structure
%clsptr3662 = call i8* @llvm_zone_malloc(%mzone* %zone3661, i64 24)
%closure3663 = bitcast i8* %clsptr3662 to { i8*, i8*, float (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3664 = call i8* @llvm_zone_malloc(%mzone* %zone3661, i64 8)
%environment3665 = bitcast i8* %envptr3664 to {{i8*, i8*, float (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3666 = call %clsvar* @new_address_table()
%var3667 = bitcast [43 x i8]* @gsxtmglfw3189 to i8*
%var3668 = bitcast [37 x i8]* @gsxtmglfw3190 to i8*
%addytable3669 = call %clsvar* @add_address_table(%mzone* %zone3661, i8* %var3667, i32 0, i8* %var3668, i32 3, %clsvar* %addytable3666)
%address-table3670 = bitcast %clsvar* %addytable3669 to i8*

; insert table, function and environment into closure struct
%closure.table3673 = getelementptr { i8*, i8*, float (i8*, i8*, i8*)*}, { i8*, i8*, float (i8*, i8*, i8*)*}* %closure3663, i32 0, i32 0
store i8* %address-table3670, i8** %closure.table3673
%closure.env3674 = getelementptr { i8*, i8*, float (i8*, i8*, i8*)*}, { i8*, i8*, float (i8*, i8*, i8*)*}* %closure3663, i32 0, i32 1
store i8* %envptr3664, i8** %closure.env3674
%closure.func3675 = getelementptr { i8*, i8*, float (i8*, i8*, i8*)*}, { i8*, i8*, float (i8*, i8*, i8*)*}* %closure3663, i32 0, i32 2
store float (i8*, i8*, i8*)* @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0__3619, float (i8*, i8*, i8*)** %closure.func3675
%closure_size3676 = call i64 @llvm_zone_mark_size(%mzone* %zone3661)
call void @llvm_zone_ptr_set_size(i8* %clsptr3662, i64 %closure_size3676)
%wrapper_ptr3677 = call i8* @llvm_zone_malloc(%mzone* %zone3661, i64 8)
%closure_wrapper3678 = bitcast i8* %wrapper_ptr3677 to { i8*, i8*, float (i8*, i8*, i8*)*}**
store { i8*, i8*, float (i8*, i8*, i8*)*}* %closure3663, { i8*, i8*, float (i8*, i8*, i8*)*}** %closure_wrapper3678

; let value assignment
%glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0 = select i1 true, { i8*, i8*, float (i8*, i8*, i8*)*}** %closure_wrapper3678, { i8*, i8*, float (i8*, i8*, i8*)*}** %closure_wrapper3678
store { i8*, i8*, float (i8*, i8*, i8*)*}** %glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0, { i8*, i8*, float (i8*, i8*, i8*)*}*** %glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0
%tmp_envptr3672 = getelementptr {{i8*, i8*, float (i8*, i8*, i8*)*}***}, {{i8*, i8*, float (i8*, i8*, i8*)*}***}* %environment3665, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, i8*)*}*** %glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0Ptr, {i8*, i8*, float (i8*, i8*, i8*)*}**** %tmp_envptr3672


%val3681 = load {i8*, i8*, float (i8*, i8*, i8*)*}**, {i8*, i8*, float (i8*, i8*, i8*)*}*** %glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0Ptr
ret {i8*, i8*, float (i8*, i8*, i8*)*}** %val3681
}


@glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, i8*)*}** @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, float (i8*, i8*, i8*)*}*, {i8*, i8*, float (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, i8*)*}, {i8*, i8*, float (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, i8*)*}, {i8*, i8*, float (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, i8*)*,  float (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret float %result
}


define dllexport ccc float @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, float (i8*, i8*, i8*)*}*, {i8*, i8*, float (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, i8*)*}, {i8*, i8*, float (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, i8*)*}, {i8*, i8*, float (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, i8*)*,  float (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret float %result
}


define dllexport ccc i8*  @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3682 = bitcast [96 x i8]* @gsxtmglfw3191 to i8*
call i32 (i8*, ...) @printf(i8* %var3682)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, float (i8*, i8*, i8*)*}*, {i8*, i8*, float (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, i8*)*}, {i8*, i8*, float (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, i8*)*}, {i8*, i8*, float (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, i8*)*,  float (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @glfw_get_pixel_ratio_adhoc_W2Zsb2F0LGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, float (i8*, i8*, i8*)*}*, {i8*, i8*, float (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, i8*)*}, {i8*, i8*, float (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, i8*)*}, {i8*, i8*, float (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, i8*)*,  float (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


