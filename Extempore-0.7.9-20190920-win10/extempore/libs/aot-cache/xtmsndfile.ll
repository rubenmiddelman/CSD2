@SF_FORMAT_WAV = dllexport global i32 65536
@SF_FORMAT_AIFF = dllexport global i32 131072
@SF_FORMAT_AU = dllexport global i32 196608
@SF_FORMAT_RAW = dllexport global i32 262144
@SF_FORMAT_PAF = dllexport global i32 327680
@SF_FORMAT_SVX = dllexport global i32 393216
@SF_FORMAT_NIST = dllexport global i32 458752
@SF_FORMAT_VOC = dllexport global i32 524288
@SF_FORMAT_IRCAM = dllexport global i32 655360
@SF_FORMAT_W64 = dllexport global i32 720896
@SF_FORMAT_MAT4 = dllexport global i32 786432
@SF_FORMAT_MAT5 = dllexport global i32 851968
@SF_FORMAT_PVF = dllexport global i32 917504
@SF_FORMAT_XI = dllexport global i32 983040
@SF_FORMAT_HTK = dllexport global i32 1048576
@SF_FORMAT_SDS = dllexport global i32 1114112
@SF_FORMAT_AVR = dllexport global i32 1179648
@SF_FORMAT_WAVEX = dllexport global i32 1245184
@SF_FORMAT_SD2 = dllexport global i32 1441792
@SF_FORMAT_FLAC = dllexport global i32 1507328
@SF_FORMAT_CAF = dllexport global i32 1572864
@SF_FORMAT_WVE = dllexport global i32 1638400
@SF_FORMAT_OGG = dllexport global i32 2097152
@SF_FORMAT_MPC2K = dllexport global i32 2162688
@SF_FORMAT_RF64 = dllexport global i32 2228224
@SF_FORMAT_PCM_S8 = dllexport global i32 1
@SF_FORMAT_PCM_16 = dllexport global i32 2
@SF_FORMAT_PCM_24 = dllexport global i32 3
@SF_FORMAT_PCM_32 = dllexport global i32 4
@SF_FORMAT_PCM_U8 = dllexport global i32 5
@SF_FORMAT_FLOAT = dllexport global i32 6
@SF_FORMAT_DOUBLE = dllexport global i32 7
@SF_FORMAT_ULAW = dllexport global i32 16
@SF_FORMAT_ALAW = dllexport global i32 17
@SF_FORMAT_IMA_ADPCM = dllexport global i32 18
@SF_FORMAT_MS_ADPCM = dllexport global i32 19
@SF_FORMAT_GSM610 = dllexport global i32 32
@SF_FORMAT_VOX_ADPCM = dllexport global i32 33
@SF_FORMAT_G721_32 = dllexport global i32 48
@SF_FORMAT_G723_24 = dllexport global i32 49
@SF_FORMAT_G723_40 = dllexport global i32 50
@SF_FORMAT_DWVW_12 = dllexport global i32 64
@SF_FORMAT_DWVW_16 = dllexport global i32 65
@SF_FORMAT_DWVW_24 = dllexport global i32 66
@SF_FORMAT_DWVW_N = dllexport global i32 67
@SF_FORMAT_DPCM_8 = dllexport global i32 80
@SF_FORMAT_DPCM_16 = dllexport global i32 81
@SF_FORMAT_VORBIS = dllexport global i32 96
@SF_ENDIAN_FILE = dllexport global i32 0
@SF_ENDIAN_LITTLE = dllexport global i32 268435456
@SF_ENDIAN_BIG = dllexport global i32 536870912
@SF_ENDIAN_CPU = dllexport global i32 805306368
@SF_FORMAT_SUBMASK = dllexport global i32 65535
@SF_FORMAT_TYPEMASK = dllexport global i32 268369920
@SF_FORMAT_ENDMASK = dllexport global i32 805306368
@SFC_GET_LIB_VERSION = dllexport global i32 4096
@SFC_GET_LOG_INFO = dllexport global i32 4097
@SFC_GET_CURRENT_SF_INFO = dllexport global i32 4098
@SFC_GET_NORM_DOUBLE = dllexport global i32 4112
@SFC_GET_NORM_FLOAT = dllexport global i32 4113
@SFC_SET_NORM_DOUBLE = dllexport global i32 4114
@SFC_SET_NORM_FLOAT = dllexport global i32 4115
@SFC_SET_SCALE_FLOAT_INT_READ = dllexport global i32 4116
@SFC_SET_SCALE_INT_FLOAT_WRITE = dllexport global i32 4117
@SFC_GET_SIMPLE_FORMAT_COUNT = dllexport global i32 4128
@SFC_GET_SIMPLE_FORMAT = dllexport global i32 4129
@SFC_GET_FORMAT_INFO = dllexport global i32 4136
@SFC_GET_FORMAT_MAJOR_COUNT = dllexport global i32 4144
@SFC_GET_FORMAT_MAJOR = dllexport global i32 4145
@SFC_GET_FORMAT_SUBTYPE_COUNT = dllexport global i32 4146
@SFC_GET_FORMAT_SUBTYPE = dllexport global i32 4147
@SFC_CALC_SIGNAL_MAX = dllexport global i32 4160
@SFC_CALC_NORM_SIGNAL_MAX = dllexport global i32 4161
@SFC_CALC_MAX_ALL_CHANNELS = dllexport global i32 4162
@SFC_CALC_NORM_MAX_ALL_CHANNELS = dllexport global i32 4163
@SFC_GET_SIGNAL_MAX = dllexport global i32 4164
@SFC_GET_MAX_ALL_CHANNELS = dllexport global i32 4165
@SFC_SET_ADD_PEAK_CHUNK = dllexport global i32 4176
@SFC_SET_ADD_HEADER_PAD_CHUNK = dllexport global i32 4177
@SFC_UPDATE_HEADER_NOW = dllexport global i32 4192
@SFC_SET_UPDATE_HEADER_AUTO = dllexport global i32 4193
@SFC_FILE_TRUNCATE = dllexport global i32 4224
@SFC_SET_RAW_START_OFFSET = dllexport global i32 4240
@SFC_SET_DITHER_ON_WRITE = dllexport global i32 4256
@SFC_SET_DITHER_ON_READ = dllexport global i32 4257
@SFC_GET_DITHER_INFO_COUNT = dllexport global i32 4258
@SFC_GET_DITHER_INFO = dllexport global i32 4259
@SFC_GET_EMBED_FILE_INFO = dllexport global i32 4272
@SFC_SET_CLIPPING = dllexport global i32 4288
@SFC_GET_CLIPPING = dllexport global i32 4289
@SFC_GET_INSTRUMENT = dllexport global i32 4304
@SFC_SET_INSTRUMENT = dllexport global i32 4305
@SFC_GET_LOOP_INFO = dllexport global i32 4320
@SFC_GET_BROADCAST_INFO = dllexport global i32 4336
@SFC_SET_BROADCAST_INFO = dllexport global i32 4337
@SFC_GET_CHANNEL_MAP_INFO = dllexport global i32 4352
@SFC_SET_CHANNEL_MAP_INFO = dllexport global i32 4353
@SFC_RAW_DATA_NEEDS_ENDSWAP = dllexport global i32 4368
@SFC_WAVEX_SET_AMBISONIC = dllexport global i32 4608
@SFC_WAVEX_GET_AMBISONIC = dllexport global i32 4609
@SFC_SET_VBR_ENCODING_QUALITY = dllexport global i32 4864
@SFC_TEST_IEEE_FLOAT_REPLACE = dllexport global i32 24577
@SFC_SET_ADD_DITHER_ON_WRITE = dllexport global i32 4208
@SFC_SET_ADD_DITHER_ON_READ = dllexport global i32 4209
@SF_STR_TITLE = dllexport global i32 1
@SF_STR_COPYRIGHT = dllexport global i32 2
@SF_STR_SOFTWARE = dllexport global i32 3
@SF_STR_ARTIST = dllexport global i32 4
@SF_STR_COMMENT = dllexport global i32 5
@SF_STR_DATE = dllexport global i32 6
@SF_STR_ALBUM = dllexport global i32 7
@SF_STR_LICENSE = dllexport global i32 8
@SF_STR_TRACKNUMBER = dllexport global i32 9
@SF_STR_GENRE = dllexport global i32 16
@SF_STR_FIRST = dllexport global i32 zeroinitializer
@SF_STR_LAST = dllexport global i32 zeroinitializer
@SF_FALSE = dllexport global i32 0
@SF_TRUE = dllexport global i32 1
@SFM_READ = dllexport global i32 16
@SFM_WRITE = dllexport global i32 32
@SFM_RDWR = dllexport global i32 48
@SF_AMBISONIC_NONE = dllexport global i32 64
@SF_AMBISONIC_B_FORMAT = dllexport global i32 4
@SF_ERR_NO_ERROR = dllexport global i32 0
@SF_ERR_UNRECOGNISED_FORMAT = dllexport global i32 1
@SF_ERR_SYSTEM = dllexport global i32 2
@SF_ERR_MALFORMED_FILE = dllexport global i32 3
@SF_ERR_UNSUPPORTED_ENCODING = dllexport global i32 4
@SF_CHANNEL_MAP_INVALID = dllexport global i32 0
@SF_CHANNEL_MAP_MONO = dllexport global i32 1
@SF_CHANNEL_MAP_LEFT = dllexport global i32 2
@SF_CHANNEL_MAP_RIGHT = dllexport global i32 3
@SF_CHANNEL_MAP_CENTER = dllexport global i32 4
@SF_CHANNEL_MAP_FRONT_LEFT = dllexport global i32 5
@SF_CHANNEL_MAP_FRONT_RIGHT = dllexport global i32 6
@SF_CHANNEL_MAP_FRONT_CENTER = dllexport global i32 7
@SF_CHANNEL_MAP_REAR_CENTER = dllexport global i32 8
@SF_CHANNEL_MAP_REAR_LEFT = dllexport global i32 9
@SF_CHANNEL_MAP_REAR_RIGHT = dllexport global i32 10
@SF_CHANNEL_MAP_LFE = dllexport global i32 11
@SF_CHANNEL_MAP_FRONT_LEFT_OF_CENTER = dllexport global i32 12
@SF_CHANNEL_MAP_FRONT_RIGHT_OF_CENTER = dllexport global i32 13
@SF_CHANNEL_MAP_SIDE_LEFT = dllexport global i32 14
@SF_CHANNEL_MAP_SIDE_RIGHT = dllexport global i32 15
@SF_CHANNEL_MAP_TOP_CENTER = dllexport global i32 16
@SF_CHANNEL_MAP_TOP_FRONT_LEFT = dllexport global i32 17
@SF_CHANNEL_MAP_TOP_FRONT_RIGHT = dllexport global i32 18
@SF_CHANNEL_MAP_TOP_FRONT_CENTER = dllexport global i32 19
@SF_CHANNEL_MAP_TOP_REAR_LEFT = dllexport global i32 20
@SF_CHANNEL_MAP_TOP_REAR_RIGHT = dllexport global i32 21
@SF_CHANNEL_MAP_TOP_REAR_CENTER = dllexport global i32 22
@SF_CHANNEL_MAP_AMBISONIC_B_W = dllexport global i32 23
@SF_CHANNEL_MAP_AMBISONIC_B_X = dllexport global i32 24
@SF_CHANNEL_MAP_AMBISONIC_B_Y = dllexport global i32 25
@SF_CHANNEL_MAP_AMBISONIC_B_Z = dllexport global i32 26
@SF_CHANNEL_MAP_MAX = dllexport global i32 27
@SF_COUNT_MAX = dllexport global i64 -1
%SF_INFO = type {i64,i32,i32,i32,i32,i32}
@gsxtmsndfile0 = hidden constant [61 x i8] c"SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ\00"
@gsxtmsndfile1 = hidden constant [66 x i8] c"{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**\00"
define dllexport fastcc %SF_INFO* @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ__1(i8* %_impz,i8* %_impenv, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}*
%SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**** %SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr


%tzone7 = load i8*, i8** %_impzPtr
%zone8 = bitcast i8* %tzone7 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_INFO*
%tzone3 = load i8*, i8** %_impzPtr
%zone4 = bitcast i8* %tzone3 to %mzone*
%dat5 = call i8* @llvm_zone_malloc(%mzone* %zone4, i64 28)
call i8* @memset(i8* %dat5, i32 0, i64 28)
%val6 = bitcast i8* %dat5 to %SF_INFO*

; let value assignment
%obj = select i1 true, %SF_INFO* %val6, %SF_INFO* %val6
store %SF_INFO* %obj, %SF_INFO** %objPtr

%val9 = load %SF_INFO*, %SF_INFO** %objPtr
%val10 = load i64, i64* %arg_0Ptr
; set tuple
%val11 = getelementptr %SF_INFO, %SF_INFO* %val9, i64 0, i32 0
store i64 %val10, i64* %val11
%val12 = load %SF_INFO*, %SF_INFO** %objPtr
%val13 = load i32, i32* %arg_1Ptr
; set tuple
%val14 = getelementptr %SF_INFO, %SF_INFO* %val12, i64 0, i32 1
store i32 %val13, i32* %val14
%val15 = load %SF_INFO*, %SF_INFO** %objPtr
%val16 = load i32, i32* %arg_2Ptr
; set tuple
%val17 = getelementptr %SF_INFO, %SF_INFO* %val15, i64 0, i32 2
store i32 %val16, i32* %val17
%val18 = load %SF_INFO*, %SF_INFO** %objPtr
%val19 = load i32, i32* %arg_3Ptr
; set tuple
%val20 = getelementptr %SF_INFO, %SF_INFO* %val18, i64 0, i32 3
store i32 %val19, i32* %val20
%val21 = load %SF_INFO*, %SF_INFO** %objPtr
%val22 = load i32, i32* %arg_4Ptr
; set tuple
%val23 = getelementptr %SF_INFO, %SF_INFO* %val21, i64 0, i32 4
store i32 %val22, i32* %val23
%val24 = load %SF_INFO*, %SF_INFO** %objPtr
%val25 = load i32, i32* %arg_5Ptr
; set tuple
%val26 = getelementptr %SF_INFO, %SF_INFO* %val24, i64 0, i32 5
store i32 %val25, i32* %val26
%val27 = load %SF_INFO*, %SF_INFO** %objPtr
ret %SF_INFO* %val27
}
@gsxtmsndfile2 = hidden constant [114 x i8] c"SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone47 = load i8*, i8** %_impzPtr
%zone48 = bitcast i8* %tzone47 to %mzone*

; let assign value to symbol SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ
%dat_SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone48, i64 8)
%SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr = bitcast i8* %dat_SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ to { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***
%tzone28 = load i8*, i8** %_impzPtr
%zone29 = bitcast i8* %tzone28 to %mzone*
call void @llvm_zone_mark(%mzone* %zone29)
; malloc closure structure
%clsptr30 = call i8* @llvm_zone_malloc(%mzone* %zone29, i64 24)
%closure31 = bitcast i8* %clsptr30 to { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr32 = call i8* @llvm_zone_malloc(%mzone* %zone29, i64 8)
%environment33 = bitcast i8* %envptr32 to {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable34 = call %clsvar* @new_address_table()
%var35 = bitcast [61 x i8]* @gsxtmsndfile0 to i8*
%var36 = bitcast [66 x i8]* @gsxtmsndfile1 to i8*
%addytable37 = call %clsvar* @add_address_table(%mzone* %zone29, i8* %var35, i32 0, i8* %var36, i32 3, %clsvar* %addytable34)
%address-table38 = bitcast %clsvar* %addytable37 to i8*

; insert table, function and environment into closure struct
%closure.table41 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure31, i32 0, i32 0
store i8* %address-table38, i8** %closure.table41
%closure.env42 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure31, i32 0, i32 1
store i8* %envptr32, i8** %closure.env42
%closure.func43 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure31, i32 0, i32 2
store %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)* @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ__1, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %closure.func43
%closure_size44 = call i64 @llvm_zone_mark_size(%mzone* %zone29)
call void @llvm_zone_ptr_set_size(i8* %clsptr30, i64 %closure_size44)
%wrapper_ptr45 = call i8* @llvm_zone_malloc(%mzone* %zone29, i64 8)
%closure_wrapper46 = bitcast i8* %wrapper_ptr45 to { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure31, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_wrapper46

; let value assignment
%SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ = select i1 true, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_wrapper46, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_wrapper46
store { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*** %SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ
%tmp_envptr40 = getelementptr {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}* %environment33, i32 0, i32 0
store {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*** %SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**** %tmp_envptr40


%val49 = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*** %SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr
ret {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %val49
}


@SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_INFO* @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ(i64 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %SF_INFO* %result
}


define dllexport ccc %SF_INFO* @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_native(i64 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %SF_INFO* %result
}


define dllexport ccc i8*  @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var50 = bitcast [114 x i8]* @gsxtmsndfile2 to i8*
call i32 (i8*, ...) @printf(i8* %var50)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var51 = bitcast [114 x i8]* @gsxtmsndfile2 to i8*
call i32 (i8*, ...) @printf(i8* %var51)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var52 = bitcast [114 x i8]* @gsxtmsndfile2 to i8*
call i32 (i8*, ...) @printf(i8* %var52)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var53 = bitcast [114 x i8]* @gsxtmsndfile2 to i8*
call i32 (i8*, ...) @printf(i8* %var53)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var54 = bitcast [114 x i8]* @gsxtmsndfile2 to i8*
call i32 (i8*, ...) @printf(i8* %var54)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var55 = bitcast [114 x i8]* @gsxtmsndfile2 to i8*
call i32 (i8*, ...) @printf(i8* %var55)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%tmpres = bitcast %SF_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile3 = hidden constant [63 x i8] c"SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ\00"
define dllexport fastcc %SF_INFO* @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ__56(i8* %_impz,i8* %_impenv, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone57 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}*
%SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**** %SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr


%tzone62 = load i8*, i8** %_impzPtr
%zone63 = bitcast i8* %tzone62 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_INFO*
%tzone58 = load i8*, i8** %_impzPtr
%zone59 = bitcast i8* %tzone58 to %mzone*
%dat60 = call i8* @llvm_zone_malloc(%mzone* %zone59, i64 28)
call i8* @memset(i8* %dat60, i32 0, i64 28)
%val61 = bitcast i8* %dat60 to %SF_INFO*

; let value assignment
%obj = select i1 true, %SF_INFO* %val61, %SF_INFO* %val61
store %SF_INFO* %obj, %SF_INFO** %objPtr

%val64 = load %SF_INFO*, %SF_INFO** %objPtr
%val65 = load i64, i64* %arg_0Ptr
; set tuple
%val66 = getelementptr %SF_INFO, %SF_INFO* %val64, i64 0, i32 0
store i64 %val65, i64* %val66
%val67 = load %SF_INFO*, %SF_INFO** %objPtr
%val68 = load i32, i32* %arg_1Ptr
; set tuple
%val69 = getelementptr %SF_INFO, %SF_INFO* %val67, i64 0, i32 1
store i32 %val68, i32* %val69
%val70 = load %SF_INFO*, %SF_INFO** %objPtr
%val71 = load i32, i32* %arg_2Ptr
; set tuple
%val72 = getelementptr %SF_INFO, %SF_INFO* %val70, i64 0, i32 2
store i32 %val71, i32* %val72
%val73 = load %SF_INFO*, %SF_INFO** %objPtr
%val74 = load i32, i32* %arg_3Ptr
; set tuple
%val75 = getelementptr %SF_INFO, %SF_INFO* %val73, i64 0, i32 3
store i32 %val74, i32* %val75
%val76 = load %SF_INFO*, %SF_INFO** %objPtr
%val77 = load i32, i32* %arg_4Ptr
; set tuple
%val78 = getelementptr %SF_INFO, %SF_INFO* %val76, i64 0, i32 4
store i32 %val77, i32* %val78
%val79 = load %SF_INFO*, %SF_INFO** %objPtr
%val80 = load i32, i32* %arg_5Ptr
; set tuple
%val81 = getelementptr %SF_INFO, %SF_INFO* %val79, i64 0, i32 5
store i32 %val80, i32* %val81
%val82 = load %SF_INFO*, %SF_INFO** %objPtr
ret %SF_INFO* %val82
}
@gsxtmsndfile4 = hidden constant [116 x i8] c"SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone102 = load i8*, i8** %_impzPtr
%zone103 = bitcast i8* %tzone102 to %mzone*

; let assign value to symbol SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ
%dat_SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone103, i64 8)
%SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr = bitcast i8* %dat_SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ to { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***
%tzone83 = load i8*, i8** %_impzPtr
%zone84 = bitcast i8* %tzone83 to %mzone*
call void @llvm_zone_mark(%mzone* %zone84)
; malloc closure structure
%clsptr85 = call i8* @llvm_zone_malloc(%mzone* %zone84, i64 24)
%closure86 = bitcast i8* %clsptr85 to { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr87 = call i8* @llvm_zone_malloc(%mzone* %zone84, i64 8)
%environment88 = bitcast i8* %envptr87 to {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable89 = call %clsvar* @new_address_table()
%var90 = bitcast [63 x i8]* @gsxtmsndfile3 to i8*
%var91 = bitcast [66 x i8]* @gsxtmsndfile1 to i8*
%addytable92 = call %clsvar* @add_address_table(%mzone* %zone84, i8* %var90, i32 0, i8* %var91, i32 3, %clsvar* %addytable89)
%address-table93 = bitcast %clsvar* %addytable92 to i8*

; insert table, function and environment into closure struct
%closure.table96 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure86, i32 0, i32 0
store i8* %address-table93, i8** %closure.table96
%closure.env97 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure86, i32 0, i32 1
store i8* %envptr87, i8** %closure.env97
%closure.func98 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure86, i32 0, i32 2
store %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)* @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ__56, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %closure.func98
%closure_size99 = call i64 @llvm_zone_mark_size(%mzone* %zone84)
call void @llvm_zone_ptr_set_size(i8* %clsptr85, i64 %closure_size99)
%wrapper_ptr100 = call i8* @llvm_zone_malloc(%mzone* %zone84, i64 8)
%closure_wrapper101 = bitcast i8* %wrapper_ptr100 to { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure86, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_wrapper101

; let value assignment
%SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ = select i1 true, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_wrapper101, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_wrapper101
store { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*** %SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ
%tmp_envptr95 = getelementptr {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}* %environment88, i32 0, i32 0
store {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*** %SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**** %tmp_envptr95


%val104 = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*** %SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr
ret {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %val104
}


@SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_INFO* @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ(i64 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %SF_INFO* %result
}


define dllexport ccc %SF_INFO* @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_native(i64 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %SF_INFO* %result
}


define dllexport ccc i8*  @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var105 = bitcast [116 x i8]* @gsxtmsndfile4 to i8*
call i32 (i8*, ...) @printf(i8* %var105)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var106 = bitcast [116 x i8]* @gsxtmsndfile4 to i8*
call i32 (i8*, ...) @printf(i8* %var106)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var107 = bitcast [116 x i8]* @gsxtmsndfile4 to i8*
call i32 (i8*, ...) @printf(i8* %var107)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var108 = bitcast [116 x i8]* @gsxtmsndfile4 to i8*
call i32 (i8*, ...) @printf(i8* %var108)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var109 = bitcast [116 x i8]* @gsxtmsndfile4 to i8*
call i32 (i8*, ...) @printf(i8* %var109)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var110 = bitcast [116 x i8]* @gsxtmsndfile4 to i8*
call i32 (i8*, ...) @printf(i8* %var110)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%tmpres = bitcast %SF_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_z_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile5 = hidden constant [63 x i8] c"SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ\00"
define dllexport fastcc %SF_INFO* @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ__111(i8* %_impz,i8* %_impenv, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone112 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}*
%SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**** %SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr


%tzone115 = load i8*, i8** %_impzPtr
%zone116 = bitcast i8* %tzone115 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_INFO*
%dat113 = call i8* @malloc(i64 28)
call i8* @memset(i8* %dat113, i32 0, i64 28)
%val114 = bitcast i8* %dat113 to %SF_INFO*

; let value assignment
%obj = select i1 true, %SF_INFO* %val114, %SF_INFO* %val114
store %SF_INFO* %obj, %SF_INFO** %objPtr

%val117 = load %SF_INFO*, %SF_INFO** %objPtr
%val118 = load i64, i64* %arg_0Ptr
; set tuple
%val119 = getelementptr %SF_INFO, %SF_INFO* %val117, i64 0, i32 0
store i64 %val118, i64* %val119
%val120 = load %SF_INFO*, %SF_INFO** %objPtr
%val121 = load i32, i32* %arg_1Ptr
; set tuple
%val122 = getelementptr %SF_INFO, %SF_INFO* %val120, i64 0, i32 1
store i32 %val121, i32* %val122
%val123 = load %SF_INFO*, %SF_INFO** %objPtr
%val124 = load i32, i32* %arg_2Ptr
; set tuple
%val125 = getelementptr %SF_INFO, %SF_INFO* %val123, i64 0, i32 2
store i32 %val124, i32* %val125
%val126 = load %SF_INFO*, %SF_INFO** %objPtr
%val127 = load i32, i32* %arg_3Ptr
; set tuple
%val128 = getelementptr %SF_INFO, %SF_INFO* %val126, i64 0, i32 3
store i32 %val127, i32* %val128
%val129 = load %SF_INFO*, %SF_INFO** %objPtr
%val130 = load i32, i32* %arg_4Ptr
; set tuple
%val131 = getelementptr %SF_INFO, %SF_INFO* %val129, i64 0, i32 4
store i32 %val130, i32* %val131
%val132 = load %SF_INFO*, %SF_INFO** %objPtr
%val133 = load i32, i32* %arg_5Ptr
; set tuple
%val134 = getelementptr %SF_INFO, %SF_INFO* %val132, i64 0, i32 5
store i32 %val133, i32* %val134
%val135 = load %SF_INFO*, %SF_INFO** %objPtr
ret %SF_INFO* %val135
}
@gsxtmsndfile6 = hidden constant [116 x i8] c"SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone155 = load i8*, i8** %_impzPtr
%zone156 = bitcast i8* %tzone155 to %mzone*

; let assign value to symbol SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ
%dat_SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone156, i64 8)
%SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr = bitcast i8* %dat_SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ to { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***
%tzone136 = load i8*, i8** %_impzPtr
%zone137 = bitcast i8* %tzone136 to %mzone*
call void @llvm_zone_mark(%mzone* %zone137)
; malloc closure structure
%clsptr138 = call i8* @llvm_zone_malloc(%mzone* %zone137, i64 24)
%closure139 = bitcast i8* %clsptr138 to { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr140 = call i8* @llvm_zone_malloc(%mzone* %zone137, i64 8)
%environment141 = bitcast i8* %envptr140 to {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable142 = call %clsvar* @new_address_table()
%var143 = bitcast [63 x i8]* @gsxtmsndfile5 to i8*
%var144 = bitcast [66 x i8]* @gsxtmsndfile1 to i8*
%addytable145 = call %clsvar* @add_address_table(%mzone* %zone137, i8* %var143, i32 0, i8* %var144, i32 3, %clsvar* %addytable142)
%address-table146 = bitcast %clsvar* %addytable145 to i8*

; insert table, function and environment into closure struct
%closure.table149 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure139, i32 0, i32 0
store i8* %address-table146, i8** %closure.table149
%closure.env150 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure139, i32 0, i32 1
store i8* %envptr140, i8** %closure.env150
%closure.func151 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure139, i32 0, i32 2
store %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)* @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ__111, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %closure.func151
%closure_size152 = call i64 @llvm_zone_mark_size(%mzone* %zone137)
call void @llvm_zone_ptr_set_size(i8* %clsptr138, i64 %closure_size152)
%wrapper_ptr153 = call i8* @llvm_zone_malloc(%mzone* %zone137, i64 8)
%closure_wrapper154 = bitcast i8* %wrapper_ptr153 to { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure139, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_wrapper154

; let value assignment
%SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ = select i1 true, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_wrapper154, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_wrapper154
store { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ, { i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*** %SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ
%tmp_envptr148 = getelementptr {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}* %environment141, i32 0, i32 0
store {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*** %SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**** %tmp_envptr148


%val157 = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*** %SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr
ret {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %val157
}


@SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_INFO* @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ(i64 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %SF_INFO* %result
}


define dllexport ccc %SF_INFO* @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_native(i64 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %SF_INFO* %result
}


define dllexport ccc i8*  @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var158 = bitcast [116 x i8]* @gsxtmsndfile6 to i8*
call i32 (i8*, ...) @printf(i8* %var158)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var159 = bitcast [116 x i8]* @gsxtmsndfile6 to i8*
call i32 (i8*, ...) @printf(i8* %var159)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var160 = bitcast [116 x i8]* @gsxtmsndfile6 to i8*
call i32 (i8*, ...) @printf(i8* %var160)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var161 = bitcast [116 x i8]* @gsxtmsndfile6 to i8*
call i32 (i8*, ...) @printf(i8* %var161)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var162 = bitcast [116 x i8]* @gsxtmsndfile6 to i8*
call i32 (i8*, ...) @printf(i8* %var162)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var163 = bitcast [116 x i8]* @gsxtmsndfile6 to i8*
call i32 (i8*, ...) @printf(i8* %var163)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%tmpres = bitcast %SF_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_h_adhoc_W1NGX0lORk8qLGk2NCxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO* (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile7 = hidden constant [3 x i8] c"%s\00"
@gsxtmsndfile8 = hidden constant [15 x i8] c"<SF_INFO:null>\00"
@gsxtmsndfile9 = hidden constant [10 x i8] c"<SF_INFO:\00"
@gsxtmsndfile10 = hidden constant [2 x i8] c",\00"
@gsxtmsndfile11 = hidden constant [2 x i8] c">\00"
@gsxtmsndfile12 = hidden constant [40 x i8] c"toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd\00"
@gsxtmsndfile13 = hidden constant [46 x i8] c"{i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd__164(i8* %_impz,i8* %_impenv, %SF_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone165 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}***}*
%toString_adhoc_W1N0cmluZyosU0ZfSU5GTypdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosU0ZfSU5GTypdPtr = load {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}***, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}**** %toString_adhoc_W1N0cmluZyosU0ZfSU5GTypdPtr_

; setup arguments
%xPtr = alloca %SF_INFO*
store %SF_INFO* %x, %SF_INFO** %xPtr


%val167 = load %SF_INFO*, %SF_INFO** %xPtr
%val168 = icmp eq %SF_INFO* %val167, null
br i1 %val168, label %then166, label %else166

then166:
%zone169 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone169)
%zone_ptr170 = bitcast %mzone* %zone169 to i8*
store i8* %zone_ptr170, i8** %_impzPtr
%tzone180 = load i8*, i8** %_impzPtr
%zone181 = bitcast i8* %tzone180 to %mzone*

; let assign value to symbol res0
%res0Ptr = alloca %String*
%tzone185 = load i8*, i8** %_impzPtr
%zone186 = bitcast i8* %tzone185 to %mzone*

; let assign value to symbol zone0
%zone0Ptr = alloca %mzone*
%tzone188 = load i8*, i8** %_impzPtr
%zone189 = bitcast i8* %tzone188 to %mzone*

; let assign value to symbol newz0
%newz0Ptr = alloca %mzone*
%tzone172 = load i8*, i8** %_impzPtr
%zone173 = bitcast i8* %tzone172 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat171 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat171, i8* %dat171
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val174 = load i8*, i8** %xx_t_mstPtr
%var175 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var176 = bitcast [15 x i8]* @gsxtmsndfile8 to i8*

%val177 = call i32 (i8*,i8*, ...) @sprintf(i8* %val174, i8* %var175, i8* %var176)
%val178 = load i8*, i8** %xx_t_mstPtr
%res179 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val178)

; let value assignment
%res0 = select i1 true, %String* %res179, %String* %res179
store %String* %res0, %String** %res0Ptr

%oldzone182 = call %mzone* @llvm_pop_zone_stack()
%newzone183 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr184 = bitcast %mzone* %newzone183 to i8*
store i8* %zone_ptr184, i8** %_impzPtr

; let value assignment
%zone0 = select i1 true, %mzone* %oldzone182, %mzone* %oldzone182
store %mzone* %zone0, %mzone** %zone0Ptr

%res187 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz0 = select i1 true, %mzone* %res187, %mzone* %res187
store %mzone* %newz0, %mzone** %newz0Ptr

%tzone194 = load i8*, i8** %_impzPtr
%zone195 = bitcast i8* %tzone194 to %mzone*

; let assign value to symbol rescopy0
%rescopy0Ptr = alloca %String*
%tzone200 = load i8*, i8** %_impzPtr
%zone201 = bitcast i8* %tzone200 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone203 = load i8*, i8** %_impzPtr
%zone204 = bitcast i8* %tzone203 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val190 = load %String*, %String** %res0Ptr
%val191 = load %mzone*, %mzone** %zone0Ptr
%val192 = load %mzone*, %mzone** %newz0Ptr
%res193 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val190, %mzone* %val191, %mzone* %val192)

; let value assignment
%rescopy0 = select i1 true, %String* %res193, %String* %res193
store %String* %rescopy0, %String** %rescopy0Ptr

%val196 = load %mzone*, %mzone** %zone0Ptr
; tuple ref
%val197 = getelementptr %mzone, %mzone* %val196, i64 0, i32 4
%val198 = load i8*, i8** %val197
%val199 = bitcast i8* %val198 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val199, {i64,i8*,i8*}* %val199
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null202 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null202, {i8*, i8*, void (i8*, i8*)*}** %null202
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone240 = load i8*, i8** %_impzPtr
%zone241 = bitcast i8* %tzone240 to %mzone*
%ifptr230 = alloca i1
%ifptr206 = alloca i1
; while loop
%val207 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val208 = icmp eq {i64,i8*,i8*}* %val207, null
br i1 %val208, label %then206, label %else206

then206:
%res209 = call ccc i1 @impc_false()
store i1 %res209, i1* %ifptr206
br label %ifcont206

else206:
%res210 = call ccc i1 @impc_true()
store i1 %res210, i1* %ifptr206
br label %ifcont206

ifcont206:
%ifres211 = load i1, i1* %ifptr206

br i1 %ifres211, label %loop205, label %after205

loop205:
; do set!
%val212 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val213 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val212, i64 0, i32 1
%val214 = load i8*, i8** %val213
%val215 = bitcast i8* %val214 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val215, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval216 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val217 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval216
%fPtr218 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val217, i32 0, i32 2
%ePtr219 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val217, i32 0, i32 1
%f220 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr218
%e221 = load i8*, i8** %ePtr219
%tzone222 = load i8*, i8** %_impzPtr
%zone223 = bitcast i8* %tzone222 to %mzone*
%z224 = bitcast %mzone* %zone223 to i8*
tail call fastcc void %f220(i8* %z224, i8* %e221)
; do set!
%val226 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val227 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val226, i64 0, i32 2
%val228 = load i8*, i8** %val227
%val229 = bitcast i8* %val228 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val229, {i64,i8*,i8*}** %hookPtr
%val231 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val232 = icmp eq {i64,i8*,i8*}* %val231, null
br i1 %val232, label %then230, label %else230

then230:
%res233 = call ccc i1 @impc_false()
store i1 %res233, i1* %ifptr230
br label %ifcont230

else230:
%res234 = call ccc i1 @impc_true()
store i1 %res234, i1* %ifptr230
br label %ifcont230

ifcont230:
%ifres235 = load i1, i1* %ifptr230

br i1 %ifres235, label %loop205, label %after205

after205:
%val237 = load %mzone*, %mzone** %zone0Ptr
call ccc void @llvm_zone_destroy(%mzone* %val237)
%val239 = load %String*, %String** %rescopy0Ptr
ret %String* %val239

else166:
%zone242 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone242)
%zone_ptr243 = bitcast %mzone* %zone242 to i8*
store i8* %zone_ptr243, i8** %_impzPtr
%tzone343 = load i8*, i8** %_impzPtr
%zone344 = bitcast i8* %tzone343 to %mzone*

; let assign value to symbol res1
%res1Ptr = alloca %String*
%tzone348 = load i8*, i8** %_impzPtr
%zone349 = bitcast i8* %tzone348 to %mzone*

; let assign value to symbol zone1
%zone1Ptr = alloca %mzone*
%tzone351 = load i8*, i8** %_impzPtr
%zone352 = bitcast i8* %tzone351 to %mzone*

; let assign value to symbol newz1
%newz1Ptr = alloca %mzone*
%tzone245 = load i8*, i8** %_impzPtr
%zone246 = bitcast i8* %tzone245 to %mzone*

; let assign value to symbol xx_t_mst_s_1
%xx_t_mst_s_1Ptr = alloca i8*
%dat244 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_1 = select i1 true, i8* %dat244, i8* %dat244
store i8* %xx_t_mst_s_1, i8** %xx_t_mst_s_1Ptr

%val247 = load i8*, i8** %xx_t_mst_s_1Ptr
%var248 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var249 = bitcast [10 x i8]* @gsxtmsndfile9 to i8*

%val250 = call i32 (i8*,i8*, ...) @sprintf(i8* %val247, i8* %var248, i8* %var249)
%val251 = load i8*, i8** %xx_t_mst_s_1Ptr
%res252 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val251)
%val253 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val254 = getelementptr %SF_INFO, %SF_INFO* %val253, i64 0, i32 0
%val255 = load i64, i64* %val254
%res256 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTY0XQ(i64 %val255)
%res257 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res252, %String* %res256)
%tzone259 = load i8*, i8** %_impzPtr
%zone260 = bitcast i8* %tzone259 to %mzone*

; let assign value to symbol xx_t_mst_s_2
%xx_t_mst_s_2Ptr = alloca i8*
%dat258 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_2 = select i1 true, i8* %dat258, i8* %dat258
store i8* %xx_t_mst_s_2, i8** %xx_t_mst_s_2Ptr

%val261 = load i8*, i8** %xx_t_mst_s_2Ptr
%var262 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var263 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val264 = call i32 (i8*,i8*, ...) @sprintf(i8* %val261, i8* %var262, i8* %var263)
%val265 = load i8*, i8** %xx_t_mst_s_2Ptr
%res266 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val265)
%res267 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res257, %String* %res266)
%val268 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val269 = getelementptr %SF_INFO, %SF_INFO* %val268, i64 0, i32 1
%val270 = load i32, i32* %val269
%res271 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val270)
%res272 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res267, %String* %res271)
%tzone274 = load i8*, i8** %_impzPtr
%zone275 = bitcast i8* %tzone274 to %mzone*

; let assign value to symbol xx_t_mst_s_3
%xx_t_mst_s_3Ptr = alloca i8*
%dat273 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_3 = select i1 true, i8* %dat273, i8* %dat273
store i8* %xx_t_mst_s_3, i8** %xx_t_mst_s_3Ptr

%val276 = load i8*, i8** %xx_t_mst_s_3Ptr
%var277 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var278 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val279 = call i32 (i8*,i8*, ...) @sprintf(i8* %val276, i8* %var277, i8* %var278)
%val280 = load i8*, i8** %xx_t_mst_s_3Ptr
%res281 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val280)
%res282 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res272, %String* %res281)
%val283 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val284 = getelementptr %SF_INFO, %SF_INFO* %val283, i64 0, i32 2
%val285 = load i32, i32* %val284
%res286 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val285)
%res287 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res282, %String* %res286)
%tzone289 = load i8*, i8** %_impzPtr
%zone290 = bitcast i8* %tzone289 to %mzone*

; let assign value to symbol xx_t_mst_s_4
%xx_t_mst_s_4Ptr = alloca i8*
%dat288 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_4 = select i1 true, i8* %dat288, i8* %dat288
store i8* %xx_t_mst_s_4, i8** %xx_t_mst_s_4Ptr

%val291 = load i8*, i8** %xx_t_mst_s_4Ptr
%var292 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var293 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val294 = call i32 (i8*,i8*, ...) @sprintf(i8* %val291, i8* %var292, i8* %var293)
%val295 = load i8*, i8** %xx_t_mst_s_4Ptr
%res296 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val295)
%res297 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res287, %String* %res296)
%val298 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val299 = getelementptr %SF_INFO, %SF_INFO* %val298, i64 0, i32 3
%val300 = load i32, i32* %val299
%res301 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val300)
%res302 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res297, %String* %res301)
%tzone304 = load i8*, i8** %_impzPtr
%zone305 = bitcast i8* %tzone304 to %mzone*

; let assign value to symbol xx_t_mst_s_5
%xx_t_mst_s_5Ptr = alloca i8*
%dat303 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_5 = select i1 true, i8* %dat303, i8* %dat303
store i8* %xx_t_mst_s_5, i8** %xx_t_mst_s_5Ptr

%val306 = load i8*, i8** %xx_t_mst_s_5Ptr
%var307 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var308 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val309 = call i32 (i8*,i8*, ...) @sprintf(i8* %val306, i8* %var307, i8* %var308)
%val310 = load i8*, i8** %xx_t_mst_s_5Ptr
%res311 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val310)
%res312 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res302, %String* %res311)
%val313 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val314 = getelementptr %SF_INFO, %SF_INFO* %val313, i64 0, i32 4
%val315 = load i32, i32* %val314
%res316 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val315)
%res317 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res312, %String* %res316)
%tzone319 = load i8*, i8** %_impzPtr
%zone320 = bitcast i8* %tzone319 to %mzone*

; let assign value to symbol xx_t_mst_s_6
%xx_t_mst_s_6Ptr = alloca i8*
%dat318 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_6 = select i1 true, i8* %dat318, i8* %dat318
store i8* %xx_t_mst_s_6, i8** %xx_t_mst_s_6Ptr

%val321 = load i8*, i8** %xx_t_mst_s_6Ptr
%var322 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var323 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val324 = call i32 (i8*,i8*, ...) @sprintf(i8* %val321, i8* %var322, i8* %var323)
%val325 = load i8*, i8** %xx_t_mst_s_6Ptr
%res326 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val325)
%res327 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res317, %String* %res326)
%val328 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val329 = getelementptr %SF_INFO, %SF_INFO* %val328, i64 0, i32 5
%val330 = load i32, i32* %val329
%res331 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val330)
%res332 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res327, %String* %res331)
%tzone334 = load i8*, i8** %_impzPtr
%zone335 = bitcast i8* %tzone334 to %mzone*

; let assign value to symbol xx_t_mst_s_7
%xx_t_mst_s_7Ptr = alloca i8*
%dat333 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_7 = select i1 true, i8* %dat333, i8* %dat333
store i8* %xx_t_mst_s_7, i8** %xx_t_mst_s_7Ptr

%val336 = load i8*, i8** %xx_t_mst_s_7Ptr
%var337 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var338 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val339 = call i32 (i8*,i8*, ...) @sprintf(i8* %val336, i8* %var337, i8* %var338)
%val340 = load i8*, i8** %xx_t_mst_s_7Ptr
%res341 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val340)
%res342 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res332, %String* %res341)

; let value assignment
%res1 = select i1 true, %String* %res342, %String* %res342
store %String* %res1, %String** %res1Ptr

%oldzone345 = call %mzone* @llvm_pop_zone_stack()
%newzone346 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr347 = bitcast %mzone* %newzone346 to i8*
store i8* %zone_ptr347, i8** %_impzPtr

; let value assignment
%zone1 = select i1 true, %mzone* %oldzone345, %mzone* %oldzone345
store %mzone* %zone1, %mzone** %zone1Ptr

%res350 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz1 = select i1 true, %mzone* %res350, %mzone* %res350
store %mzone* %newz1, %mzone** %newz1Ptr

%tzone357 = load i8*, i8** %_impzPtr
%zone358 = bitcast i8* %tzone357 to %mzone*

; let assign value to symbol rescopy1
%rescopy1Ptr = alloca %String*
%tzone363 = load i8*, i8** %_impzPtr
%zone364 = bitcast i8* %tzone363 to %mzone*

; let assign value to symbol hook_s_8
%hook_s_8Ptr = alloca {i64,i8*,i8*}*
%tzone366 = load i8*, i8** %_impzPtr
%zone367 = bitcast i8* %tzone366 to %mzone*

; let assign value to symbol f_s_9
%f_s_9Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val353 = load %String*, %String** %res1Ptr
%val354 = load %mzone*, %mzone** %zone1Ptr
%val355 = load %mzone*, %mzone** %newz1Ptr
%res356 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val353, %mzone* %val354, %mzone* %val355)

; let value assignment
%rescopy1 = select i1 true, %String* %res356, %String* %res356
store %String* %rescopy1, %String** %rescopy1Ptr

%val359 = load %mzone*, %mzone** %zone1Ptr
; tuple ref
%val360 = getelementptr %mzone, %mzone* %val359, i64 0, i32 4
%val361 = load i8*, i8** %val360
%val362 = bitcast i8* %val361 to {i64,i8*,i8*}*

; let value assignment
%hook_s_8 = select i1 true, {i64,i8*,i8*}* %val362, {i64,i8*,i8*}* %val362
store {i64,i8*,i8*}* %hook_s_8, {i64,i8*,i8*}** %hook_s_8Ptr

%null365 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_9 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null365, {i8*, i8*, void (i8*, i8*)*}** %null365
store {i8*, i8*, void (i8*, i8*)*}** %f_s_9, {i8*, i8*, void (i8*, i8*)*}*** %f_s_9Ptr

; promote local stack var allocations
%tzone403 = load i8*, i8** %_impzPtr
%zone404 = bitcast i8* %tzone403 to %mzone*
%ifptr393 = alloca i1
%ifptr369 = alloca i1
; while loop
%val370 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_8Ptr
%val371 = icmp eq {i64,i8*,i8*}* %val370, null
br i1 %val371, label %then369, label %else369

then369:
%res372 = call ccc i1 @impc_false()
store i1 %res372, i1* %ifptr369
br label %ifcont369

else369:
%res373 = call ccc i1 @impc_true()
store i1 %res373, i1* %ifptr369
br label %ifcont369

ifcont369:
%ifres374 = load i1, i1* %ifptr369

br i1 %ifres374, label %loop368, label %after368

loop368:
; do set!
%val375 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_8Ptr
; tuple ref
%val376 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val375, i64 0, i32 1
%val377 = load i8*, i8** %val376
%val378 = bitcast i8* %val377 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val378, {i8*, i8*, void (i8*, i8*)*}*** %f_s_9Ptr

; apply closure 
%vval379 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_9Ptr
%val380 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval379
%fPtr381 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val380, i32 0, i32 2
%ePtr382 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val380, i32 0, i32 1
%f383 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr381
%e384 = load i8*, i8** %ePtr382
%tzone385 = load i8*, i8** %_impzPtr
%zone386 = bitcast i8* %tzone385 to %mzone*
%z387 = bitcast %mzone* %zone386 to i8*
tail call fastcc void %f383(i8* %z387, i8* %e384)
; do set!
%val389 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_8Ptr
; tuple ref
%val390 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val389, i64 0, i32 2
%val391 = load i8*, i8** %val390
%val392 = bitcast i8* %val391 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val392, {i64,i8*,i8*}** %hook_s_8Ptr
%val394 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_8Ptr
%val395 = icmp eq {i64,i8*,i8*}* %val394, null
br i1 %val395, label %then393, label %else393

then393:
%res396 = call ccc i1 @impc_false()
store i1 %res396, i1* %ifptr393
br label %ifcont393

else393:
%res397 = call ccc i1 @impc_true()
store i1 %res397, i1* %ifptr393
br label %ifcont393

ifcont393:
%ifres398 = load i1, i1* %ifptr393

br i1 %ifres398, label %loop368, label %after368

after368:
%val400 = load %mzone*, %mzone** %zone1Ptr
call ccc void @llvm_zone_destroy(%mzone* %val400)
%val402 = load %String*, %String** %rescopy1Ptr
ret %String* %val402
}
@gsxtmsndfile14 = hidden constant [93 x i8] c"toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}** @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone424 = load i8*, i8** %_impzPtr
%zone425 = bitcast i8* %tzone424 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd
%dat_toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd = call i8* @llvm_zone_malloc(%mzone* %zone425, i64 8)
%toString_adhoc_W1N0cmluZyosU0ZfSU5GTypdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd to { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}***
%tzone405 = load i8*, i8** %_impzPtr
%zone406 = bitcast i8* %tzone405 to %mzone*
call void @llvm_zone_mark(%mzone* %zone406)
; malloc closure structure
%clsptr407 = call i8* @llvm_zone_malloc(%mzone* %zone406, i64 24)
%closure408 = bitcast i8* %clsptr407 to { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}*

; malloc environment structure
%envptr409 = call i8* @llvm_zone_malloc(%mzone* %zone406, i64 8)
%environment410 = bitcast i8* %envptr409 to {{i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}***}*

; malloc closure address table
%addytable411 = call %clsvar* @new_address_table()
%var412 = bitcast [40 x i8]* @gsxtmsndfile12 to i8*
%var413 = bitcast [46 x i8]* @gsxtmsndfile13 to i8*
%addytable414 = call %clsvar* @add_address_table(%mzone* %zone406, i8* %var412, i32 0, i8* %var413, i32 3, %clsvar* %addytable411)
%address-table415 = bitcast %clsvar* %addytable414 to i8*

; insert table, function and environment into closure struct
%closure.table418 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}* %closure408, i32 0, i32 0
store i8* %address-table415, i8** %closure.table418
%closure.env419 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}* %closure408, i32 0, i32 1
store i8* %envptr409, i8** %closure.env419
%closure.func420 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}* %closure408, i32 0, i32 2
store %String* (i8*, i8*, %SF_INFO*)* @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd__164, %String* (i8*, i8*, %SF_INFO*)** %closure.func420
%closure_size421 = call i64 @llvm_zone_mark_size(%mzone* %zone406)
call void @llvm_zone_ptr_set_size(i8* %clsptr407, i64 %closure_size421)
%wrapper_ptr422 = call i8* @llvm_zone_malloc(%mzone* %zone406, i64 8)
%closure_wrapper423 = bitcast i8* %wrapper_ptr422 to { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}**
store { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}* %closure408, { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}** %closure_wrapper423

; let value assignment
%toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}** %closure_wrapper423, { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}** %closure_wrapper423
store { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}** %toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd, { i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfSU5GTypdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd
%tmp_envptr417 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}***}* %environment410, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfSU5GTypdPtr, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}**** %tmp_envptr417


%val426 = load {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}**, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfSU5GTypdPtr
ret {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}** %val426
}


@toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}** @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_INFO*)*,  %String* (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_native(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_INFO*)*,  %String* (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var427 = bitcast [93 x i8]* @gsxtmsndfile14 to i8*
call i32 (i8*, ...) @printf(i8* %var427)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_INFO*)*,  %String* (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*}*
%arg_p_0 = getelementptr {%SF_INFO*}, {%SF_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_INFO*)*,  %String* (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile15 = hidden constant [33 x i8] c"print_adhoc_W3ZvaWQsU0ZfSU5GTypd\00"
@gsxtmsndfile16 = hidden constant [42 x i8] c"{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU0ZfSU5GTypd__428(i8* %_impz,i8* %_impenv, %SF_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone429 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***}*
%print_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr = load {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**** %print_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr_

; setup arguments
%xPtr = alloca %SF_INFO*
store %SF_INFO* %x, %SF_INFO** %xPtr


%val431 = load %SF_INFO*, %SF_INFO** %xPtr
%val432 = icmp eq %SF_INFO* %val431, null
br i1 %val432, label %then430, label %else430

then430:
%var433 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var434 = bitcast [15 x i8]* @gsxtmsndfile8 to i8*

%val435 = call i32 (i8*, ...) @printf(i8* %var433, i8* %var434)
br label %ifcont430

else430:
%var437 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var438 = bitcast [10 x i8]* @gsxtmsndfile9 to i8*

%val439 = call i32 (i8*, ...) @printf(i8* %var437, i8* %var438)
%val440 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val441 = getelementptr %SF_INFO, %SF_INFO* %val440, i64 0, i32 0
%val442 = load i64, i64* %val441
call fastcc void @print_adhoc_W3ZvaWQsaTY0XQ(i64 %val442)
%var444 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var445 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val446 = call i32 (i8*, ...) @printf(i8* %var444, i8* %var445)
%val447 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val448 = getelementptr %SF_INFO, %SF_INFO* %val447, i64 0, i32 1
%val449 = load i32, i32* %val448
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val449)
%var451 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var452 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val453 = call i32 (i8*, ...) @printf(i8* %var451, i8* %var452)
%val454 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val455 = getelementptr %SF_INFO, %SF_INFO* %val454, i64 0, i32 2
%val456 = load i32, i32* %val455
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val456)
%var458 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var459 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val460 = call i32 (i8*, ...) @printf(i8* %var458, i8* %var459)
%val461 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val462 = getelementptr %SF_INFO, %SF_INFO* %val461, i64 0, i32 3
%val463 = load i32, i32* %val462
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val463)
%var465 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var466 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val467 = call i32 (i8*, ...) @printf(i8* %var465, i8* %var466)
%val468 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val469 = getelementptr %SF_INFO, %SF_INFO* %val468, i64 0, i32 4
%val470 = load i32, i32* %val469
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val470)
%var472 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var473 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val474 = call i32 (i8*, ...) @printf(i8* %var472, i8* %var473)
%val475 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val476 = getelementptr %SF_INFO, %SF_INFO* %val475, i64 0, i32 5
%val477 = load i32, i32* %val476
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val477)
%var479 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var480 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val481 = call i32 (i8*, ...) @printf(i8* %var479, i8* %var480)
br label %ifcont430

ifcont430:
ret void
}
@gsxtmsndfile17 = hidden constant [86 x i8] c"print_adhoc_W3ZvaWQsU0ZfSU5GTypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone503 = load i8*, i8** %_impzPtr
%zone504 = bitcast i8* %tzone503 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU0ZfSU5GTypd
%dat_print_adhoc_W3ZvaWQsU0ZfSU5GTypd = call i8* @llvm_zone_malloc(%mzone* %zone504, i64 8)
%print_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU0ZfSU5GTypd to { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***
%tzone484 = load i8*, i8** %_impzPtr
%zone485 = bitcast i8* %tzone484 to %mzone*
call void @llvm_zone_mark(%mzone* %zone485)
; malloc closure structure
%clsptr486 = call i8* @llvm_zone_malloc(%mzone* %zone485, i64 24)
%closure487 = bitcast i8* %clsptr486 to { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*

; malloc environment structure
%envptr488 = call i8* @llvm_zone_malloc(%mzone* %zone485, i64 8)
%environment489 = bitcast i8* %envptr488 to {{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***}*

; malloc closure address table
%addytable490 = call %clsvar* @new_address_table()
%var491 = bitcast [33 x i8]* @gsxtmsndfile15 to i8*
%var492 = bitcast [42 x i8]* @gsxtmsndfile16 to i8*
%addytable493 = call %clsvar* @add_address_table(%mzone* %zone485, i8* %var491, i32 0, i8* %var492, i32 3, %clsvar* %addytable490)
%address-table494 = bitcast %clsvar* %addytable493 to i8*

; insert table, function and environment into closure struct
%closure.table497 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure487, i32 0, i32 0
store i8* %address-table494, i8** %closure.table497
%closure.env498 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure487, i32 0, i32 1
store i8* %envptr488, i8** %closure.env498
%closure.func499 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure487, i32 0, i32 2
store void (i8*, i8*, %SF_INFO*)* @print_adhoc_W3ZvaWQsU0ZfSU5GTypd__428, void (i8*, i8*, %SF_INFO*)** %closure.func499
%closure_size500 = call i64 @llvm_zone_mark_size(%mzone* %zone485)
call void @llvm_zone_ptr_set_size(i8* %clsptr486, i64 %closure_size500)
%wrapper_ptr501 = call i8* @llvm_zone_malloc(%mzone* %zone485, i64 8)
%closure_wrapper502 = bitcast i8* %wrapper_ptr501 to { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**
store { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure487, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_wrapper502

; let value assignment
%print_adhoc_W3ZvaWQsU0ZfSU5GTypd = select i1 true, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_wrapper502, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_wrapper502
store { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %print_adhoc_W3ZvaWQsU0ZfSU5GTypd, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU0ZfSU5GTypd
%tmp_envptr496 = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***}* %environment489, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**** %tmp_envptr496


%val505 = load {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr
ret {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %val505
}


@print_adhoc_W3ZvaWQsU0ZfSU5GTypd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU0ZfSU5GTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU0ZfSU5GTypd(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INFO*)*,  void (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_native(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INFO*)*,  void (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var506 = bitcast [86 x i8]* @gsxtmsndfile17 to i8*
call i32 (i8*, ...) @printf(i8* %var506)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INFO*)*,  void (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*}*
%arg_p_0 = getelementptr {%SF_INFO*}, {%SF_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INFO*)*,  void (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile18 = hidden constant [63 x i8] c"SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd\00"
@gsxtmsndfile19 = hidden constant [65 x i8] c"{i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**\00"
define dllexport fastcc %SF_INFO @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd__507(i8* %_impz,i8* %_impenv, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone508 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}*
%SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJdPtr = load {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***, {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**** %SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJdPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr


%tzone510 = load i8*, i8** %_impzPtr
%zone511 = bitcast i8* %tzone510 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_INFO*
%dat509 = alloca %SF_INFO, align 16

; let value assignment
%obj = select i1 true, %SF_INFO* %dat509, %SF_INFO* %dat509
store %SF_INFO* %obj, %SF_INFO** %objPtr

%val512 = load %SF_INFO*, %SF_INFO** %objPtr
%val513 = load i64, i64* %arg_0Ptr
; set tuple
%val514 = getelementptr %SF_INFO, %SF_INFO* %val512, i64 0, i32 0
store i64 %val513, i64* %val514
%val515 = load %SF_INFO*, %SF_INFO** %objPtr
%val516 = load i32, i32* %arg_1Ptr
; set tuple
%val517 = getelementptr %SF_INFO, %SF_INFO* %val515, i64 0, i32 1
store i32 %val516, i32* %val517
%val518 = load %SF_INFO*, %SF_INFO** %objPtr
%val519 = load i32, i32* %arg_2Ptr
; set tuple
%val520 = getelementptr %SF_INFO, %SF_INFO* %val518, i64 0, i32 2
store i32 %val519, i32* %val520
%val521 = load %SF_INFO*, %SF_INFO** %objPtr
%val522 = load i32, i32* %arg_3Ptr
; set tuple
%val523 = getelementptr %SF_INFO, %SF_INFO* %val521, i64 0, i32 3
store i32 %val522, i32* %val523
%val524 = load %SF_INFO*, %SF_INFO** %objPtr
%val525 = load i32, i32* %arg_4Ptr
; set tuple
%val526 = getelementptr %SF_INFO, %SF_INFO* %val524, i64 0, i32 4
store i32 %val525, i32* %val526
%val527 = load %SF_INFO*, %SF_INFO** %objPtr
%val528 = load i32, i32* %arg_5Ptr
; set tuple
%val529 = getelementptr %SF_INFO, %SF_INFO* %val527, i64 0, i32 5
store i32 %val528, i32* %val529
%val530 = load %SF_INFO*, %SF_INFO** %objPtr
; pointer ref
%val531 = getelementptr %SF_INFO, %SF_INFO* %val530, i64 0
%val532 = load %SF_INFO, %SF_INFO* %val531
ret %SF_INFO %val532
}
@gsxtmsndfile20 = hidden constant [116 x i8] c"SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone552 = load i8*, i8** %_impzPtr
%zone553 = bitcast i8* %tzone552 to %mzone*

; let assign value to symbol SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd
%dat_SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone553, i64 8)
%SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJdPtr = bitcast i8* %dat_SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd to { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***
%tzone533 = load i8*, i8** %_impzPtr
%zone534 = bitcast i8* %tzone533 to %mzone*
call void @llvm_zone_mark(%mzone* %zone534)
; malloc closure structure
%clsptr535 = call i8* @llvm_zone_malloc(%mzone* %zone534, i64 24)
%closure536 = bitcast i8* %clsptr535 to { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr537 = call i8* @llvm_zone_malloc(%mzone* %zone534, i64 8)
%environment538 = bitcast i8* %envptr537 to {{i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable539 = call %clsvar* @new_address_table()
%var540 = bitcast [63 x i8]* @gsxtmsndfile18 to i8*
%var541 = bitcast [65 x i8]* @gsxtmsndfile19 to i8*
%addytable542 = call %clsvar* @add_address_table(%mzone* %zone534, i8* %var540, i32 0, i8* %var541, i32 3, %clsvar* %addytable539)
%address-table543 = bitcast %clsvar* %addytable542 to i8*

; insert table, function and environment into closure struct
%closure.table546 = getelementptr { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure536, i32 0, i32 0
store i8* %address-table543, i8** %closure.table546
%closure.env547 = getelementptr { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure536, i32 0, i32 1
store i8* %envptr537, i8** %closure.env547
%closure.func548 = getelementptr { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure536, i32 0, i32 2
store %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)* @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd__507, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)** %closure.func548
%closure_size549 = call i64 @llvm_zone_mark_size(%mzone* %zone534)
call void @llvm_zone_ptr_set_size(i8* %clsptr535, i64 %closure_size549)
%wrapper_ptr550 = call i8* @llvm_zone_malloc(%mzone* %zone534, i64 8)
%closure_wrapper551 = bitcast i8* %wrapper_ptr550 to { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure536, { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_wrapper551

; let value assignment
%SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd = select i1 true, { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_wrapper551, { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_wrapper551
store { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd, { i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*** %SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd
%tmp_envptr545 = getelementptr {{i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}***}* %environment538, i32 0, i32 0
store {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*** %SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJdPtr, {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**** %tmp_envptr545


%val554 = load {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**, {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*** %SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJdPtr
ret {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %val554
}


@SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_INFO @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd(i64 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %SF_INFO %result
}


define dllexport ccc %SF_INFO @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_native(i64 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret %SF_INFO %result
}


define dllexport ccc void @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {i64, i32, i32, i32, i32, i32}, {i64, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INFO_val_adhoc_W1NGX0lORk8saTY0LGkzMixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}, {i8*, i8*, %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)*,  %SF_INFO (i8*, i8*, i64, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO %ff(i8* %_impz, i8* %ee, i64 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile21 = hidden constant [39 x i8] c"hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ\00"
@gsxtmsndfile22 = hidden constant [47 x i8] c"{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}**\00"
define dllexport fastcc %SF_INFO* @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ__561(i8* %_impz,i8* %_impenv, %SF_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone562 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}***}*
%hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQPtr_ = getelementptr {{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQPtr = load {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}***, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}**** %hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQPtr_

; setup arguments
%xPtr = alloca %SF_INFO*
store %SF_INFO* %x, %SF_INFO** %xPtr


%tzone565 = load i8*, i8** %_impzPtr
%zone566 = bitcast i8* %tzone565 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_INFO*
%dat563 = call i8* @malloc(i64 28)
call i8* @memset(i8* %dat563, i32 0, i64 28)
%val564 = bitcast i8* %dat563 to %SF_INFO*

; let value assignment
%obj = select i1 true, %SF_INFO* %val564, %SF_INFO* %val564
store %SF_INFO* %obj, %SF_INFO** %objPtr

%val567 = load %SF_INFO*, %SF_INFO** %objPtr
%val568 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val569 = getelementptr %SF_INFO, %SF_INFO* %val568, i64 0, i32 0
%val570 = load i64, i64* %val569
; set tuple
%val571 = getelementptr %SF_INFO, %SF_INFO* %val567, i64 0, i32 0
store i64 %val570, i64* %val571
%val572 = load %SF_INFO*, %SF_INFO** %objPtr
%val573 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val574 = getelementptr %SF_INFO, %SF_INFO* %val573, i64 0, i32 1
%val575 = load i32, i32* %val574
; set tuple
%val576 = getelementptr %SF_INFO, %SF_INFO* %val572, i64 0, i32 1
store i32 %val575, i32* %val576
%val577 = load %SF_INFO*, %SF_INFO** %objPtr
%val578 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val579 = getelementptr %SF_INFO, %SF_INFO* %val578, i64 0, i32 2
%val580 = load i32, i32* %val579
; set tuple
%val581 = getelementptr %SF_INFO, %SF_INFO* %val577, i64 0, i32 2
store i32 %val580, i32* %val581
%val582 = load %SF_INFO*, %SF_INFO** %objPtr
%val583 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val584 = getelementptr %SF_INFO, %SF_INFO* %val583, i64 0, i32 3
%val585 = load i32, i32* %val584
; set tuple
%val586 = getelementptr %SF_INFO, %SF_INFO* %val582, i64 0, i32 3
store i32 %val585, i32* %val586
%val587 = load %SF_INFO*, %SF_INFO** %objPtr
%val588 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val589 = getelementptr %SF_INFO, %SF_INFO* %val588, i64 0, i32 4
%val590 = load i32, i32* %val589
; set tuple
%val591 = getelementptr %SF_INFO, %SF_INFO* %val587, i64 0, i32 4
store i32 %val590, i32* %val591
%val592 = load %SF_INFO*, %SF_INFO** %objPtr
%val593 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val594 = getelementptr %SF_INFO, %SF_INFO* %val593, i64 0, i32 5
%val595 = load i32, i32* %val594
; set tuple
%val596 = getelementptr %SF_INFO, %SF_INFO* %val592, i64 0, i32 5
store i32 %val595, i32* %val596
%val597 = load %SF_INFO*, %SF_INFO** %objPtr
ret %SF_INFO* %val597
}
@gsxtmsndfile23 = hidden constant [92 x i8] c"hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}** @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone617 = load i8*, i8** %_impzPtr
%zone618 = bitcast i8* %tzone617 to %mzone*

; let assign value to symbol hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ
%dat_hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone618, i64 8)
%hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQPtr = bitcast i8* %dat_hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ to { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}***
%tzone598 = load i8*, i8** %_impzPtr
%zone599 = bitcast i8* %tzone598 to %mzone*
call void @llvm_zone_mark(%mzone* %zone599)
; malloc closure structure
%clsptr600 = call i8* @llvm_zone_malloc(%mzone* %zone599, i64 24)
%closure601 = bitcast i8* %clsptr600 to { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}*

; malloc environment structure
%envptr602 = call i8* @llvm_zone_malloc(%mzone* %zone599, i64 8)
%environment603 = bitcast i8* %envptr602 to {{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}***}*

; malloc closure address table
%addytable604 = call %clsvar* @new_address_table()
%var605 = bitcast [39 x i8]* @gsxtmsndfile21 to i8*
%var606 = bitcast [47 x i8]* @gsxtmsndfile22 to i8*
%addytable607 = call %clsvar* @add_address_table(%mzone* %zone599, i8* %var605, i32 0, i8* %var606, i32 3, %clsvar* %addytable604)
%address-table608 = bitcast %clsvar* %addytable607 to i8*

; insert table, function and environment into closure struct
%closure.table611 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}* %closure601, i32 0, i32 0
store i8* %address-table608, i8** %closure.table611
%closure.env612 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}* %closure601, i32 0, i32 1
store i8* %envptr602, i8** %closure.env612
%closure.func613 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}* %closure601, i32 0, i32 2
store %SF_INFO* (i8*, i8*, %SF_INFO*)* @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ__561, %SF_INFO* (i8*, i8*, %SF_INFO*)** %closure.func613
%closure_size614 = call i64 @llvm_zone_mark_size(%mzone* %zone599)
call void @llvm_zone_ptr_set_size(i8* %clsptr600, i64 %closure_size614)
%wrapper_ptr615 = call i8* @llvm_zone_malloc(%mzone* %zone599, i64 8)
%closure_wrapper616 = bitcast i8* %wrapper_ptr615 to { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}**
store { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}* %closure601, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}** %closure_wrapper616

; let value assignment
%hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ = select i1 true, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}** %closure_wrapper616, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}** %closure_wrapper616
store { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}** %hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}*** %hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ
%tmp_envptr610 = getelementptr {{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}***}* %environment603, i32 0, i32 0
store {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}*** %hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQPtr, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}**** %tmp_envptr610


%val619 = load {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}**, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}*** %hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQPtr
ret {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}** %val619
}


@hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}** @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_INFO* @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, %SF_INFO*)*,  %SF_INFO* (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret %SF_INFO* %result
}


define dllexport ccc %SF_INFO* @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_native(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, %SF_INFO*)*,  %SF_INFO* (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret %SF_INFO* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var620 = bitcast [92 x i8]* @gsxtmsndfile23 to i8*
call i32 (i8*, ...) @printf(i8* %var620)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, %SF_INFO*)*,  %SF_INFO* (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%tmpres = bitcast %SF_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*}*
%arg_p_0 = getelementptr {%SF_INFO*}, {%SF_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, %SF_INFO*)*,  %SF_INFO* (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile24 = hidden constant [33 x i8] c"hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd__621(i8* %_impz,i8* %_impenv, %SF_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone622 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***}*
%hfree_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr = load {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**** %hfree_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr_

; setup arguments
%xPtr = alloca %SF_INFO*
store %SF_INFO* %x, %SF_INFO** %xPtr


%val623 = load %SF_INFO*, %SF_INFO** %xPtr
%val624 = bitcast %SF_INFO* %val623 to i8*
call ccc void @free(i8* %val624)
ret void
}
@gsxtmsndfile25 = hidden constant [86 x i8] c"hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone646 = load i8*, i8** %_impzPtr
%zone647 = bitcast i8* %tzone646 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd
%dat_hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd = call i8* @llvm_zone_malloc(%mzone* %zone647, i64 8)
%hfree_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd to { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***
%tzone627 = load i8*, i8** %_impzPtr
%zone628 = bitcast i8* %tzone627 to %mzone*
call void @llvm_zone_mark(%mzone* %zone628)
; malloc closure structure
%clsptr629 = call i8* @llvm_zone_malloc(%mzone* %zone628, i64 24)
%closure630 = bitcast i8* %clsptr629 to { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*

; malloc environment structure
%envptr631 = call i8* @llvm_zone_malloc(%mzone* %zone628, i64 8)
%environment632 = bitcast i8* %envptr631 to {{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***}*

; malloc closure address table
%addytable633 = call %clsvar* @new_address_table()
%var634 = bitcast [33 x i8]* @gsxtmsndfile24 to i8*
%var635 = bitcast [42 x i8]* @gsxtmsndfile16 to i8*
%addytable636 = call %clsvar* @add_address_table(%mzone* %zone628, i8* %var634, i32 0, i8* %var635, i32 3, %clsvar* %addytable633)
%address-table637 = bitcast %clsvar* %addytable636 to i8*

; insert table, function and environment into closure struct
%closure.table640 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure630, i32 0, i32 0
store i8* %address-table637, i8** %closure.table640
%closure.env641 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure630, i32 0, i32 1
store i8* %envptr631, i8** %closure.env641
%closure.func642 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure630, i32 0, i32 2
store void (i8*, i8*, %SF_INFO*)* @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd__621, void (i8*, i8*, %SF_INFO*)** %closure.func642
%closure_size643 = call i64 @llvm_zone_mark_size(%mzone* %zone628)
call void @llvm_zone_ptr_set_size(i8* %clsptr629, i64 %closure_size643)
%wrapper_ptr644 = call i8* @llvm_zone_malloc(%mzone* %zone628, i64 8)
%closure_wrapper645 = bitcast i8* %wrapper_ptr644 to { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**
store { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure630, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_wrapper645

; let value assignment
%hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd = select i1 true, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_wrapper645, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_wrapper645
store { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd, { i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd
%tmp_envptr639 = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_INFO*)*}***}* %environment632, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**** %tmp_envptr639


%val648 = load {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfSU5GTypdPtr
ret {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %val648
}


@hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INFO*)*,  void (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_native(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INFO*)*,  void (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var649 = bitcast [86 x i8]* @gsxtmsndfile25 to i8*
call i32 (i8*, ...) @printf(i8* %var649)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INFO*)*,  void (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*}*
%arg_p_0 = getelementptr {%SF_INFO*}, {%SF_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INFO*)*,  void (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile26 = hidden constant [57 x i8] c"zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd\00"
@gsxtmsndfile27 = hidden constant [65 x i8] c"{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %SF_INFO* @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd__650(i8* %_impz,i8* %_impenv, %SF_INFO* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone651 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}***, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %SF_INFO*
store %SF_INFO* %x, %SF_INFO** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val653 = load %mzone*, %mzone** %fromzPtr
%val654 = load %SF_INFO*, %SF_INFO** %xPtr
%val655 = bitcast %SF_INFO* %val654 to i8*
%res656 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val653, i8* %val655)
br i1 %res656, label %then652, label %else652

then652:
%val657 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val657)
%zone_ptr658 = bitcast %mzone* %val657 to i8*
store i8* %zone_ptr658, i8** %_impzPtr
%tzone664 = load i8*, i8** %_impzPtr
%zone665 = bitcast i8* %tzone664 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_INFO*
%tzone660 = load i8*, i8** %_impzPtr
%zone661 = bitcast i8* %tzone660 to %mzone*
%dat662 = call i8* @llvm_zone_malloc(%mzone* %zone661, i64 28)
call i8* @memset(i8* %dat662, i32 0, i64 28)
%val663 = bitcast i8* %dat662 to %SF_INFO*

; let value assignment
%obj = select i1 true, %SF_INFO* %val663, %SF_INFO* %val663
store %SF_INFO* %obj, %SF_INFO** %objPtr

%val666 = load %SF_INFO*, %SF_INFO** %objPtr
%val667 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val668 = getelementptr %SF_INFO, %SF_INFO* %val667, i64 0, i32 0
%val669 = load i64, i64* %val668
; set tuple
%val670 = getelementptr %SF_INFO, %SF_INFO* %val666, i64 0, i32 0
store i64 %val669, i64* %val670
%val671 = load %SF_INFO*, %SF_INFO** %objPtr
%val672 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val673 = getelementptr %SF_INFO, %SF_INFO* %val672, i64 0, i32 1
%val674 = load i32, i32* %val673
; set tuple
%val675 = getelementptr %SF_INFO, %SF_INFO* %val671, i64 0, i32 1
store i32 %val674, i32* %val675
%val676 = load %SF_INFO*, %SF_INFO** %objPtr
%val677 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val678 = getelementptr %SF_INFO, %SF_INFO* %val677, i64 0, i32 2
%val679 = load i32, i32* %val678
; set tuple
%val680 = getelementptr %SF_INFO, %SF_INFO* %val676, i64 0, i32 2
store i32 %val679, i32* %val680
%val681 = load %SF_INFO*, %SF_INFO** %objPtr
%val682 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val683 = getelementptr %SF_INFO, %SF_INFO* %val682, i64 0, i32 3
%val684 = load i32, i32* %val683
; set tuple
%val685 = getelementptr %SF_INFO, %SF_INFO* %val681, i64 0, i32 3
store i32 %val684, i32* %val685
%val686 = load %SF_INFO*, %SF_INFO** %objPtr
%val687 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val688 = getelementptr %SF_INFO, %SF_INFO* %val687, i64 0, i32 4
%val689 = load i32, i32* %val688
; set tuple
%val690 = getelementptr %SF_INFO, %SF_INFO* %val686, i64 0, i32 4
store i32 %val689, i32* %val690
%val691 = load %SF_INFO*, %SF_INFO** %objPtr
%val692 = load %SF_INFO*, %SF_INFO** %xPtr
; tuple ref
%val693 = getelementptr %SF_INFO, %SF_INFO* %val692, i64 0, i32 5
%val694 = load i32, i32* %val693
; set tuple
%val695 = getelementptr %SF_INFO, %SF_INFO* %val691, i64 0, i32 5
store i32 %val694, i32* %val695
%oldzone696 = call %mzone* @llvm_pop_zone_stack()
%newzone697 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr698 = bitcast %mzone* %newzone697 to i8*
store i8* %zone_ptr698, i8** %_impzPtr
%val699 = load %SF_INFO*, %SF_INFO** %objPtr
ret %SF_INFO* %val699

else652:
%val700 = load %SF_INFO*, %SF_INFO** %xPtr
ret %SF_INFO* %val700
}
@gsxtmsndfile28 = hidden constant [110 x i8] c"zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone720 = load i8*, i8** %_impzPtr
%zone721 = bitcast i8* %tzone720 to %mzone*

; let assign value to symbol zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone721, i64 8)
%zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd to { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}***
%tzone701 = load i8*, i8** %_impzPtr
%zone702 = bitcast i8* %tzone701 to %mzone*
call void @llvm_zone_mark(%mzone* %zone702)
; malloc closure structure
%clsptr703 = call i8* @llvm_zone_malloc(%mzone* %zone702, i64 24)
%closure704 = bitcast i8* %clsptr703 to { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr705 = call i8* @llvm_zone_malloc(%mzone* %zone702, i64 8)
%environment706 = bitcast i8* %envptr705 to {{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable707 = call %clsvar* @new_address_table()
%var708 = bitcast [57 x i8]* @gsxtmsndfile26 to i8*
%var709 = bitcast [65 x i8]* @gsxtmsndfile27 to i8*
%addytable710 = call %clsvar* @add_address_table(%mzone* %zone702, i8* %var708, i32 0, i8* %var709, i32 3, %clsvar* %addytable707)
%address-table711 = bitcast %clsvar* %addytable710 to i8*

; insert table, function and environment into closure struct
%closure.table714 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}* %closure704, i32 0, i32 0
store i8* %address-table711, i8** %closure.table714
%closure.env715 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}* %closure704, i32 0, i32 1
store i8* %envptr705, i8** %closure.env715
%closure.func716 = getelementptr { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}* %closure704, i32 0, i32 2
store %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)* @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd__650, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)** %closure.func716
%closure_size717 = call i64 @llvm_zone_mark_size(%mzone* %zone702)
call void @llvm_zone_ptr_set_size(i8* %clsptr703, i64 %closure_size717)
%wrapper_ptr718 = call i8* @llvm_zone_malloc(%mzone* %zone702, i64 8)
%closure_wrapper719 = bitcast i8* %wrapper_ptr718 to { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}**
store { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}* %closure704, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}** %closure_wrapper719

; let value assignment
%zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}** %closure_wrapper719, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}** %closure_wrapper719
store { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd, { i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd
%tmp_envptr713 = getelementptr {{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}***}* %environment706, i32 0, i32 0
store {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}**** %tmp_envptr713


%val722 = load {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}**, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}** %val722
}


@zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_INFO* @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd(%SF_INFO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*,  %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %SF_INFO* %result
}


define dllexport ccc %SF_INFO* @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_native(%SF_INFO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*,  %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %SF_INFO* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var723 = bitcast [110 x i8]* @gsxtmsndfile28 to i8*
call i32 (i8*, ...) @printf(i8* %var723)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var724 = bitcast [110 x i8]* @gsxtmsndfile28 to i8*
call i32 (i8*, ...) @printf(i8* %var724)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var725 = bitcast [110 x i8]* @gsxtmsndfile28 to i8*
call i32 (i8*, ...) @printf(i8* %var725)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*,  %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %SF_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%SF_INFO*, %mzone*, %mzone*}, {%SF_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
%arg_p_1 = getelementptr {%SF_INFO*, %mzone*, %mzone*}, {%SF_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%SF_INFO*, %mzone*, %mzone*}, {%SF_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0lORk8qLFNGX0lORk8qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)*,  %SF_INFO* (i8*, i8*, %SF_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INFO* %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%SF_FORMAT_INFO = type {i32,i8*,i8*}
@gsxtmsndfile29 = hidden constant [61 x i8] c"SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0\00"
@gsxtmsndfile30 = hidden constant [58 x i8] c"{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**\00"
define dllexport fastcc %SF_FORMAT_INFO* @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0__726(i8* %_impz,i8* %_impenv, i32 %arg_0, i8* %arg_1, i8* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone727 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}*
%SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}, {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**** %SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr


%tzone732 = load i8*, i8** %_impzPtr
%zone733 = bitcast i8* %tzone732 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_FORMAT_INFO*
%tzone728 = load i8*, i8** %_impzPtr
%zone729 = bitcast i8* %tzone728 to %mzone*
%dat730 = call i8* @llvm_zone_malloc(%mzone* %zone729, i64 24)
call i8* @memset(i8* %dat730, i32 0, i64 24)
%val731 = bitcast i8* %dat730 to %SF_FORMAT_INFO*

; let value assignment
%obj = select i1 true, %SF_FORMAT_INFO* %val731, %SF_FORMAT_INFO* %val731
store %SF_FORMAT_INFO* %obj, %SF_FORMAT_INFO** %objPtr

%val734 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val735 = load i32, i32* %arg_0Ptr
; set tuple
%val736 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val734, i64 0, i32 0
store i32 %val735, i32* %val736
%val737 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val738 = load i8*, i8** %arg_1Ptr
; set tuple
%val739 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val737, i64 0, i32 1
store i8* %val738, i8** %val739
%val740 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val741 = load i8*, i8** %arg_2Ptr
; set tuple
%val742 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val740, i64 0, i32 2
store i8* %val741, i8** %val742
%val743 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
ret %SF_FORMAT_INFO* %val743
}
@gsxtmsndfile31 = hidden constant [114 x i8] c"SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone763 = load i8*, i8** %_impzPtr
%zone764 = bitcast i8* %tzone763 to %mzone*

; let assign value to symbol SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0
%dat_SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone764, i64 8)
%SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr = bitcast i8* %dat_SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***
%tzone744 = load i8*, i8** %_impzPtr
%zone745 = bitcast i8* %tzone744 to %mzone*
call void @llvm_zone_mark(%mzone* %zone745)
; malloc closure structure
%clsptr746 = call i8* @llvm_zone_malloc(%mzone* %zone745, i64 24)
%closure747 = bitcast i8* %clsptr746 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*

; malloc environment structure
%envptr748 = call i8* @llvm_zone_malloc(%mzone* %zone745, i64 8)
%environment749 = bitcast i8* %envptr748 to {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}*

; malloc closure address table
%addytable750 = call %clsvar* @new_address_table()
%var751 = bitcast [61 x i8]* @gsxtmsndfile29 to i8*
%var752 = bitcast [58 x i8]* @gsxtmsndfile30 to i8*
%addytable753 = call %clsvar* @add_address_table(%mzone* %zone745, i8* %var751, i32 0, i8* %var752, i32 3, %clsvar* %addytable750)
%address-table754 = bitcast %clsvar* %addytable753 to i8*

; insert table, function and environment into closure struct
%closure.table757 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure747, i32 0, i32 0
store i8* %address-table754, i8** %closure.table757
%closure.env758 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure747, i32 0, i32 1
store i8* %envptr748, i8** %closure.env758
%closure.func759 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure747, i32 0, i32 2
store %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)* @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0__726, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %closure.func759
%closure_size760 = call i64 @llvm_zone_mark_size(%mzone* %zone745)
call void @llvm_zone_ptr_set_size(i8* %clsptr746, i64 %closure_size760)
%wrapper_ptr761 = call i8* @llvm_zone_malloc(%mzone* %zone745, i64 8)
%closure_wrapper762 = bitcast i8* %wrapper_ptr761 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
store { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure747, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_wrapper762

; let value assignment
%SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0 = select i1 true, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_wrapper762, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_wrapper762
store { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*** %SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0
%tmp_envptr756 = getelementptr {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}, {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}* %environment749, i32 0, i32 0
store {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*** %SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**** %tmp_envptr756


%val765 = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*** %SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr
ret {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %val765
}


@SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_FORMAT_INFO* @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0(i32 %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
ret %SF_FORMAT_INFO* %result
}


define dllexport ccc %SF_FORMAT_INFO* @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_native(i32 %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
ret %SF_FORMAT_INFO* %result
}


define dllexport ccc i8*  @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var766 = bitcast [114 x i8]* @gsxtmsndfile31 to i8*
call i32 (i8*, ...) @printf(i8* %var766)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var767 = bitcast [114 x i8]* @gsxtmsndfile31 to i8*
call i32 (i8*, ...) @printf(i8* %var767)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var768 = bitcast [114 x i8]* @gsxtmsndfile31 to i8*
call i32 (i8*, ...) @printf(i8* %var768)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
%tmpres = bitcast %SF_FORMAT_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i8*, i8*}*
%arg_p_0 = getelementptr {i32, i8*, i8*}, {i32, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i8*, i8*}, {i32, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i32, i8*, i8*}, {i32, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile32 = hidden constant [63 x i8] c"SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0\00"
define dllexport fastcc %SF_FORMAT_INFO* @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0__769(i8* %_impz,i8* %_impenv, i32 %arg_0, i8* %arg_1, i8* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone770 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}*
%SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}, {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**** %SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr


%tzone775 = load i8*, i8** %_impzPtr
%zone776 = bitcast i8* %tzone775 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_FORMAT_INFO*
%tzone771 = load i8*, i8** %_impzPtr
%zone772 = bitcast i8* %tzone771 to %mzone*
%dat773 = call i8* @llvm_zone_malloc(%mzone* %zone772, i64 24)
call i8* @memset(i8* %dat773, i32 0, i64 24)
%val774 = bitcast i8* %dat773 to %SF_FORMAT_INFO*

; let value assignment
%obj = select i1 true, %SF_FORMAT_INFO* %val774, %SF_FORMAT_INFO* %val774
store %SF_FORMAT_INFO* %obj, %SF_FORMAT_INFO** %objPtr

%val777 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val778 = load i32, i32* %arg_0Ptr
; set tuple
%val779 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val777, i64 0, i32 0
store i32 %val778, i32* %val779
%val780 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val781 = load i8*, i8** %arg_1Ptr
; set tuple
%val782 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val780, i64 0, i32 1
store i8* %val781, i8** %val782
%val783 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val784 = load i8*, i8** %arg_2Ptr
; set tuple
%val785 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val783, i64 0, i32 2
store i8* %val784, i8** %val785
%val786 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
ret %SF_FORMAT_INFO* %val786
}
@gsxtmsndfile33 = hidden constant [116 x i8] c"SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone806 = load i8*, i8** %_impzPtr
%zone807 = bitcast i8* %tzone806 to %mzone*

; let assign value to symbol SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0
%dat_SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone807, i64 8)
%SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr = bitcast i8* %dat_SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***
%tzone787 = load i8*, i8** %_impzPtr
%zone788 = bitcast i8* %tzone787 to %mzone*
call void @llvm_zone_mark(%mzone* %zone788)
; malloc closure structure
%clsptr789 = call i8* @llvm_zone_malloc(%mzone* %zone788, i64 24)
%closure790 = bitcast i8* %clsptr789 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*

; malloc environment structure
%envptr791 = call i8* @llvm_zone_malloc(%mzone* %zone788, i64 8)
%environment792 = bitcast i8* %envptr791 to {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}*

; malloc closure address table
%addytable793 = call %clsvar* @new_address_table()
%var794 = bitcast [63 x i8]* @gsxtmsndfile32 to i8*
%var795 = bitcast [58 x i8]* @gsxtmsndfile30 to i8*
%addytable796 = call %clsvar* @add_address_table(%mzone* %zone788, i8* %var794, i32 0, i8* %var795, i32 3, %clsvar* %addytable793)
%address-table797 = bitcast %clsvar* %addytable796 to i8*

; insert table, function and environment into closure struct
%closure.table800 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure790, i32 0, i32 0
store i8* %address-table797, i8** %closure.table800
%closure.env801 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure790, i32 0, i32 1
store i8* %envptr791, i8** %closure.env801
%closure.func802 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure790, i32 0, i32 2
store %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)* @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0__769, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %closure.func802
%closure_size803 = call i64 @llvm_zone_mark_size(%mzone* %zone788)
call void @llvm_zone_ptr_set_size(i8* %clsptr789, i64 %closure_size803)
%wrapper_ptr804 = call i8* @llvm_zone_malloc(%mzone* %zone788, i64 8)
%closure_wrapper805 = bitcast i8* %wrapper_ptr804 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
store { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure790, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_wrapper805

; let value assignment
%SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0 = select i1 true, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_wrapper805, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_wrapper805
store { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*** %SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0
%tmp_envptr799 = getelementptr {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}, {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}* %environment792, i32 0, i32 0
store {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*** %SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**** %tmp_envptr799


%val808 = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*** %SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr
ret {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %val808
}


@SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_FORMAT_INFO* @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0(i32 %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
ret %SF_FORMAT_INFO* %result
}


define dllexport ccc %SF_FORMAT_INFO* @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_native(i32 %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
ret %SF_FORMAT_INFO* %result
}


define dllexport ccc i8*  @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var809 = bitcast [116 x i8]* @gsxtmsndfile33 to i8*
call i32 (i8*, ...) @printf(i8* %var809)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var810 = bitcast [116 x i8]* @gsxtmsndfile33 to i8*
call i32 (i8*, ...) @printf(i8* %var810)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var811 = bitcast [116 x i8]* @gsxtmsndfile33 to i8*
call i32 (i8*, ...) @printf(i8* %var811)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
%tmpres = bitcast %SF_FORMAT_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i8*, i8*}*
%arg_p_0 = getelementptr {i32, i8*, i8*}, {i32, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i8*, i8*}, {i32, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i32, i8*, i8*}, {i32, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_z_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile34 = hidden constant [63 x i8] c"SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0\00"
define dllexport fastcc %SF_FORMAT_INFO* @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0__812(i8* %_impz,i8* %_impenv, i32 %arg_0, i8* %arg_1, i8* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone813 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}*
%SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}, {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**** %SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr


%tzone816 = load i8*, i8** %_impzPtr
%zone817 = bitcast i8* %tzone816 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_FORMAT_INFO*
%dat814 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat814, i32 0, i64 24)
%val815 = bitcast i8* %dat814 to %SF_FORMAT_INFO*

; let value assignment
%obj = select i1 true, %SF_FORMAT_INFO* %val815, %SF_FORMAT_INFO* %val815
store %SF_FORMAT_INFO* %obj, %SF_FORMAT_INFO** %objPtr

%val818 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val819 = load i32, i32* %arg_0Ptr
; set tuple
%val820 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val818, i64 0, i32 0
store i32 %val819, i32* %val820
%val821 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val822 = load i8*, i8** %arg_1Ptr
; set tuple
%val823 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val821, i64 0, i32 1
store i8* %val822, i8** %val823
%val824 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val825 = load i8*, i8** %arg_2Ptr
; set tuple
%val826 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val824, i64 0, i32 2
store i8* %val825, i8** %val826
%val827 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
ret %SF_FORMAT_INFO* %val827
}
@gsxtmsndfile35 = hidden constant [116 x i8] c"SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone847 = load i8*, i8** %_impzPtr
%zone848 = bitcast i8* %tzone847 to %mzone*

; let assign value to symbol SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0
%dat_SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone848, i64 8)
%SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr = bitcast i8* %dat_SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***
%tzone828 = load i8*, i8** %_impzPtr
%zone829 = bitcast i8* %tzone828 to %mzone*
call void @llvm_zone_mark(%mzone* %zone829)
; malloc closure structure
%clsptr830 = call i8* @llvm_zone_malloc(%mzone* %zone829, i64 24)
%closure831 = bitcast i8* %clsptr830 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*

; malloc environment structure
%envptr832 = call i8* @llvm_zone_malloc(%mzone* %zone829, i64 8)
%environment833 = bitcast i8* %envptr832 to {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}*

; malloc closure address table
%addytable834 = call %clsvar* @new_address_table()
%var835 = bitcast [63 x i8]* @gsxtmsndfile34 to i8*
%var836 = bitcast [58 x i8]* @gsxtmsndfile30 to i8*
%addytable837 = call %clsvar* @add_address_table(%mzone* %zone829, i8* %var835, i32 0, i8* %var836, i32 3, %clsvar* %addytable834)
%address-table838 = bitcast %clsvar* %addytable837 to i8*

; insert table, function and environment into closure struct
%closure.table841 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure831, i32 0, i32 0
store i8* %address-table838, i8** %closure.table841
%closure.env842 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure831, i32 0, i32 1
store i8* %envptr832, i8** %closure.env842
%closure.func843 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure831, i32 0, i32 2
store %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)* @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0__812, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %closure.func843
%closure_size844 = call i64 @llvm_zone_mark_size(%mzone* %zone829)
call void @llvm_zone_ptr_set_size(i8* %clsptr830, i64 %closure_size844)
%wrapper_ptr845 = call i8* @llvm_zone_malloc(%mzone* %zone829, i64 8)
%closure_wrapper846 = bitcast i8* %wrapper_ptr845 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
store { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure831, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_wrapper846

; let value assignment
%SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0 = select i1 true, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_wrapper846, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_wrapper846
store { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*** %SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0
%tmp_envptr840 = getelementptr {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}, {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}***}* %environment833, i32 0, i32 0
store {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*** %SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**** %tmp_envptr840


%val849 = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*** %SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0Ptr
ret {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %val849
}


@SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_FORMAT_INFO* @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0(i32 %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
ret %SF_FORMAT_INFO* %result
}


define dllexport ccc %SF_FORMAT_INFO* @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_native(i32 %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
ret %SF_FORMAT_INFO* %result
}


define dllexport ccc i8*  @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var850 = bitcast [116 x i8]* @gsxtmsndfile35 to i8*
call i32 (i8*, ...) @printf(i8* %var850)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var851 = bitcast [116 x i8]* @gsxtmsndfile35 to i8*
call i32 (i8*, ...) @printf(i8* %var851)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var852 = bitcast [116 x i8]* @gsxtmsndfile35 to i8*
call i32 (i8*, ...) @printf(i8* %var852)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
%tmpres = bitcast %SF_FORMAT_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i8*, i8*}*
%arg_p_0 = getelementptr {i32, i8*, i8*}, {i32, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i8*, i8*}, {i32, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i32, i8*, i8*}, {i32, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_h_adhoc_W1NGX0ZPUk1BVF9JTkZPKixpMzIsaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO* (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile36 = hidden constant [22 x i8] c"<SF_FORMAT_INFO:null>\00"
@gsxtmsndfile37 = hidden constant [17 x i8] c"<SF_FORMAT_INFO:\00"
@gsxtmsndfile38 = hidden constant [50 x i8] c"toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ\00"
@gsxtmsndfile39 = hidden constant [53 x i8] c"{i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ__853(i8* %_impz,i8* %_impenv, %SF_FORMAT_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone854 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}***}*
%toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQPtr = load {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}***, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}**** %toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQPtr_

; setup arguments
%xPtr = alloca %SF_FORMAT_INFO*
store %SF_FORMAT_INFO* %x, %SF_FORMAT_INFO** %xPtr


%val856 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
%val857 = icmp eq %SF_FORMAT_INFO* %val856, null
br i1 %val857, label %then855, label %else855

then855:
%zone858 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone858)
%zone_ptr859 = bitcast %mzone* %zone858 to i8*
store i8* %zone_ptr859, i8** %_impzPtr
%tzone869 = load i8*, i8** %_impzPtr
%zone870 = bitcast i8* %tzone869 to %mzone*

; let assign value to symbol res2
%res2Ptr = alloca %String*
%tzone874 = load i8*, i8** %_impzPtr
%zone875 = bitcast i8* %tzone874 to %mzone*

; let assign value to symbol zone2
%zone2Ptr = alloca %mzone*
%tzone877 = load i8*, i8** %_impzPtr
%zone878 = bitcast i8* %tzone877 to %mzone*

; let assign value to symbol newz2
%newz2Ptr = alloca %mzone*
%tzone861 = load i8*, i8** %_impzPtr
%zone862 = bitcast i8* %tzone861 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat860 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat860, i8* %dat860
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val863 = load i8*, i8** %xx_t_mstPtr
%var864 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var865 = bitcast [22 x i8]* @gsxtmsndfile36 to i8*

%val866 = call i32 (i8*,i8*, ...) @sprintf(i8* %val863, i8* %var864, i8* %var865)
%val867 = load i8*, i8** %xx_t_mstPtr
%res868 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val867)

; let value assignment
%res2 = select i1 true, %String* %res868, %String* %res868
store %String* %res2, %String** %res2Ptr

%oldzone871 = call %mzone* @llvm_pop_zone_stack()
%newzone872 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr873 = bitcast %mzone* %newzone872 to i8*
store i8* %zone_ptr873, i8** %_impzPtr

; let value assignment
%zone2 = select i1 true, %mzone* %oldzone871, %mzone* %oldzone871
store %mzone* %zone2, %mzone** %zone2Ptr

%res876 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz2 = select i1 true, %mzone* %res876, %mzone* %res876
store %mzone* %newz2, %mzone** %newz2Ptr

%tzone883 = load i8*, i8** %_impzPtr
%zone884 = bitcast i8* %tzone883 to %mzone*

; let assign value to symbol rescopy2
%rescopy2Ptr = alloca %String*
%tzone889 = load i8*, i8** %_impzPtr
%zone890 = bitcast i8* %tzone889 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone892 = load i8*, i8** %_impzPtr
%zone893 = bitcast i8* %tzone892 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val879 = load %String*, %String** %res2Ptr
%val880 = load %mzone*, %mzone** %zone2Ptr
%val881 = load %mzone*, %mzone** %newz2Ptr
%res882 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val879, %mzone* %val880, %mzone* %val881)

; let value assignment
%rescopy2 = select i1 true, %String* %res882, %String* %res882
store %String* %rescopy2, %String** %rescopy2Ptr

%val885 = load %mzone*, %mzone** %zone2Ptr
; tuple ref
%val886 = getelementptr %mzone, %mzone* %val885, i64 0, i32 4
%val887 = load i8*, i8** %val886
%val888 = bitcast i8* %val887 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val888, {i64,i8*,i8*}* %val888
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null891 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null891, {i8*, i8*, void (i8*, i8*)*}** %null891
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone929 = load i8*, i8** %_impzPtr
%zone930 = bitcast i8* %tzone929 to %mzone*
%ifptr919 = alloca i1
%ifptr895 = alloca i1
; while loop
%val896 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val897 = icmp eq {i64,i8*,i8*}* %val896, null
br i1 %val897, label %then895, label %else895

then895:
%res898 = call ccc i1 @impc_false()
store i1 %res898, i1* %ifptr895
br label %ifcont895

else895:
%res899 = call ccc i1 @impc_true()
store i1 %res899, i1* %ifptr895
br label %ifcont895

ifcont895:
%ifres900 = load i1, i1* %ifptr895

br i1 %ifres900, label %loop894, label %after894

loop894:
; do set!
%val901 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val902 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val901, i64 0, i32 1
%val903 = load i8*, i8** %val902
%val904 = bitcast i8* %val903 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val904, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval905 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val906 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval905
%fPtr907 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val906, i32 0, i32 2
%ePtr908 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val906, i32 0, i32 1
%f909 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr907
%e910 = load i8*, i8** %ePtr908
%tzone911 = load i8*, i8** %_impzPtr
%zone912 = bitcast i8* %tzone911 to %mzone*
%z913 = bitcast %mzone* %zone912 to i8*
tail call fastcc void %f909(i8* %z913, i8* %e910)
; do set!
%val915 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val916 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val915, i64 0, i32 2
%val917 = load i8*, i8** %val916
%val918 = bitcast i8* %val917 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val918, {i64,i8*,i8*}** %hookPtr
%val920 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val921 = icmp eq {i64,i8*,i8*}* %val920, null
br i1 %val921, label %then919, label %else919

then919:
%res922 = call ccc i1 @impc_false()
store i1 %res922, i1* %ifptr919
br label %ifcont919

else919:
%res923 = call ccc i1 @impc_true()
store i1 %res923, i1* %ifptr919
br label %ifcont919

ifcont919:
%ifres924 = load i1, i1* %ifptr919

br i1 %ifres924, label %loop894, label %after894

after894:
%val926 = load %mzone*, %mzone** %zone2Ptr
call ccc void @llvm_zone_destroy(%mzone* %val926)
%val928 = load %String*, %String** %rescopy2Ptr
ret %String* %val928

else855:
%zone931 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone931)
%zone_ptr932 = bitcast %mzone* %zone931 to i8*
store i8* %zone_ptr932, i8** %_impzPtr
%tzone987 = load i8*, i8** %_impzPtr
%zone988 = bitcast i8* %tzone987 to %mzone*

; let assign value to symbol res3
%res3Ptr = alloca %String*
%tzone992 = load i8*, i8** %_impzPtr
%zone993 = bitcast i8* %tzone992 to %mzone*

; let assign value to symbol zone3
%zone3Ptr = alloca %mzone*
%tzone995 = load i8*, i8** %_impzPtr
%zone996 = bitcast i8* %tzone995 to %mzone*

; let assign value to symbol newz3
%newz3Ptr = alloca %mzone*
%tzone934 = load i8*, i8** %_impzPtr
%zone935 = bitcast i8* %tzone934 to %mzone*

; let assign value to symbol xx_t_mst_s_10
%xx_t_mst_s_10Ptr = alloca i8*
%dat933 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_10 = select i1 true, i8* %dat933, i8* %dat933
store i8* %xx_t_mst_s_10, i8** %xx_t_mst_s_10Ptr

%val936 = load i8*, i8** %xx_t_mst_s_10Ptr
%var937 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var938 = bitcast [17 x i8]* @gsxtmsndfile37 to i8*

%val939 = call i32 (i8*,i8*, ...) @sprintf(i8* %val936, i8* %var937, i8* %var938)
%val940 = load i8*, i8** %xx_t_mst_s_10Ptr
%res941 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val940)
%val942 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val943 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val942, i64 0, i32 0
%val944 = load i32, i32* %val943
%res945 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val944)
%res946 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res941, %String* %res945)
%tzone948 = load i8*, i8** %_impzPtr
%zone949 = bitcast i8* %tzone948 to %mzone*

; let assign value to symbol xx_t_mst_s_11
%xx_t_mst_s_11Ptr = alloca i8*
%dat947 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_11 = select i1 true, i8* %dat947, i8* %dat947
store i8* %xx_t_mst_s_11, i8** %xx_t_mst_s_11Ptr

%val950 = load i8*, i8** %xx_t_mst_s_11Ptr
%var951 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var952 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val953 = call i32 (i8*,i8*, ...) @sprintf(i8* %val950, i8* %var951, i8* %var952)
%val954 = load i8*, i8** %xx_t_mst_s_11Ptr
%res955 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val954)
%res956 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res946, %String* %res955)
%val957 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val958 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val957, i64 0, i32 1
%val959 = load i8*, i8** %val958
%res960 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ(i8* %val959)
%res961 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res956, %String* %res960)
%tzone963 = load i8*, i8** %_impzPtr
%zone964 = bitcast i8* %tzone963 to %mzone*

; let assign value to symbol xx_t_mst_s_12
%xx_t_mst_s_12Ptr = alloca i8*
%dat962 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_12 = select i1 true, i8* %dat962, i8* %dat962
store i8* %xx_t_mst_s_12, i8** %xx_t_mst_s_12Ptr

%val965 = load i8*, i8** %xx_t_mst_s_12Ptr
%var966 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var967 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val968 = call i32 (i8*,i8*, ...) @sprintf(i8* %val965, i8* %var966, i8* %var967)
%val969 = load i8*, i8** %xx_t_mst_s_12Ptr
%res970 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val969)
%res971 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res961, %String* %res970)
%val972 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val973 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val972, i64 0, i32 2
%val974 = load i8*, i8** %val973
%res975 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ(i8* %val974)
%res976 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res971, %String* %res975)
%tzone978 = load i8*, i8** %_impzPtr
%zone979 = bitcast i8* %tzone978 to %mzone*

; let assign value to symbol xx_t_mst_s_13
%xx_t_mst_s_13Ptr = alloca i8*
%dat977 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_13 = select i1 true, i8* %dat977, i8* %dat977
store i8* %xx_t_mst_s_13, i8** %xx_t_mst_s_13Ptr

%val980 = load i8*, i8** %xx_t_mst_s_13Ptr
%var981 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var982 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val983 = call i32 (i8*,i8*, ...) @sprintf(i8* %val980, i8* %var981, i8* %var982)
%val984 = load i8*, i8** %xx_t_mst_s_13Ptr
%res985 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val984)
%res986 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res976, %String* %res985)

; let value assignment
%res3 = select i1 true, %String* %res986, %String* %res986
store %String* %res3, %String** %res3Ptr

%oldzone989 = call %mzone* @llvm_pop_zone_stack()
%newzone990 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr991 = bitcast %mzone* %newzone990 to i8*
store i8* %zone_ptr991, i8** %_impzPtr

; let value assignment
%zone3 = select i1 true, %mzone* %oldzone989, %mzone* %oldzone989
store %mzone* %zone3, %mzone** %zone3Ptr

%res994 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz3 = select i1 true, %mzone* %res994, %mzone* %res994
store %mzone* %newz3, %mzone** %newz3Ptr

%tzone1001 = load i8*, i8** %_impzPtr
%zone1002 = bitcast i8* %tzone1001 to %mzone*

; let assign value to symbol rescopy3
%rescopy3Ptr = alloca %String*
%tzone1007 = load i8*, i8** %_impzPtr
%zone1008 = bitcast i8* %tzone1007 to %mzone*

; let assign value to symbol hook_s_14
%hook_s_14Ptr = alloca {i64,i8*,i8*}*
%tzone1010 = load i8*, i8** %_impzPtr
%zone1011 = bitcast i8* %tzone1010 to %mzone*

; let assign value to symbol f_s_15
%f_s_15Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val997 = load %String*, %String** %res3Ptr
%val998 = load %mzone*, %mzone** %zone3Ptr
%val999 = load %mzone*, %mzone** %newz3Ptr
%res1000 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val997, %mzone* %val998, %mzone* %val999)

; let value assignment
%rescopy3 = select i1 true, %String* %res1000, %String* %res1000
store %String* %rescopy3, %String** %rescopy3Ptr

%val1003 = load %mzone*, %mzone** %zone3Ptr
; tuple ref
%val1004 = getelementptr %mzone, %mzone* %val1003, i64 0, i32 4
%val1005 = load i8*, i8** %val1004
%val1006 = bitcast i8* %val1005 to {i64,i8*,i8*}*

; let value assignment
%hook_s_14 = select i1 true, {i64,i8*,i8*}* %val1006, {i64,i8*,i8*}* %val1006
store {i64,i8*,i8*}* %hook_s_14, {i64,i8*,i8*}** %hook_s_14Ptr

%null1009 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_15 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null1009, {i8*, i8*, void (i8*, i8*)*}** %null1009
store {i8*, i8*, void (i8*, i8*)*}** %f_s_15, {i8*, i8*, void (i8*, i8*)*}*** %f_s_15Ptr

; promote local stack var allocations
%tzone1047 = load i8*, i8** %_impzPtr
%zone1048 = bitcast i8* %tzone1047 to %mzone*
%ifptr1037 = alloca i1
%ifptr1013 = alloca i1
; while loop
%val1014 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_14Ptr
%val1015 = icmp eq {i64,i8*,i8*}* %val1014, null
br i1 %val1015, label %then1013, label %else1013

then1013:
%res1016 = call ccc i1 @impc_false()
store i1 %res1016, i1* %ifptr1013
br label %ifcont1013

else1013:
%res1017 = call ccc i1 @impc_true()
store i1 %res1017, i1* %ifptr1013
br label %ifcont1013

ifcont1013:
%ifres1018 = load i1, i1* %ifptr1013

br i1 %ifres1018, label %loop1012, label %after1012

loop1012:
; do set!
%val1019 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_14Ptr
; tuple ref
%val1020 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1019, i64 0, i32 1
%val1021 = load i8*, i8** %val1020
%val1022 = bitcast i8* %val1021 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val1022, {i8*, i8*, void (i8*, i8*)*}*** %f_s_15Ptr

; apply closure 
%vval1023 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_15Ptr
%val1024 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval1023
%fPtr1025 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1024, i32 0, i32 2
%ePtr1026 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1024, i32 0, i32 1
%f1027 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr1025
%e1028 = load i8*, i8** %ePtr1026
%tzone1029 = load i8*, i8** %_impzPtr
%zone1030 = bitcast i8* %tzone1029 to %mzone*
%z1031 = bitcast %mzone* %zone1030 to i8*
tail call fastcc void %f1027(i8* %z1031, i8* %e1028)
; do set!
%val1033 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_14Ptr
; tuple ref
%val1034 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1033, i64 0, i32 2
%val1035 = load i8*, i8** %val1034
%val1036 = bitcast i8* %val1035 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val1036, {i64,i8*,i8*}** %hook_s_14Ptr
%val1038 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_14Ptr
%val1039 = icmp eq {i64,i8*,i8*}* %val1038, null
br i1 %val1039, label %then1037, label %else1037

then1037:
%res1040 = call ccc i1 @impc_false()
store i1 %res1040, i1* %ifptr1037
br label %ifcont1037

else1037:
%res1041 = call ccc i1 @impc_true()
store i1 %res1041, i1* %ifptr1037
br label %ifcont1037

ifcont1037:
%ifres1042 = load i1, i1* %ifptr1037

br i1 %ifres1042, label %loop1012, label %after1012

after1012:
%val1044 = load %mzone*, %mzone** %zone3Ptr
call ccc void @llvm_zone_destroy(%mzone* %val1044)
%val1046 = load %String*, %String** %rescopy3Ptr
ret %String* %val1046
}
@gsxtmsndfile40 = hidden constant [103 x i8] c"toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}** @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1068 = load i8*, i8** %_impzPtr
%zone1069 = bitcast i8* %tzone1068 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ
%dat_toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone1069, i64 8)
%toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ to { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}***
%tzone1049 = load i8*, i8** %_impzPtr
%zone1050 = bitcast i8* %tzone1049 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1050)
; malloc closure structure
%clsptr1051 = call i8* @llvm_zone_malloc(%mzone* %zone1050, i64 24)
%closure1052 = bitcast i8* %clsptr1051 to { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}*

; malloc environment structure
%envptr1053 = call i8* @llvm_zone_malloc(%mzone* %zone1050, i64 8)
%environment1054 = bitcast i8* %envptr1053 to {{i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}***}*

; malloc closure address table
%addytable1055 = call %clsvar* @new_address_table()
%var1056 = bitcast [50 x i8]* @gsxtmsndfile38 to i8*
%var1057 = bitcast [53 x i8]* @gsxtmsndfile39 to i8*
%addytable1058 = call %clsvar* @add_address_table(%mzone* %zone1050, i8* %var1056, i32 0, i8* %var1057, i32 3, %clsvar* %addytable1055)
%address-table1059 = bitcast %clsvar* %addytable1058 to i8*

; insert table, function and environment into closure struct
%closure.table1062 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1052, i32 0, i32 0
store i8* %address-table1059, i8** %closure.table1062
%closure.env1063 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1052, i32 0, i32 1
store i8* %envptr1053, i8** %closure.env1063
%closure.func1064 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1052, i32 0, i32 2
store %String* (i8*, i8*, %SF_FORMAT_INFO*)* @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ__853, %String* (i8*, i8*, %SF_FORMAT_INFO*)** %closure.func1064
%closure_size1065 = call i64 @llvm_zone_mark_size(%mzone* %zone1050)
call void @llvm_zone_ptr_set_size(i8* %clsptr1051, i64 %closure_size1065)
%wrapper_ptr1066 = call i8* @llvm_zone_malloc(%mzone* %zone1050, i64 8)
%closure_wrapper1067 = bitcast i8* %wrapper_ptr1066 to { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}**
store { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1052, { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_wrapper1067

; let value assignment
%toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_wrapper1067, { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_wrapper1067
store { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}** %toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ, { i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ
%tmp_envptr1061 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}***}* %environment1054, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQPtr, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}**** %tmp_envptr1061


%val1070 = load {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}**, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}** %val1070
}


@toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}** @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ(%SF_FORMAT_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_FORMAT_INFO*)*,  %String* (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_native(%SF_FORMAT_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_FORMAT_INFO*)*,  %String* (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1071 = bitcast [103 x i8]* @gsxtmsndfile40 to i8*
call i32 (i8*, ...) @printf(i8* %var1071)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_FORMAT_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_FORMAT_INFO*)*,  %String* (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_FORMAT_INFO*}*
%arg_p_0 = getelementptr {%SF_FORMAT_INFO*}, {%SF_FORMAT_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_FORMAT_INFO*)*,  %String* (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile41 = hidden constant [43 x i8] c"print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ\00"
@gsxtmsndfile42 = hidden constant [49 x i8] c"{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ__1072(i8* %_impz,i8* %_impenv, %SF_FORMAT_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1073 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***}*
%print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr = load {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**** %print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr_

; setup arguments
%xPtr = alloca %SF_FORMAT_INFO*
store %SF_FORMAT_INFO* %x, %SF_FORMAT_INFO** %xPtr


%val1075 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
%val1076 = icmp eq %SF_FORMAT_INFO* %val1075, null
br i1 %val1076, label %then1074, label %else1074

then1074:
%var1077 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1078 = bitcast [22 x i8]* @gsxtmsndfile36 to i8*

%val1079 = call i32 (i8*, ...) @printf(i8* %var1077, i8* %var1078)
br label %ifcont1074

else1074:
%var1081 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1082 = bitcast [17 x i8]* @gsxtmsndfile37 to i8*

%val1083 = call i32 (i8*, ...) @printf(i8* %var1081, i8* %var1082)
%val1084 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1085 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1084, i64 0, i32 0
%val1086 = load i32, i32* %val1085
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val1086)
%var1088 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1089 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val1090 = call i32 (i8*, ...) @printf(i8* %var1088, i8* %var1089)
%val1091 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1092 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1091, i64 0, i32 1
%val1093 = load i8*, i8** %val1092
call fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %val1093)
%var1095 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1096 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val1097 = call i32 (i8*, ...) @printf(i8* %var1095, i8* %var1096)
%val1098 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1099 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1098, i64 0, i32 2
%val1100 = load i8*, i8** %val1099
call fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %val1100)
%var1102 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1103 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val1104 = call i32 (i8*, ...) @printf(i8* %var1102, i8* %var1103)
br label %ifcont1074

ifcont1074:
ret void
}
@gsxtmsndfile43 = hidden constant [96 x i8] c"print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1126 = load i8*, i8** %_impzPtr
%zone1127 = bitcast i8* %tzone1126 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ
%dat_print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone1127, i64 8)
%print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ to { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***
%tzone1107 = load i8*, i8** %_impzPtr
%zone1108 = bitcast i8* %tzone1107 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1108)
; malloc closure structure
%clsptr1109 = call i8* @llvm_zone_malloc(%mzone* %zone1108, i64 24)
%closure1110 = bitcast i8* %clsptr1109 to { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*

; malloc environment structure
%envptr1111 = call i8* @llvm_zone_malloc(%mzone* %zone1108, i64 8)
%environment1112 = bitcast i8* %envptr1111 to {{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***}*

; malloc closure address table
%addytable1113 = call %clsvar* @new_address_table()
%var1114 = bitcast [43 x i8]* @gsxtmsndfile41 to i8*
%var1115 = bitcast [49 x i8]* @gsxtmsndfile42 to i8*
%addytable1116 = call %clsvar* @add_address_table(%mzone* %zone1108, i8* %var1114, i32 0, i8* %var1115, i32 3, %clsvar* %addytable1113)
%address-table1117 = bitcast %clsvar* %addytable1116 to i8*

; insert table, function and environment into closure struct
%closure.table1120 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1110, i32 0, i32 0
store i8* %address-table1117, i8** %closure.table1120
%closure.env1121 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1110, i32 0, i32 1
store i8* %envptr1111, i8** %closure.env1121
%closure.func1122 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1110, i32 0, i32 2
store void (i8*, i8*, %SF_FORMAT_INFO*)* @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ__1072, void (i8*, i8*, %SF_FORMAT_INFO*)** %closure.func1122
%closure_size1123 = call i64 @llvm_zone_mark_size(%mzone* %zone1108)
call void @llvm_zone_ptr_set_size(i8* %clsptr1109, i64 %closure_size1123)
%wrapper_ptr1124 = call i8* @llvm_zone_malloc(%mzone* %zone1108, i64 8)
%closure_wrapper1125 = bitcast i8* %wrapper_ptr1124 to { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**
store { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1110, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_wrapper1125

; let value assignment
%print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_wrapper1125, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_wrapper1125
store { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ
%tmp_envptr1119 = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***}* %environment1112, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**** %tmp_envptr1119


%val1128 = load {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr
ret {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %val1128
}


@print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ(%SF_FORMAT_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_FORMAT_INFO*)*,  void (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_native(%SF_FORMAT_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_FORMAT_INFO*)*,  void (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1129 = bitcast [96 x i8]* @gsxtmsndfile43 to i8*
call i32 (i8*, ...) @printf(i8* %var1129)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_FORMAT_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_FORMAT_INFO*)*,  void (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_FORMAT_INFO*}*
%arg_p_0 = getelementptr {%SF_FORMAT_INFO*}, {%SF_FORMAT_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_FORMAT_INFO*)*,  void (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile44 = hidden constant [64 x i8] c"SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ\00"
@gsxtmsndfile45 = hidden constant [57 x i8] c"{i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}**\00"
define dllexport fastcc %SF_FORMAT_INFO @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ__1130(i8* %_impz,i8* %_impenv, i32 %arg_0, i8* %arg_1, i8* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1131 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}***}*
%SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQPtr_ = getelementptr {{i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}***}, {{i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQPtr = load {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}***, {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}**** %SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i8*
store i8* %arg_1, i8** %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr


%tzone1133 = load i8*, i8** %_impzPtr
%zone1134 = bitcast i8* %tzone1133 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_FORMAT_INFO*
%dat1132 = alloca %SF_FORMAT_INFO, align 16

; let value assignment
%obj = select i1 true, %SF_FORMAT_INFO* %dat1132, %SF_FORMAT_INFO* %dat1132
store %SF_FORMAT_INFO* %obj, %SF_FORMAT_INFO** %objPtr

%val1135 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val1136 = load i32, i32* %arg_0Ptr
; set tuple
%val1137 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1135, i64 0, i32 0
store i32 %val1136, i32* %val1137
%val1138 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val1139 = load i8*, i8** %arg_1Ptr
; set tuple
%val1140 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1138, i64 0, i32 1
store i8* %val1139, i8** %val1140
%val1141 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val1142 = load i8*, i8** %arg_2Ptr
; set tuple
%val1143 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1141, i64 0, i32 2
store i8* %val1142, i8** %val1143
%val1144 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
; pointer ref
%val1145 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1144, i64 0
%val1146 = load %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1145
ret %SF_FORMAT_INFO %val1146
}
@gsxtmsndfile46 = hidden constant [117 x i8] c"SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}** @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1166 = load i8*, i8** %_impzPtr
%zone1167 = bitcast i8* %tzone1166 to %mzone*

; let assign value to symbol SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ
%dat_SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1167, i64 8)
%SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQPtr = bitcast i8* %dat_SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ to { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}***
%tzone1147 = load i8*, i8** %_impzPtr
%zone1148 = bitcast i8* %tzone1147 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1148)
; malloc closure structure
%clsptr1149 = call i8* @llvm_zone_malloc(%mzone* %zone1148, i64 24)
%closure1150 = bitcast i8* %clsptr1149 to { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}*

; malloc environment structure
%envptr1151 = call i8* @llvm_zone_malloc(%mzone* %zone1148, i64 8)
%environment1152 = bitcast i8* %envptr1151 to {{i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}***}*

; malloc closure address table
%addytable1153 = call %clsvar* @new_address_table()
%var1154 = bitcast [64 x i8]* @gsxtmsndfile44 to i8*
%var1155 = bitcast [57 x i8]* @gsxtmsndfile45 to i8*
%addytable1156 = call %clsvar* @add_address_table(%mzone* %zone1148, i8* %var1154, i32 0, i8* %var1155, i32 3, %clsvar* %addytable1153)
%address-table1157 = bitcast %clsvar* %addytable1156 to i8*

; insert table, function and environment into closure struct
%closure.table1160 = getelementptr { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}, { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}* %closure1150, i32 0, i32 0
store i8* %address-table1157, i8** %closure.table1160
%closure.env1161 = getelementptr { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}, { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}* %closure1150, i32 0, i32 1
store i8* %envptr1151, i8** %closure.env1161
%closure.func1162 = getelementptr { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}, { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}* %closure1150, i32 0, i32 2
store %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)* @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ__1130, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)** %closure.func1162
%closure_size1163 = call i64 @llvm_zone_mark_size(%mzone* %zone1148)
call void @llvm_zone_ptr_set_size(i8* %clsptr1149, i64 %closure_size1163)
%wrapper_ptr1164 = call i8* @llvm_zone_malloc(%mzone* %zone1148, i64 8)
%closure_wrapper1165 = bitcast i8* %wrapper_ptr1164 to { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}**
store { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}* %closure1150, { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}** %closure_wrapper1165

; let value assignment
%SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ = select i1 true, { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}** %closure_wrapper1165, { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}** %closure_wrapper1165
store { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}** %SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ, { i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}*** %SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQPtr

; add data to environment
; don't need to alloc for env var SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ
%tmp_envptr1159 = getelementptr {{i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}***}, {{i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}***}* %environment1152, i32 0, i32 0
store {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}*** %SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQPtr, {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}**** %tmp_envptr1159


%val1168 = load {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}**, {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}*** %SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQPtr
ret {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}** %val1168
}


@SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}** @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_FORMAT_INFO @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ(i32 %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
ret %SF_FORMAT_INFO %result
}


define dllexport ccc %SF_FORMAT_INFO @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_native(i32 %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
ret %SF_FORMAT_INFO %result
}


define dllexport ccc void @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i8*, i8*}*
%arg_p_0 = getelementptr {i32, i8*, i8*}, {i32, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i8*, i8*}, {i32, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i32, i8*, i8*}, {i32, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_FORMAT_INFO_val_adhoc_W1NGX0ZPUk1BVF9JTkZPLGkzMixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}*, {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}, {i8*, i8*, %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)*,  %SF_FORMAT_INFO (i8*, i8*, i32, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile47 = hidden constant [57 x i8] c"hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd\00"
@gsxtmsndfile48 = hidden constant [61 x i8] c"{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}**\00"
define dllexport fastcc %SF_FORMAT_INFO* @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd__1172(i8* %_impz,i8* %_impenv, %SF_FORMAT_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1173 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}***}*
%hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypdPtr_ = getelementptr {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}***}, {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypdPtr = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}***, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}**** %hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypdPtr_

; setup arguments
%xPtr = alloca %SF_FORMAT_INFO*
store %SF_FORMAT_INFO* %x, %SF_FORMAT_INFO** %xPtr


%tzone1176 = load i8*, i8** %_impzPtr
%zone1177 = bitcast i8* %tzone1176 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_FORMAT_INFO*
%dat1174 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat1174, i32 0, i64 24)
%val1175 = bitcast i8* %dat1174 to %SF_FORMAT_INFO*

; let value assignment
%obj = select i1 true, %SF_FORMAT_INFO* %val1175, %SF_FORMAT_INFO* %val1175
store %SF_FORMAT_INFO* %obj, %SF_FORMAT_INFO** %objPtr

%val1178 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val1179 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1180 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1179, i64 0, i32 0
%val1181 = load i32, i32* %val1180
; set tuple
%val1182 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1178, i64 0, i32 0
store i32 %val1181, i32* %val1182
%val1183 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val1184 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1185 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1184, i64 0, i32 1
%val1186 = load i8*, i8** %val1185
; set tuple
%val1187 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1183, i64 0, i32 1
store i8* %val1186, i8** %val1187
%val1188 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val1189 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1190 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1189, i64 0, i32 2
%val1191 = load i8*, i8** %val1190
; set tuple
%val1192 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1188, i64 0, i32 2
store i8* %val1191, i8** %val1192
%val1193 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
ret %SF_FORMAT_INFO* %val1193
}
@gsxtmsndfile49 = hidden constant [110 x i8] c"hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}** @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1213 = load i8*, i8** %_impzPtr
%zone1214 = bitcast i8* %tzone1213 to %mzone*

; let assign value to symbol hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd
%dat_hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd = call i8* @llvm_zone_malloc(%mzone* %zone1214, i64 8)
%hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypdPtr = bitcast i8* %dat_hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}***
%tzone1194 = load i8*, i8** %_impzPtr
%zone1195 = bitcast i8* %tzone1194 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1195)
; malloc closure structure
%clsptr1196 = call i8* @llvm_zone_malloc(%mzone* %zone1195, i64 24)
%closure1197 = bitcast i8* %clsptr1196 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}*

; malloc environment structure
%envptr1198 = call i8* @llvm_zone_malloc(%mzone* %zone1195, i64 8)
%environment1199 = bitcast i8* %envptr1198 to {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}***}*

; malloc closure address table
%addytable1200 = call %clsvar* @new_address_table()
%var1201 = bitcast [57 x i8]* @gsxtmsndfile47 to i8*
%var1202 = bitcast [61 x i8]* @gsxtmsndfile48 to i8*
%addytable1203 = call %clsvar* @add_address_table(%mzone* %zone1195, i8* %var1201, i32 0, i8* %var1202, i32 3, %clsvar* %addytable1200)
%address-table1204 = bitcast %clsvar* %addytable1203 to i8*

; insert table, function and environment into closure struct
%closure.table1207 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1197, i32 0, i32 0
store i8* %address-table1204, i8** %closure.table1207
%closure.env1208 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1197, i32 0, i32 1
store i8* %envptr1198, i8** %closure.env1208
%closure.func1209 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1197, i32 0, i32 2
store %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)* @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd__1172, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)** %closure.func1209
%closure_size1210 = call i64 @llvm_zone_mark_size(%mzone* %zone1195)
call void @llvm_zone_ptr_set_size(i8* %clsptr1196, i64 %closure_size1210)
%wrapper_ptr1211 = call i8* @llvm_zone_malloc(%mzone* %zone1195, i64 8)
%closure_wrapper1212 = bitcast i8* %wrapper_ptr1211 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}**
store { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1197, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_wrapper1212

; let value assignment
%hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd = select i1 true, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_wrapper1212, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_wrapper1212
store { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}** %hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}*** %hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypdPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd
%tmp_envptr1206 = getelementptr {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}***}, {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}***}* %environment1199, i32 0, i32 0
store {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}*** %hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypdPtr, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}**** %tmp_envptr1206


%val1215 = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}**, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}*** %hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypdPtr
ret {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}** %val1215
}


@hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}** @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_FORMAT_INFO* @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd(%SF_FORMAT_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*,  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
ret %SF_FORMAT_INFO* %result
}


define dllexport ccc %SF_FORMAT_INFO* @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_native(%SF_FORMAT_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*,  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
ret %SF_FORMAT_INFO* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1216 = bitcast [110 x i8]* @gsxtmsndfile49 to i8*
call i32 (i8*, ...) @printf(i8* %var1216)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_FORMAT_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*,  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
%tmpres = bitcast %SF_FORMAT_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_FORMAT_INFO*}*
%arg_p_0 = getelementptr {%SF_FORMAT_INFO*}, {%SF_FORMAT_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)*,  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile50 = hidden constant [43 x i8] c"hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ__1217(i8* %_impz,i8* %_impenv, %SF_FORMAT_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1218 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***}*
%hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr = load {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**** %hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr_

; setup arguments
%xPtr = alloca %SF_FORMAT_INFO*
store %SF_FORMAT_INFO* %x, %SF_FORMAT_INFO** %xPtr


%val1219 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
%val1220 = bitcast %SF_FORMAT_INFO* %val1219 to i8*
call ccc void @free(i8* %val1220)
ret void
}
@gsxtmsndfile51 = hidden constant [96 x i8] c"hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1242 = load i8*, i8** %_impzPtr
%zone1243 = bitcast i8* %tzone1242 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ
%dat_hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone1243, i64 8)
%hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ to { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***
%tzone1223 = load i8*, i8** %_impzPtr
%zone1224 = bitcast i8* %tzone1223 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1224)
; malloc closure structure
%clsptr1225 = call i8* @llvm_zone_malloc(%mzone* %zone1224, i64 24)
%closure1226 = bitcast i8* %clsptr1225 to { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*

; malloc environment structure
%envptr1227 = call i8* @llvm_zone_malloc(%mzone* %zone1224, i64 8)
%environment1228 = bitcast i8* %envptr1227 to {{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***}*

; malloc closure address table
%addytable1229 = call %clsvar* @new_address_table()
%var1230 = bitcast [43 x i8]* @gsxtmsndfile50 to i8*
%var1231 = bitcast [49 x i8]* @gsxtmsndfile42 to i8*
%addytable1232 = call %clsvar* @add_address_table(%mzone* %zone1224, i8* %var1230, i32 0, i8* %var1231, i32 3, %clsvar* %addytable1229)
%address-table1233 = bitcast %clsvar* %addytable1232 to i8*

; insert table, function and environment into closure struct
%closure.table1236 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1226, i32 0, i32 0
store i8* %address-table1233, i8** %closure.table1236
%closure.env1237 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1226, i32 0, i32 1
store i8* %envptr1227, i8** %closure.env1237
%closure.func1238 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1226, i32 0, i32 2
store void (i8*, i8*, %SF_FORMAT_INFO*)* @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ__1217, void (i8*, i8*, %SF_FORMAT_INFO*)** %closure.func1238
%closure_size1239 = call i64 @llvm_zone_mark_size(%mzone* %zone1224)
call void @llvm_zone_ptr_set_size(i8* %clsptr1225, i64 %closure_size1239)
%wrapper_ptr1240 = call i8* @llvm_zone_malloc(%mzone* %zone1224, i64 8)
%closure_wrapper1241 = bitcast i8* %wrapper_ptr1240 to { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**
store { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure1226, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_wrapper1241

; let value assignment
%hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_wrapper1241, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_wrapper1241
store { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ, { i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ
%tmp_envptr1235 = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}***}* %environment1228, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**** %tmp_envptr1235


%val1244 = load {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQPtr
ret {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %val1244
}


@hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ(%SF_FORMAT_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_FORMAT_INFO*)*,  void (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_native(%SF_FORMAT_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_FORMAT_INFO*)*,  void (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1245 = bitcast [96 x i8]* @gsxtmsndfile51 to i8*
call i32 (i8*, ...) @printf(i8* %var1245)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_FORMAT_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_FORMAT_INFO*)*,  void (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_FORMAT_INFO*}*
%arg_p_0 = getelementptr {%SF_FORMAT_INFO*}, {%SF_FORMAT_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRk9STUFUX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_FORMAT_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_FORMAT_INFO*)*,  void (i8*, i8*, %SF_FORMAT_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile52 = hidden constant [76 x i8] c"zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0\00"
@gsxtmsndfile53 = hidden constant [79 x i8] c"{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %SF_FORMAT_INFO* @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0__1246(i8* %_impz,i8* %_impenv, %SF_FORMAT_INFO* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1247 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}***, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca %SF_FORMAT_INFO*
store %SF_FORMAT_INFO* %x, %SF_FORMAT_INFO** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val1249 = load %mzone*, %mzone** %fromzPtr
%val1250 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
%val1251 = bitcast %SF_FORMAT_INFO* %val1250 to i8*
%res1252 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1249, i8* %val1251)
br i1 %res1252, label %then1248, label %else1248

then1248:
%val1253 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val1253)
%zone_ptr1254 = bitcast %mzone* %val1253 to i8*
store i8* %zone_ptr1254, i8** %_impzPtr
%tzone1260 = load i8*, i8** %_impzPtr
%zone1261 = bitcast i8* %tzone1260 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_FORMAT_INFO*
%tzone1256 = load i8*, i8** %_impzPtr
%zone1257 = bitcast i8* %tzone1256 to %mzone*
%dat1258 = call i8* @llvm_zone_malloc(%mzone* %zone1257, i64 24)
call i8* @memset(i8* %dat1258, i32 0, i64 24)
%val1259 = bitcast i8* %dat1258 to %SF_FORMAT_INFO*

; let value assignment
%obj = select i1 true, %SF_FORMAT_INFO* %val1259, %SF_FORMAT_INFO* %val1259
store %SF_FORMAT_INFO* %obj, %SF_FORMAT_INFO** %objPtr

; promote local stack var allocations
%tzone1329 = load i8*, i8** %_impzPtr
%zone1330 = bitcast i8* %tzone1329 to %mzone*
%ifptr1296 = alloca i8*
%ifptr1267 = alloca i8*
%val1262 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val1263 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1264 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1263, i64 0, i32 0
%val1265 = load i32, i32* %val1264
; set tuple
%val1266 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1262, i64 0, i32 0
store i32 %val1265, i32* %val1266
%val1268 = load %mzone*, %mzone** %fromzPtr
%val1269 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1270 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1269, i64 0, i32 1
%val1271 = load i8*, i8** %val1270
%val1272 = bitcast i8* %val1271 to i8*
%res1273 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1268, i8* %val1272)
br i1 %res1273, label %then1267, label %else1267

then1267:
%tzone1278 = load i8*, i8** %_impzPtr
%zone1279 = bitcast i8* %tzone1278 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i8*
%tzone1274 = load i8*, i8** %_impzPtr
%zone1275 = bitcast i8* %tzone1274 to %mzone*
%dat1276 = call i8* @llvm_zone_malloc(%mzone* %zone1275, i64 1)
call i8* @memset(i8* %dat1276, i32 0, i64 1)
%val1277 = bitcast i8* %dat1276 to i8*

; let value assignment
%newptr = select i1 true, i8* %val1277, i8* %val1277
store i8* %newptr, i8** %newptrPtr

%val1280 = load i8*, i8** %newptrPtr
%val1281 = bitcast i8* %val1280 to i8*
%val1282 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1283 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1282, i64 0, i32 1
%val1284 = load i8*, i8** %val1283
%val1285 = bitcast i8* %val1284 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val1281, i8* %val1285, i64 1, i32 1, i1 0)
%val1287 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val1288 = load i8*, i8** %newptrPtr
; set tuple
%val1289 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1287, i64 0, i32 1
store i8* %val1288, i8** %val1289
store i8* %val1288, i8** %ifptr1267
br label %ifcont1267

else1267:
%val1290 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val1291 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1292 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1291, i64 0, i32 1
%val1293 = load i8*, i8** %val1292
; set tuple
%val1294 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1290, i64 0, i32 1
store i8* %val1293, i8** %val1294
store i8* %val1293, i8** %ifptr1267
br label %ifcont1267

ifcont1267:
%ifres1295 = load i8*, i8** %ifptr1267

%val1297 = load %mzone*, %mzone** %fromzPtr
%val1298 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1299 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1298, i64 0, i32 2
%val1300 = load i8*, i8** %val1299
%val1301 = bitcast i8* %val1300 to i8*
%res1302 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1297, i8* %val1301)
br i1 %res1302, label %then1296, label %else1296

then1296:
%tzone1307 = load i8*, i8** %_impzPtr
%zone1308 = bitcast i8* %tzone1307 to %mzone*

; let assign value to symbol newptr_s_16
%newptr_s_16Ptr = alloca i8*
%tzone1303 = load i8*, i8** %_impzPtr
%zone1304 = bitcast i8* %tzone1303 to %mzone*
%dat1305 = call i8* @llvm_zone_malloc(%mzone* %zone1304, i64 1)
call i8* @memset(i8* %dat1305, i32 0, i64 1)
%val1306 = bitcast i8* %dat1305 to i8*

; let value assignment
%newptr_s_16 = select i1 true, i8* %val1306, i8* %val1306
store i8* %newptr_s_16, i8** %newptr_s_16Ptr

%val1309 = load i8*, i8** %newptr_s_16Ptr
%val1310 = bitcast i8* %val1309 to i8*
%val1311 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1312 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1311, i64 0, i32 2
%val1313 = load i8*, i8** %val1312
%val1314 = bitcast i8* %val1313 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val1310, i8* %val1314, i64 1, i32 1, i1 0)
%val1316 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val1317 = load i8*, i8** %newptr_s_16Ptr
; set tuple
%val1318 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1316, i64 0, i32 2
store i8* %val1317, i8** %val1318
store i8* %val1317, i8** %ifptr1296
br label %ifcont1296

else1296:
%val1319 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
%val1320 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
; tuple ref
%val1321 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1320, i64 0, i32 2
%val1322 = load i8*, i8** %val1321
; set tuple
%val1323 = getelementptr %SF_FORMAT_INFO, %SF_FORMAT_INFO* %val1319, i64 0, i32 2
store i8* %val1322, i8** %val1323
store i8* %val1322, i8** %ifptr1296
br label %ifcont1296

ifcont1296:
%ifres1324 = load i8*, i8** %ifptr1296

%oldzone1325 = call %mzone* @llvm_pop_zone_stack()
%newzone1326 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1327 = bitcast %mzone* %newzone1326 to i8*
store i8* %zone_ptr1327, i8** %_impzPtr
%val1328 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %objPtr
ret %SF_FORMAT_INFO* %val1328

else1248:
%val1331 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %xPtr
ret %SF_FORMAT_INFO* %val1331
}
@gsxtmsndfile54 = hidden constant [129 x i8] c"zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1351 = load i8*, i8** %_impzPtr
%zone1352 = bitcast i8* %tzone1351 to %mzone*

; let assign value to symbol zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1352, i64 8)
%zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}***
%tzone1332 = load i8*, i8** %_impzPtr
%zone1333 = bitcast i8* %tzone1332 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1333)
; malloc closure structure
%clsptr1334 = call i8* @llvm_zone_malloc(%mzone* %zone1333, i64 24)
%closure1335 = bitcast i8* %clsptr1334 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr1336 = call i8* @llvm_zone_malloc(%mzone* %zone1333, i64 8)
%environment1337 = bitcast i8* %envptr1336 to {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable1338 = call %clsvar* @new_address_table()
%var1339 = bitcast [76 x i8]* @gsxtmsndfile52 to i8*
%var1340 = bitcast [79 x i8]* @gsxtmsndfile53 to i8*
%addytable1341 = call %clsvar* @add_address_table(%mzone* %zone1333, i8* %var1339, i32 0, i8* %var1340, i32 3, %clsvar* %addytable1338)
%address-table1342 = bitcast %clsvar* %addytable1341 to i8*

; insert table, function and environment into closure struct
%closure.table1345 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}* %closure1335, i32 0, i32 0
store i8* %address-table1342, i8** %closure.table1345
%closure.env1346 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}* %closure1335, i32 0, i32 1
store i8* %envptr1336, i8** %closure.env1346
%closure.func1347 = getelementptr { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}* %closure1335, i32 0, i32 2
store %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)* @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0__1246, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)** %closure.func1347
%closure_size1348 = call i64 @llvm_zone_mark_size(%mzone* %zone1333)
call void @llvm_zone_ptr_set_size(i8* %clsptr1334, i64 %closure_size1348)
%wrapper_ptr1349 = call i8* @llvm_zone_malloc(%mzone* %zone1333, i64 8)
%closure_wrapper1350 = bitcast i8* %wrapper_ptr1349 to { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}**
store { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}* %closure1335, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}** %closure_wrapper1350

; let value assignment
%zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}** %closure_wrapper1350, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}** %closure_wrapper1350
store { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0, { i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0
%tmp_envptr1344 = getelementptr {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}***}* %environment1337, i32 0, i32 0
store {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}**** %tmp_envptr1344


%val1353 = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}**, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}** %val1353
}


@zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_FORMAT_INFO* @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0(%SF_FORMAT_INFO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*,  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %SF_FORMAT_INFO* %result
}


define dllexport ccc %SF_FORMAT_INFO* @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_native(%SF_FORMAT_INFO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*,  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %SF_FORMAT_INFO* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1354 = bitcast [129 x i8]* @gsxtmsndfile54 to i8*
call i32 (i8*, ...) @printf(i8* %var1354)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_FORMAT_INFO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1355 = bitcast [129 x i8]* @gsxtmsndfile54 to i8*
call i32 (i8*, ...) @printf(i8* %var1355)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1356 = bitcast [129 x i8]* @gsxtmsndfile54 to i8*
call i32 (i8*, ...) @printf(i8* %var1356)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*,  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %SF_FORMAT_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_FORMAT_INFO*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%SF_FORMAT_INFO*, %mzone*, %mzone*}, {%SF_FORMAT_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_FORMAT_INFO*, %SF_FORMAT_INFO** %arg_p_0
%arg_p_1 = getelementptr {%SF_FORMAT_INFO*, %mzone*, %mzone*}, {%SF_FORMAT_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%SF_FORMAT_INFO*, %mzone*, %mzone*}, {%SF_FORMAT_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0ZPUk1BVF9JTkZPKixTRl9GT1JNQVRfSU5GTyosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)*,  %SF_FORMAT_INFO* (i8*, i8*, %SF_FORMAT_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_FORMAT_INFO* %ff(i8* %_impz, i8* %ee, %SF_FORMAT_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@SFD_DEFAULT_LEVEL = dllexport global i32 0
@SFD_CUSTOM_LEVEL = dllexport global i32 1073741824
@SFD_NO_DITHER = dllexport global i32 500
@SFD_WHITE = dllexport global i32 501
@SFD_TRIANGULAR_PDF = dllexport global i32 502
%SF_DITHER_INFO = type {i32,double,i8*}
@gsxtmsndfile55 = hidden constant [65 x i8] c"SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0\00"
@gsxtmsndfile56 = hidden constant [61 x i8] c"{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**\00"
define dllexport fastcc %SF_DITHER_INFO* @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0__1357(i8* %_impz,i8* %_impenv, i32 %arg_0, double %arg_1, i8* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1358 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}*
%SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}, {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}* %impenv, i32 0, i32 0
%SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**** %SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca double
store double %arg_1, double* %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr


%tzone1363 = load i8*, i8** %_impzPtr
%zone1364 = bitcast i8* %tzone1363 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_DITHER_INFO*
%tzone1359 = load i8*, i8** %_impzPtr
%zone1360 = bitcast i8* %tzone1359 to %mzone*
%dat1361 = call i8* @llvm_zone_malloc(%mzone* %zone1360, i64 24)
call i8* @memset(i8* %dat1361, i32 0, i64 24)
%val1362 = bitcast i8* %dat1361 to %SF_DITHER_INFO*

; let value assignment
%obj = select i1 true, %SF_DITHER_INFO* %val1362, %SF_DITHER_INFO* %val1362
store %SF_DITHER_INFO* %obj, %SF_DITHER_INFO** %objPtr

%val1365 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1366 = load i32, i32* %arg_0Ptr
; set tuple
%val1367 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1365, i64 0, i32 0
store i32 %val1366, i32* %val1367
%val1368 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1369 = load double, double* %arg_1Ptr
; set tuple
%val1370 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1368, i64 0, i32 1
store double %val1369, double* %val1370
%val1371 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1372 = load i8*, i8** %arg_2Ptr
; set tuple
%val1373 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1371, i64 0, i32 2
store i8* %val1372, i8** %val1373
%val1374 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
ret %SF_DITHER_INFO* %val1374
}
@gsxtmsndfile57 = hidden constant [118 x i8] c"SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1394 = load i8*, i8** %_impzPtr
%zone1395 = bitcast i8* %tzone1394 to %mzone*

; let assign value to symbol SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0
%dat_SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone1395, i64 8)
%SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr = bitcast i8* %dat_SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***
%tzone1375 = load i8*, i8** %_impzPtr
%zone1376 = bitcast i8* %tzone1375 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1376)
; malloc closure structure
%clsptr1377 = call i8* @llvm_zone_malloc(%mzone* %zone1376, i64 24)
%closure1378 = bitcast i8* %clsptr1377 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*

; malloc environment structure
%envptr1379 = call i8* @llvm_zone_malloc(%mzone* %zone1376, i64 8)
%environment1380 = bitcast i8* %envptr1379 to {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}*

; malloc closure address table
%addytable1381 = call %clsvar* @new_address_table()
%var1382 = bitcast [65 x i8]* @gsxtmsndfile55 to i8*
%var1383 = bitcast [61 x i8]* @gsxtmsndfile56 to i8*
%addytable1384 = call %clsvar* @add_address_table(%mzone* %zone1376, i8* %var1382, i32 0, i8* %var1383, i32 3, %clsvar* %addytable1381)
%address-table1385 = bitcast %clsvar* %addytable1384 to i8*

; insert table, function and environment into closure struct
%closure.table1388 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure1378, i32 0, i32 0
store i8* %address-table1385, i8** %closure.table1388
%closure.env1389 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure1378, i32 0, i32 1
store i8* %envptr1379, i8** %closure.env1389
%closure.func1390 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure1378, i32 0, i32 2
store %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)* @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0__1357, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %closure.func1390
%closure_size1391 = call i64 @llvm_zone_mark_size(%mzone* %zone1376)
call void @llvm_zone_ptr_set_size(i8* %clsptr1377, i64 %closure_size1391)
%wrapper_ptr1392 = call i8* @llvm_zone_malloc(%mzone* %zone1376, i64 8)
%closure_wrapper1393 = bitcast i8* %wrapper_ptr1392 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
store { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure1378, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_wrapper1393

; let value assignment
%SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0 = select i1 true, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_wrapper1393, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_wrapper1393
store { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*** %SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0
%tmp_envptr1387 = getelementptr {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}, {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}* %environment1380, i32 0, i32 0
store {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*** %SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**** %tmp_envptr1387


%val1396 = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*** %SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr
ret {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %val1396
}


@SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_DITHER_INFO* @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0(i32 %arg_0,double %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
ret %SF_DITHER_INFO* %result
}


define dllexport ccc %SF_DITHER_INFO* @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_native(i32 %arg_0,double %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
ret %SF_DITHER_INFO* %result
}


define dllexport ccc i8*  @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1397 = bitcast [118 x i8]* @gsxtmsndfile57 to i8*
call i32 (i8*, ...) @printf(i8* %var1397)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1398 = bitcast [118 x i8]* @gsxtmsndfile57 to i8*
call i32 (i8*, ...) @printf(i8* %var1398)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1399 = bitcast [118 x i8]* @gsxtmsndfile57 to i8*
call i32 (i8*, ...) @printf(i8* %var1399)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
%tmpres = bitcast %SF_DITHER_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, double, i8*}*
%arg_p_0 = getelementptr {i32, double, i8*}, {i32, double, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, double, i8*}, {i32, double, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {i32, double, i8*}, {i32, double, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile58 = hidden constant [67 x i8] c"SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0\00"
define dllexport fastcc %SF_DITHER_INFO* @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0__1400(i8* %_impz,i8* %_impenv, i32 %arg_0, double %arg_1, i8* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1401 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}*
%SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}, {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}* %impenv, i32 0, i32 0
%SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**** %SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca double
store double %arg_1, double* %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr


%tzone1406 = load i8*, i8** %_impzPtr
%zone1407 = bitcast i8* %tzone1406 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_DITHER_INFO*
%tzone1402 = load i8*, i8** %_impzPtr
%zone1403 = bitcast i8* %tzone1402 to %mzone*
%dat1404 = call i8* @llvm_zone_malloc(%mzone* %zone1403, i64 24)
call i8* @memset(i8* %dat1404, i32 0, i64 24)
%val1405 = bitcast i8* %dat1404 to %SF_DITHER_INFO*

; let value assignment
%obj = select i1 true, %SF_DITHER_INFO* %val1405, %SF_DITHER_INFO* %val1405
store %SF_DITHER_INFO* %obj, %SF_DITHER_INFO** %objPtr

%val1408 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1409 = load i32, i32* %arg_0Ptr
; set tuple
%val1410 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1408, i64 0, i32 0
store i32 %val1409, i32* %val1410
%val1411 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1412 = load double, double* %arg_1Ptr
; set tuple
%val1413 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1411, i64 0, i32 1
store double %val1412, double* %val1413
%val1414 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1415 = load i8*, i8** %arg_2Ptr
; set tuple
%val1416 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1414, i64 0, i32 2
store i8* %val1415, i8** %val1416
%val1417 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
ret %SF_DITHER_INFO* %val1417
}
@gsxtmsndfile59 = hidden constant [120 x i8] c"SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1437 = load i8*, i8** %_impzPtr
%zone1438 = bitcast i8* %tzone1437 to %mzone*

; let assign value to symbol SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0
%dat_SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone1438, i64 8)
%SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr = bitcast i8* %dat_SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***
%tzone1418 = load i8*, i8** %_impzPtr
%zone1419 = bitcast i8* %tzone1418 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1419)
; malloc closure structure
%clsptr1420 = call i8* @llvm_zone_malloc(%mzone* %zone1419, i64 24)
%closure1421 = bitcast i8* %clsptr1420 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*

; malloc environment structure
%envptr1422 = call i8* @llvm_zone_malloc(%mzone* %zone1419, i64 8)
%environment1423 = bitcast i8* %envptr1422 to {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}*

; malloc closure address table
%addytable1424 = call %clsvar* @new_address_table()
%var1425 = bitcast [67 x i8]* @gsxtmsndfile58 to i8*
%var1426 = bitcast [61 x i8]* @gsxtmsndfile56 to i8*
%addytable1427 = call %clsvar* @add_address_table(%mzone* %zone1419, i8* %var1425, i32 0, i8* %var1426, i32 3, %clsvar* %addytable1424)
%address-table1428 = bitcast %clsvar* %addytable1427 to i8*

; insert table, function and environment into closure struct
%closure.table1431 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure1421, i32 0, i32 0
store i8* %address-table1428, i8** %closure.table1431
%closure.env1432 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure1421, i32 0, i32 1
store i8* %envptr1422, i8** %closure.env1432
%closure.func1433 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure1421, i32 0, i32 2
store %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)* @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0__1400, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %closure.func1433
%closure_size1434 = call i64 @llvm_zone_mark_size(%mzone* %zone1419)
call void @llvm_zone_ptr_set_size(i8* %clsptr1420, i64 %closure_size1434)
%wrapper_ptr1435 = call i8* @llvm_zone_malloc(%mzone* %zone1419, i64 8)
%closure_wrapper1436 = bitcast i8* %wrapper_ptr1435 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
store { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure1421, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_wrapper1436

; let value assignment
%SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0 = select i1 true, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_wrapper1436, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_wrapper1436
store { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*** %SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0
%tmp_envptr1430 = getelementptr {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}, {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}* %environment1423, i32 0, i32 0
store {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*** %SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**** %tmp_envptr1430


%val1439 = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*** %SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr
ret {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %val1439
}


@SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_DITHER_INFO* @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0(i32 %arg_0,double %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
ret %SF_DITHER_INFO* %result
}


define dllexport ccc %SF_DITHER_INFO* @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_native(i32 %arg_0,double %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
ret %SF_DITHER_INFO* %result
}


define dllexport ccc i8*  @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1440 = bitcast [120 x i8]* @gsxtmsndfile59 to i8*
call i32 (i8*, ...) @printf(i8* %var1440)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1441 = bitcast [120 x i8]* @gsxtmsndfile59 to i8*
call i32 (i8*, ...) @printf(i8* %var1441)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1442 = bitcast [120 x i8]* @gsxtmsndfile59 to i8*
call i32 (i8*, ...) @printf(i8* %var1442)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
%tmpres = bitcast %SF_DITHER_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, double, i8*}*
%arg_p_0 = getelementptr {i32, double, i8*}, {i32, double, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, double, i8*}, {i32, double, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {i32, double, i8*}, {i32, double, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_z_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile60 = hidden constant [67 x i8] c"SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0\00"
define dllexport fastcc %SF_DITHER_INFO* @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0__1443(i8* %_impz,i8* %_impenv, i32 %arg_0, double %arg_1, i8* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1444 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}*
%SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}, {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}* %impenv, i32 0, i32 0
%SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**** %SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca double
store double %arg_1, double* %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr


%tzone1447 = load i8*, i8** %_impzPtr
%zone1448 = bitcast i8* %tzone1447 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_DITHER_INFO*
%dat1445 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat1445, i32 0, i64 24)
%val1446 = bitcast i8* %dat1445 to %SF_DITHER_INFO*

; let value assignment
%obj = select i1 true, %SF_DITHER_INFO* %val1446, %SF_DITHER_INFO* %val1446
store %SF_DITHER_INFO* %obj, %SF_DITHER_INFO** %objPtr

%val1449 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1450 = load i32, i32* %arg_0Ptr
; set tuple
%val1451 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1449, i64 0, i32 0
store i32 %val1450, i32* %val1451
%val1452 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1453 = load double, double* %arg_1Ptr
; set tuple
%val1454 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1452, i64 0, i32 1
store double %val1453, double* %val1454
%val1455 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1456 = load i8*, i8** %arg_2Ptr
; set tuple
%val1457 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1455, i64 0, i32 2
store i8* %val1456, i8** %val1457
%val1458 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
ret %SF_DITHER_INFO* %val1458
}
@gsxtmsndfile61 = hidden constant [120 x i8] c"SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1478 = load i8*, i8** %_impzPtr
%zone1479 = bitcast i8* %tzone1478 to %mzone*

; let assign value to symbol SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0
%dat_SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone1479, i64 8)
%SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr = bitcast i8* %dat_SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***
%tzone1459 = load i8*, i8** %_impzPtr
%zone1460 = bitcast i8* %tzone1459 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1460)
; malloc closure structure
%clsptr1461 = call i8* @llvm_zone_malloc(%mzone* %zone1460, i64 24)
%closure1462 = bitcast i8* %clsptr1461 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*

; malloc environment structure
%envptr1463 = call i8* @llvm_zone_malloc(%mzone* %zone1460, i64 8)
%environment1464 = bitcast i8* %envptr1463 to {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}*

; malloc closure address table
%addytable1465 = call %clsvar* @new_address_table()
%var1466 = bitcast [67 x i8]* @gsxtmsndfile60 to i8*
%var1467 = bitcast [61 x i8]* @gsxtmsndfile56 to i8*
%addytable1468 = call %clsvar* @add_address_table(%mzone* %zone1460, i8* %var1466, i32 0, i8* %var1467, i32 3, %clsvar* %addytable1465)
%address-table1469 = bitcast %clsvar* %addytable1468 to i8*

; insert table, function and environment into closure struct
%closure.table1472 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure1462, i32 0, i32 0
store i8* %address-table1469, i8** %closure.table1472
%closure.env1473 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure1462, i32 0, i32 1
store i8* %envptr1463, i8** %closure.env1473
%closure.func1474 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure1462, i32 0, i32 2
store %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)* @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0__1443, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %closure.func1474
%closure_size1475 = call i64 @llvm_zone_mark_size(%mzone* %zone1460)
call void @llvm_zone_ptr_set_size(i8* %clsptr1461, i64 %closure_size1475)
%wrapper_ptr1476 = call i8* @llvm_zone_malloc(%mzone* %zone1460, i64 8)
%closure_wrapper1477 = bitcast i8* %wrapper_ptr1476 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
store { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure1462, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_wrapper1477

; let value assignment
%SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0 = select i1 true, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_wrapper1477, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_wrapper1477
store { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*** %SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0
%tmp_envptr1471 = getelementptr {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}, {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}***}* %environment1464, i32 0, i32 0
store {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*** %SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**** %tmp_envptr1471


%val1480 = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*** %SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0Ptr
ret {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %val1480
}


@SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_DITHER_INFO* @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0(i32 %arg_0,double %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
ret %SF_DITHER_INFO* %result
}


define dllexport ccc %SF_DITHER_INFO* @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_native(i32 %arg_0,double %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
ret %SF_DITHER_INFO* %result
}


define dllexport ccc i8*  @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1481 = bitcast [120 x i8]* @gsxtmsndfile61 to i8*
call i32 (i8*, ...) @printf(i8* %var1481)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1482 = bitcast [120 x i8]* @gsxtmsndfile61 to i8*
call i32 (i8*, ...) @printf(i8* %var1482)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1483 = bitcast [120 x i8]* @gsxtmsndfile61 to i8*
call i32 (i8*, ...) @printf(i8* %var1483)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
%tmpres = bitcast %SF_DITHER_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, double, i8*}*
%arg_p_0 = getelementptr {i32, double, i8*}, {i32, double, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, double, i8*}, {i32, double, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {i32, double, i8*}, {i32, double, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_h_adhoc_W1NGX0RJVEhFUl9JTkZPKixpMzIsZG91YmxlLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO* (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile62 = hidden constant [22 x i8] c"<SF_DITHER_INFO:null>\00"
@gsxtmsndfile63 = hidden constant [17 x i8] c"<SF_DITHER_INFO:\00"
@gsxtmsndfile64 = hidden constant [50 x i8] c"toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ\00"
@gsxtmsndfile65 = hidden constant [53 x i8] c"{i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ__1484(i8* %_impz,i8* %_impenv, %SF_DITHER_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1485 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}***}*
%toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQPtr = load {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}***, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}**** %toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQPtr_

; setup arguments
%xPtr = alloca %SF_DITHER_INFO*
store %SF_DITHER_INFO* %x, %SF_DITHER_INFO** %xPtr


%val1487 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
%val1488 = icmp eq %SF_DITHER_INFO* %val1487, null
br i1 %val1488, label %then1486, label %else1486

then1486:
%zone1489 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone1489)
%zone_ptr1490 = bitcast %mzone* %zone1489 to i8*
store i8* %zone_ptr1490, i8** %_impzPtr
%tzone1500 = load i8*, i8** %_impzPtr
%zone1501 = bitcast i8* %tzone1500 to %mzone*

; let assign value to symbol res4
%res4Ptr = alloca %String*
%tzone1505 = load i8*, i8** %_impzPtr
%zone1506 = bitcast i8* %tzone1505 to %mzone*

; let assign value to symbol zone4
%zone4Ptr = alloca %mzone*
%tzone1508 = load i8*, i8** %_impzPtr
%zone1509 = bitcast i8* %tzone1508 to %mzone*

; let assign value to symbol newz4
%newz4Ptr = alloca %mzone*
%tzone1492 = load i8*, i8** %_impzPtr
%zone1493 = bitcast i8* %tzone1492 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat1491 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat1491, i8* %dat1491
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val1494 = load i8*, i8** %xx_t_mstPtr
%var1495 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1496 = bitcast [22 x i8]* @gsxtmsndfile62 to i8*

%val1497 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1494, i8* %var1495, i8* %var1496)
%val1498 = load i8*, i8** %xx_t_mstPtr
%res1499 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1498)

; let value assignment
%res4 = select i1 true, %String* %res1499, %String* %res1499
store %String* %res4, %String** %res4Ptr

%oldzone1502 = call %mzone* @llvm_pop_zone_stack()
%newzone1503 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1504 = bitcast %mzone* %newzone1503 to i8*
store i8* %zone_ptr1504, i8** %_impzPtr

; let value assignment
%zone4 = select i1 true, %mzone* %oldzone1502, %mzone* %oldzone1502
store %mzone* %zone4, %mzone** %zone4Ptr

%res1507 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz4 = select i1 true, %mzone* %res1507, %mzone* %res1507
store %mzone* %newz4, %mzone** %newz4Ptr

%tzone1514 = load i8*, i8** %_impzPtr
%zone1515 = bitcast i8* %tzone1514 to %mzone*

; let assign value to symbol rescopy4
%rescopy4Ptr = alloca %String*
%tzone1520 = load i8*, i8** %_impzPtr
%zone1521 = bitcast i8* %tzone1520 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone1523 = load i8*, i8** %_impzPtr
%zone1524 = bitcast i8* %tzone1523 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val1510 = load %String*, %String** %res4Ptr
%val1511 = load %mzone*, %mzone** %zone4Ptr
%val1512 = load %mzone*, %mzone** %newz4Ptr
%res1513 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val1510, %mzone* %val1511, %mzone* %val1512)

; let value assignment
%rescopy4 = select i1 true, %String* %res1513, %String* %res1513
store %String* %rescopy4, %String** %rescopy4Ptr

%val1516 = load %mzone*, %mzone** %zone4Ptr
; tuple ref
%val1517 = getelementptr %mzone, %mzone* %val1516, i64 0, i32 4
%val1518 = load i8*, i8** %val1517
%val1519 = bitcast i8* %val1518 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val1519, {i64,i8*,i8*}* %val1519
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null1522 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null1522, {i8*, i8*, void (i8*, i8*)*}** %null1522
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone1560 = load i8*, i8** %_impzPtr
%zone1561 = bitcast i8* %tzone1560 to %mzone*
%ifptr1550 = alloca i1
%ifptr1526 = alloca i1
; while loop
%val1527 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1528 = icmp eq {i64,i8*,i8*}* %val1527, null
br i1 %val1528, label %then1526, label %else1526

then1526:
%res1529 = call ccc i1 @impc_false()
store i1 %res1529, i1* %ifptr1526
br label %ifcont1526

else1526:
%res1530 = call ccc i1 @impc_true()
store i1 %res1530, i1* %ifptr1526
br label %ifcont1526

ifcont1526:
%ifres1531 = load i1, i1* %ifptr1526

br i1 %ifres1531, label %loop1525, label %after1525

loop1525:
; do set!
%val1532 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val1533 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1532, i64 0, i32 1
%val1534 = load i8*, i8** %val1533
%val1535 = bitcast i8* %val1534 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val1535, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval1536 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val1537 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval1536
%fPtr1538 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1537, i32 0, i32 2
%ePtr1539 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1537, i32 0, i32 1
%f1540 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr1538
%e1541 = load i8*, i8** %ePtr1539
%tzone1542 = load i8*, i8** %_impzPtr
%zone1543 = bitcast i8* %tzone1542 to %mzone*
%z1544 = bitcast %mzone* %zone1543 to i8*
tail call fastcc void %f1540(i8* %z1544, i8* %e1541)
; do set!
%val1546 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val1547 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1546, i64 0, i32 2
%val1548 = load i8*, i8** %val1547
%val1549 = bitcast i8* %val1548 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val1549, {i64,i8*,i8*}** %hookPtr
%val1551 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1552 = icmp eq {i64,i8*,i8*}* %val1551, null
br i1 %val1552, label %then1550, label %else1550

then1550:
%res1553 = call ccc i1 @impc_false()
store i1 %res1553, i1* %ifptr1550
br label %ifcont1550

else1550:
%res1554 = call ccc i1 @impc_true()
store i1 %res1554, i1* %ifptr1550
br label %ifcont1550

ifcont1550:
%ifres1555 = load i1, i1* %ifptr1550

br i1 %ifres1555, label %loop1525, label %after1525

after1525:
%val1557 = load %mzone*, %mzone** %zone4Ptr
call ccc void @llvm_zone_destroy(%mzone* %val1557)
%val1559 = load %String*, %String** %rescopy4Ptr
ret %String* %val1559

else1486:
%zone1562 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone1562)
%zone_ptr1563 = bitcast %mzone* %zone1562 to i8*
store i8* %zone_ptr1563, i8** %_impzPtr
%tzone1618 = load i8*, i8** %_impzPtr
%zone1619 = bitcast i8* %tzone1618 to %mzone*

; let assign value to symbol res5
%res5Ptr = alloca %String*
%tzone1623 = load i8*, i8** %_impzPtr
%zone1624 = bitcast i8* %tzone1623 to %mzone*

; let assign value to symbol zone5
%zone5Ptr = alloca %mzone*
%tzone1626 = load i8*, i8** %_impzPtr
%zone1627 = bitcast i8* %tzone1626 to %mzone*

; let assign value to symbol newz5
%newz5Ptr = alloca %mzone*
%tzone1565 = load i8*, i8** %_impzPtr
%zone1566 = bitcast i8* %tzone1565 to %mzone*

; let assign value to symbol xx_t_mst_s_17
%xx_t_mst_s_17Ptr = alloca i8*
%dat1564 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_17 = select i1 true, i8* %dat1564, i8* %dat1564
store i8* %xx_t_mst_s_17, i8** %xx_t_mst_s_17Ptr

%val1567 = load i8*, i8** %xx_t_mst_s_17Ptr
%var1568 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1569 = bitcast [17 x i8]* @gsxtmsndfile63 to i8*

%val1570 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1567, i8* %var1568, i8* %var1569)
%val1571 = load i8*, i8** %xx_t_mst_s_17Ptr
%res1572 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1571)
%val1573 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1574 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1573, i64 0, i32 0
%val1575 = load i32, i32* %val1574
%res1576 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val1575)
%res1577 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1572, %String* %res1576)
%tzone1579 = load i8*, i8** %_impzPtr
%zone1580 = bitcast i8* %tzone1579 to %mzone*

; let assign value to symbol xx_t_mst_s_18
%xx_t_mst_s_18Ptr = alloca i8*
%dat1578 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_18 = select i1 true, i8* %dat1578, i8* %dat1578
store i8* %xx_t_mst_s_18, i8** %xx_t_mst_s_18Ptr

%val1581 = load i8*, i8** %xx_t_mst_s_18Ptr
%var1582 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1583 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val1584 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1581, i8* %var1582, i8* %var1583)
%val1585 = load i8*, i8** %xx_t_mst_s_18Ptr
%res1586 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1585)
%res1587 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1577, %String* %res1586)
%val1588 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1589 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1588, i64 0, i32 1
%val1590 = load double, double* %val1589
%res1591 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZG91YmxlXQ(double %val1590)
%res1592 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1587, %String* %res1591)
%tzone1594 = load i8*, i8** %_impzPtr
%zone1595 = bitcast i8* %tzone1594 to %mzone*

; let assign value to symbol xx_t_mst_s_19
%xx_t_mst_s_19Ptr = alloca i8*
%dat1593 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_19 = select i1 true, i8* %dat1593, i8* %dat1593
store i8* %xx_t_mst_s_19, i8** %xx_t_mst_s_19Ptr

%val1596 = load i8*, i8** %xx_t_mst_s_19Ptr
%var1597 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1598 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val1599 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1596, i8* %var1597, i8* %var1598)
%val1600 = load i8*, i8** %xx_t_mst_s_19Ptr
%res1601 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1600)
%res1602 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1592, %String* %res1601)
%val1603 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1604 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1603, i64 0, i32 2
%val1605 = load i8*, i8** %val1604
%res1606 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1605)
%res1607 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1602, %String* %res1606)
%tzone1609 = load i8*, i8** %_impzPtr
%zone1610 = bitcast i8* %tzone1609 to %mzone*

; let assign value to symbol xx_t_mst_s_20
%xx_t_mst_s_20Ptr = alloca i8*
%dat1608 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_20 = select i1 true, i8* %dat1608, i8* %dat1608
store i8* %xx_t_mst_s_20, i8** %xx_t_mst_s_20Ptr

%val1611 = load i8*, i8** %xx_t_mst_s_20Ptr
%var1612 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1613 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val1614 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1611, i8* %var1612, i8* %var1613)
%val1615 = load i8*, i8** %xx_t_mst_s_20Ptr
%res1616 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1615)
%res1617 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res1607, %String* %res1616)

; let value assignment
%res5 = select i1 true, %String* %res1617, %String* %res1617
store %String* %res5, %String** %res5Ptr

%oldzone1620 = call %mzone* @llvm_pop_zone_stack()
%newzone1621 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1622 = bitcast %mzone* %newzone1621 to i8*
store i8* %zone_ptr1622, i8** %_impzPtr

; let value assignment
%zone5 = select i1 true, %mzone* %oldzone1620, %mzone* %oldzone1620
store %mzone* %zone5, %mzone** %zone5Ptr

%res1625 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz5 = select i1 true, %mzone* %res1625, %mzone* %res1625
store %mzone* %newz5, %mzone** %newz5Ptr

%tzone1632 = load i8*, i8** %_impzPtr
%zone1633 = bitcast i8* %tzone1632 to %mzone*

; let assign value to symbol rescopy5
%rescopy5Ptr = alloca %String*
%tzone1638 = load i8*, i8** %_impzPtr
%zone1639 = bitcast i8* %tzone1638 to %mzone*

; let assign value to symbol hook_s_21
%hook_s_21Ptr = alloca {i64,i8*,i8*}*
%tzone1641 = load i8*, i8** %_impzPtr
%zone1642 = bitcast i8* %tzone1641 to %mzone*

; let assign value to symbol f_s_22
%f_s_22Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val1628 = load %String*, %String** %res5Ptr
%val1629 = load %mzone*, %mzone** %zone5Ptr
%val1630 = load %mzone*, %mzone** %newz5Ptr
%res1631 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val1628, %mzone* %val1629, %mzone* %val1630)

; let value assignment
%rescopy5 = select i1 true, %String* %res1631, %String* %res1631
store %String* %rescopy5, %String** %rescopy5Ptr

%val1634 = load %mzone*, %mzone** %zone5Ptr
; tuple ref
%val1635 = getelementptr %mzone, %mzone* %val1634, i64 0, i32 4
%val1636 = load i8*, i8** %val1635
%val1637 = bitcast i8* %val1636 to {i64,i8*,i8*}*

; let value assignment
%hook_s_21 = select i1 true, {i64,i8*,i8*}* %val1637, {i64,i8*,i8*}* %val1637
store {i64,i8*,i8*}* %hook_s_21, {i64,i8*,i8*}** %hook_s_21Ptr

%null1640 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_22 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null1640, {i8*, i8*, void (i8*, i8*)*}** %null1640
store {i8*, i8*, void (i8*, i8*)*}** %f_s_22, {i8*, i8*, void (i8*, i8*)*}*** %f_s_22Ptr

; promote local stack var allocations
%tzone1678 = load i8*, i8** %_impzPtr
%zone1679 = bitcast i8* %tzone1678 to %mzone*
%ifptr1668 = alloca i1
%ifptr1644 = alloca i1
; while loop
%val1645 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_21Ptr
%val1646 = icmp eq {i64,i8*,i8*}* %val1645, null
br i1 %val1646, label %then1644, label %else1644

then1644:
%res1647 = call ccc i1 @impc_false()
store i1 %res1647, i1* %ifptr1644
br label %ifcont1644

else1644:
%res1648 = call ccc i1 @impc_true()
store i1 %res1648, i1* %ifptr1644
br label %ifcont1644

ifcont1644:
%ifres1649 = load i1, i1* %ifptr1644

br i1 %ifres1649, label %loop1643, label %after1643

loop1643:
; do set!
%val1650 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_21Ptr
; tuple ref
%val1651 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1650, i64 0, i32 1
%val1652 = load i8*, i8** %val1651
%val1653 = bitcast i8* %val1652 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val1653, {i8*, i8*, void (i8*, i8*)*}*** %f_s_22Ptr

; apply closure 
%vval1654 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_22Ptr
%val1655 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval1654
%fPtr1656 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1655, i32 0, i32 2
%ePtr1657 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val1655, i32 0, i32 1
%f1658 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr1656
%e1659 = load i8*, i8** %ePtr1657
%tzone1660 = load i8*, i8** %_impzPtr
%zone1661 = bitcast i8* %tzone1660 to %mzone*
%z1662 = bitcast %mzone* %zone1661 to i8*
tail call fastcc void %f1658(i8* %z1662, i8* %e1659)
; do set!
%val1664 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_21Ptr
; tuple ref
%val1665 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1664, i64 0, i32 2
%val1666 = load i8*, i8** %val1665
%val1667 = bitcast i8* %val1666 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val1667, {i64,i8*,i8*}** %hook_s_21Ptr
%val1669 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_21Ptr
%val1670 = icmp eq {i64,i8*,i8*}* %val1669, null
br i1 %val1670, label %then1668, label %else1668

then1668:
%res1671 = call ccc i1 @impc_false()
store i1 %res1671, i1* %ifptr1668
br label %ifcont1668

else1668:
%res1672 = call ccc i1 @impc_true()
store i1 %res1672, i1* %ifptr1668
br label %ifcont1668

ifcont1668:
%ifres1673 = load i1, i1* %ifptr1668

br i1 %ifres1673, label %loop1643, label %after1643

after1643:
%val1675 = load %mzone*, %mzone** %zone5Ptr
call ccc void @llvm_zone_destroy(%mzone* %val1675)
%val1677 = load %String*, %String** %rescopy5Ptr
ret %String* %val1677
}
@gsxtmsndfile66 = hidden constant [103 x i8] c"toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}** @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1699 = load i8*, i8** %_impzPtr
%zone1700 = bitcast i8* %tzone1699 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ
%dat_toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone1700, i64 8)
%toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ to { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}***
%tzone1680 = load i8*, i8** %_impzPtr
%zone1681 = bitcast i8* %tzone1680 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1681)
; malloc closure structure
%clsptr1682 = call i8* @llvm_zone_malloc(%mzone* %zone1681, i64 24)
%closure1683 = bitcast i8* %clsptr1682 to { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}*

; malloc environment structure
%envptr1684 = call i8* @llvm_zone_malloc(%mzone* %zone1681, i64 8)
%environment1685 = bitcast i8* %envptr1684 to {{i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}***}*

; malloc closure address table
%addytable1686 = call %clsvar* @new_address_table()
%var1687 = bitcast [50 x i8]* @gsxtmsndfile64 to i8*
%var1688 = bitcast [53 x i8]* @gsxtmsndfile65 to i8*
%addytable1689 = call %clsvar* @add_address_table(%mzone* %zone1681, i8* %var1687, i32 0, i8* %var1688, i32 3, %clsvar* %addytable1686)
%address-table1690 = bitcast %clsvar* %addytable1689 to i8*

; insert table, function and environment into closure struct
%closure.table1693 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1683, i32 0, i32 0
store i8* %address-table1690, i8** %closure.table1693
%closure.env1694 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1683, i32 0, i32 1
store i8* %envptr1684, i8** %closure.env1694
%closure.func1695 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1683, i32 0, i32 2
store %String* (i8*, i8*, %SF_DITHER_INFO*)* @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ__1484, %String* (i8*, i8*, %SF_DITHER_INFO*)** %closure.func1695
%closure_size1696 = call i64 @llvm_zone_mark_size(%mzone* %zone1681)
call void @llvm_zone_ptr_set_size(i8* %clsptr1682, i64 %closure_size1696)
%wrapper_ptr1697 = call i8* @llvm_zone_malloc(%mzone* %zone1681, i64 8)
%closure_wrapper1698 = bitcast i8* %wrapper_ptr1697 to { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}**
store { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1683, { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_wrapper1698

; let value assignment
%toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_wrapper1698, { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_wrapper1698
store { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}** %toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ, { i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ
%tmp_envptr1692 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}***}* %environment1685, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQPtr, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}**** %tmp_envptr1692


%val1701 = load {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}**, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}** %val1701
}


@toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}** @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ(%SF_DITHER_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_DITHER_INFO*)*,  %String* (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_native(%SF_DITHER_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_DITHER_INFO*)*,  %String* (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1702 = bitcast [103 x i8]* @gsxtmsndfile66 to i8*
call i32 (i8*, ...) @printf(i8* %var1702)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_DITHER_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_DITHER_INFO*)*,  %String* (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_DITHER_INFO*}*
%arg_p_0 = getelementptr {%SF_DITHER_INFO*}, {%SF_DITHER_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_DITHER_INFO*)*,  %String* (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile67 = hidden constant [43 x i8] c"print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ\00"
@gsxtmsndfile68 = hidden constant [49 x i8] c"{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ__1703(i8* %_impz,i8* %_impenv, %SF_DITHER_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1704 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***}*
%print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr = load {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**** %print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr_

; setup arguments
%xPtr = alloca %SF_DITHER_INFO*
store %SF_DITHER_INFO* %x, %SF_DITHER_INFO** %xPtr


%val1706 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
%val1707 = icmp eq %SF_DITHER_INFO* %val1706, null
br i1 %val1707, label %then1705, label %else1705

then1705:
%var1708 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1709 = bitcast [22 x i8]* @gsxtmsndfile62 to i8*

%val1710 = call i32 (i8*, ...) @printf(i8* %var1708, i8* %var1709)
br label %ifcont1705

else1705:
%var1712 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1713 = bitcast [17 x i8]* @gsxtmsndfile63 to i8*

%val1714 = call i32 (i8*, ...) @printf(i8* %var1712, i8* %var1713)
%val1715 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1716 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1715, i64 0, i32 0
%val1717 = load i32, i32* %val1716
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val1717)
%var1719 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1720 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val1721 = call i32 (i8*, ...) @printf(i8* %var1719, i8* %var1720)
%val1722 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1723 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1722, i64 0, i32 1
%val1724 = load double, double* %val1723
call fastcc void @print_adhoc_W3ZvaWQsZG91YmxlXQ(double %val1724)
%var1726 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1727 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val1728 = call i32 (i8*, ...) @printf(i8* %var1726, i8* %var1727)
%val1729 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1730 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1729, i64 0, i32 2
%val1731 = load i8*, i8** %val1730
call fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %val1731)
%var1733 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var1734 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val1735 = call i32 (i8*, ...) @printf(i8* %var1733, i8* %var1734)
br label %ifcont1705

ifcont1705:
ret void
}
@gsxtmsndfile69 = hidden constant [96 x i8] c"print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1757 = load i8*, i8** %_impzPtr
%zone1758 = bitcast i8* %tzone1757 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ
%dat_print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone1758, i64 8)
%print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ to { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***
%tzone1738 = load i8*, i8** %_impzPtr
%zone1739 = bitcast i8* %tzone1738 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1739)
; malloc closure structure
%clsptr1740 = call i8* @llvm_zone_malloc(%mzone* %zone1739, i64 24)
%closure1741 = bitcast i8* %clsptr1740 to { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*

; malloc environment structure
%envptr1742 = call i8* @llvm_zone_malloc(%mzone* %zone1739, i64 8)
%environment1743 = bitcast i8* %envptr1742 to {{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***}*

; malloc closure address table
%addytable1744 = call %clsvar* @new_address_table()
%var1745 = bitcast [43 x i8]* @gsxtmsndfile67 to i8*
%var1746 = bitcast [49 x i8]* @gsxtmsndfile68 to i8*
%addytable1747 = call %clsvar* @add_address_table(%mzone* %zone1739, i8* %var1745, i32 0, i8* %var1746, i32 3, %clsvar* %addytable1744)
%address-table1748 = bitcast %clsvar* %addytable1747 to i8*

; insert table, function and environment into closure struct
%closure.table1751 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1741, i32 0, i32 0
store i8* %address-table1748, i8** %closure.table1751
%closure.env1752 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1741, i32 0, i32 1
store i8* %envptr1742, i8** %closure.env1752
%closure.func1753 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1741, i32 0, i32 2
store void (i8*, i8*, %SF_DITHER_INFO*)* @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ__1703, void (i8*, i8*, %SF_DITHER_INFO*)** %closure.func1753
%closure_size1754 = call i64 @llvm_zone_mark_size(%mzone* %zone1739)
call void @llvm_zone_ptr_set_size(i8* %clsptr1740, i64 %closure_size1754)
%wrapper_ptr1755 = call i8* @llvm_zone_malloc(%mzone* %zone1739, i64 8)
%closure_wrapper1756 = bitcast i8* %wrapper_ptr1755 to { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**
store { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1741, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_wrapper1756

; let value assignment
%print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_wrapper1756, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_wrapper1756
store { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ
%tmp_envptr1750 = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***}* %environment1743, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**** %tmp_envptr1750


%val1759 = load {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr
ret {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %val1759
}


@print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ(%SF_DITHER_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_DITHER_INFO*)*,  void (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_native(%SF_DITHER_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_DITHER_INFO*)*,  void (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1760 = bitcast [96 x i8]* @gsxtmsndfile69 to i8*
call i32 (i8*, ...) @printf(i8* %var1760)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_DITHER_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_DITHER_INFO*)*,  void (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_DITHER_INFO*}*
%arg_p_0 = getelementptr {%SF_DITHER_INFO*}, {%SF_DITHER_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_DITHER_INFO*)*,  void (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile70 = hidden constant [68 x i8] c"SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ\00"
@gsxtmsndfile71 = hidden constant [60 x i8] c"{i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}**\00"
define dllexport fastcc %SF_DITHER_INFO @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ__1761(i8* %_impz,i8* %_impenv, i32 %arg_0, double %arg_1, i8* %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1762 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}***}*
%SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQPtr_ = getelementptr {{i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}***}, {{i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}***}* %impenv, i32 0, i32 0
%SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQPtr = load {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}***, {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}**** %SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca double
store double %arg_1, double* %arg_1Ptr
%arg_2Ptr = alloca i8*
store i8* %arg_2, i8** %arg_2Ptr


%tzone1764 = load i8*, i8** %_impzPtr
%zone1765 = bitcast i8* %tzone1764 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_DITHER_INFO*
%dat1763 = alloca %SF_DITHER_INFO, align 16

; let value assignment
%obj = select i1 true, %SF_DITHER_INFO* %dat1763, %SF_DITHER_INFO* %dat1763
store %SF_DITHER_INFO* %obj, %SF_DITHER_INFO** %objPtr

%val1766 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1767 = load i32, i32* %arg_0Ptr
; set tuple
%val1768 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1766, i64 0, i32 0
store i32 %val1767, i32* %val1768
%val1769 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1770 = load double, double* %arg_1Ptr
; set tuple
%val1771 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1769, i64 0, i32 1
store double %val1770, double* %val1771
%val1772 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1773 = load i8*, i8** %arg_2Ptr
; set tuple
%val1774 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1772, i64 0, i32 2
store i8* %val1773, i8** %val1774
%val1775 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
; pointer ref
%val1776 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1775, i64 0
%val1777 = load %SF_DITHER_INFO, %SF_DITHER_INFO* %val1776
ret %SF_DITHER_INFO %val1777
}
@gsxtmsndfile72 = hidden constant [121 x i8] c"SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}** @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1797 = load i8*, i8** %_impzPtr
%zone1798 = bitcast i8* %tzone1797 to %mzone*

; let assign value to symbol SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ
%dat_SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1798, i64 8)
%SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQPtr = bitcast i8* %dat_SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ to { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}***
%tzone1778 = load i8*, i8** %_impzPtr
%zone1779 = bitcast i8* %tzone1778 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1779)
; malloc closure structure
%clsptr1780 = call i8* @llvm_zone_malloc(%mzone* %zone1779, i64 24)
%closure1781 = bitcast i8* %clsptr1780 to { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}*

; malloc environment structure
%envptr1782 = call i8* @llvm_zone_malloc(%mzone* %zone1779, i64 8)
%environment1783 = bitcast i8* %envptr1782 to {{i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}***}*

; malloc closure address table
%addytable1784 = call %clsvar* @new_address_table()
%var1785 = bitcast [68 x i8]* @gsxtmsndfile70 to i8*
%var1786 = bitcast [60 x i8]* @gsxtmsndfile71 to i8*
%addytable1787 = call %clsvar* @add_address_table(%mzone* %zone1779, i8* %var1785, i32 0, i8* %var1786, i32 3, %clsvar* %addytable1784)
%address-table1788 = bitcast %clsvar* %addytable1787 to i8*

; insert table, function and environment into closure struct
%closure.table1791 = getelementptr { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}, { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}* %closure1781, i32 0, i32 0
store i8* %address-table1788, i8** %closure.table1791
%closure.env1792 = getelementptr { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}, { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}* %closure1781, i32 0, i32 1
store i8* %envptr1782, i8** %closure.env1792
%closure.func1793 = getelementptr { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}, { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}* %closure1781, i32 0, i32 2
store %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)* @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ__1761, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)** %closure.func1793
%closure_size1794 = call i64 @llvm_zone_mark_size(%mzone* %zone1779)
call void @llvm_zone_ptr_set_size(i8* %clsptr1780, i64 %closure_size1794)
%wrapper_ptr1795 = call i8* @llvm_zone_malloc(%mzone* %zone1779, i64 8)
%closure_wrapper1796 = bitcast i8* %wrapper_ptr1795 to { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}**
store { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}* %closure1781, { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}** %closure_wrapper1796

; let value assignment
%SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ = select i1 true, { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}** %closure_wrapper1796, { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}** %closure_wrapper1796
store { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}** %SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ, { i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}*** %SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQPtr

; add data to environment
; don't need to alloc for env var SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ
%tmp_envptr1790 = getelementptr {{i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}***}, {{i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}***}* %environment1783, i32 0, i32 0
store {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}*** %SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQPtr, {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}**** %tmp_envptr1790


%val1799 = load {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}**, {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}*** %SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQPtr
ret {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}** %val1799
}


@SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}** @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_DITHER_INFO @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ(i32 %arg_0,double %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
ret %SF_DITHER_INFO %result
}


define dllexport ccc %SF_DITHER_INFO @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_native(i32 %arg_0,double %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
ret %SF_DITHER_INFO %result
}


define dllexport ccc void @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, double, i8*}*
%arg_p_0 = getelementptr {i32, double, i8*}, {i32, double, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, double, i8*}, {i32, double, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load double, double* %arg_p_1
%arg_p_2 = getelementptr {i32, double, i8*}, {i32, double, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_DITHER_INFO_val_adhoc_W1NGX0RJVEhFUl9JTkZPLGkzMixkb3VibGUsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}*, {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}, {i8*, i8*, %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)*,  %SF_DITHER_INFO (i8*, i8*, i32, double, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO %ff(i8* %_impz, i8* %ee, i32 %arg_0, double %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile73 = hidden constant [57 x i8] c"hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd\00"
@gsxtmsndfile74 = hidden constant [61 x i8] c"{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}**\00"
define dllexport fastcc %SF_DITHER_INFO* @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd__1803(i8* %_impz,i8* %_impenv, %SF_DITHER_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1804 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}***}*
%hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypdPtr_ = getelementptr {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}***}, {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypdPtr = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}***, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}**** %hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypdPtr_

; setup arguments
%xPtr = alloca %SF_DITHER_INFO*
store %SF_DITHER_INFO* %x, %SF_DITHER_INFO** %xPtr


%tzone1807 = load i8*, i8** %_impzPtr
%zone1808 = bitcast i8* %tzone1807 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_DITHER_INFO*
%dat1805 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat1805, i32 0, i64 24)
%val1806 = bitcast i8* %dat1805 to %SF_DITHER_INFO*

; let value assignment
%obj = select i1 true, %SF_DITHER_INFO* %val1806, %SF_DITHER_INFO* %val1806
store %SF_DITHER_INFO* %obj, %SF_DITHER_INFO** %objPtr

%val1809 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1810 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1811 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1810, i64 0, i32 0
%val1812 = load i32, i32* %val1811
; set tuple
%val1813 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1809, i64 0, i32 0
store i32 %val1812, i32* %val1813
%val1814 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1815 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1816 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1815, i64 0, i32 1
%val1817 = load double, double* %val1816
; set tuple
%val1818 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1814, i64 0, i32 1
store double %val1817, double* %val1818
%val1819 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1820 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1821 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1820, i64 0, i32 2
%val1822 = load i8*, i8** %val1821
; set tuple
%val1823 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1819, i64 0, i32 2
store i8* %val1822, i8** %val1823
%val1824 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
ret %SF_DITHER_INFO* %val1824
}
@gsxtmsndfile75 = hidden constant [110 x i8] c"hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}** @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1844 = load i8*, i8** %_impzPtr
%zone1845 = bitcast i8* %tzone1844 to %mzone*

; let assign value to symbol hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd
%dat_hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd = call i8* @llvm_zone_malloc(%mzone* %zone1845, i64 8)
%hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypdPtr = bitcast i8* %dat_hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}***
%tzone1825 = load i8*, i8** %_impzPtr
%zone1826 = bitcast i8* %tzone1825 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1826)
; malloc closure structure
%clsptr1827 = call i8* @llvm_zone_malloc(%mzone* %zone1826, i64 24)
%closure1828 = bitcast i8* %clsptr1827 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}*

; malloc environment structure
%envptr1829 = call i8* @llvm_zone_malloc(%mzone* %zone1826, i64 8)
%environment1830 = bitcast i8* %envptr1829 to {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}***}*

; malloc closure address table
%addytable1831 = call %clsvar* @new_address_table()
%var1832 = bitcast [57 x i8]* @gsxtmsndfile73 to i8*
%var1833 = bitcast [61 x i8]* @gsxtmsndfile74 to i8*
%addytable1834 = call %clsvar* @add_address_table(%mzone* %zone1826, i8* %var1832, i32 0, i8* %var1833, i32 3, %clsvar* %addytable1831)
%address-table1835 = bitcast %clsvar* %addytable1834 to i8*

; insert table, function and environment into closure struct
%closure.table1838 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1828, i32 0, i32 0
store i8* %address-table1835, i8** %closure.table1838
%closure.env1839 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1828, i32 0, i32 1
store i8* %envptr1829, i8** %closure.env1839
%closure.func1840 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1828, i32 0, i32 2
store %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)* @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd__1803, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)** %closure.func1840
%closure_size1841 = call i64 @llvm_zone_mark_size(%mzone* %zone1826)
call void @llvm_zone_ptr_set_size(i8* %clsptr1827, i64 %closure_size1841)
%wrapper_ptr1842 = call i8* @llvm_zone_malloc(%mzone* %zone1826, i64 8)
%closure_wrapper1843 = bitcast i8* %wrapper_ptr1842 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}**
store { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1828, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_wrapper1843

; let value assignment
%hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd = select i1 true, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_wrapper1843, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_wrapper1843
store { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}** %hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}*** %hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypdPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd
%tmp_envptr1837 = getelementptr {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}***}, {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}***}* %environment1830, i32 0, i32 0
store {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}*** %hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypdPtr, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}**** %tmp_envptr1837


%val1846 = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}**, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}*** %hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypdPtr
ret {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}** %val1846
}


@hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}** @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_DITHER_INFO* @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd(%SF_DITHER_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*,  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
ret %SF_DITHER_INFO* %result
}


define dllexport ccc %SF_DITHER_INFO* @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_native(%SF_DITHER_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*,  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
ret %SF_DITHER_INFO* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1847 = bitcast [110 x i8]* @gsxtmsndfile75 to i8*
call i32 (i8*, ...) @printf(i8* %var1847)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_DITHER_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*,  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
%tmpres = bitcast %SF_DITHER_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_DITHER_INFO*}*
%arg_p_0 = getelementptr {%SF_DITHER_INFO*}, {%SF_DITHER_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)*,  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile76 = hidden constant [43 x i8] c"hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ__1848(i8* %_impz,i8* %_impenv, %SF_DITHER_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1849 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***}*
%hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr = load {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**** %hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr_

; setup arguments
%xPtr = alloca %SF_DITHER_INFO*
store %SF_DITHER_INFO* %x, %SF_DITHER_INFO** %xPtr


%val1850 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
%val1851 = bitcast %SF_DITHER_INFO* %val1850 to i8*
call ccc void @free(i8* %val1851)
ret void
}
@gsxtmsndfile77 = hidden constant [96 x i8] c"hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1873 = load i8*, i8** %_impzPtr
%zone1874 = bitcast i8* %tzone1873 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ
%dat_hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone1874, i64 8)
%hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ to { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***
%tzone1854 = load i8*, i8** %_impzPtr
%zone1855 = bitcast i8* %tzone1854 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1855)
; malloc closure structure
%clsptr1856 = call i8* @llvm_zone_malloc(%mzone* %zone1855, i64 24)
%closure1857 = bitcast i8* %clsptr1856 to { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*

; malloc environment structure
%envptr1858 = call i8* @llvm_zone_malloc(%mzone* %zone1855, i64 8)
%environment1859 = bitcast i8* %envptr1858 to {{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***}*

; malloc closure address table
%addytable1860 = call %clsvar* @new_address_table()
%var1861 = bitcast [43 x i8]* @gsxtmsndfile76 to i8*
%var1862 = bitcast [49 x i8]* @gsxtmsndfile68 to i8*
%addytable1863 = call %clsvar* @add_address_table(%mzone* %zone1855, i8* %var1861, i32 0, i8* %var1862, i32 3, %clsvar* %addytable1860)
%address-table1864 = bitcast %clsvar* %addytable1863 to i8*

; insert table, function and environment into closure struct
%closure.table1867 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1857, i32 0, i32 0
store i8* %address-table1864, i8** %closure.table1867
%closure.env1868 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1857, i32 0, i32 1
store i8* %envptr1858, i8** %closure.env1868
%closure.func1869 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1857, i32 0, i32 2
store void (i8*, i8*, %SF_DITHER_INFO*)* @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ__1848, void (i8*, i8*, %SF_DITHER_INFO*)** %closure.func1869
%closure_size1870 = call i64 @llvm_zone_mark_size(%mzone* %zone1855)
call void @llvm_zone_ptr_set_size(i8* %clsptr1856, i64 %closure_size1870)
%wrapper_ptr1871 = call i8* @llvm_zone_malloc(%mzone* %zone1855, i64 8)
%closure_wrapper1872 = bitcast i8* %wrapper_ptr1871 to { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**
store { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure1857, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_wrapper1872

; let value assignment
%hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_wrapper1872, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_wrapper1872
store { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ, { i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ
%tmp_envptr1866 = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}***}* %environment1859, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**** %tmp_envptr1866


%val1875 = load {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQPtr
ret {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %val1875
}


@hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ(%SF_DITHER_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_DITHER_INFO*)*,  void (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_native(%SF_DITHER_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_DITHER_INFO*)*,  void (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1876 = bitcast [96 x i8]* @gsxtmsndfile77 to i8*
call i32 (i8*, ...) @printf(i8* %var1876)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_DITHER_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_DITHER_INFO*)*,  void (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_DITHER_INFO*}*
%arg_p_0 = getelementptr {%SF_DITHER_INFO*}, {%SF_DITHER_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRElUSEVSX0lORk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_DITHER_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_DITHER_INFO*)*,  void (i8*, i8*, %SF_DITHER_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile78 = hidden constant [76 x i8] c"zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0\00"
@gsxtmsndfile79 = hidden constant [79 x i8] c"{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %SF_DITHER_INFO* @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0__1877(i8* %_impz,i8* %_impenv, %SF_DITHER_INFO* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1878 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}***, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca %SF_DITHER_INFO*
store %SF_DITHER_INFO* %x, %SF_DITHER_INFO** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val1880 = load %mzone*, %mzone** %fromzPtr
%val1881 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
%val1882 = bitcast %SF_DITHER_INFO* %val1881 to i8*
%res1883 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1880, i8* %val1882)
br i1 %res1883, label %then1879, label %else1879

then1879:
%val1884 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val1884)
%zone_ptr1885 = bitcast %mzone* %val1884 to i8*
store i8* %zone_ptr1885, i8** %_impzPtr
%tzone1891 = load i8*, i8** %_impzPtr
%zone1892 = bitcast i8* %tzone1891 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_DITHER_INFO*
%tzone1887 = load i8*, i8** %_impzPtr
%zone1888 = bitcast i8* %tzone1887 to %mzone*
%dat1889 = call i8* @llvm_zone_malloc(%mzone* %zone1888, i64 24)
call i8* @memset(i8* %dat1889, i32 0, i64 24)
%val1890 = bitcast i8* %dat1889 to %SF_DITHER_INFO*

; let value assignment
%obj = select i1 true, %SF_DITHER_INFO* %val1890, %SF_DITHER_INFO* %val1890
store %SF_DITHER_INFO* %obj, %SF_DITHER_INFO** %objPtr

; promote local stack var allocations
%tzone1936 = load i8*, i8** %_impzPtr
%zone1937 = bitcast i8* %tzone1936 to %mzone*
%ifptr1903 = alloca i8*
%val1893 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1894 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1895 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1894, i64 0, i32 0
%val1896 = load i32, i32* %val1895
; set tuple
%val1897 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1893, i64 0, i32 0
store i32 %val1896, i32* %val1897
%val1898 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1899 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1900 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1899, i64 0, i32 1
%val1901 = load double, double* %val1900
; set tuple
%val1902 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1898, i64 0, i32 1
store double %val1901, double* %val1902
%val1904 = load %mzone*, %mzone** %fromzPtr
%val1905 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1906 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1905, i64 0, i32 2
%val1907 = load i8*, i8** %val1906
%val1908 = bitcast i8* %val1907 to i8*
%res1909 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1904, i8* %val1908)
br i1 %res1909, label %then1903, label %else1903

then1903:
%tzone1914 = load i8*, i8** %_impzPtr
%zone1915 = bitcast i8* %tzone1914 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i8*
%tzone1910 = load i8*, i8** %_impzPtr
%zone1911 = bitcast i8* %tzone1910 to %mzone*
%dat1912 = call i8* @llvm_zone_malloc(%mzone* %zone1911, i64 1)
call i8* @memset(i8* %dat1912, i32 0, i64 1)
%val1913 = bitcast i8* %dat1912 to i8*

; let value assignment
%newptr = select i1 true, i8* %val1913, i8* %val1913
store i8* %newptr, i8** %newptrPtr

%val1916 = load i8*, i8** %newptrPtr
%val1917 = bitcast i8* %val1916 to i8*
%val1918 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1919 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1918, i64 0, i32 2
%val1920 = load i8*, i8** %val1919
%val1921 = bitcast i8* %val1920 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val1917, i8* %val1921, i64 1, i32 1, i1 0)
%val1923 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1924 = load i8*, i8** %newptrPtr
; set tuple
%val1925 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1923, i64 0, i32 2
store i8* %val1924, i8** %val1925
store i8* %val1924, i8** %ifptr1903
br label %ifcont1903

else1903:
%val1926 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
%val1927 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
; tuple ref
%val1928 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1927, i64 0, i32 2
%val1929 = load i8*, i8** %val1928
; set tuple
%val1930 = getelementptr %SF_DITHER_INFO, %SF_DITHER_INFO* %val1926, i64 0, i32 2
store i8* %val1929, i8** %val1930
store i8* %val1929, i8** %ifptr1903
br label %ifcont1903

ifcont1903:
%ifres1931 = load i8*, i8** %ifptr1903

%oldzone1932 = call %mzone* @llvm_pop_zone_stack()
%newzone1933 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1934 = bitcast %mzone* %newzone1933 to i8*
store i8* %zone_ptr1934, i8** %_impzPtr
%val1935 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %objPtr
ret %SF_DITHER_INFO* %val1935

else1879:
%val1938 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %xPtr
ret %SF_DITHER_INFO* %val1938
}
@gsxtmsndfile80 = hidden constant [129 x i8] c"zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1958 = load i8*, i8** %_impzPtr
%zone1959 = bitcast i8* %tzone1958 to %mzone*

; let assign value to symbol zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1959, i64 8)
%zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}***
%tzone1939 = load i8*, i8** %_impzPtr
%zone1940 = bitcast i8* %tzone1939 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1940)
; malloc closure structure
%clsptr1941 = call i8* @llvm_zone_malloc(%mzone* %zone1940, i64 24)
%closure1942 = bitcast i8* %clsptr1941 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr1943 = call i8* @llvm_zone_malloc(%mzone* %zone1940, i64 8)
%environment1944 = bitcast i8* %envptr1943 to {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable1945 = call %clsvar* @new_address_table()
%var1946 = bitcast [76 x i8]* @gsxtmsndfile78 to i8*
%var1947 = bitcast [79 x i8]* @gsxtmsndfile79 to i8*
%addytable1948 = call %clsvar* @add_address_table(%mzone* %zone1940, i8* %var1946, i32 0, i8* %var1947, i32 3, %clsvar* %addytable1945)
%address-table1949 = bitcast %clsvar* %addytable1948 to i8*

; insert table, function and environment into closure struct
%closure.table1952 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}* %closure1942, i32 0, i32 0
store i8* %address-table1949, i8** %closure.table1952
%closure.env1953 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}* %closure1942, i32 0, i32 1
store i8* %envptr1943, i8** %closure.env1953
%closure.func1954 = getelementptr { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}* %closure1942, i32 0, i32 2
store %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)* @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0__1877, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)** %closure.func1954
%closure_size1955 = call i64 @llvm_zone_mark_size(%mzone* %zone1940)
call void @llvm_zone_ptr_set_size(i8* %clsptr1941, i64 %closure_size1955)
%wrapper_ptr1956 = call i8* @llvm_zone_malloc(%mzone* %zone1940, i64 8)
%closure_wrapper1957 = bitcast i8* %wrapper_ptr1956 to { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}**
store { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}* %closure1942, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}** %closure_wrapper1957

; let value assignment
%zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}** %closure_wrapper1957, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}** %closure_wrapper1957
store { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0, { i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0
%tmp_envptr1951 = getelementptr {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}***}* %environment1944, i32 0, i32 0
store {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}**** %tmp_envptr1951


%val1960 = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}**, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}** %val1960
}


@zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_DITHER_INFO* @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0(%SF_DITHER_INFO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*,  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %SF_DITHER_INFO* %result
}


define dllexport ccc %SF_DITHER_INFO* @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_native(%SF_DITHER_INFO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*,  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %SF_DITHER_INFO* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1961 = bitcast [129 x i8]* @gsxtmsndfile80 to i8*
call i32 (i8*, ...) @printf(i8* %var1961)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_DITHER_INFO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1962 = bitcast [129 x i8]* @gsxtmsndfile80 to i8*
call i32 (i8*, ...) @printf(i8* %var1962)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1963 = bitcast [129 x i8]* @gsxtmsndfile80 to i8*
call i32 (i8*, ...) @printf(i8* %var1963)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*,  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %SF_DITHER_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_DITHER_INFO*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%SF_DITHER_INFO*, %mzone*, %mzone*}, {%SF_DITHER_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_DITHER_INFO*, %SF_DITHER_INFO** %arg_p_0
%arg_p_1 = getelementptr {%SF_DITHER_INFO*, %mzone*, %mzone*}, {%SF_DITHER_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%SF_DITHER_INFO*, %mzone*, %mzone*}, {%SF_DITHER_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0RJVEhFUl9JTkZPKixTRl9ESVRIRVJfSU5GTyosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)*,  %SF_DITHER_INFO* (i8*, i8*, %SF_DITHER_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_DITHER_INFO* %ff(i8* %_impz, i8* %ee, %SF_DITHER_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%SF_EMBED_FILE_INFO = type {i64,i64}
@gsxtmsndfile81 = hidden constant [65 x i8] c"SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0\00"
@gsxtmsndfile82 = hidden constant [57 x i8] c"{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**\00"
define dllexport fastcc %SF_EMBED_FILE_INFO* @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0__1964(i8* %_impz,i8* %_impenv, i64 %arg_0, i64 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1965 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}*
%SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr_ = getelementptr {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**** %SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i64
store i64 %arg_1, i64* %arg_1Ptr


%tzone1970 = load i8*, i8** %_impzPtr
%zone1971 = bitcast i8* %tzone1970 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_EMBED_FILE_INFO*
%tzone1966 = load i8*, i8** %_impzPtr
%zone1967 = bitcast i8* %tzone1966 to %mzone*
%dat1968 = call i8* @llvm_zone_malloc(%mzone* %zone1967, i64 16)
call i8* @memset(i8* %dat1968, i32 0, i64 16)
%val1969 = bitcast i8* %dat1968 to %SF_EMBED_FILE_INFO*

; let value assignment
%obj = select i1 true, %SF_EMBED_FILE_INFO* %val1969, %SF_EMBED_FILE_INFO* %val1969
store %SF_EMBED_FILE_INFO* %obj, %SF_EMBED_FILE_INFO** %objPtr

%val1972 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
%val1973 = load i64, i64* %arg_0Ptr
; set tuple
%val1974 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val1972, i64 0, i32 0
store i64 %val1973, i64* %val1974
%val1975 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
%val1976 = load i64, i64* %arg_1Ptr
; set tuple
%val1977 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val1975, i64 0, i32 1
store i64 %val1976, i64* %val1977
%val1978 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
ret %SF_EMBED_FILE_INFO* %val1978
}
@gsxtmsndfile83 = hidden constant [118 x i8] c"SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1998 = load i8*, i8** %_impzPtr
%zone1999 = bitcast i8* %tzone1998 to %mzone*

; let assign value to symbol SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0
%dat_SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone1999, i64 8)
%SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr = bitcast i8* %dat_SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***
%tzone1979 = load i8*, i8** %_impzPtr
%zone1980 = bitcast i8* %tzone1979 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1980)
; malloc closure structure
%clsptr1981 = call i8* @llvm_zone_malloc(%mzone* %zone1980, i64 24)
%closure1982 = bitcast i8* %clsptr1981 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr1983 = call i8* @llvm_zone_malloc(%mzone* %zone1980, i64 8)
%environment1984 = bitcast i8* %envptr1983 to {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable1985 = call %clsvar* @new_address_table()
%var1986 = bitcast [65 x i8]* @gsxtmsndfile81 to i8*
%var1987 = bitcast [57 x i8]* @gsxtmsndfile82 to i8*
%addytable1988 = call %clsvar* @add_address_table(%mzone* %zone1980, i8* %var1986, i32 0, i8* %var1987, i32 3, %clsvar* %addytable1985)
%address-table1989 = bitcast %clsvar* %addytable1988 to i8*

; insert table, function and environment into closure struct
%closure.table1992 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure1982, i32 0, i32 0
store i8* %address-table1989, i8** %closure.table1992
%closure.env1993 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure1982, i32 0, i32 1
store i8* %envptr1983, i8** %closure.env1993
%closure.func1994 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure1982, i32 0, i32 2
store %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)* @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0__1964, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %closure.func1994
%closure_size1995 = call i64 @llvm_zone_mark_size(%mzone* %zone1980)
call void @llvm_zone_ptr_set_size(i8* %clsptr1981, i64 %closure_size1995)
%wrapper_ptr1996 = call i8* @llvm_zone_malloc(%mzone* %zone1980, i64 8)
%closure_wrapper1997 = bitcast i8* %wrapper_ptr1996 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
store { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure1982, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_wrapper1997

; let value assignment
%SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0 = select i1 true, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_wrapper1997, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_wrapper1997
store { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*** %SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr

; add data to environment
; don't need to alloc for env var SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0
%tmp_envptr1991 = getelementptr {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}* %environment1984, i32 0, i32 0
store {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*** %SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**** %tmp_envptr1991


%val2000 = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*** %SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr
ret {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %val2000
}


@SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_EMBED_FILE_INFO* @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %SF_EMBED_FILE_INFO* %result
}


define dllexport ccc %SF_EMBED_FILE_INFO* @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_native(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %SF_EMBED_FILE_INFO* %result
}


define dllexport ccc i8*  @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2001 = bitcast [118 x i8]* @gsxtmsndfile83 to i8*
call i32 (i8*, ...) @printf(i8* %var2001)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2002 = bitcast [118 x i8]* @gsxtmsndfile83 to i8*
call i32 (i8*, ...) @printf(i8* %var2002)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%tmpres = bitcast %SF_EMBED_FILE_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64}*
%arg_p_0 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile84 = hidden constant [67 x i8] c"SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0\00"
define dllexport fastcc %SF_EMBED_FILE_INFO* @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0__2003(i8* %_impz,i8* %_impenv, i64 %arg_0, i64 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2004 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}*
%SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr_ = getelementptr {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**** %SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i64
store i64 %arg_1, i64* %arg_1Ptr


%tzone2009 = load i8*, i8** %_impzPtr
%zone2010 = bitcast i8* %tzone2009 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_EMBED_FILE_INFO*
%tzone2005 = load i8*, i8** %_impzPtr
%zone2006 = bitcast i8* %tzone2005 to %mzone*
%dat2007 = call i8* @llvm_zone_malloc(%mzone* %zone2006, i64 16)
call i8* @memset(i8* %dat2007, i32 0, i64 16)
%val2008 = bitcast i8* %dat2007 to %SF_EMBED_FILE_INFO*

; let value assignment
%obj = select i1 true, %SF_EMBED_FILE_INFO* %val2008, %SF_EMBED_FILE_INFO* %val2008
store %SF_EMBED_FILE_INFO* %obj, %SF_EMBED_FILE_INFO** %objPtr

%val2011 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
%val2012 = load i64, i64* %arg_0Ptr
; set tuple
%val2013 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2011, i64 0, i32 0
store i64 %val2012, i64* %val2013
%val2014 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
%val2015 = load i64, i64* %arg_1Ptr
; set tuple
%val2016 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2014, i64 0, i32 1
store i64 %val2015, i64* %val2016
%val2017 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
ret %SF_EMBED_FILE_INFO* %val2017
}
@gsxtmsndfile85 = hidden constant [120 x i8] c"SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2037 = load i8*, i8** %_impzPtr
%zone2038 = bitcast i8* %tzone2037 to %mzone*

; let assign value to symbol SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0
%dat_SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone2038, i64 8)
%SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr = bitcast i8* %dat_SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***
%tzone2018 = load i8*, i8** %_impzPtr
%zone2019 = bitcast i8* %tzone2018 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2019)
; malloc closure structure
%clsptr2020 = call i8* @llvm_zone_malloc(%mzone* %zone2019, i64 24)
%closure2021 = bitcast i8* %clsptr2020 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr2022 = call i8* @llvm_zone_malloc(%mzone* %zone2019, i64 8)
%environment2023 = bitcast i8* %envptr2022 to {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable2024 = call %clsvar* @new_address_table()
%var2025 = bitcast [67 x i8]* @gsxtmsndfile84 to i8*
%var2026 = bitcast [57 x i8]* @gsxtmsndfile82 to i8*
%addytable2027 = call %clsvar* @add_address_table(%mzone* %zone2019, i8* %var2025, i32 0, i8* %var2026, i32 3, %clsvar* %addytable2024)
%address-table2028 = bitcast %clsvar* %addytable2027 to i8*

; insert table, function and environment into closure struct
%closure.table2031 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure2021, i32 0, i32 0
store i8* %address-table2028, i8** %closure.table2031
%closure.env2032 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure2021, i32 0, i32 1
store i8* %envptr2022, i8** %closure.env2032
%closure.func2033 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure2021, i32 0, i32 2
store %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)* @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0__2003, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %closure.func2033
%closure_size2034 = call i64 @llvm_zone_mark_size(%mzone* %zone2019)
call void @llvm_zone_ptr_set_size(i8* %clsptr2020, i64 %closure_size2034)
%wrapper_ptr2035 = call i8* @llvm_zone_malloc(%mzone* %zone2019, i64 8)
%closure_wrapper2036 = bitcast i8* %wrapper_ptr2035 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
store { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure2021, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_wrapper2036

; let value assignment
%SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0 = select i1 true, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_wrapper2036, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_wrapper2036
store { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*** %SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr

; add data to environment
; don't need to alloc for env var SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0
%tmp_envptr2030 = getelementptr {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}* %environment2023, i32 0, i32 0
store {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*** %SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**** %tmp_envptr2030


%val2039 = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*** %SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr
ret {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %val2039
}


@SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_EMBED_FILE_INFO* @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %SF_EMBED_FILE_INFO* %result
}


define dllexport ccc %SF_EMBED_FILE_INFO* @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_native(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %SF_EMBED_FILE_INFO* %result
}


define dllexport ccc i8*  @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2040 = bitcast [120 x i8]* @gsxtmsndfile85 to i8*
call i32 (i8*, ...) @printf(i8* %var2040)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2041 = bitcast [120 x i8]* @gsxtmsndfile85 to i8*
call i32 (i8*, ...) @printf(i8* %var2041)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%tmpres = bitcast %SF_EMBED_FILE_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64}*
%arg_p_0 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_z_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile86 = hidden constant [67 x i8] c"SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0\00"
define dllexport fastcc %SF_EMBED_FILE_INFO* @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0__2042(i8* %_impz,i8* %_impenv, i64 %arg_0, i64 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2043 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}*
%SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr_ = getelementptr {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**** %SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i64
store i64 %arg_1, i64* %arg_1Ptr


%tzone2046 = load i8*, i8** %_impzPtr
%zone2047 = bitcast i8* %tzone2046 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_EMBED_FILE_INFO*
%dat2044 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat2044, i32 0, i64 16)
%val2045 = bitcast i8* %dat2044 to %SF_EMBED_FILE_INFO*

; let value assignment
%obj = select i1 true, %SF_EMBED_FILE_INFO* %val2045, %SF_EMBED_FILE_INFO* %val2045
store %SF_EMBED_FILE_INFO* %obj, %SF_EMBED_FILE_INFO** %objPtr

%val2048 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
%val2049 = load i64, i64* %arg_0Ptr
; set tuple
%val2050 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2048, i64 0, i32 0
store i64 %val2049, i64* %val2050
%val2051 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
%val2052 = load i64, i64* %arg_1Ptr
; set tuple
%val2053 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2051, i64 0, i32 1
store i64 %val2052, i64* %val2053
%val2054 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
ret %SF_EMBED_FILE_INFO* %val2054
}
@gsxtmsndfile87 = hidden constant [120 x i8] c"SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2074 = load i8*, i8** %_impzPtr
%zone2075 = bitcast i8* %tzone2074 to %mzone*

; let assign value to symbol SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0
%dat_SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone2075, i64 8)
%SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr = bitcast i8* %dat_SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***
%tzone2055 = load i8*, i8** %_impzPtr
%zone2056 = bitcast i8* %tzone2055 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2056)
; malloc closure structure
%clsptr2057 = call i8* @llvm_zone_malloc(%mzone* %zone2056, i64 24)
%closure2058 = bitcast i8* %clsptr2057 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr2059 = call i8* @llvm_zone_malloc(%mzone* %zone2056, i64 8)
%environment2060 = bitcast i8* %envptr2059 to {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable2061 = call %clsvar* @new_address_table()
%var2062 = bitcast [67 x i8]* @gsxtmsndfile86 to i8*
%var2063 = bitcast [57 x i8]* @gsxtmsndfile82 to i8*
%addytable2064 = call %clsvar* @add_address_table(%mzone* %zone2056, i8* %var2062, i32 0, i8* %var2063, i32 3, %clsvar* %addytable2061)
%address-table2065 = bitcast %clsvar* %addytable2064 to i8*

; insert table, function and environment into closure struct
%closure.table2068 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure2058, i32 0, i32 0
store i8* %address-table2065, i8** %closure.table2068
%closure.env2069 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure2058, i32 0, i32 1
store i8* %envptr2059, i8** %closure.env2069
%closure.func2070 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure2058, i32 0, i32 2
store %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)* @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0__2042, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %closure.func2070
%closure_size2071 = call i64 @llvm_zone_mark_size(%mzone* %zone2056)
call void @llvm_zone_ptr_set_size(i8* %clsptr2057, i64 %closure_size2071)
%wrapper_ptr2072 = call i8* @llvm_zone_malloc(%mzone* %zone2056, i64 8)
%closure_wrapper2073 = bitcast i8* %wrapper_ptr2072 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
store { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure2058, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_wrapper2073

; let value assignment
%SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0 = select i1 true, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_wrapper2073, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_wrapper2073
store { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*** %SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr

; add data to environment
; don't need to alloc for env var SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0
%tmp_envptr2067 = getelementptr {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}***}* %environment2060, i32 0, i32 0
store {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*** %SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**** %tmp_envptr2067


%val2076 = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*** %SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0Ptr
ret {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %val2076
}


@SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_EMBED_FILE_INFO* @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %SF_EMBED_FILE_INFO* %result
}


define dllexport ccc %SF_EMBED_FILE_INFO* @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_native(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %SF_EMBED_FILE_INFO* %result
}


define dllexport ccc i8*  @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2077 = bitcast [120 x i8]* @gsxtmsndfile87 to i8*
call i32 (i8*, ...) @printf(i8* %var2077)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2078 = bitcast [120 x i8]* @gsxtmsndfile87 to i8*
call i32 (i8*, ...) @printf(i8* %var2078)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%tmpres = bitcast %SF_EMBED_FILE_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64}*
%arg_p_0 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_h_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile88 = hidden constant [26 x i8] c"<SF_EMBED_FILE_INFO:null>\00"
@gsxtmsndfile89 = hidden constant [21 x i8] c"<SF_EMBED_FILE_INFO:\00"
@gsxtmsndfile90 = hidden constant [55 x i8] c"toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0\00"
@gsxtmsndfile91 = hidden constant [57 x i8] c"{i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0__2079(i8* %_impz,i8* %_impenv, %SF_EMBED_FILE_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2080 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}*
%toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**** %toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr_

; setup arguments
%xPtr = alloca %SF_EMBED_FILE_INFO*
store %SF_EMBED_FILE_INFO* %x, %SF_EMBED_FILE_INFO** %xPtr


%val2082 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
%val2083 = icmp eq %SF_EMBED_FILE_INFO* %val2082, null
br i1 %val2083, label %then2081, label %else2081

then2081:
%zone2084 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone2084)
%zone_ptr2085 = bitcast %mzone* %zone2084 to i8*
store i8* %zone_ptr2085, i8** %_impzPtr
%tzone2095 = load i8*, i8** %_impzPtr
%zone2096 = bitcast i8* %tzone2095 to %mzone*

; let assign value to symbol res6
%res6Ptr = alloca %String*
%tzone2100 = load i8*, i8** %_impzPtr
%zone2101 = bitcast i8* %tzone2100 to %mzone*

; let assign value to symbol zone6
%zone6Ptr = alloca %mzone*
%tzone2103 = load i8*, i8** %_impzPtr
%zone2104 = bitcast i8* %tzone2103 to %mzone*

; let assign value to symbol newz6
%newz6Ptr = alloca %mzone*
%tzone2087 = load i8*, i8** %_impzPtr
%zone2088 = bitcast i8* %tzone2087 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat2086 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat2086, i8* %dat2086
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val2089 = load i8*, i8** %xx_t_mstPtr
%var2090 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2091 = bitcast [26 x i8]* @gsxtmsndfile88 to i8*

%val2092 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2089, i8* %var2090, i8* %var2091)
%val2093 = load i8*, i8** %xx_t_mstPtr
%res2094 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2093)

; let value assignment
%res6 = select i1 true, %String* %res2094, %String* %res2094
store %String* %res6, %String** %res6Ptr

%oldzone2097 = call %mzone* @llvm_pop_zone_stack()
%newzone2098 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2099 = bitcast %mzone* %newzone2098 to i8*
store i8* %zone_ptr2099, i8** %_impzPtr

; let value assignment
%zone6 = select i1 true, %mzone* %oldzone2097, %mzone* %oldzone2097
store %mzone* %zone6, %mzone** %zone6Ptr

%res2102 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz6 = select i1 true, %mzone* %res2102, %mzone* %res2102
store %mzone* %newz6, %mzone** %newz6Ptr

%tzone2109 = load i8*, i8** %_impzPtr
%zone2110 = bitcast i8* %tzone2109 to %mzone*

; let assign value to symbol rescopy6
%rescopy6Ptr = alloca %String*
%tzone2115 = load i8*, i8** %_impzPtr
%zone2116 = bitcast i8* %tzone2115 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone2118 = load i8*, i8** %_impzPtr
%zone2119 = bitcast i8* %tzone2118 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val2105 = load %String*, %String** %res6Ptr
%val2106 = load %mzone*, %mzone** %zone6Ptr
%val2107 = load %mzone*, %mzone** %newz6Ptr
%res2108 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val2105, %mzone* %val2106, %mzone* %val2107)

; let value assignment
%rescopy6 = select i1 true, %String* %res2108, %String* %res2108
store %String* %rescopy6, %String** %rescopy6Ptr

%val2111 = load %mzone*, %mzone** %zone6Ptr
; tuple ref
%val2112 = getelementptr %mzone, %mzone* %val2111, i64 0, i32 4
%val2113 = load i8*, i8** %val2112
%val2114 = bitcast i8* %val2113 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val2114, {i64,i8*,i8*}* %val2114
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null2117 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null2117, {i8*, i8*, void (i8*, i8*)*}** %null2117
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone2155 = load i8*, i8** %_impzPtr
%zone2156 = bitcast i8* %tzone2155 to %mzone*
%ifptr2145 = alloca i1
%ifptr2121 = alloca i1
; while loop
%val2122 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2123 = icmp eq {i64,i8*,i8*}* %val2122, null
br i1 %val2123, label %then2121, label %else2121

then2121:
%res2124 = call ccc i1 @impc_false()
store i1 %res2124, i1* %ifptr2121
br label %ifcont2121

else2121:
%res2125 = call ccc i1 @impc_true()
store i1 %res2125, i1* %ifptr2121
br label %ifcont2121

ifcont2121:
%ifres2126 = load i1, i1* %ifptr2121

br i1 %ifres2126, label %loop2120, label %after2120

loop2120:
; do set!
%val2127 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val2128 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2127, i64 0, i32 1
%val2129 = load i8*, i8** %val2128
%val2130 = bitcast i8* %val2129 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val2130, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval2131 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val2132 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval2131
%fPtr2133 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2132, i32 0, i32 2
%ePtr2134 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2132, i32 0, i32 1
%f2135 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr2133
%e2136 = load i8*, i8** %ePtr2134
%tzone2137 = load i8*, i8** %_impzPtr
%zone2138 = bitcast i8* %tzone2137 to %mzone*
%z2139 = bitcast %mzone* %zone2138 to i8*
tail call fastcc void %f2135(i8* %z2139, i8* %e2136)
; do set!
%val2141 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val2142 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2141, i64 0, i32 2
%val2143 = load i8*, i8** %val2142
%val2144 = bitcast i8* %val2143 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val2144, {i64,i8*,i8*}** %hookPtr
%val2146 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2147 = icmp eq {i64,i8*,i8*}* %val2146, null
br i1 %val2147, label %then2145, label %else2145

then2145:
%res2148 = call ccc i1 @impc_false()
store i1 %res2148, i1* %ifptr2145
br label %ifcont2145

else2145:
%res2149 = call ccc i1 @impc_true()
store i1 %res2149, i1* %ifptr2145
br label %ifcont2145

ifcont2145:
%ifres2150 = load i1, i1* %ifptr2145

br i1 %ifres2150, label %loop2120, label %after2120

after2120:
%val2152 = load %mzone*, %mzone** %zone6Ptr
call ccc void @llvm_zone_destroy(%mzone* %val2152)
%val2154 = load %String*, %String** %rescopy6Ptr
ret %String* %val2154

else2081:
%zone2157 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone2157)
%zone_ptr2158 = bitcast %mzone* %zone2157 to i8*
store i8* %zone_ptr2158, i8** %_impzPtr
%tzone2198 = load i8*, i8** %_impzPtr
%zone2199 = bitcast i8* %tzone2198 to %mzone*

; let assign value to symbol res7
%res7Ptr = alloca %String*
%tzone2203 = load i8*, i8** %_impzPtr
%zone2204 = bitcast i8* %tzone2203 to %mzone*

; let assign value to symbol zone7
%zone7Ptr = alloca %mzone*
%tzone2206 = load i8*, i8** %_impzPtr
%zone2207 = bitcast i8* %tzone2206 to %mzone*

; let assign value to symbol newz7
%newz7Ptr = alloca %mzone*
%tzone2160 = load i8*, i8** %_impzPtr
%zone2161 = bitcast i8* %tzone2160 to %mzone*

; let assign value to symbol xx_t_mst_s_23
%xx_t_mst_s_23Ptr = alloca i8*
%dat2159 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_23 = select i1 true, i8* %dat2159, i8* %dat2159
store i8* %xx_t_mst_s_23, i8** %xx_t_mst_s_23Ptr

%val2162 = load i8*, i8** %xx_t_mst_s_23Ptr
%var2163 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2164 = bitcast [21 x i8]* @gsxtmsndfile89 to i8*

%val2165 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2162, i8* %var2163, i8* %var2164)
%val2166 = load i8*, i8** %xx_t_mst_s_23Ptr
%res2167 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2166)
%val2168 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
; tuple ref
%val2169 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2168, i64 0, i32 0
%val2170 = load i64, i64* %val2169
%res2171 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTY0XQ(i64 %val2170)
%res2172 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2167, %String* %res2171)
%tzone2174 = load i8*, i8** %_impzPtr
%zone2175 = bitcast i8* %tzone2174 to %mzone*

; let assign value to symbol xx_t_mst_s_24
%xx_t_mst_s_24Ptr = alloca i8*
%dat2173 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_24 = select i1 true, i8* %dat2173, i8* %dat2173
store i8* %xx_t_mst_s_24, i8** %xx_t_mst_s_24Ptr

%val2176 = load i8*, i8** %xx_t_mst_s_24Ptr
%var2177 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2178 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val2179 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2176, i8* %var2177, i8* %var2178)
%val2180 = load i8*, i8** %xx_t_mst_s_24Ptr
%res2181 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2180)
%res2182 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2172, %String* %res2181)
%val2183 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
; tuple ref
%val2184 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2183, i64 0, i32 1
%val2185 = load i64, i64* %val2184
%res2186 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTY0XQ(i64 %val2185)
%res2187 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2182, %String* %res2186)
%tzone2189 = load i8*, i8** %_impzPtr
%zone2190 = bitcast i8* %tzone2189 to %mzone*

; let assign value to symbol xx_t_mst_s_25
%xx_t_mst_s_25Ptr = alloca i8*
%dat2188 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_25 = select i1 true, i8* %dat2188, i8* %dat2188
store i8* %xx_t_mst_s_25, i8** %xx_t_mst_s_25Ptr

%val2191 = load i8*, i8** %xx_t_mst_s_25Ptr
%var2192 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2193 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val2194 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2191, i8* %var2192, i8* %var2193)
%val2195 = load i8*, i8** %xx_t_mst_s_25Ptr
%res2196 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2195)
%res2197 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2187, %String* %res2196)

; let value assignment
%res7 = select i1 true, %String* %res2197, %String* %res2197
store %String* %res7, %String** %res7Ptr

%oldzone2200 = call %mzone* @llvm_pop_zone_stack()
%newzone2201 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2202 = bitcast %mzone* %newzone2201 to i8*
store i8* %zone_ptr2202, i8** %_impzPtr

; let value assignment
%zone7 = select i1 true, %mzone* %oldzone2200, %mzone* %oldzone2200
store %mzone* %zone7, %mzone** %zone7Ptr

%res2205 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz7 = select i1 true, %mzone* %res2205, %mzone* %res2205
store %mzone* %newz7, %mzone** %newz7Ptr

%tzone2212 = load i8*, i8** %_impzPtr
%zone2213 = bitcast i8* %tzone2212 to %mzone*

; let assign value to symbol rescopy7
%rescopy7Ptr = alloca %String*
%tzone2218 = load i8*, i8** %_impzPtr
%zone2219 = bitcast i8* %tzone2218 to %mzone*

; let assign value to symbol hook_s_26
%hook_s_26Ptr = alloca {i64,i8*,i8*}*
%tzone2221 = load i8*, i8** %_impzPtr
%zone2222 = bitcast i8* %tzone2221 to %mzone*

; let assign value to symbol f_s_27
%f_s_27Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val2208 = load %String*, %String** %res7Ptr
%val2209 = load %mzone*, %mzone** %zone7Ptr
%val2210 = load %mzone*, %mzone** %newz7Ptr
%res2211 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val2208, %mzone* %val2209, %mzone* %val2210)

; let value assignment
%rescopy7 = select i1 true, %String* %res2211, %String* %res2211
store %String* %rescopy7, %String** %rescopy7Ptr

%val2214 = load %mzone*, %mzone** %zone7Ptr
; tuple ref
%val2215 = getelementptr %mzone, %mzone* %val2214, i64 0, i32 4
%val2216 = load i8*, i8** %val2215
%val2217 = bitcast i8* %val2216 to {i64,i8*,i8*}*

; let value assignment
%hook_s_26 = select i1 true, {i64,i8*,i8*}* %val2217, {i64,i8*,i8*}* %val2217
store {i64,i8*,i8*}* %hook_s_26, {i64,i8*,i8*}** %hook_s_26Ptr

%null2220 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_27 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null2220, {i8*, i8*, void (i8*, i8*)*}** %null2220
store {i8*, i8*, void (i8*, i8*)*}** %f_s_27, {i8*, i8*, void (i8*, i8*)*}*** %f_s_27Ptr

; promote local stack var allocations
%tzone2258 = load i8*, i8** %_impzPtr
%zone2259 = bitcast i8* %tzone2258 to %mzone*
%ifptr2248 = alloca i1
%ifptr2224 = alloca i1
; while loop
%val2225 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_26Ptr
%val2226 = icmp eq {i64,i8*,i8*}* %val2225, null
br i1 %val2226, label %then2224, label %else2224

then2224:
%res2227 = call ccc i1 @impc_false()
store i1 %res2227, i1* %ifptr2224
br label %ifcont2224

else2224:
%res2228 = call ccc i1 @impc_true()
store i1 %res2228, i1* %ifptr2224
br label %ifcont2224

ifcont2224:
%ifres2229 = load i1, i1* %ifptr2224

br i1 %ifres2229, label %loop2223, label %after2223

loop2223:
; do set!
%val2230 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_26Ptr
; tuple ref
%val2231 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2230, i64 0, i32 1
%val2232 = load i8*, i8** %val2231
%val2233 = bitcast i8* %val2232 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val2233, {i8*, i8*, void (i8*, i8*)*}*** %f_s_27Ptr

; apply closure 
%vval2234 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_27Ptr
%val2235 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval2234
%fPtr2236 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2235, i32 0, i32 2
%ePtr2237 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2235, i32 0, i32 1
%f2238 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr2236
%e2239 = load i8*, i8** %ePtr2237
%tzone2240 = load i8*, i8** %_impzPtr
%zone2241 = bitcast i8* %tzone2240 to %mzone*
%z2242 = bitcast %mzone* %zone2241 to i8*
tail call fastcc void %f2238(i8* %z2242, i8* %e2239)
; do set!
%val2244 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_26Ptr
; tuple ref
%val2245 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2244, i64 0, i32 2
%val2246 = load i8*, i8** %val2245
%val2247 = bitcast i8* %val2246 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val2247, {i64,i8*,i8*}** %hook_s_26Ptr
%val2249 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_26Ptr
%val2250 = icmp eq {i64,i8*,i8*}* %val2249, null
br i1 %val2250, label %then2248, label %else2248

then2248:
%res2251 = call ccc i1 @impc_false()
store i1 %res2251, i1* %ifptr2248
br label %ifcont2248

else2248:
%res2252 = call ccc i1 @impc_true()
store i1 %res2252, i1* %ifptr2248
br label %ifcont2248

ifcont2248:
%ifres2253 = load i1, i1* %ifptr2248

br i1 %ifres2253, label %loop2223, label %after2223

after2223:
%val2255 = load %mzone*, %mzone** %zone7Ptr
call ccc void @llvm_zone_destroy(%mzone* %val2255)
%val2257 = load %String*, %String** %rescopy7Ptr
ret %String* %val2257
}
@gsxtmsndfile92 = hidden constant [108 x i8] c"toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2279 = load i8*, i8** %_impzPtr
%zone2280 = bitcast i8* %tzone2279 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0
%dat_toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2280, i64 8)
%toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0 to { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***
%tzone2260 = load i8*, i8** %_impzPtr
%zone2261 = bitcast i8* %tzone2260 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2261)
; malloc closure structure
%clsptr2262 = call i8* @llvm_zone_malloc(%mzone* %zone2261, i64 24)
%closure2263 = bitcast i8* %clsptr2262 to { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*

; malloc environment structure
%envptr2264 = call i8* @llvm_zone_malloc(%mzone* %zone2261, i64 8)
%environment2265 = bitcast i8* %envptr2264 to {{i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}*

; malloc closure address table
%addytable2266 = call %clsvar* @new_address_table()
%var2267 = bitcast [55 x i8]* @gsxtmsndfile90 to i8*
%var2268 = bitcast [57 x i8]* @gsxtmsndfile91 to i8*
%addytable2269 = call %clsvar* @add_address_table(%mzone* %zone2261, i8* %var2267, i32 0, i8* %var2268, i32 3, %clsvar* %addytable2266)
%address-table2270 = bitcast %clsvar* %addytable2269 to i8*

; insert table, function and environment into closure struct
%closure.table2273 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2263, i32 0, i32 0
store i8* %address-table2270, i8** %closure.table2273
%closure.env2274 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2263, i32 0, i32 1
store i8* %envptr2264, i8** %closure.env2274
%closure.func2275 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2263, i32 0, i32 2
store %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)* @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0__2079, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)** %closure.func2275
%closure_size2276 = call i64 @llvm_zone_mark_size(%mzone* %zone2261)
call void @llvm_zone_ptr_set_size(i8* %clsptr2262, i64 %closure_size2276)
%wrapper_ptr2277 = call i8* @llvm_zone_malloc(%mzone* %zone2261, i64 8)
%closure_wrapper2278 = bitcast i8* %wrapper_ptr2277 to { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
store { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2263, { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_wrapper2278

; let value assignment
%toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_wrapper2278, { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_wrapper2278
store { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0, { i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0
%tmp_envptr2272 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}* %environment2265, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**** %tmp_envptr2272


%val2281 = load {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %val2281
}


@toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0(%SF_EMBED_FILE_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_native(%SF_EMBED_FILE_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2282 = bitcast [108 x i8]* @gsxtmsndfile92 to i8*
call i32 (i8*, ...) @printf(i8* %var2282)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_EMBED_FILE_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_EMBED_FILE_INFO*}*
%arg_p_0 = getelementptr {%SF_EMBED_FILE_INFO*}, {%SF_EMBED_FILE_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  %String* (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile93 = hidden constant [48 x i8] c"print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0\00"
@gsxtmsndfile94 = hidden constant [53 x i8] c"{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0__2283(i8* %_impz,i8* %_impenv, %SF_EMBED_FILE_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2284 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}*
%print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**** %print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr_

; setup arguments
%xPtr = alloca %SF_EMBED_FILE_INFO*
store %SF_EMBED_FILE_INFO* %x, %SF_EMBED_FILE_INFO** %xPtr


%val2286 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
%val2287 = icmp eq %SF_EMBED_FILE_INFO* %val2286, null
br i1 %val2287, label %then2285, label %else2285

then2285:
%var2288 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2289 = bitcast [26 x i8]* @gsxtmsndfile88 to i8*

%val2290 = call i32 (i8*, ...) @printf(i8* %var2288, i8* %var2289)
br label %ifcont2285

else2285:
%var2292 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2293 = bitcast [21 x i8]* @gsxtmsndfile89 to i8*

%val2294 = call i32 (i8*, ...) @printf(i8* %var2292, i8* %var2293)
%val2295 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
; tuple ref
%val2296 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2295, i64 0, i32 0
%val2297 = load i64, i64* %val2296
call fastcc void @print_adhoc_W3ZvaWQsaTY0XQ(i64 %val2297)
%var2299 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2300 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val2301 = call i32 (i8*, ...) @printf(i8* %var2299, i8* %var2300)
%val2302 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
; tuple ref
%val2303 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2302, i64 0, i32 1
%val2304 = load i64, i64* %val2303
call fastcc void @print_adhoc_W3ZvaWQsaTY0XQ(i64 %val2304)
%var2306 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2307 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val2308 = call i32 (i8*, ...) @printf(i8* %var2306, i8* %var2307)
br label %ifcont2285

ifcont2285:
ret void
}
@gsxtmsndfile95 = hidden constant [101 x i8] c"print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2330 = load i8*, i8** %_impzPtr
%zone2331 = bitcast i8* %tzone2330 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0
%dat_print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2331, i64 8)
%print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0 to { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***
%tzone2311 = load i8*, i8** %_impzPtr
%zone2312 = bitcast i8* %tzone2311 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2312)
; malloc closure structure
%clsptr2313 = call i8* @llvm_zone_malloc(%mzone* %zone2312, i64 24)
%closure2314 = bitcast i8* %clsptr2313 to { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*

; malloc environment structure
%envptr2315 = call i8* @llvm_zone_malloc(%mzone* %zone2312, i64 8)
%environment2316 = bitcast i8* %envptr2315 to {{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}*

; malloc closure address table
%addytable2317 = call %clsvar* @new_address_table()
%var2318 = bitcast [48 x i8]* @gsxtmsndfile93 to i8*
%var2319 = bitcast [53 x i8]* @gsxtmsndfile94 to i8*
%addytable2320 = call %clsvar* @add_address_table(%mzone* %zone2312, i8* %var2318, i32 0, i8* %var2319, i32 3, %clsvar* %addytable2317)
%address-table2321 = bitcast %clsvar* %addytable2320 to i8*

; insert table, function and environment into closure struct
%closure.table2324 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2314, i32 0, i32 0
store i8* %address-table2321, i8** %closure.table2324
%closure.env2325 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2314, i32 0, i32 1
store i8* %envptr2315, i8** %closure.env2325
%closure.func2326 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2314, i32 0, i32 2
store void (i8*, i8*, %SF_EMBED_FILE_INFO*)* @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0__2283, void (i8*, i8*, %SF_EMBED_FILE_INFO*)** %closure.func2326
%closure_size2327 = call i64 @llvm_zone_mark_size(%mzone* %zone2312)
call void @llvm_zone_ptr_set_size(i8* %clsptr2313, i64 %closure_size2327)
%wrapper_ptr2328 = call i8* @llvm_zone_malloc(%mzone* %zone2312, i64 8)
%closure_wrapper2329 = bitcast i8* %wrapper_ptr2328 to { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
store { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2314, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_wrapper2329

; let value assignment
%print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_wrapper2329, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_wrapper2329
store { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0
%tmp_envptr2323 = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}* %environment2316, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**** %tmp_envptr2323


%val2332 = load {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %val2332
}


@print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0(%SF_EMBED_FILE_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  void (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_native(%SF_EMBED_FILE_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  void (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2333 = bitcast [101 x i8]* @gsxtmsndfile95 to i8*
call i32 (i8*, ...) @printf(i8* %var2333)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_EMBED_FILE_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  void (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_EMBED_FILE_INFO*}*
%arg_p_0 = getelementptr {%SF_EMBED_FILE_INFO*}, {%SF_EMBED_FILE_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  void (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile96 = hidden constant [68 x i8] c"SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ\00"
@gsxtmsndfile97 = hidden constant [56 x i8] c"{i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}**\00"
define dllexport fastcc %SF_EMBED_FILE_INFO @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ__2334(i8* %_impz,i8* %_impenv, i64 %arg_0, i64 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2335 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}***}*
%SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQPtr = load {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}***, {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}**** %SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQPtr_

; setup arguments
%arg_0Ptr = alloca i64
store i64 %arg_0, i64* %arg_0Ptr
%arg_1Ptr = alloca i64
store i64 %arg_1, i64* %arg_1Ptr


%tzone2337 = load i8*, i8** %_impzPtr
%zone2338 = bitcast i8* %tzone2337 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_EMBED_FILE_INFO*
%dat2336 = alloca %SF_EMBED_FILE_INFO, align 16

; let value assignment
%obj = select i1 true, %SF_EMBED_FILE_INFO* %dat2336, %SF_EMBED_FILE_INFO* %dat2336
store %SF_EMBED_FILE_INFO* %obj, %SF_EMBED_FILE_INFO** %objPtr

%val2339 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
%val2340 = load i64, i64* %arg_0Ptr
; set tuple
%val2341 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2339, i64 0, i32 0
store i64 %val2340, i64* %val2341
%val2342 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
%val2343 = load i64, i64* %arg_1Ptr
; set tuple
%val2344 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2342, i64 0, i32 1
store i64 %val2343, i64* %val2344
%val2345 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
; pointer ref
%val2346 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2345, i64 0
%val2347 = load %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2346
ret %SF_EMBED_FILE_INFO %val2347
}
@gsxtmsndfile98 = hidden constant [121 x i8] c"SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}** @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2367 = load i8*, i8** %_impzPtr
%zone2368 = bitcast i8* %tzone2367 to %mzone*

; let assign value to symbol SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ
%dat_SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone2368, i64 8)
%SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQPtr = bitcast i8* %dat_SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ to { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}***
%tzone2348 = load i8*, i8** %_impzPtr
%zone2349 = bitcast i8* %tzone2348 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2349)
; malloc closure structure
%clsptr2350 = call i8* @llvm_zone_malloc(%mzone* %zone2349, i64 24)
%closure2351 = bitcast i8* %clsptr2350 to { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr2352 = call i8* @llvm_zone_malloc(%mzone* %zone2349, i64 8)
%environment2353 = bitcast i8* %envptr2352 to {{i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable2354 = call %clsvar* @new_address_table()
%var2355 = bitcast [68 x i8]* @gsxtmsndfile96 to i8*
%var2356 = bitcast [56 x i8]* @gsxtmsndfile97 to i8*
%addytable2357 = call %clsvar* @add_address_table(%mzone* %zone2349, i8* %var2355, i32 0, i8* %var2356, i32 3, %clsvar* %addytable2354)
%address-table2358 = bitcast %clsvar* %addytable2357 to i8*

; insert table, function and environment into closure struct
%closure.table2361 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}, { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}* %closure2351, i32 0, i32 0
store i8* %address-table2358, i8** %closure.table2361
%closure.env2362 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}, { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}* %closure2351, i32 0, i32 1
store i8* %envptr2352, i8** %closure.env2362
%closure.func2363 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}, { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}* %closure2351, i32 0, i32 2
store %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)* @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ__2334, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)** %closure.func2363
%closure_size2364 = call i64 @llvm_zone_mark_size(%mzone* %zone2349)
call void @llvm_zone_ptr_set_size(i8* %clsptr2350, i64 %closure_size2364)
%wrapper_ptr2365 = call i8* @llvm_zone_malloc(%mzone* %zone2349, i64 8)
%closure_wrapper2366 = bitcast i8* %wrapper_ptr2365 to { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}**
store { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}* %closure2351, { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}** %closure_wrapper2366

; let value assignment
%SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ = select i1 true, { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}** %closure_wrapper2366, { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}** %closure_wrapper2366
store { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}** %SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ, { i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}*** %SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ
%tmp_envptr2360 = getelementptr {{i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}***}* %environment2353, i32 0, i32 0
store {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}*** %SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQPtr, {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}**** %tmp_envptr2360


%val2369 = load {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}**, {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}*** %SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQPtr
ret {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}** %val2369
}


@SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}** @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_EMBED_FILE_INFO @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %SF_EMBED_FILE_INFO %result
}


define dllexport ccc %SF_EMBED_FILE_INFO @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_native(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %SF_EMBED_FILE_INFO %result
}


define dllexport ccc void @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64}*
%arg_p_0 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_EMBED_FILE_INFO_val_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}, {i8*, i8*, %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)*,  %SF_EMBED_FILE_INFO (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile99 = hidden constant [68 x i8] c"hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0\00"
@gsxtmsndfile100 = hidden constant [69 x i8] c"{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**\00"
define dllexport fastcc %SF_EMBED_FILE_INFO* @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0__2372(i8* %_impz,i8* %_impenv, %SF_EMBED_FILE_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2373 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}*
%hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}, {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**** %hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr_

; setup arguments
%xPtr = alloca %SF_EMBED_FILE_INFO*
store %SF_EMBED_FILE_INFO* %x, %SF_EMBED_FILE_INFO** %xPtr


%tzone2376 = load i8*, i8** %_impzPtr
%zone2377 = bitcast i8* %tzone2376 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_EMBED_FILE_INFO*
%dat2374 = call i8* @malloc(i64 16)
call i8* @memset(i8* %dat2374, i32 0, i64 16)
%val2375 = bitcast i8* %dat2374 to %SF_EMBED_FILE_INFO*

; let value assignment
%obj = select i1 true, %SF_EMBED_FILE_INFO* %val2375, %SF_EMBED_FILE_INFO* %val2375
store %SF_EMBED_FILE_INFO* %obj, %SF_EMBED_FILE_INFO** %objPtr

%val2378 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
%val2379 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
; tuple ref
%val2380 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2379, i64 0, i32 0
%val2381 = load i64, i64* %val2380
; set tuple
%val2382 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2378, i64 0, i32 0
store i64 %val2381, i64* %val2382
%val2383 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
%val2384 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
; tuple ref
%val2385 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2384, i64 0, i32 1
%val2386 = load i64, i64* %val2385
; set tuple
%val2387 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2383, i64 0, i32 1
store i64 %val2386, i64* %val2387
%val2388 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
ret %SF_EMBED_FILE_INFO* %val2388
}
@gsxtmsndfile101 = hidden constant [121 x i8] c"hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2408 = load i8*, i8** %_impzPtr
%zone2409 = bitcast i8* %tzone2408 to %mzone*

; let assign value to symbol hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0
%dat_hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2409, i64 8)
%hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***
%tzone2389 = load i8*, i8** %_impzPtr
%zone2390 = bitcast i8* %tzone2389 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2390)
; malloc closure structure
%clsptr2391 = call i8* @llvm_zone_malloc(%mzone* %zone2390, i64 24)
%closure2392 = bitcast i8* %clsptr2391 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*

; malloc environment structure
%envptr2393 = call i8* @llvm_zone_malloc(%mzone* %zone2390, i64 8)
%environment2394 = bitcast i8* %envptr2393 to {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}*

; malloc closure address table
%addytable2395 = call %clsvar* @new_address_table()
%var2396 = bitcast [68 x i8]* @gsxtmsndfile99 to i8*
%var2397 = bitcast [69 x i8]* @gsxtmsndfile100 to i8*
%addytable2398 = call %clsvar* @add_address_table(%mzone* %zone2390, i8* %var2396, i32 0, i8* %var2397, i32 3, %clsvar* %addytable2395)
%address-table2399 = bitcast %clsvar* %addytable2398 to i8*

; insert table, function and environment into closure struct
%closure.table2402 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2392, i32 0, i32 0
store i8* %address-table2399, i8** %closure.table2402
%closure.env2403 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2392, i32 0, i32 1
store i8* %envptr2393, i8** %closure.env2403
%closure.func2404 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2392, i32 0, i32 2
store %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)* @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0__2372, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)** %closure.func2404
%closure_size2405 = call i64 @llvm_zone_mark_size(%mzone* %zone2390)
call void @llvm_zone_ptr_set_size(i8* %clsptr2391, i64 %closure_size2405)
%wrapper_ptr2406 = call i8* @llvm_zone_malloc(%mzone* %zone2390, i64 8)
%closure_wrapper2407 = bitcast i8* %wrapper_ptr2406 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
store { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2392, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_wrapper2407

; let value assignment
%hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0 = select i1 true, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_wrapper2407, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_wrapper2407
store { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*** %hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0
%tmp_envptr2401 = getelementptr {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}, {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}* %environment2394, i32 0, i32 0
store {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*** %hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**** %tmp_envptr2401


%val2410 = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*** %hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr
ret {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %val2410
}


@hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_EMBED_FILE_INFO* @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0(%SF_EMBED_FILE_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
ret %SF_EMBED_FILE_INFO* %result
}


define dllexport ccc %SF_EMBED_FILE_INFO* @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_native(%SF_EMBED_FILE_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
ret %SF_EMBED_FILE_INFO* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2411 = bitcast [121 x i8]* @gsxtmsndfile101 to i8*
call i32 (i8*, ...) @printf(i8* %var2411)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_EMBED_FILE_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
%tmpres = bitcast %SF_EMBED_FILE_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_EMBED_FILE_INFO*}*
%arg_p_0 = getelementptr {%SF_EMBED_FILE_INFO*}, {%SF_EMBED_FILE_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile102 = hidden constant [48 x i8] c"hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0__2412(i8* %_impz,i8* %_impenv, %SF_EMBED_FILE_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2413 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}*
%hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**** %hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr_

; setup arguments
%xPtr = alloca %SF_EMBED_FILE_INFO*
store %SF_EMBED_FILE_INFO* %x, %SF_EMBED_FILE_INFO** %xPtr


%val2414 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
%val2415 = bitcast %SF_EMBED_FILE_INFO* %val2414 to i8*
call ccc void @free(i8* %val2415)
ret void
}
@gsxtmsndfile103 = hidden constant [101 x i8] c"hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2437 = load i8*, i8** %_impzPtr
%zone2438 = bitcast i8* %tzone2437 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0
%dat_hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2438, i64 8)
%hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0 to { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***
%tzone2418 = load i8*, i8** %_impzPtr
%zone2419 = bitcast i8* %tzone2418 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2419)
; malloc closure structure
%clsptr2420 = call i8* @llvm_zone_malloc(%mzone* %zone2419, i64 24)
%closure2421 = bitcast i8* %clsptr2420 to { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*

; malloc environment structure
%envptr2422 = call i8* @llvm_zone_malloc(%mzone* %zone2419, i64 8)
%environment2423 = bitcast i8* %envptr2422 to {{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}*

; malloc closure address table
%addytable2424 = call %clsvar* @new_address_table()
%var2425 = bitcast [48 x i8]* @gsxtmsndfile102 to i8*
%var2426 = bitcast [53 x i8]* @gsxtmsndfile94 to i8*
%addytable2427 = call %clsvar* @add_address_table(%mzone* %zone2419, i8* %var2425, i32 0, i8* %var2426, i32 3, %clsvar* %addytable2424)
%address-table2428 = bitcast %clsvar* %addytable2427 to i8*

; insert table, function and environment into closure struct
%closure.table2431 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2421, i32 0, i32 0
store i8* %address-table2428, i8** %closure.table2431
%closure.env2432 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2421, i32 0, i32 1
store i8* %envptr2422, i8** %closure.env2432
%closure.func2433 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2421, i32 0, i32 2
store void (i8*, i8*, %SF_EMBED_FILE_INFO*)* @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0__2412, void (i8*, i8*, %SF_EMBED_FILE_INFO*)** %closure.func2433
%closure_size2434 = call i64 @llvm_zone_mark_size(%mzone* %zone2419)
call void @llvm_zone_ptr_set_size(i8* %clsptr2420, i64 %closure_size2434)
%wrapper_ptr2435 = call i8* @llvm_zone_malloc(%mzone* %zone2419, i64 8)
%closure_wrapper2436 = bitcast i8* %wrapper_ptr2435 to { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
store { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure2421, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_wrapper2436

; let value assignment
%hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_wrapper2436, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_wrapper2436
store { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0, { i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0
%tmp_envptr2430 = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}***}* %environment2423, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**** %tmp_envptr2430


%val2439 = load {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %val2439
}


@hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0(%SF_EMBED_FILE_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  void (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_native(%SF_EMBED_FILE_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  void (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2440 = bitcast [101 x i8]* @gsxtmsndfile103 to i8*
call i32 (i8*, ...) @printf(i8* %var2440)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_EMBED_FILE_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  void (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_EMBED_FILE_INFO*}*
%arg_p_0 = getelementptr {%SF_EMBED_FILE_INFO*}, {%SF_EMBED_FILE_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfRU1CRURfRklMRV9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_EMBED_FILE_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_EMBED_FILE_INFO*)*,  void (i8*, i8*, %SF_EMBED_FILE_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile104 = hidden constant [87 x i8] c"zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmsndfile105 = hidden constant [87 x i8] c"{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %SF_EMBED_FILE_INFO* @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ__2441(i8* %_impz,i8* %_impenv, %SF_EMBED_FILE_INFO* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2442 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}***, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %SF_EMBED_FILE_INFO*
store %SF_EMBED_FILE_INFO* %x, %SF_EMBED_FILE_INFO** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val2444 = load %mzone*, %mzone** %fromzPtr
%val2445 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
%val2446 = bitcast %SF_EMBED_FILE_INFO* %val2445 to i8*
%res2447 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val2444, i8* %val2446)
br i1 %res2447, label %then2443, label %else2443

then2443:
%val2448 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val2448)
%zone_ptr2449 = bitcast %mzone* %val2448 to i8*
store i8* %zone_ptr2449, i8** %_impzPtr
%tzone2455 = load i8*, i8** %_impzPtr
%zone2456 = bitcast i8* %tzone2455 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_EMBED_FILE_INFO*
%tzone2451 = load i8*, i8** %_impzPtr
%zone2452 = bitcast i8* %tzone2451 to %mzone*
%dat2453 = call i8* @llvm_zone_malloc(%mzone* %zone2452, i64 16)
call i8* @memset(i8* %dat2453, i32 0, i64 16)
%val2454 = bitcast i8* %dat2453 to %SF_EMBED_FILE_INFO*

; let value assignment
%obj = select i1 true, %SF_EMBED_FILE_INFO* %val2454, %SF_EMBED_FILE_INFO* %val2454
store %SF_EMBED_FILE_INFO* %obj, %SF_EMBED_FILE_INFO** %objPtr

%val2457 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
%val2458 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
; tuple ref
%val2459 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2458, i64 0, i32 0
%val2460 = load i64, i64* %val2459
; set tuple
%val2461 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2457, i64 0, i32 0
store i64 %val2460, i64* %val2461
%val2462 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
%val2463 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
; tuple ref
%val2464 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2463, i64 0, i32 1
%val2465 = load i64, i64* %val2464
; set tuple
%val2466 = getelementptr %SF_EMBED_FILE_INFO, %SF_EMBED_FILE_INFO* %val2462, i64 0, i32 1
store i64 %val2465, i64* %val2466
%oldzone2467 = call %mzone* @llvm_pop_zone_stack()
%newzone2468 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2469 = bitcast %mzone* %newzone2468 to i8*
store i8* %zone_ptr2469, i8** %_impzPtr
%val2470 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %objPtr
ret %SF_EMBED_FILE_INFO* %val2470

else2443:
%val2471 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %xPtr
ret %SF_EMBED_FILE_INFO* %val2471
}
@gsxtmsndfile106 = hidden constant [140 x i8] c"zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2491 = load i8*, i8** %_impzPtr
%zone2492 = bitcast i8* %tzone2491 to %mzone*

; let assign value to symbol zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2492, i64 8)
%zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}***
%tzone2472 = load i8*, i8** %_impzPtr
%zone2473 = bitcast i8* %tzone2472 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2473)
; malloc closure structure
%clsptr2474 = call i8* @llvm_zone_malloc(%mzone* %zone2473, i64 24)
%closure2475 = bitcast i8* %clsptr2474 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr2476 = call i8* @llvm_zone_malloc(%mzone* %zone2473, i64 8)
%environment2477 = bitcast i8* %envptr2476 to {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable2478 = call %clsvar* @new_address_table()
%var2479 = bitcast [87 x i8]* @gsxtmsndfile104 to i8*
%var2480 = bitcast [87 x i8]* @gsxtmsndfile105 to i8*
%addytable2481 = call %clsvar* @add_address_table(%mzone* %zone2473, i8* %var2479, i32 0, i8* %var2480, i32 3, %clsvar* %addytable2478)
%address-table2482 = bitcast %clsvar* %addytable2481 to i8*

; insert table, function and environment into closure struct
%closure.table2485 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}* %closure2475, i32 0, i32 0
store i8* %address-table2482, i8** %closure.table2485
%closure.env2486 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}* %closure2475, i32 0, i32 1
store i8* %envptr2476, i8** %closure.env2486
%closure.func2487 = getelementptr { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}* %closure2475, i32 0, i32 2
store %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)* @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ__2441, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)** %closure.func2487
%closure_size2488 = call i64 @llvm_zone_mark_size(%mzone* %zone2473)
call void @llvm_zone_ptr_set_size(i8* %clsptr2474, i64 %closure_size2488)
%wrapper_ptr2489 = call i8* @llvm_zone_malloc(%mzone* %zone2473, i64 8)
%closure_wrapper2490 = bitcast i8* %wrapper_ptr2489 to { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}**
store { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}* %closure2475, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}** %closure_wrapper2490

; let value assignment
%zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}** %closure_wrapper2490, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}** %closure_wrapper2490
store { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ
%tmp_envptr2484 = getelementptr {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}***}* %environment2477, i32 0, i32 0
store {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}**** %tmp_envptr2484


%val2493 = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}**, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}** %val2493
}


@zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_EMBED_FILE_INFO* @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ(%SF_EMBED_FILE_INFO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %SF_EMBED_FILE_INFO* %result
}


define dllexport ccc %SF_EMBED_FILE_INFO* @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_native(%SF_EMBED_FILE_INFO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %SF_EMBED_FILE_INFO* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2494 = bitcast [140 x i8]* @gsxtmsndfile106 to i8*
call i32 (i8*, ...) @printf(i8* %var2494)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_EMBED_FILE_INFO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2495 = bitcast [140 x i8]* @gsxtmsndfile106 to i8*
call i32 (i8*, ...) @printf(i8* %var2495)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2496 = bitcast [140 x i8]* @gsxtmsndfile106 to i8*
call i32 (i8*, ...) @printf(i8* %var2496)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %SF_EMBED_FILE_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_EMBED_FILE_INFO*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%SF_EMBED_FILE_INFO*, %mzone*, %mzone*}, {%SF_EMBED_FILE_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_EMBED_FILE_INFO*, %SF_EMBED_FILE_INFO** %arg_p_0
%arg_p_1 = getelementptr {%SF_EMBED_FILE_INFO*, %mzone*, %mzone*}, {%SF_EMBED_FILE_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%SF_EMBED_FILE_INFO*, %mzone*, %mzone*}, {%SF_EMBED_FILE_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0VNQkVEX0ZJTEVfSU5GTyosU0ZfRU1CRURfRklMRV9JTkZPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)*,  %SF_EMBED_FILE_INFO* (i8*, i8*, %SF_EMBED_FILE_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_EMBED_FILE_INFO* %ff(i8* %_impz, i8* %ee, %SF_EMBED_FILE_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@SF_LOOP_NONE = dllexport global i32 800
@SF_LOOP_FORWARD = dllexport global i32 801
@SF_LOOP_BACKWARD = dllexport global i32 802
@SF_LOOP_ALTERNATING = dllexport global i32 803
%SF_INSTRUMENT = type {i32,i8,i8,i8,i8,i8,i8,i32,[16 x {i32,i32,i32,i32}]}
@gsxtmsndfile107 = hidden constant [108 x i8] c"SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0\00"
@gsxtmsndfile108 = hidden constant [102 x i8] c"{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**\00"
define dllexport fastcc %SF_INSTRUMENT* @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0__2497(i8* %_impz,i8* %_impenv, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2498 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}*
%SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr_ = getelementptr {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}, {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}* %impenv, i32 0, i32 0
%SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**** %SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i8
store i8 %arg_1, i8* %arg_1Ptr
%arg_2Ptr = alloca i8
store i8 %arg_2, i8* %arg_2Ptr
%arg_3Ptr = alloca i8
store i8 %arg_3, i8* %arg_3Ptr
%arg_4Ptr = alloca i8
store i8 %arg_4, i8* %arg_4Ptr
%arg_5Ptr = alloca i8
store i8 %arg_5, i8* %arg_5Ptr
%arg_6Ptr = alloca i8
store i8 %arg_6, i8* %arg_6Ptr
%arg_7Ptr = alloca i32
store i32 %arg_7, i32* %arg_7Ptr
%arg_8Ptr = alloca [16 x {i32,i32,i32,i32}]
store [16 x {i32,i32,i32,i32}] %arg_8, [16 x {i32,i32,i32,i32}]* %arg_8Ptr


%tzone2503 = load i8*, i8** %_impzPtr
%zone2504 = bitcast i8* %tzone2503 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_INSTRUMENT*
%tzone2499 = load i8*, i8** %_impzPtr
%zone2500 = bitcast i8* %tzone2499 to %mzone*
%dat2501 = call i8* @llvm_zone_malloc(%mzone* %zone2500, i64 272)
call i8* @memset(i8* %dat2501, i32 0, i64 272)
%val2502 = bitcast i8* %dat2501 to %SF_INSTRUMENT*

; let value assignment
%obj = select i1 true, %SF_INSTRUMENT* %val2502, %SF_INSTRUMENT* %val2502
store %SF_INSTRUMENT* %obj, %SF_INSTRUMENT** %objPtr

%val2505 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2506 = load i32, i32* %arg_0Ptr
; set tuple
%val2507 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2505, i64 0, i32 0
store i32 %val2506, i32* %val2507
%val2508 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2509 = load i8, i8* %arg_1Ptr
; set tuple
%val2510 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2508, i64 0, i32 1
store i8 %val2509, i8* %val2510
%val2511 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2512 = load i8, i8* %arg_2Ptr
; set tuple
%val2513 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2511, i64 0, i32 2
store i8 %val2512, i8* %val2513
%val2514 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2515 = load i8, i8* %arg_3Ptr
; set tuple
%val2516 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2514, i64 0, i32 3
store i8 %val2515, i8* %val2516
%val2517 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2518 = load i8, i8* %arg_4Ptr
; set tuple
%val2519 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2517, i64 0, i32 4
store i8 %val2518, i8* %val2519
%val2520 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2521 = load i8, i8* %arg_5Ptr
; set tuple
%val2522 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2520, i64 0, i32 5
store i8 %val2521, i8* %val2522
%val2523 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2524 = load i8, i8* %arg_6Ptr
; set tuple
%val2525 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2523, i64 0, i32 6
store i8 %val2524, i8* %val2525
%val2526 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2527 = load i32, i32* %arg_7Ptr
; set tuple
%val2528 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2526, i64 0, i32 7
store i32 %val2527, i32* %val2528
%val2529 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2530 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %arg_8Ptr
; set tuple
%val2531 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2529, i64 0, i32 8
store [16 x {i32,i32,i32,i32}] %val2530, [16 x {i32,i32,i32,i32}]* %val2531
%val2532 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
ret %SF_INSTRUMENT* %val2532
}
@gsxtmsndfile109 = hidden constant [161 x i8] c"SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2552 = load i8*, i8** %_impzPtr
%zone2553 = bitcast i8* %tzone2552 to %mzone*

; let assign value to symbol SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0
%dat_SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0 = call i8* @llvm_zone_malloc(%mzone* %zone2553, i64 8)
%SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr = bitcast i8* %dat_SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***
%tzone2533 = load i8*, i8** %_impzPtr
%zone2534 = bitcast i8* %tzone2533 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2534)
; malloc closure structure
%clsptr2535 = call i8* @llvm_zone_malloc(%mzone* %zone2534, i64 24)
%closure2536 = bitcast i8* %clsptr2535 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*

; malloc environment structure
%envptr2537 = call i8* @llvm_zone_malloc(%mzone* %zone2534, i64 8)
%environment2538 = bitcast i8* %envptr2537 to {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}*

; malloc closure address table
%addytable2539 = call %clsvar* @new_address_table()
%var2540 = bitcast [108 x i8]* @gsxtmsndfile107 to i8*
%var2541 = bitcast [102 x i8]* @gsxtmsndfile108 to i8*
%addytable2542 = call %clsvar* @add_address_table(%mzone* %zone2534, i8* %var2540, i32 0, i8* %var2541, i32 3, %clsvar* %addytable2539)
%address-table2543 = bitcast %clsvar* %addytable2542 to i8*

; insert table, function and environment into closure struct
%closure.table2546 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure2536, i32 0, i32 0
store i8* %address-table2543, i8** %closure.table2546
%closure.env2547 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure2536, i32 0, i32 1
store i8* %envptr2537, i8** %closure.env2547
%closure.func2548 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure2536, i32 0, i32 2
store %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])* @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0__2497, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %closure.func2548
%closure_size2549 = call i64 @llvm_zone_mark_size(%mzone* %zone2534)
call void @llvm_zone_ptr_set_size(i8* %clsptr2535, i64 %closure_size2549)
%wrapper_ptr2550 = call i8* @llvm_zone_malloc(%mzone* %zone2534, i64 8)
%closure_wrapper2551 = bitcast i8* %wrapper_ptr2550 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
store { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure2536, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper2551

; let value assignment
%SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0 = select i1 true, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper2551, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper2551
store { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*** %SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr

; add data to environment
; don't need to alloc for env var SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0
%tmp_envptr2545 = getelementptr {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}, {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}* %environment2538, i32 0, i32 0
store {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*** %SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**** %tmp_envptr2545


%val2554 = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*** %SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr
ret {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %val2554
}


@SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var = dllexport global [1 x i8*] [ i8* null ]

@SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_INSTRUMENT* @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0(i32 %arg_0,i8 %arg_1,i8 %arg_2,i8 %arg_3,i8 %arg_4,i8 %arg_5,i8 %arg_6,i32 %arg_7,[16 x {i32,i32,i32,i32}] %arg_8) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*,  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8)
ret %SF_INSTRUMENT* %result
}


define dllexport ccc %SF_INSTRUMENT* @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_native(i32 %arg_0,i8 %arg_1,i8 %arg_2,i8 %arg_3,i8 %arg_4,i8 %arg_5,i8 %arg_6,i32 %arg_7,[16 x {i32,i32,i32,i32}] %arg_8) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*,  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8)
ret %SF_INSTRUMENT* %result
}


define dllexport ccc void @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}*
%arg_p_0 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
%arg_p_2 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 2
%arg_2 = load i8, i8* %arg_p_2
%arg_p_3 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 3
%arg_3 = load i8, i8* %arg_p_3
%arg_p_4 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 4
%arg_4 = load i8, i8* %arg_p_4
%arg_p_5 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 5
%arg_5 = load i8, i8* %arg_p_5
%arg_p_6 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 6
%arg_6 = load i8, i8* %arg_p_6
%arg_p_7 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 7
%arg_7 = load i32, i32* %arg_p_7
%arg_p_8 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 8
%arg_8 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %arg_p_8
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*,  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile110 = hidden constant [110 x i8] c"SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0\00"
define dllexport fastcc %SF_INSTRUMENT* @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0__2563(i8* %_impz,i8* %_impenv, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2564 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}*
%SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr_ = getelementptr {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}, {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}* %impenv, i32 0, i32 0
%SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**** %SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i8
store i8 %arg_1, i8* %arg_1Ptr
%arg_2Ptr = alloca i8
store i8 %arg_2, i8* %arg_2Ptr
%arg_3Ptr = alloca i8
store i8 %arg_3, i8* %arg_3Ptr
%arg_4Ptr = alloca i8
store i8 %arg_4, i8* %arg_4Ptr
%arg_5Ptr = alloca i8
store i8 %arg_5, i8* %arg_5Ptr
%arg_6Ptr = alloca i8
store i8 %arg_6, i8* %arg_6Ptr
%arg_7Ptr = alloca i32
store i32 %arg_7, i32* %arg_7Ptr
%arg_8Ptr = alloca [16 x {i32,i32,i32,i32}]
store [16 x {i32,i32,i32,i32}] %arg_8, [16 x {i32,i32,i32,i32}]* %arg_8Ptr


%tzone2569 = load i8*, i8** %_impzPtr
%zone2570 = bitcast i8* %tzone2569 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_INSTRUMENT*
%tzone2565 = load i8*, i8** %_impzPtr
%zone2566 = bitcast i8* %tzone2565 to %mzone*
%dat2567 = call i8* @llvm_zone_malloc(%mzone* %zone2566, i64 272)
call i8* @memset(i8* %dat2567, i32 0, i64 272)
%val2568 = bitcast i8* %dat2567 to %SF_INSTRUMENT*

; let value assignment
%obj = select i1 true, %SF_INSTRUMENT* %val2568, %SF_INSTRUMENT* %val2568
store %SF_INSTRUMENT* %obj, %SF_INSTRUMENT** %objPtr

%val2571 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2572 = load i32, i32* %arg_0Ptr
; set tuple
%val2573 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2571, i64 0, i32 0
store i32 %val2572, i32* %val2573
%val2574 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2575 = load i8, i8* %arg_1Ptr
; set tuple
%val2576 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2574, i64 0, i32 1
store i8 %val2575, i8* %val2576
%val2577 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2578 = load i8, i8* %arg_2Ptr
; set tuple
%val2579 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2577, i64 0, i32 2
store i8 %val2578, i8* %val2579
%val2580 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2581 = load i8, i8* %arg_3Ptr
; set tuple
%val2582 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2580, i64 0, i32 3
store i8 %val2581, i8* %val2582
%val2583 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2584 = load i8, i8* %arg_4Ptr
; set tuple
%val2585 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2583, i64 0, i32 4
store i8 %val2584, i8* %val2585
%val2586 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2587 = load i8, i8* %arg_5Ptr
; set tuple
%val2588 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2586, i64 0, i32 5
store i8 %val2587, i8* %val2588
%val2589 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2590 = load i8, i8* %arg_6Ptr
; set tuple
%val2591 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2589, i64 0, i32 6
store i8 %val2590, i8* %val2591
%val2592 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2593 = load i32, i32* %arg_7Ptr
; set tuple
%val2594 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2592, i64 0, i32 7
store i32 %val2593, i32* %val2594
%val2595 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2596 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %arg_8Ptr
; set tuple
%val2597 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2595, i64 0, i32 8
store [16 x {i32,i32,i32,i32}] %val2596, [16 x {i32,i32,i32,i32}]* %val2597
%val2598 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
ret %SF_INSTRUMENT* %val2598
}
@gsxtmsndfile111 = hidden constant [163 x i8] c"SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2618 = load i8*, i8** %_impzPtr
%zone2619 = bitcast i8* %tzone2618 to %mzone*

; let assign value to symbol SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0
%dat_SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0 = call i8* @llvm_zone_malloc(%mzone* %zone2619, i64 8)
%SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr = bitcast i8* %dat_SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***
%tzone2599 = load i8*, i8** %_impzPtr
%zone2600 = bitcast i8* %tzone2599 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2600)
; malloc closure structure
%clsptr2601 = call i8* @llvm_zone_malloc(%mzone* %zone2600, i64 24)
%closure2602 = bitcast i8* %clsptr2601 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*

; malloc environment structure
%envptr2603 = call i8* @llvm_zone_malloc(%mzone* %zone2600, i64 8)
%environment2604 = bitcast i8* %envptr2603 to {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}*

; malloc closure address table
%addytable2605 = call %clsvar* @new_address_table()
%var2606 = bitcast [110 x i8]* @gsxtmsndfile110 to i8*
%var2607 = bitcast [102 x i8]* @gsxtmsndfile108 to i8*
%addytable2608 = call %clsvar* @add_address_table(%mzone* %zone2600, i8* %var2606, i32 0, i8* %var2607, i32 3, %clsvar* %addytable2605)
%address-table2609 = bitcast %clsvar* %addytable2608 to i8*

; insert table, function and environment into closure struct
%closure.table2612 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure2602, i32 0, i32 0
store i8* %address-table2609, i8** %closure.table2612
%closure.env2613 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure2602, i32 0, i32 1
store i8* %envptr2603, i8** %closure.env2613
%closure.func2614 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure2602, i32 0, i32 2
store %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])* @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0__2563, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %closure.func2614
%closure_size2615 = call i64 @llvm_zone_mark_size(%mzone* %zone2600)
call void @llvm_zone_ptr_set_size(i8* %clsptr2601, i64 %closure_size2615)
%wrapper_ptr2616 = call i8* @llvm_zone_malloc(%mzone* %zone2600, i64 8)
%closure_wrapper2617 = bitcast i8* %wrapper_ptr2616 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
store { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure2602, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper2617

; let value assignment
%SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0 = select i1 true, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper2617, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper2617
store { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*** %SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr

; add data to environment
; don't need to alloc for env var SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0
%tmp_envptr2611 = getelementptr {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}, {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}* %environment2604, i32 0, i32 0
store {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*** %SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**** %tmp_envptr2611


%val2620 = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*** %SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr
ret {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %val2620
}


@SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var = dllexport global [1 x i8*] [ i8* null ]

@SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_INSTRUMENT* @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0(i32 %arg_0,i8 %arg_1,i8 %arg_2,i8 %arg_3,i8 %arg_4,i8 %arg_5,i8 %arg_6,i32 %arg_7,[16 x {i32,i32,i32,i32}] %arg_8) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*,  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8)
ret %SF_INSTRUMENT* %result
}


define dllexport ccc %SF_INSTRUMENT* @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_native(i32 %arg_0,i8 %arg_1,i8 %arg_2,i8 %arg_3,i8 %arg_4,i8 %arg_5,i8 %arg_6,i32 %arg_7,[16 x {i32,i32,i32,i32}] %arg_8) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*,  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8)
ret %SF_INSTRUMENT* %result
}


define dllexport ccc void @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}*
%arg_p_0 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
%arg_p_2 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 2
%arg_2 = load i8, i8* %arg_p_2
%arg_p_3 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 3
%arg_3 = load i8, i8* %arg_p_3
%arg_p_4 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 4
%arg_4 = load i8, i8* %arg_p_4
%arg_p_5 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 5
%arg_5 = load i8, i8* %arg_p_5
%arg_p_6 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 6
%arg_6 = load i8, i8* %arg_p_6
%arg_p_7 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 7
%arg_7 = load i32, i32* %arg_p_7
%arg_p_8 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 8
%arg_8 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %arg_p_8
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_z_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*,  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile112 = hidden constant [110 x i8] c"SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0\00"
define dllexport fastcc %SF_INSTRUMENT* @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0__2629(i8* %_impz,i8* %_impenv, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2630 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}*
%SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr_ = getelementptr {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}, {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}* %impenv, i32 0, i32 0
%SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**** %SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i8
store i8 %arg_1, i8* %arg_1Ptr
%arg_2Ptr = alloca i8
store i8 %arg_2, i8* %arg_2Ptr
%arg_3Ptr = alloca i8
store i8 %arg_3, i8* %arg_3Ptr
%arg_4Ptr = alloca i8
store i8 %arg_4, i8* %arg_4Ptr
%arg_5Ptr = alloca i8
store i8 %arg_5, i8* %arg_5Ptr
%arg_6Ptr = alloca i8
store i8 %arg_6, i8* %arg_6Ptr
%arg_7Ptr = alloca i32
store i32 %arg_7, i32* %arg_7Ptr
%arg_8Ptr = alloca [16 x {i32,i32,i32,i32}]
store [16 x {i32,i32,i32,i32}] %arg_8, [16 x {i32,i32,i32,i32}]* %arg_8Ptr


%tzone2633 = load i8*, i8** %_impzPtr
%zone2634 = bitcast i8* %tzone2633 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_INSTRUMENT*
%dat2631 = call i8* @malloc(i64 272)
call i8* @memset(i8* %dat2631, i32 0, i64 272)
%val2632 = bitcast i8* %dat2631 to %SF_INSTRUMENT*

; let value assignment
%obj = select i1 true, %SF_INSTRUMENT* %val2632, %SF_INSTRUMENT* %val2632
store %SF_INSTRUMENT* %obj, %SF_INSTRUMENT** %objPtr

%val2635 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2636 = load i32, i32* %arg_0Ptr
; set tuple
%val2637 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2635, i64 0, i32 0
store i32 %val2636, i32* %val2637
%val2638 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2639 = load i8, i8* %arg_1Ptr
; set tuple
%val2640 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2638, i64 0, i32 1
store i8 %val2639, i8* %val2640
%val2641 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2642 = load i8, i8* %arg_2Ptr
; set tuple
%val2643 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2641, i64 0, i32 2
store i8 %val2642, i8* %val2643
%val2644 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2645 = load i8, i8* %arg_3Ptr
; set tuple
%val2646 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2644, i64 0, i32 3
store i8 %val2645, i8* %val2646
%val2647 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2648 = load i8, i8* %arg_4Ptr
; set tuple
%val2649 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2647, i64 0, i32 4
store i8 %val2648, i8* %val2649
%val2650 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2651 = load i8, i8* %arg_5Ptr
; set tuple
%val2652 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2650, i64 0, i32 5
store i8 %val2651, i8* %val2652
%val2653 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2654 = load i8, i8* %arg_6Ptr
; set tuple
%val2655 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2653, i64 0, i32 6
store i8 %val2654, i8* %val2655
%val2656 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2657 = load i32, i32* %arg_7Ptr
; set tuple
%val2658 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2656, i64 0, i32 7
store i32 %val2657, i32* %val2658
%val2659 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val2660 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %arg_8Ptr
; set tuple
%val2661 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2659, i64 0, i32 8
store [16 x {i32,i32,i32,i32}] %val2660, [16 x {i32,i32,i32,i32}]* %val2661
%val2662 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
ret %SF_INSTRUMENT* %val2662
}
@gsxtmsndfile113 = hidden constant [163 x i8] c"SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2682 = load i8*, i8** %_impzPtr
%zone2683 = bitcast i8* %tzone2682 to %mzone*

; let assign value to symbol SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0
%dat_SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0 = call i8* @llvm_zone_malloc(%mzone* %zone2683, i64 8)
%SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr = bitcast i8* %dat_SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***
%tzone2663 = load i8*, i8** %_impzPtr
%zone2664 = bitcast i8* %tzone2663 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2664)
; malloc closure structure
%clsptr2665 = call i8* @llvm_zone_malloc(%mzone* %zone2664, i64 24)
%closure2666 = bitcast i8* %clsptr2665 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*

; malloc environment structure
%envptr2667 = call i8* @llvm_zone_malloc(%mzone* %zone2664, i64 8)
%environment2668 = bitcast i8* %envptr2667 to {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}*

; malloc closure address table
%addytable2669 = call %clsvar* @new_address_table()
%var2670 = bitcast [110 x i8]* @gsxtmsndfile112 to i8*
%var2671 = bitcast [102 x i8]* @gsxtmsndfile108 to i8*
%addytable2672 = call %clsvar* @add_address_table(%mzone* %zone2664, i8* %var2670, i32 0, i8* %var2671, i32 3, %clsvar* %addytable2669)
%address-table2673 = bitcast %clsvar* %addytable2672 to i8*

; insert table, function and environment into closure struct
%closure.table2676 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure2666, i32 0, i32 0
store i8* %address-table2673, i8** %closure.table2676
%closure.env2677 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure2666, i32 0, i32 1
store i8* %envptr2667, i8** %closure.env2677
%closure.func2678 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure2666, i32 0, i32 2
store %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])* @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0__2629, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %closure.func2678
%closure_size2679 = call i64 @llvm_zone_mark_size(%mzone* %zone2664)
call void @llvm_zone_ptr_set_size(i8* %clsptr2665, i64 %closure_size2679)
%wrapper_ptr2680 = call i8* @llvm_zone_malloc(%mzone* %zone2664, i64 8)
%closure_wrapper2681 = bitcast i8* %wrapper_ptr2680 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
store { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure2666, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper2681

; let value assignment
%SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0 = select i1 true, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper2681, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper2681
store { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*** %SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr

; add data to environment
; don't need to alloc for env var SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0
%tmp_envptr2675 = getelementptr {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}, {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}* %environment2668, i32 0, i32 0
store {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*** %SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**** %tmp_envptr2675


%val2684 = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*** %SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0Ptr
ret {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %val2684
}


@SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var = dllexport global [1 x i8*] [ i8* null ]

@SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_INSTRUMENT* @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0(i32 %arg_0,i8 %arg_1,i8 %arg_2,i8 %arg_3,i8 %arg_4,i8 %arg_5,i8 %arg_6,i32 %arg_7,[16 x {i32,i32,i32,i32}] %arg_8) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*,  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8)
ret %SF_INSTRUMENT* %result
}


define dllexport ccc %SF_INSTRUMENT* @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_native(i32 %arg_0,i8 %arg_1,i8 %arg_2,i8 %arg_3,i8 %arg_4,i8 %arg_5,i8 %arg_6,i32 %arg_7,[16 x {i32,i32,i32,i32}] %arg_8) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*,  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8)
ret %SF_INSTRUMENT* %result
}


define dllexport ccc void @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}*
%arg_p_0 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
%arg_p_2 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 2
%arg_2 = load i8, i8* %arg_p_2
%arg_p_3 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 3
%arg_3 = load i8, i8* %arg_p_3
%arg_p_4 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 4
%arg_4 = load i8, i8* %arg_p_4
%arg_p_5 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 5
%arg_5 = load i8, i8* %arg_p_5
%arg_p_6 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 6
%arg_6 = load i8, i8* %arg_p_6
%arg_p_7 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 7
%arg_7 = load i32, i32* %arg_p_7
%arg_p_8 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 8
%arg_8 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %arg_p_8
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_h_adhoc_W1NGX0lOU1RSVU1FTlQqLGkzMixpOCxpOCxpOCxpOCxpOCxpOCxpMzIsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*,  %SF_INSTRUMENT* (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile114 = hidden constant [2 x i8] c"_\00"
@gsxtmsndfile115 = hidden constant [59 x i8] c"toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q\00"
@gsxtmsndfile116 = hidden constant [61 x i8] c"{i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**\00"
define dllexport fastcc %String* @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q__2694(i8* %_impz,i8* %_impenv, [16 x {i32,i32,i32,i32}] %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2695 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***}*
%toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***}, {{i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***}* %impenv, i32 0, i32 0
%toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr = load {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***, {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**** %toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr_

; setup arguments
%xPtr = alloca [16 x {i32,i32,i32,i32}]
store [16 x {i32,i32,i32,i32}] %x, [16 x {i32,i32,i32,i32}]* %xPtr


%var2696 = bitcast [2 x i8]* @gsxtmsndfile114 to i8*
%res2697 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var2696)
ret %String* %res2697
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2717 = load i8*, i8** %_impzPtr
%zone2718 = bitcast i8* %tzone2717 to %mzone*

; let assign value to symbol toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q
%dat_toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q = call i8* @llvm_zone_malloc(%mzone* %zone2718, i64 8)
%toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr = bitcast i8* %dat_toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q to { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***
%tzone2698 = load i8*, i8** %_impzPtr
%zone2699 = bitcast i8* %tzone2698 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2699)
; malloc closure structure
%clsptr2700 = call i8* @llvm_zone_malloc(%mzone* %zone2699, i64 24)
%closure2701 = bitcast i8* %clsptr2700 to { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*

; malloc environment structure
%envptr2702 = call i8* @llvm_zone_malloc(%mzone* %zone2699, i64 8)
%environment2703 = bitcast i8* %envptr2702 to {{i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***}*

; malloc closure address table
%addytable2704 = call %clsvar* @new_address_table()
%var2705 = bitcast [59 x i8]* @gsxtmsndfile115 to i8*
%var2706 = bitcast [61 x i8]* @gsxtmsndfile116 to i8*
%addytable2707 = call %clsvar* @add_address_table(%mzone* %zone2699, i8* %var2705, i32 0, i8* %var2706, i32 3, %clsvar* %addytable2704)
%address-table2708 = bitcast %clsvar* %addytable2707 to i8*

; insert table, function and environment into closure struct
%closure.table2711 = getelementptr { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure2701, i32 0, i32 0
store i8* %address-table2708, i8** %closure.table2711
%closure.env2712 = getelementptr { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure2701, i32 0, i32 1
store i8* %envptr2702, i8** %closure.env2712
%closure.func2713 = getelementptr { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure2701, i32 0, i32 2
store %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])* @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q__2694, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])** %closure.func2713
%closure_size2714 = call i64 @llvm_zone_mark_size(%mzone* %zone2699)
call void @llvm_zone_ptr_set_size(i8* %clsptr2700, i64 %closure_size2714)
%wrapper_ptr2715 = call i8* @llvm_zone_malloc(%mzone* %zone2699, i64 8)
%closure_wrapper2716 = bitcast i8* %wrapper_ptr2715 to { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**
store { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure2701, { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper2716

; let value assignment
%toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q = select i1 true, { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper2716, { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper2716
store { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q, { i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*** %toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr

; add data to environment
; don't need to alloc for env var toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q
%tmp_envptr2710 = getelementptr {{i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***}, {{i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***}* %environment2703, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*** %toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr, {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**** %tmp_envptr2710


%val2719 = load {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**, {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*** %toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr
ret {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %val2719
}


@toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var = dllexport global [1 x i8*] [ i8* null ]

@toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q([16 x {i32,i32,i32,i32}] %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*,  %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, [16 x {i32,i32,i32,i32}] %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_native([16 x {i32,i32,i32,i32}] %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*,  %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, [16 x {i32,i32,i32,i32}] %arg_0)
ret %String* %result
}


define dllexport ccc void @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[16 x {i32,i32,i32,i32}]}*
%arg_p_0 = getelementptr {[16 x {i32,i32,i32,i32}]}, {[16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 0
%arg_0 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])*,  %String* (i8*, i8*, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, [16 x {i32,i32,i32,i32}] %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile117 = hidden constant [21 x i8] c"<SF_INSTRUMENT:null>\00"
@gsxtmsndfile118 = hidden constant [16 x i8] c"<SF_INSTRUMENT:\00"
@gsxtmsndfile119 = hidden constant [48 x i8] c"toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd\00"
@gsxtmsndfile120 = hidden constant [52 x i8] c"{i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd__2693(i8* %_impz,i8* %_impenv, %SF_INSTRUMENT* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2720 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}***}*
%toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpdPtr = load {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}***, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}**** %toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpdPtr_

; setup arguments
%xPtr = alloca %SF_INSTRUMENT*
store %SF_INSTRUMENT* %x, %SF_INSTRUMENT** %xPtr


%val2722 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
%val2723 = icmp eq %SF_INSTRUMENT* %val2722, null
br i1 %val2723, label %then2721, label %else2721

then2721:
%zone2724 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone2724)
%zone_ptr2725 = bitcast %mzone* %zone2724 to i8*
store i8* %zone_ptr2725, i8** %_impzPtr
%tzone2735 = load i8*, i8** %_impzPtr
%zone2736 = bitcast i8* %tzone2735 to %mzone*

; let assign value to symbol res8
%res8Ptr = alloca %String*
%tzone2740 = load i8*, i8** %_impzPtr
%zone2741 = bitcast i8* %tzone2740 to %mzone*

; let assign value to symbol zone8
%zone8Ptr = alloca %mzone*
%tzone2743 = load i8*, i8** %_impzPtr
%zone2744 = bitcast i8* %tzone2743 to %mzone*

; let assign value to symbol newz8
%newz8Ptr = alloca %mzone*
%tzone2727 = load i8*, i8** %_impzPtr
%zone2728 = bitcast i8* %tzone2727 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat2726 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat2726, i8* %dat2726
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val2729 = load i8*, i8** %xx_t_mstPtr
%var2730 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2731 = bitcast [21 x i8]* @gsxtmsndfile117 to i8*

%val2732 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2729, i8* %var2730, i8* %var2731)
%val2733 = load i8*, i8** %xx_t_mstPtr
%res2734 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2733)

; let value assignment
%res8 = select i1 true, %String* %res2734, %String* %res2734
store %String* %res8, %String** %res8Ptr

%oldzone2737 = call %mzone* @llvm_pop_zone_stack()
%newzone2738 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2739 = bitcast %mzone* %newzone2738 to i8*
store i8* %zone_ptr2739, i8** %_impzPtr

; let value assignment
%zone8 = select i1 true, %mzone* %oldzone2737, %mzone* %oldzone2737
store %mzone* %zone8, %mzone** %zone8Ptr

%res2742 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz8 = select i1 true, %mzone* %res2742, %mzone* %res2742
store %mzone* %newz8, %mzone** %newz8Ptr

%tzone2749 = load i8*, i8** %_impzPtr
%zone2750 = bitcast i8* %tzone2749 to %mzone*

; let assign value to symbol rescopy8
%rescopy8Ptr = alloca %String*
%tzone2755 = load i8*, i8** %_impzPtr
%zone2756 = bitcast i8* %tzone2755 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone2758 = load i8*, i8** %_impzPtr
%zone2759 = bitcast i8* %tzone2758 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val2745 = load %String*, %String** %res8Ptr
%val2746 = load %mzone*, %mzone** %zone8Ptr
%val2747 = load %mzone*, %mzone** %newz8Ptr
%res2748 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val2745, %mzone* %val2746, %mzone* %val2747)

; let value assignment
%rescopy8 = select i1 true, %String* %res2748, %String* %res2748
store %String* %rescopy8, %String** %rescopy8Ptr

%val2751 = load %mzone*, %mzone** %zone8Ptr
; tuple ref
%val2752 = getelementptr %mzone, %mzone* %val2751, i64 0, i32 4
%val2753 = load i8*, i8** %val2752
%val2754 = bitcast i8* %val2753 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val2754, {i64,i8*,i8*}* %val2754
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null2757 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null2757, {i8*, i8*, void (i8*, i8*)*}** %null2757
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone2795 = load i8*, i8** %_impzPtr
%zone2796 = bitcast i8* %tzone2795 to %mzone*
%ifptr2785 = alloca i1
%ifptr2761 = alloca i1
; while loop
%val2762 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2763 = icmp eq {i64,i8*,i8*}* %val2762, null
br i1 %val2763, label %then2761, label %else2761

then2761:
%res2764 = call ccc i1 @impc_false()
store i1 %res2764, i1* %ifptr2761
br label %ifcont2761

else2761:
%res2765 = call ccc i1 @impc_true()
store i1 %res2765, i1* %ifptr2761
br label %ifcont2761

ifcont2761:
%ifres2766 = load i1, i1* %ifptr2761

br i1 %ifres2766, label %loop2760, label %after2760

loop2760:
; do set!
%val2767 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val2768 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2767, i64 0, i32 1
%val2769 = load i8*, i8** %val2768
%val2770 = bitcast i8* %val2769 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val2770, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval2771 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val2772 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval2771
%fPtr2773 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2772, i32 0, i32 2
%ePtr2774 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2772, i32 0, i32 1
%f2775 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr2773
%e2776 = load i8*, i8** %ePtr2774
%tzone2777 = load i8*, i8** %_impzPtr
%zone2778 = bitcast i8* %tzone2777 to %mzone*
%z2779 = bitcast %mzone* %zone2778 to i8*
tail call fastcc void %f2775(i8* %z2779, i8* %e2776)
; do set!
%val2781 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val2782 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2781, i64 0, i32 2
%val2783 = load i8*, i8** %val2782
%val2784 = bitcast i8* %val2783 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val2784, {i64,i8*,i8*}** %hookPtr
%val2786 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2787 = icmp eq {i64,i8*,i8*}* %val2786, null
br i1 %val2787, label %then2785, label %else2785

then2785:
%res2788 = call ccc i1 @impc_false()
store i1 %res2788, i1* %ifptr2785
br label %ifcont2785

else2785:
%res2789 = call ccc i1 @impc_true()
store i1 %res2789, i1* %ifptr2785
br label %ifcont2785

ifcont2785:
%ifres2790 = load i1, i1* %ifptr2785

br i1 %ifres2790, label %loop2760, label %after2760

after2760:
%val2792 = load %mzone*, %mzone** %zone8Ptr
call ccc void @llvm_zone_destroy(%mzone* %val2792)
%val2794 = load %String*, %String** %rescopy8Ptr
ret %String* %val2794

else2721:
%zone2797 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone2797)
%zone_ptr2798 = bitcast %mzone* %zone2797 to i8*
store i8* %zone_ptr2798, i8** %_impzPtr
%tzone2943 = load i8*, i8** %_impzPtr
%zone2944 = bitcast i8* %tzone2943 to %mzone*

; let assign value to symbol res9
%res9Ptr = alloca %String*
%tzone2948 = load i8*, i8** %_impzPtr
%zone2949 = bitcast i8* %tzone2948 to %mzone*

; let assign value to symbol zone9
%zone9Ptr = alloca %mzone*
%tzone2951 = load i8*, i8** %_impzPtr
%zone2952 = bitcast i8* %tzone2951 to %mzone*

; let assign value to symbol newz9
%newz9Ptr = alloca %mzone*
%tzone2800 = load i8*, i8** %_impzPtr
%zone2801 = bitcast i8* %tzone2800 to %mzone*

; let assign value to symbol xx_t_mst_s_28
%xx_t_mst_s_28Ptr = alloca i8*
%dat2799 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_28 = select i1 true, i8* %dat2799, i8* %dat2799
store i8* %xx_t_mst_s_28, i8** %xx_t_mst_s_28Ptr

%val2802 = load i8*, i8** %xx_t_mst_s_28Ptr
%var2803 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2804 = bitcast [16 x i8]* @gsxtmsndfile118 to i8*

%val2805 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2802, i8* %var2803, i8* %var2804)
%val2806 = load i8*, i8** %xx_t_mst_s_28Ptr
%res2807 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2806)
%val2808 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val2809 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2808, i64 0, i32 0
%val2810 = load i32, i32* %val2809
%res2811 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val2810)
%res2812 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2807, %String* %res2811)
%tzone2814 = load i8*, i8** %_impzPtr
%zone2815 = bitcast i8* %tzone2814 to %mzone*

; let assign value to symbol xx_t_mst_s_29
%xx_t_mst_s_29Ptr = alloca i8*
%dat2813 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_29 = select i1 true, i8* %dat2813, i8* %dat2813
store i8* %xx_t_mst_s_29, i8** %xx_t_mst_s_29Ptr

%val2816 = load i8*, i8** %xx_t_mst_s_29Ptr
%var2817 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2818 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val2819 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2816, i8* %var2817, i8* %var2818)
%val2820 = load i8*, i8** %xx_t_mst_s_29Ptr
%res2821 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2820)
%res2822 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2812, %String* %res2821)
%val2823 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val2824 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2823, i64 0, i32 1
%val2825 = load i8, i8* %val2824
%res2826 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaThd(i8 %val2825)
%res2827 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2822, %String* %res2826)
%tzone2829 = load i8*, i8** %_impzPtr
%zone2830 = bitcast i8* %tzone2829 to %mzone*

; let assign value to symbol xx_t_mst_s_30
%xx_t_mst_s_30Ptr = alloca i8*
%dat2828 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_30 = select i1 true, i8* %dat2828, i8* %dat2828
store i8* %xx_t_mst_s_30, i8** %xx_t_mst_s_30Ptr

%val2831 = load i8*, i8** %xx_t_mst_s_30Ptr
%var2832 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2833 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val2834 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2831, i8* %var2832, i8* %var2833)
%val2835 = load i8*, i8** %xx_t_mst_s_30Ptr
%res2836 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2835)
%res2837 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2827, %String* %res2836)
%val2838 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val2839 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2838, i64 0, i32 2
%val2840 = load i8, i8* %val2839
%res2841 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaThd(i8 %val2840)
%res2842 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2837, %String* %res2841)
%tzone2844 = load i8*, i8** %_impzPtr
%zone2845 = bitcast i8* %tzone2844 to %mzone*

; let assign value to symbol xx_t_mst_s_31
%xx_t_mst_s_31Ptr = alloca i8*
%dat2843 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_31 = select i1 true, i8* %dat2843, i8* %dat2843
store i8* %xx_t_mst_s_31, i8** %xx_t_mst_s_31Ptr

%val2846 = load i8*, i8** %xx_t_mst_s_31Ptr
%var2847 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2848 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val2849 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2846, i8* %var2847, i8* %var2848)
%val2850 = load i8*, i8** %xx_t_mst_s_31Ptr
%res2851 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2850)
%res2852 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2842, %String* %res2851)
%val2853 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val2854 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2853, i64 0, i32 3
%val2855 = load i8, i8* %val2854
%res2856 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaThd(i8 %val2855)
%res2857 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2852, %String* %res2856)
%tzone2859 = load i8*, i8** %_impzPtr
%zone2860 = bitcast i8* %tzone2859 to %mzone*

; let assign value to symbol xx_t_mst_s_32
%xx_t_mst_s_32Ptr = alloca i8*
%dat2858 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_32 = select i1 true, i8* %dat2858, i8* %dat2858
store i8* %xx_t_mst_s_32, i8** %xx_t_mst_s_32Ptr

%val2861 = load i8*, i8** %xx_t_mst_s_32Ptr
%var2862 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2863 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val2864 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2861, i8* %var2862, i8* %var2863)
%val2865 = load i8*, i8** %xx_t_mst_s_32Ptr
%res2866 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2865)
%res2867 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2857, %String* %res2866)
%val2868 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val2869 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2868, i64 0, i32 4
%val2870 = load i8, i8* %val2869
%res2871 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaThd(i8 %val2870)
%res2872 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2867, %String* %res2871)
%tzone2874 = load i8*, i8** %_impzPtr
%zone2875 = bitcast i8* %tzone2874 to %mzone*

; let assign value to symbol xx_t_mst_s_33
%xx_t_mst_s_33Ptr = alloca i8*
%dat2873 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_33 = select i1 true, i8* %dat2873, i8* %dat2873
store i8* %xx_t_mst_s_33, i8** %xx_t_mst_s_33Ptr

%val2876 = load i8*, i8** %xx_t_mst_s_33Ptr
%var2877 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2878 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val2879 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2876, i8* %var2877, i8* %var2878)
%val2880 = load i8*, i8** %xx_t_mst_s_33Ptr
%res2881 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2880)
%res2882 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2872, %String* %res2881)
%val2883 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val2884 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2883, i64 0, i32 5
%val2885 = load i8, i8* %val2884
%res2886 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaThd(i8 %val2885)
%res2887 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2882, %String* %res2886)
%tzone2889 = load i8*, i8** %_impzPtr
%zone2890 = bitcast i8* %tzone2889 to %mzone*

; let assign value to symbol xx_t_mst_s_34
%xx_t_mst_s_34Ptr = alloca i8*
%dat2888 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_34 = select i1 true, i8* %dat2888, i8* %dat2888
store i8* %xx_t_mst_s_34, i8** %xx_t_mst_s_34Ptr

%val2891 = load i8*, i8** %xx_t_mst_s_34Ptr
%var2892 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2893 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val2894 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2891, i8* %var2892, i8* %var2893)
%val2895 = load i8*, i8** %xx_t_mst_s_34Ptr
%res2896 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2895)
%res2897 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2887, %String* %res2896)
%val2898 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val2899 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2898, i64 0, i32 6
%val2900 = load i8, i8* %val2899
%res2901 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaThd(i8 %val2900)
%res2902 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2897, %String* %res2901)
%tzone2904 = load i8*, i8** %_impzPtr
%zone2905 = bitcast i8* %tzone2904 to %mzone*

; let assign value to symbol xx_t_mst_s_35
%xx_t_mst_s_35Ptr = alloca i8*
%dat2903 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_35 = select i1 true, i8* %dat2903, i8* %dat2903
store i8* %xx_t_mst_s_35, i8** %xx_t_mst_s_35Ptr

%val2906 = load i8*, i8** %xx_t_mst_s_35Ptr
%var2907 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2908 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val2909 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2906, i8* %var2907, i8* %var2908)
%val2910 = load i8*, i8** %xx_t_mst_s_35Ptr
%res2911 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2910)
%res2912 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2902, %String* %res2911)
%val2913 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val2914 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2913, i64 0, i32 7
%val2915 = load i32, i32* %val2914
%res2916 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val2915)
%res2917 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2912, %String* %res2916)
%tzone2919 = load i8*, i8** %_impzPtr
%zone2920 = bitcast i8* %tzone2919 to %mzone*

; let assign value to symbol xx_t_mst_s_36
%xx_t_mst_s_36Ptr = alloca i8*
%dat2918 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_36 = select i1 true, i8* %dat2918, i8* %dat2918
store i8* %xx_t_mst_s_36, i8** %xx_t_mst_s_36Ptr

%val2921 = load i8*, i8** %xx_t_mst_s_36Ptr
%var2922 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2923 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val2924 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2921, i8* %var2922, i8* %var2923)
%val2925 = load i8*, i8** %xx_t_mst_s_36Ptr
%res2926 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2925)
%res2927 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2917, %String* %res2926)
%val2928 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val2929 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val2928, i64 0, i32 8
%val2930 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %val2929
%res2931 = call fastcc %String* @toString_poly_W1N0cmluZyosfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q([16 x {i32,i32,i32,i32}] %val2930)
%res2932 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2927, %String* %res2931)
%tzone2934 = load i8*, i8** %_impzPtr
%zone2935 = bitcast i8* %tzone2934 to %mzone*

; let assign value to symbol xx_t_mst_s_37
%xx_t_mst_s_37Ptr = alloca i8*
%dat2933 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_37 = select i1 true, i8* %dat2933, i8* %dat2933
store i8* %xx_t_mst_s_37, i8** %xx_t_mst_s_37Ptr

%val2936 = load i8*, i8** %xx_t_mst_s_37Ptr
%var2937 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var2938 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val2939 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2936, i8* %var2937, i8* %var2938)
%val2940 = load i8*, i8** %xx_t_mst_s_37Ptr
%res2941 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2940)
%res2942 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2932, %String* %res2941)

; let value assignment
%res9 = select i1 true, %String* %res2942, %String* %res2942
store %String* %res9, %String** %res9Ptr

%oldzone2945 = call %mzone* @llvm_pop_zone_stack()
%newzone2946 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2947 = bitcast %mzone* %newzone2946 to i8*
store i8* %zone_ptr2947, i8** %_impzPtr

; let value assignment
%zone9 = select i1 true, %mzone* %oldzone2945, %mzone* %oldzone2945
store %mzone* %zone9, %mzone** %zone9Ptr

%res2950 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz9 = select i1 true, %mzone* %res2950, %mzone* %res2950
store %mzone* %newz9, %mzone** %newz9Ptr

%tzone2957 = load i8*, i8** %_impzPtr
%zone2958 = bitcast i8* %tzone2957 to %mzone*

; let assign value to symbol rescopy9
%rescopy9Ptr = alloca %String*
%tzone2963 = load i8*, i8** %_impzPtr
%zone2964 = bitcast i8* %tzone2963 to %mzone*

; let assign value to symbol hook_s_38
%hook_s_38Ptr = alloca {i64,i8*,i8*}*
%tzone2966 = load i8*, i8** %_impzPtr
%zone2967 = bitcast i8* %tzone2966 to %mzone*

; let assign value to symbol f_s_39
%f_s_39Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val2953 = load %String*, %String** %res9Ptr
%val2954 = load %mzone*, %mzone** %zone9Ptr
%val2955 = load %mzone*, %mzone** %newz9Ptr
%res2956 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val2953, %mzone* %val2954, %mzone* %val2955)

; let value assignment
%rescopy9 = select i1 true, %String* %res2956, %String* %res2956
store %String* %rescopy9, %String** %rescopy9Ptr

%val2959 = load %mzone*, %mzone** %zone9Ptr
; tuple ref
%val2960 = getelementptr %mzone, %mzone* %val2959, i64 0, i32 4
%val2961 = load i8*, i8** %val2960
%val2962 = bitcast i8* %val2961 to {i64,i8*,i8*}*

; let value assignment
%hook_s_38 = select i1 true, {i64,i8*,i8*}* %val2962, {i64,i8*,i8*}* %val2962
store {i64,i8*,i8*}* %hook_s_38, {i64,i8*,i8*}** %hook_s_38Ptr

%null2965 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_39 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null2965, {i8*, i8*, void (i8*, i8*)*}** %null2965
store {i8*, i8*, void (i8*, i8*)*}** %f_s_39, {i8*, i8*, void (i8*, i8*)*}*** %f_s_39Ptr

; promote local stack var allocations
%tzone3003 = load i8*, i8** %_impzPtr
%zone3004 = bitcast i8* %tzone3003 to %mzone*
%ifptr2993 = alloca i1
%ifptr2969 = alloca i1
; while loop
%val2970 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_38Ptr
%val2971 = icmp eq {i64,i8*,i8*}* %val2970, null
br i1 %val2971, label %then2969, label %else2969

then2969:
%res2972 = call ccc i1 @impc_false()
store i1 %res2972, i1* %ifptr2969
br label %ifcont2969

else2969:
%res2973 = call ccc i1 @impc_true()
store i1 %res2973, i1* %ifptr2969
br label %ifcont2969

ifcont2969:
%ifres2974 = load i1, i1* %ifptr2969

br i1 %ifres2974, label %loop2968, label %after2968

loop2968:
; do set!
%val2975 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_38Ptr
; tuple ref
%val2976 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2975, i64 0, i32 1
%val2977 = load i8*, i8** %val2976
%val2978 = bitcast i8* %val2977 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val2978, {i8*, i8*, void (i8*, i8*)*}*** %f_s_39Ptr

; apply closure 
%vval2979 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_39Ptr
%val2980 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval2979
%fPtr2981 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2980, i32 0, i32 2
%ePtr2982 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2980, i32 0, i32 1
%f2983 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr2981
%e2984 = load i8*, i8** %ePtr2982
%tzone2985 = load i8*, i8** %_impzPtr
%zone2986 = bitcast i8* %tzone2985 to %mzone*
%z2987 = bitcast %mzone* %zone2986 to i8*
tail call fastcc void %f2983(i8* %z2987, i8* %e2984)
; do set!
%val2989 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_38Ptr
; tuple ref
%val2990 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2989, i64 0, i32 2
%val2991 = load i8*, i8** %val2990
%val2992 = bitcast i8* %val2991 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val2992, {i64,i8*,i8*}** %hook_s_38Ptr
%val2994 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_38Ptr
%val2995 = icmp eq {i64,i8*,i8*}* %val2994, null
br i1 %val2995, label %then2993, label %else2993

then2993:
%res2996 = call ccc i1 @impc_false()
store i1 %res2996, i1* %ifptr2993
br label %ifcont2993

else2993:
%res2997 = call ccc i1 @impc_true()
store i1 %res2997, i1* %ifptr2993
br label %ifcont2993

ifcont2993:
%ifres2998 = load i1, i1* %ifptr2993

br i1 %ifres2998, label %loop2968, label %after2968

after2968:
%val3000 = load %mzone*, %mzone** %zone9Ptr
call ccc void @llvm_zone_destroy(%mzone* %val3000)
%val3002 = load %String*, %String** %rescopy9Ptr
ret %String* %val3002
}
@gsxtmsndfile121 = hidden constant [101 x i8] c"toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}** @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3024 = load i8*, i8** %_impzPtr
%zone3025 = bitcast i8* %tzone3024 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd
%dat_toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd = call i8* @llvm_zone_malloc(%mzone* %zone3025, i64 8)
%toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd to { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}***
%tzone3005 = load i8*, i8** %_impzPtr
%zone3006 = bitcast i8* %tzone3005 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3006)
; malloc closure structure
%clsptr3007 = call i8* @llvm_zone_malloc(%mzone* %zone3006, i64 24)
%closure3008 = bitcast i8* %clsptr3007 to { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}*

; malloc environment structure
%envptr3009 = call i8* @llvm_zone_malloc(%mzone* %zone3006, i64 8)
%environment3010 = bitcast i8* %envptr3009 to {{i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}***}*

; malloc closure address table
%addytable3011 = call %clsvar* @new_address_table()
%var3012 = bitcast [48 x i8]* @gsxtmsndfile119 to i8*
%var3013 = bitcast [52 x i8]* @gsxtmsndfile120 to i8*
%addytable3014 = call %clsvar* @add_address_table(%mzone* %zone3006, i8* %var3012, i32 0, i8* %var3013, i32 3, %clsvar* %addytable3011)
%address-table3015 = bitcast %clsvar* %addytable3014 to i8*

; insert table, function and environment into closure struct
%closure.table3018 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3008, i32 0, i32 0
store i8* %address-table3015, i8** %closure.table3018
%closure.env3019 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3008, i32 0, i32 1
store i8* %envptr3009, i8** %closure.env3019
%closure.func3020 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3008, i32 0, i32 2
store %String* (i8*, i8*, %SF_INSTRUMENT*)* @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd__2693, %String* (i8*, i8*, %SF_INSTRUMENT*)** %closure.func3020
%closure_size3021 = call i64 @llvm_zone_mark_size(%mzone* %zone3006)
call void @llvm_zone_ptr_set_size(i8* %clsptr3007, i64 %closure_size3021)
%wrapper_ptr3022 = call i8* @llvm_zone_malloc(%mzone* %zone3006, i64 8)
%closure_wrapper3023 = bitcast i8* %wrapper_ptr3022 to { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}**
store { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3008, { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_wrapper3023

; let value assignment
%toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_wrapper3023, { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_wrapper3023
store { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}** %toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd, { i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd
%tmp_envptr3017 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}***}* %environment3010, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpdPtr, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}**** %tmp_envptr3017


%val3026 = load {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}**, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpdPtr
ret {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}** %val3026
}


@toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}** @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd(%SF_INSTRUMENT* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_INSTRUMENT*)*,  %String* (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_native(%SF_INSTRUMENT* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_INSTRUMENT*)*,  %String* (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3027 = bitcast [101 x i8]* @gsxtmsndfile121 to i8*
call i32 (i8*, ...) @printf(i8* %var3027)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INSTRUMENT*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_INSTRUMENT*)*,  %String* (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INSTRUMENT*}*
%arg_p_0 = getelementptr {%SF_INSTRUMENT*}, {%SF_INSTRUMENT*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_INSTRUMENT*)*,  %String* (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile122 = hidden constant [2 x i8] c"<\00"
@gsxtmsndfile123 = hidden constant [46 x i8] c"print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg\00"
@gsxtmsndfile124 = hidden constant [50 x i8] c"{i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}**\00"
define dllexport fastcc void @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg__3030(i8* %_impz,i8* %_impenv, {i32,i32,i32,i32} %tup) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3031 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}***}*
%print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKgPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}***}, {{i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}***}* %impenv, i32 0, i32 0
%print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKgPtr = load {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}***, {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}**** %print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKgPtr_

; setup arguments
%tupPtr = alloca {i32,i32,i32,i32}
store {i32,i32,i32,i32} %tup, {i32,i32,i32,i32}* %tupPtr


%var3032 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3033 = bitcast [2 x i8]* @gsxtmsndfile122 to i8*

%val3034 = call i32 (i8*, ...) @printf(i8* %var3032, i8* %var3033)
%val3035 = load {i32,i32,i32,i32}, {i32,i32,i32,i32}* %tupPtr
; tuple ref
%val3036 = extractvalue {i32,i32,i32,i32} %val3035, 0
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val3036)
%var3038 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3039 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3040 = call i32 (i8*, ...) @printf(i8* %var3038, i8* %var3039)
%val3041 = load {i32,i32,i32,i32}, {i32,i32,i32,i32}* %tupPtr
; tuple ref
%val3042 = extractvalue {i32,i32,i32,i32} %val3041, 1
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val3042)
%var3044 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3045 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3046 = call i32 (i8*, ...) @printf(i8* %var3044, i8* %var3045)
%val3047 = load {i32,i32,i32,i32}, {i32,i32,i32,i32}* %tupPtr
; tuple ref
%val3048 = extractvalue {i32,i32,i32,i32} %val3047, 2
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val3048)
%var3050 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3051 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3052 = call i32 (i8*, ...) @printf(i8* %var3050, i8* %var3051)
%val3053 = load {i32,i32,i32,i32}, {i32,i32,i32,i32}* %tupPtr
; tuple ref
%val3054 = extractvalue {i32,i32,i32,i32} %val3053, 3
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val3054)
%var3056 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3057 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val3058 = call i32 (i8*, ...) @printf(i8* %var3056, i8* %var3057)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}** @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3080 = load i8*, i8** %_impzPtr
%zone3081 = bitcast i8* %tzone3080 to %mzone*

; let assign value to symbol print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg
%dat_print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg = call i8* @llvm_zone_malloc(%mzone* %zone3081, i64 8)
%print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKgPtr = bitcast i8* %dat_print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg to { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}***
%tzone3061 = load i8*, i8** %_impzPtr
%zone3062 = bitcast i8* %tzone3061 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3062)
; malloc closure structure
%clsptr3063 = call i8* @llvm_zone_malloc(%mzone* %zone3062, i64 24)
%closure3064 = bitcast i8* %clsptr3063 to { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}*

; malloc environment structure
%envptr3065 = call i8* @llvm_zone_malloc(%mzone* %zone3062, i64 8)
%environment3066 = bitcast i8* %envptr3065 to {{i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}***}*

; malloc closure address table
%addytable3067 = call %clsvar* @new_address_table()
%var3068 = bitcast [46 x i8]* @gsxtmsndfile123 to i8*
%var3069 = bitcast [50 x i8]* @gsxtmsndfile124 to i8*
%addytable3070 = call %clsvar* @add_address_table(%mzone* %zone3062, i8* %var3068, i32 0, i8* %var3069, i32 3, %clsvar* %addytable3067)
%address-table3071 = bitcast %clsvar* %addytable3070 to i8*

; insert table, function and environment into closure struct
%closure.table3074 = getelementptr { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}, { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}* %closure3064, i32 0, i32 0
store i8* %address-table3071, i8** %closure.table3074
%closure.env3075 = getelementptr { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}, { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}* %closure3064, i32 0, i32 1
store i8* %envptr3065, i8** %closure.env3075
%closure.func3076 = getelementptr { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}, { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}* %closure3064, i32 0, i32 2
store void (i8*, i8*, {i32,i32,i32,i32})* @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg__3030, void (i8*, i8*, {i32,i32,i32,i32})** %closure.func3076
%closure_size3077 = call i64 @llvm_zone_mark_size(%mzone* %zone3062)
call void @llvm_zone_ptr_set_size(i8* %clsptr3063, i64 %closure_size3077)
%wrapper_ptr3078 = call i8* @llvm_zone_malloc(%mzone* %zone3062, i64 8)
%closure_wrapper3079 = bitcast i8* %wrapper_ptr3078 to { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}**
store { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}* %closure3064, { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}** %closure_wrapper3079

; let value assignment
%print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg = select i1 true, { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}** %closure_wrapper3079, { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}** %closure_wrapper3079
store { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}** %print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg, { i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}*** %print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKgPtr

; add data to environment
; don't need to alloc for env var print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg
%tmp_envptr3073 = getelementptr {{i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}***}, {{i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}***}* %environment3066, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}*** %print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKgPtr, {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}**** %tmp_envptr3073


%val3082 = load {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}**, {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}*** %print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKgPtr
ret {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}** %val3082
}


@print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_var = dllexport global [1 x i8*] [ i8* null ]

@print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}** @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg({i32,i32,i32,i32} %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}**
%closure = load {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}*, {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}, {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}, {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, {i32,i32,i32,i32})*,  void (i8*, i8*, {i32,i32,i32,i32})** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, {i32,i32,i32,i32} %arg_0)
ret void
}


define dllexport ccc void @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_native({i32,i32,i32,i32} %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}**
%closure = load {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}*, {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}, {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}, {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, {i32,i32,i32,i32})*,  void (i8*, i8*, {i32,i32,i32,i32})** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, {i32,i32,i32,i32} %arg_0)
ret void
}


define dllexport ccc void @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {{i32,i32,i32,i32}}*
%arg_p_0 = getelementptr {{i32,i32,i32,i32}}, {{i32,i32,i32,i32}}* %fstruct, i32 0, i32 0
%arg_0 = load {i32,i32,i32,i32}, {i32,i32,i32,i32}* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}**
%closure = load {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}*, {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}, {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}, {i8*, i8*, void (i8*, i8*, {i32,i32,i32,i32})*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, {i32,i32,i32,i32})*,  void (i8*, i8*, {i32,i32,i32,i32})** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, {i32,i32,i32,i32} %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile125 = hidden constant [2 x i8] c"|\00"
@gsxtmsndfile126 = hidden constant [52 x i8] c"print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q\00"
@gsxtmsndfile127 = hidden constant [57 x i8] c"{i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**\00"
define dllexport fastcc void @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q__3029(i8* %_impz,i8* %_impenv, [16 x {i32,i32,i32,i32}] %arr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3083 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***}*
%print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***}, {{i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***}* %impenv, i32 0, i32 0
%print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr = load {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***, {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**** %print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr_

; setup arguments
%arrPtr = alloca [16 x {i32,i32,i32,i32}]
store [16 x {i32,i32,i32,i32}] %arr, [16 x {i32,i32,i32,i32}]* %arrPtr


%tzone3084 = load i8*, i8** %_impzPtr
%zone3085 = bitcast i8* %tzone3084 to %mzone*

; let assign value to symbol a1
%a1Ptr = alloca [16 x {i32,i32,i32,i32}]*

; let value assignment
%a1 = select i1 true, [16 x {i32,i32,i32,i32}]* %arrPtr, [16 x {i32,i32,i32,i32}]* %arrPtr
store [16 x {i32,i32,i32,i32}]* %a1, [16 x {i32,i32,i32,i32}]** %a1Ptr

%var3086 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3087 = bitcast [2 x i8]* @gsxtmsndfile125 to i8*

%val3088 = call i32 (i8*, ...) @printf(i8* %var3086, i8* %var3087)
%val3089 = load [16 x {i32,i32,i32,i32}]*, [16 x {i32,i32,i32,i32}]** %a1Ptr
; array ref
%_val3090 = getelementptr [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %val3089, i32 0, i64 0
%val3091 = load {i32,i32,i32,i32}, {i32,i32,i32,i32}* %_val3090
call fastcc void @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg({i32,i32,i32,i32} %val3091)
%tzone3095 = load i8*, i8** %_impzPtr
%zone3096 = bitcast i8* %tzone3095 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val3094 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val3094, i64 %val3094
store i64 %i, i64* %iPtr

; setup loop
%val3099 = sub i64 16, 1
store i64 0, i64* %iPtr
%val3110 = load i64, i64* %iPtr
%num3111 = add i64 %val3099, %val3110
%comp3112 = icmp ult i64 %val3099, 1
br i1 %comp3112, label %after3097, label %loop3097

loop3097:
%var3100 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3101 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3102 = call i32 (i8*, ...) @printf(i8* %var3100, i8* %var3101)
%val3103 = load i64, i64* %iPtr
%val3104 = add i64 1, %val3103
%val3105 = load [16 x {i32,i32,i32,i32}]*, [16 x {i32,i32,i32,i32}]** %a1Ptr
; array ref
%_val3106 = getelementptr [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %val3105, i32 0, i64 %val3104
%val3107 = load {i32,i32,i32,i32}, {i32,i32,i32,i32}* %_val3106
call fastcc void @print_poly_W3ZvaWQsPGkzMixpMzIsaTMyLGkzMj5dKg({i32,i32,i32,i32} %val3107)
%loop_cnt3097 = load i64, i64* %iPtr
%next3097 = add i64 %loop_cnt3097, 1
store i64 %next3097, i64* %iPtr
%cmp3097 = icmp ult i64 %next3097, %num3111
br i1 %cmp3097, label %loop3097, label %after3097

after3097:
%var3114 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3115 = bitcast [2 x i8]* @gsxtmsndfile125 to i8*

%val3116 = call i32 (i8*, ...) @printf(i8* %var3114, i8* %var3115)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3138 = load i8*, i8** %_impzPtr
%zone3139 = bitcast i8* %tzone3138 to %mzone*

; let assign value to symbol print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q
%dat_print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q = call i8* @llvm_zone_malloc(%mzone* %zone3139, i64 8)
%print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr = bitcast i8* %dat_print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q to { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***
%tzone3119 = load i8*, i8** %_impzPtr
%zone3120 = bitcast i8* %tzone3119 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3120)
; malloc closure structure
%clsptr3121 = call i8* @llvm_zone_malloc(%mzone* %zone3120, i64 24)
%closure3122 = bitcast i8* %clsptr3121 to { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*

; malloc environment structure
%envptr3123 = call i8* @llvm_zone_malloc(%mzone* %zone3120, i64 8)
%environment3124 = bitcast i8* %envptr3123 to {{i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***}*

; malloc closure address table
%addytable3125 = call %clsvar* @new_address_table()
%var3126 = bitcast [52 x i8]* @gsxtmsndfile126 to i8*
%var3127 = bitcast [57 x i8]* @gsxtmsndfile127 to i8*
%addytable3128 = call %clsvar* @add_address_table(%mzone* %zone3120, i8* %var3126, i32 0, i8* %var3127, i32 3, %clsvar* %addytable3125)
%address-table3129 = bitcast %clsvar* %addytable3128 to i8*

; insert table, function and environment into closure struct
%closure.table3132 = getelementptr { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure3122, i32 0, i32 0
store i8* %address-table3129, i8** %closure.table3132
%closure.env3133 = getelementptr { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure3122, i32 0, i32 1
store i8* %envptr3123, i8** %closure.env3133
%closure.func3134 = getelementptr { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure3122, i32 0, i32 2
store void (i8*, i8*, [16 x {i32,i32,i32,i32}])* @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q__3029, void (i8*, i8*, [16 x {i32,i32,i32,i32}])** %closure.func3134
%closure_size3135 = call i64 @llvm_zone_mark_size(%mzone* %zone3120)
call void @llvm_zone_ptr_set_size(i8* %clsptr3121, i64 %closure_size3135)
%wrapper_ptr3136 = call i8* @llvm_zone_malloc(%mzone* %zone3120, i64 8)
%closure_wrapper3137 = bitcast i8* %wrapper_ptr3136 to { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**
store { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure3122, { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper3137

; let value assignment
%print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q = select i1 true, { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper3137, { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper3137
store { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q, { i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*** %print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr

; add data to environment
; don't need to alloc for env var print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q
%tmp_envptr3131 = getelementptr {{i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***}, {{i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}***}* %environment3124, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*** %print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr, {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**** %tmp_envptr3131


%val3140 = load {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**, {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*** %print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0qPtr
ret {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %val3140
}


@print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var = dllexport global [1 x i8*] [ i8* null ]

@print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q([16 x {i32,i32,i32,i32}] %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, [16 x {i32,i32,i32,i32}])*,  void (i8*, i8*, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, [16 x {i32,i32,i32,i32}] %arg_0)
ret void
}


define dllexport ccc void @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_native([16 x {i32,i32,i32,i32}] %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, [16 x {i32,i32,i32,i32}])*,  void (i8*, i8*, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, [16 x {i32,i32,i32,i32}] %arg_0)
ret void
}


define dllexport ccc void @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[16 x {i32,i32,i32,i32}]}*
%arg_p_0 = getelementptr {[16 x {i32,i32,i32,i32}]}, {[16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 0
%arg_0 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, void (i8*, i8*, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, [16 x {i32,i32,i32,i32}])*,  void (i8*, i8*, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, [16 x {i32,i32,i32,i32}] %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile128 = hidden constant [41 x i8] c"print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd\00"
@gsxtmsndfile129 = hidden constant [48 x i8] c"{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd__3028(i8* %_impz,i8* %_impenv, %SF_INSTRUMENT* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3141 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***}*
%print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr = load {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**** %print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr_

; setup arguments
%xPtr = alloca %SF_INSTRUMENT*
store %SF_INSTRUMENT* %x, %SF_INSTRUMENT** %xPtr


%val3143 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
%val3144 = icmp eq %SF_INSTRUMENT* %val3143, null
br i1 %val3144, label %then3142, label %else3142

then3142:
%var3145 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3146 = bitcast [21 x i8]* @gsxtmsndfile117 to i8*

%val3147 = call i32 (i8*, ...) @printf(i8* %var3145, i8* %var3146)
br label %ifcont3142

else3142:
%var3149 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3150 = bitcast [16 x i8]* @gsxtmsndfile118 to i8*

%val3151 = call i32 (i8*, ...) @printf(i8* %var3149, i8* %var3150)
%val3152 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3153 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3152, i64 0, i32 0
%val3154 = load i32, i32* %val3153
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val3154)
%var3156 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3157 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3158 = call i32 (i8*, ...) @printf(i8* %var3156, i8* %var3157)
%val3159 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3160 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3159, i64 0, i32 1
%val3161 = load i8, i8* %val3160
call fastcc void @print_adhoc_W3ZvaWQsaThd(i8 %val3161)
%var3163 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3164 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3165 = call i32 (i8*, ...) @printf(i8* %var3163, i8* %var3164)
%val3166 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3167 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3166, i64 0, i32 2
%val3168 = load i8, i8* %val3167
call fastcc void @print_adhoc_W3ZvaWQsaThd(i8 %val3168)
%var3170 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3171 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3172 = call i32 (i8*, ...) @printf(i8* %var3170, i8* %var3171)
%val3173 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3174 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3173, i64 0, i32 3
%val3175 = load i8, i8* %val3174
call fastcc void @print_adhoc_W3ZvaWQsaThd(i8 %val3175)
%var3177 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3178 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3179 = call i32 (i8*, ...) @printf(i8* %var3177, i8* %var3178)
%val3180 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3181 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3180, i64 0, i32 4
%val3182 = load i8, i8* %val3181
call fastcc void @print_adhoc_W3ZvaWQsaThd(i8 %val3182)
%var3184 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3185 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3186 = call i32 (i8*, ...) @printf(i8* %var3184, i8* %var3185)
%val3187 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3188 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3187, i64 0, i32 5
%val3189 = load i8, i8* %val3188
call fastcc void @print_adhoc_W3ZvaWQsaThd(i8 %val3189)
%var3191 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3192 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3193 = call i32 (i8*, ...) @printf(i8* %var3191, i8* %var3192)
%val3194 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3195 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3194, i64 0, i32 6
%val3196 = load i8, i8* %val3195
call fastcc void @print_adhoc_W3ZvaWQsaThd(i8 %val3196)
%var3198 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3199 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3200 = call i32 (i8*, ...) @printf(i8* %var3198, i8* %var3199)
%val3201 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3202 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3201, i64 0, i32 7
%val3203 = load i32, i32* %val3202
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val3203)
%var3205 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3206 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3207 = call i32 (i8*, ...) @printf(i8* %var3205, i8* %var3206)
%val3208 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3209 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3208, i64 0, i32 8
%val3210 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %val3209
call fastcc void @print_poly_W3ZvaWQsfDE2LDxpMzIsaTMyLGkzMixpMzI_fF0q([16 x {i32,i32,i32,i32}] %val3210)
%var3212 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3213 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val3214 = call i32 (i8*, ...) @printf(i8* %var3212, i8* %var3213)
br label %ifcont3142

ifcont3142:
ret void
}
@gsxtmsndfile130 = hidden constant [94 x i8] c"print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3236 = load i8*, i8** %_impzPtr
%zone3237 = bitcast i8* %tzone3236 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd
%dat_print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd = call i8* @llvm_zone_malloc(%mzone* %zone3237, i64 8)
%print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd to { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***
%tzone3217 = load i8*, i8** %_impzPtr
%zone3218 = bitcast i8* %tzone3217 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3218)
; malloc closure structure
%clsptr3219 = call i8* @llvm_zone_malloc(%mzone* %zone3218, i64 24)
%closure3220 = bitcast i8* %clsptr3219 to { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*

; malloc environment structure
%envptr3221 = call i8* @llvm_zone_malloc(%mzone* %zone3218, i64 8)
%environment3222 = bitcast i8* %envptr3221 to {{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***}*

; malloc closure address table
%addytable3223 = call %clsvar* @new_address_table()
%var3224 = bitcast [41 x i8]* @gsxtmsndfile128 to i8*
%var3225 = bitcast [48 x i8]* @gsxtmsndfile129 to i8*
%addytable3226 = call %clsvar* @add_address_table(%mzone* %zone3218, i8* %var3224, i32 0, i8* %var3225, i32 3, %clsvar* %addytable3223)
%address-table3227 = bitcast %clsvar* %addytable3226 to i8*

; insert table, function and environment into closure struct
%closure.table3230 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3220, i32 0, i32 0
store i8* %address-table3227, i8** %closure.table3230
%closure.env3231 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3220, i32 0, i32 1
store i8* %envptr3221, i8** %closure.env3231
%closure.func3232 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3220, i32 0, i32 2
store void (i8*, i8*, %SF_INSTRUMENT*)* @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd__3028, void (i8*, i8*, %SF_INSTRUMENT*)** %closure.func3232
%closure_size3233 = call i64 @llvm_zone_mark_size(%mzone* %zone3218)
call void @llvm_zone_ptr_set_size(i8* %clsptr3219, i64 %closure_size3233)
%wrapper_ptr3234 = call i8* @llvm_zone_malloc(%mzone* %zone3218, i64 8)
%closure_wrapper3235 = bitcast i8* %wrapper_ptr3234 to { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**
store { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3220, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_wrapper3235

; let value assignment
%print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_wrapper3235, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_wrapper3235
store { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*** %print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd
%tmp_envptr3229 = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***}* %environment3222, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*** %print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**** %tmp_envptr3229


%val3238 = load {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*** %print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr
ret {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %val3238
}


@print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd(%SF_INSTRUMENT* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INSTRUMENT*)*,  void (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_native(%SF_INSTRUMENT* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INSTRUMENT*)*,  void (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3239 = bitcast [94 x i8]* @gsxtmsndfile130 to i8*
call i32 (i8*, ...) @printf(i8* %var3239)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INSTRUMENT*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INSTRUMENT*)*,  void (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INSTRUMENT*}*
%arg_p_0 = getelementptr {%SF_INSTRUMENT*}, {%SF_INSTRUMENT*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INSTRUMENT*)*,  void (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile131 = hidden constant [111 x i8] c"SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ\00"
@gsxtmsndfile132 = hidden constant [101 x i8] c"{i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**\00"
define dllexport fastcc %SF_INSTRUMENT @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ__3240(i8* %_impz,i8* %_impenv, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3241 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}*
%SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQPtr_ = getelementptr {{i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}, {{i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}* %impenv, i32 0, i32 0
%SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQPtr = load {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***, {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**** %SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i8
store i8 %arg_1, i8* %arg_1Ptr
%arg_2Ptr = alloca i8
store i8 %arg_2, i8* %arg_2Ptr
%arg_3Ptr = alloca i8
store i8 %arg_3, i8* %arg_3Ptr
%arg_4Ptr = alloca i8
store i8 %arg_4, i8* %arg_4Ptr
%arg_5Ptr = alloca i8
store i8 %arg_5, i8* %arg_5Ptr
%arg_6Ptr = alloca i8
store i8 %arg_6, i8* %arg_6Ptr
%arg_7Ptr = alloca i32
store i32 %arg_7, i32* %arg_7Ptr
%arg_8Ptr = alloca [16 x {i32,i32,i32,i32}]
store [16 x {i32,i32,i32,i32}] %arg_8, [16 x {i32,i32,i32,i32}]* %arg_8Ptr


%tzone3243 = load i8*, i8** %_impzPtr
%zone3244 = bitcast i8* %tzone3243 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_INSTRUMENT*
%dat3242 = alloca %SF_INSTRUMENT, align 16

; let value assignment
%obj = select i1 true, %SF_INSTRUMENT* %dat3242, %SF_INSTRUMENT* %dat3242
store %SF_INSTRUMENT* %obj, %SF_INSTRUMENT** %objPtr

%val3245 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3246 = load i32, i32* %arg_0Ptr
; set tuple
%val3247 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3245, i64 0, i32 0
store i32 %val3246, i32* %val3247
%val3248 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3249 = load i8, i8* %arg_1Ptr
; set tuple
%val3250 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3248, i64 0, i32 1
store i8 %val3249, i8* %val3250
%val3251 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3252 = load i8, i8* %arg_2Ptr
; set tuple
%val3253 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3251, i64 0, i32 2
store i8 %val3252, i8* %val3253
%val3254 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3255 = load i8, i8* %arg_3Ptr
; set tuple
%val3256 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3254, i64 0, i32 3
store i8 %val3255, i8* %val3256
%val3257 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3258 = load i8, i8* %arg_4Ptr
; set tuple
%val3259 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3257, i64 0, i32 4
store i8 %val3258, i8* %val3259
%val3260 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3261 = load i8, i8* %arg_5Ptr
; set tuple
%val3262 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3260, i64 0, i32 5
store i8 %val3261, i8* %val3262
%val3263 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3264 = load i8, i8* %arg_6Ptr
; set tuple
%val3265 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3263, i64 0, i32 6
store i8 %val3264, i8* %val3265
%val3266 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3267 = load i32, i32* %arg_7Ptr
; set tuple
%val3268 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3266, i64 0, i32 7
store i32 %val3267, i32* %val3268
%val3269 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3270 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %arg_8Ptr
; set tuple
%val3271 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3269, i64 0, i32 8
store [16 x {i32,i32,i32,i32}] %val3270, [16 x {i32,i32,i32,i32}]* %val3271
%val3272 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
; pointer ref
%val3273 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3272, i64 0
%val3274 = load %SF_INSTRUMENT, %SF_INSTRUMENT* %val3273
ret %SF_INSTRUMENT %val3274
}
@gsxtmsndfile133 = hidden constant [164 x i8] c"SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3294 = load i8*, i8** %_impzPtr
%zone3295 = bitcast i8* %tzone3294 to %mzone*

; let assign value to symbol SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ
%dat_SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ = call i8* @llvm_zone_malloc(%mzone* %zone3295, i64 8)
%SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQPtr = bitcast i8* %dat_SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ to { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***
%tzone3275 = load i8*, i8** %_impzPtr
%zone3276 = bitcast i8* %tzone3275 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3276)
; malloc closure structure
%clsptr3277 = call i8* @llvm_zone_malloc(%mzone* %zone3276, i64 24)
%closure3278 = bitcast i8* %clsptr3277 to { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*

; malloc environment structure
%envptr3279 = call i8* @llvm_zone_malloc(%mzone* %zone3276, i64 8)
%environment3280 = bitcast i8* %envptr3279 to {{i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}*

; malloc closure address table
%addytable3281 = call %clsvar* @new_address_table()
%var3282 = bitcast [111 x i8]* @gsxtmsndfile131 to i8*
%var3283 = bitcast [101 x i8]* @gsxtmsndfile132 to i8*
%addytable3284 = call %clsvar* @add_address_table(%mzone* %zone3276, i8* %var3282, i32 0, i8* %var3283, i32 3, %clsvar* %addytable3281)
%address-table3285 = bitcast %clsvar* %addytable3284 to i8*

; insert table, function and environment into closure struct
%closure.table3288 = getelementptr { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure3278, i32 0, i32 0
store i8* %address-table3285, i8** %closure.table3288
%closure.env3289 = getelementptr { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure3278, i32 0, i32 1
store i8* %envptr3279, i8** %closure.env3289
%closure.func3290 = getelementptr { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure3278, i32 0, i32 2
store %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])* @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ__3240, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %closure.func3290
%closure_size3291 = call i64 @llvm_zone_mark_size(%mzone* %zone3276)
call void @llvm_zone_ptr_set_size(i8* %clsptr3277, i64 %closure_size3291)
%wrapper_ptr3292 = call i8* @llvm_zone_malloc(%mzone* %zone3276, i64 8)
%closure_wrapper3293 = bitcast i8* %wrapper_ptr3292 to { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
store { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure3278, { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper3293

; let value assignment
%SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ = select i1 true, { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper3293, { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_wrapper3293
store { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ, { i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*** %SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQPtr

; add data to environment
; don't need to alloc for env var SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ
%tmp_envptr3287 = getelementptr {{i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}, {{i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}***}* %environment3280, i32 0, i32 0
store {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*** %SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQPtr, {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**** %tmp_envptr3287


%val3296 = load {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**, {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*** %SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQPtr
ret {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %val3296
}


@SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_var = dllexport global [1 x i8*] [ i8* null ]

@SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_INSTRUMENT @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ(i32 %arg_0,i8 %arg_1,i8 %arg_2,i8 %arg_3,i8 %arg_4,i8 %arg_5,i8 %arg_6,i32 %arg_7,[16 x {i32,i32,i32,i32}] %arg_8) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*,  %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8)
ret %SF_INSTRUMENT %result
}


define dllexport ccc %SF_INSTRUMENT @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_native(i32 %arg_0,i8 %arg_1,i8 %arg_2,i8 %arg_3,i8 %arg_4,i8 %arg_5,i8 %arg_6,i32 %arg_7,[16 x {i32,i32,i32,i32}] %arg_8) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*,  %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8)
ret %SF_INSTRUMENT %result
}


define dllexport ccc void @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}*
%arg_p_0 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 1
%arg_1 = load i8, i8* %arg_p_1
%arg_p_2 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 2
%arg_2 = load i8, i8* %arg_p_2
%arg_p_3 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 3
%arg_3 = load i8, i8* %arg_p_3
%arg_p_4 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 4
%arg_4 = load i8, i8* %arg_p_4
%arg_p_5 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 5
%arg_5 = load i8, i8* %arg_p_5
%arg_p_6 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 6
%arg_6 = load i8, i8* %arg_p_6
%arg_p_7 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 7
%arg_7 = load i32, i32* %arg_p_7
%arg_p_8 = getelementptr {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}, {i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}]}* %fstruct, i32 0, i32 8
%arg_8 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %arg_p_8
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_INSTRUMENT_val_adhoc_W1NGX0lOU1RSVU1FTlQsaTMyLGk4LGk4LGk4LGk4LGk4LGk4LGkzMix8MTYsPGkzMixpMzIsaTMyLGkzMj58XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}*, {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}, {i8*, i8*, %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])*,  %SF_INSTRUMENT (i8*, i8*, i32, i8, i8, i8, i8, i8, i8, i32, [16 x {i32,i32,i32,i32}])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8 %arg_1, i8 %arg_2, i8 %arg_3, i8 %arg_4, i8 %arg_5, i8 %arg_6, i32 %arg_7, [16 x {i32,i32,i32,i32}] %arg_8)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile134 = hidden constant [55 x i8] c"hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ\00"
@gsxtmsndfile135 = hidden constant [59 x i8] c"{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}**\00"
define dllexport fastcc %SF_INSTRUMENT* @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ__3305(i8* %_impz,i8* %_impenv, %SF_INSTRUMENT* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3306 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}***}*
%hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQPtr_ = getelementptr {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}***}, {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQPtr = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}***, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}**** %hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQPtr_

; setup arguments
%xPtr = alloca %SF_INSTRUMENT*
store %SF_INSTRUMENT* %x, %SF_INSTRUMENT** %xPtr


%tzone3309 = load i8*, i8** %_impzPtr
%zone3310 = bitcast i8* %tzone3309 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_INSTRUMENT*
%dat3307 = call i8* @malloc(i64 272)
call i8* @memset(i8* %dat3307, i32 0, i64 272)
%val3308 = bitcast i8* %dat3307 to %SF_INSTRUMENT*

; let value assignment
%obj = select i1 true, %SF_INSTRUMENT* %val3308, %SF_INSTRUMENT* %val3308
store %SF_INSTRUMENT* %obj, %SF_INSTRUMENT** %objPtr

%val3311 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3312 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3313 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3312, i64 0, i32 0
%val3314 = load i32, i32* %val3313
; set tuple
%val3315 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3311, i64 0, i32 0
store i32 %val3314, i32* %val3315
%val3316 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3317 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3318 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3317, i64 0, i32 1
%val3319 = load i8, i8* %val3318
; set tuple
%val3320 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3316, i64 0, i32 1
store i8 %val3319, i8* %val3320
%val3321 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3322 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3323 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3322, i64 0, i32 2
%val3324 = load i8, i8* %val3323
; set tuple
%val3325 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3321, i64 0, i32 2
store i8 %val3324, i8* %val3325
%val3326 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3327 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3328 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3327, i64 0, i32 3
%val3329 = load i8, i8* %val3328
; set tuple
%val3330 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3326, i64 0, i32 3
store i8 %val3329, i8* %val3330
%val3331 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3332 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3333 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3332, i64 0, i32 4
%val3334 = load i8, i8* %val3333
; set tuple
%val3335 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3331, i64 0, i32 4
store i8 %val3334, i8* %val3335
%val3336 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3337 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3338 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3337, i64 0, i32 5
%val3339 = load i8, i8* %val3338
; set tuple
%val3340 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3336, i64 0, i32 5
store i8 %val3339, i8* %val3340
%val3341 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3342 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3343 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3342, i64 0, i32 6
%val3344 = load i8, i8* %val3343
; set tuple
%val3345 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3341, i64 0, i32 6
store i8 %val3344, i8* %val3345
%val3346 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3347 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3348 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3347, i64 0, i32 7
%val3349 = load i32, i32* %val3348
; set tuple
%val3350 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3346, i64 0, i32 7
store i32 %val3349, i32* %val3350
%val3351 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3352 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3353 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3352, i64 0, i32 8
%val3354 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %val3353
; set tuple
%val3355 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3351, i64 0, i32 8
store [16 x {i32,i32,i32,i32}] %val3354, [16 x {i32,i32,i32,i32}]* %val3355
%val3356 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
ret %SF_INSTRUMENT* %val3356
}
@gsxtmsndfile136 = hidden constant [108 x i8] c"hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}** @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3376 = load i8*, i8** %_impzPtr
%zone3377 = bitcast i8* %tzone3376 to %mzone*

; let assign value to symbol hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ
%dat_hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3377, i64 8)
%hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQPtr = bitcast i8* %dat_hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}***
%tzone3357 = load i8*, i8** %_impzPtr
%zone3358 = bitcast i8* %tzone3357 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3358)
; malloc closure structure
%clsptr3359 = call i8* @llvm_zone_malloc(%mzone* %zone3358, i64 24)
%closure3360 = bitcast i8* %clsptr3359 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}*

; malloc environment structure
%envptr3361 = call i8* @llvm_zone_malloc(%mzone* %zone3358, i64 8)
%environment3362 = bitcast i8* %envptr3361 to {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}***}*

; malloc closure address table
%addytable3363 = call %clsvar* @new_address_table()
%var3364 = bitcast [55 x i8]* @gsxtmsndfile134 to i8*
%var3365 = bitcast [59 x i8]* @gsxtmsndfile135 to i8*
%addytable3366 = call %clsvar* @add_address_table(%mzone* %zone3358, i8* %var3364, i32 0, i8* %var3365, i32 3, %clsvar* %addytable3363)
%address-table3367 = bitcast %clsvar* %addytable3366 to i8*

; insert table, function and environment into closure struct
%closure.table3370 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3360, i32 0, i32 0
store i8* %address-table3367, i8** %closure.table3370
%closure.env3371 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3360, i32 0, i32 1
store i8* %envptr3361, i8** %closure.env3371
%closure.func3372 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3360, i32 0, i32 2
store %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)* @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ__3305, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)** %closure.func3372
%closure_size3373 = call i64 @llvm_zone_mark_size(%mzone* %zone3358)
call void @llvm_zone_ptr_set_size(i8* %clsptr3359, i64 %closure_size3373)
%wrapper_ptr3374 = call i8* @llvm_zone_malloc(%mzone* %zone3358, i64 8)
%closure_wrapper3375 = bitcast i8* %wrapper_ptr3374 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}**
store { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3360, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_wrapper3375

; let value assignment
%hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ = select i1 true, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_wrapper3375, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_wrapper3375
store { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}** %hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}*** %hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ
%tmp_envptr3369 = getelementptr {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}***}, {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}***}* %environment3362, i32 0, i32 0
store {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}*** %hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQPtr, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}**** %tmp_envptr3369


%val3378 = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}**, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}*** %hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQPtr
ret {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}** %val3378
}


@hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}** @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_INSTRUMENT* @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ(%SF_INSTRUMENT* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*,  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
ret %SF_INSTRUMENT* %result
}


define dllexport ccc %SF_INSTRUMENT* @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_native(%SF_INSTRUMENT* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*,  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
ret %SF_INSTRUMENT* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3379 = bitcast [108 x i8]* @gsxtmsndfile136 to i8*
call i32 (i8*, ...) @printf(i8* %var3379)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INSTRUMENT*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*,  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
%tmpres = bitcast %SF_INSTRUMENT* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INSTRUMENT*}*
%arg_p_0 = getelementptr {%SF_INSTRUMENT*}, {%SF_INSTRUMENT*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)*,  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile137 = hidden constant [41 x i8] c"hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd__3380(i8* %_impz,i8* %_impenv, %SF_INSTRUMENT* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3381 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***}*
%hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr = load {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**** %hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr_

; setup arguments
%xPtr = alloca %SF_INSTRUMENT*
store %SF_INSTRUMENT* %x, %SF_INSTRUMENT** %xPtr


%val3382 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
%val3383 = bitcast %SF_INSTRUMENT* %val3382 to i8*
call ccc void @free(i8* %val3383)
ret void
}
@gsxtmsndfile138 = hidden constant [94 x i8] c"hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3405 = load i8*, i8** %_impzPtr
%zone3406 = bitcast i8* %tzone3405 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd
%dat_hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd = call i8* @llvm_zone_malloc(%mzone* %zone3406, i64 8)
%hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd to { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***
%tzone3386 = load i8*, i8** %_impzPtr
%zone3387 = bitcast i8* %tzone3386 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3387)
; malloc closure structure
%clsptr3388 = call i8* @llvm_zone_malloc(%mzone* %zone3387, i64 24)
%closure3389 = bitcast i8* %clsptr3388 to { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*

; malloc environment structure
%envptr3390 = call i8* @llvm_zone_malloc(%mzone* %zone3387, i64 8)
%environment3391 = bitcast i8* %envptr3390 to {{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***}*

; malloc closure address table
%addytable3392 = call %clsvar* @new_address_table()
%var3393 = bitcast [41 x i8]* @gsxtmsndfile137 to i8*
%var3394 = bitcast [48 x i8]* @gsxtmsndfile129 to i8*
%addytable3395 = call %clsvar* @add_address_table(%mzone* %zone3387, i8* %var3393, i32 0, i8* %var3394, i32 3, %clsvar* %addytable3392)
%address-table3396 = bitcast %clsvar* %addytable3395 to i8*

; insert table, function and environment into closure struct
%closure.table3399 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3389, i32 0, i32 0
store i8* %address-table3396, i8** %closure.table3399
%closure.env3400 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3389, i32 0, i32 1
store i8* %envptr3390, i8** %closure.env3400
%closure.func3401 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3389, i32 0, i32 2
store void (i8*, i8*, %SF_INSTRUMENT*)* @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd__3380, void (i8*, i8*, %SF_INSTRUMENT*)** %closure.func3401
%closure_size3402 = call i64 @llvm_zone_mark_size(%mzone* %zone3387)
call void @llvm_zone_ptr_set_size(i8* %clsptr3388, i64 %closure_size3402)
%wrapper_ptr3403 = call i8* @llvm_zone_malloc(%mzone* %zone3387, i64 8)
%closure_wrapper3404 = bitcast i8* %wrapper_ptr3403 to { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**
store { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure3389, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_wrapper3404

; let value assignment
%hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd = select i1 true, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_wrapper3404, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_wrapper3404
store { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd, { i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd
%tmp_envptr3398 = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}***}* %environment3391, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**** %tmp_envptr3398


%val3407 = load {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpdPtr
ret {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %val3407
}


@hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd(%SF_INSTRUMENT* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INSTRUMENT*)*,  void (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_native(%SF_INSTRUMENT* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INSTRUMENT*)*,  void (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3408 = bitcast [94 x i8]* @gsxtmsndfile138 to i8*
call i32 (i8*, ...) @printf(i8* %var3408)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INSTRUMENT*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INSTRUMENT*)*,  void (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INSTRUMENT*}*
%arg_p_0 = getelementptr {%SF_INSTRUMENT*}, {%SF_INSTRUMENT*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfSU5TVFJVTUVOVCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}*, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}, {i8*, i8*, void (i8*, i8*, %SF_INSTRUMENT*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_INSTRUMENT*)*,  void (i8*, i8*, %SF_INSTRUMENT*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile139 = hidden constant [73 x i8] c"zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd\00"
@gsxtmsndfile140 = hidden constant [77 x i8] c"{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %SF_INSTRUMENT* @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd__3409(i8* %_impz,i8* %_impenv, %SF_INSTRUMENT* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3410 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}***, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %SF_INSTRUMENT*
store %SF_INSTRUMENT* %x, %SF_INSTRUMENT** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val3412 = load %mzone*, %mzone** %fromzPtr
%val3413 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
%val3414 = bitcast %SF_INSTRUMENT* %val3413 to i8*
%res3415 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3412, i8* %val3414)
br i1 %res3415, label %then3411, label %else3411

then3411:
%val3416 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val3416)
%zone_ptr3417 = bitcast %mzone* %val3416 to i8*
store i8* %zone_ptr3417, i8** %_impzPtr
%tzone3423 = load i8*, i8** %_impzPtr
%zone3424 = bitcast i8* %tzone3423 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_INSTRUMENT*
%tzone3419 = load i8*, i8** %_impzPtr
%zone3420 = bitcast i8* %tzone3419 to %mzone*
%dat3421 = call i8* @llvm_zone_malloc(%mzone* %zone3420, i64 272)
call i8* @memset(i8* %dat3421, i32 0, i64 272)
%val3422 = bitcast i8* %dat3421 to %SF_INSTRUMENT*

; let value assignment
%obj = select i1 true, %SF_INSTRUMENT* %val3422, %SF_INSTRUMENT* %val3422
store %SF_INSTRUMENT* %obj, %SF_INSTRUMENT** %objPtr

%val3425 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3426 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3427 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3426, i64 0, i32 0
%val3428 = load i32, i32* %val3427
; set tuple
%val3429 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3425, i64 0, i32 0
store i32 %val3428, i32* %val3429
%val3430 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3431 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3432 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3431, i64 0, i32 1
%val3433 = load i8, i8* %val3432
; set tuple
%val3434 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3430, i64 0, i32 1
store i8 %val3433, i8* %val3434
%val3435 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3436 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3437 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3436, i64 0, i32 2
%val3438 = load i8, i8* %val3437
; set tuple
%val3439 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3435, i64 0, i32 2
store i8 %val3438, i8* %val3439
%val3440 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3441 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3442 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3441, i64 0, i32 3
%val3443 = load i8, i8* %val3442
; set tuple
%val3444 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3440, i64 0, i32 3
store i8 %val3443, i8* %val3444
%val3445 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3446 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3447 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3446, i64 0, i32 4
%val3448 = load i8, i8* %val3447
; set tuple
%val3449 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3445, i64 0, i32 4
store i8 %val3448, i8* %val3449
%val3450 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3451 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3452 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3451, i64 0, i32 5
%val3453 = load i8, i8* %val3452
; set tuple
%val3454 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3450, i64 0, i32 5
store i8 %val3453, i8* %val3454
%val3455 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3456 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3457 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3456, i64 0, i32 6
%val3458 = load i8, i8* %val3457
; set tuple
%val3459 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3455, i64 0, i32 6
store i8 %val3458, i8* %val3459
%val3460 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3461 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3462 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3461, i64 0, i32 7
%val3463 = load i32, i32* %val3462
; set tuple
%val3464 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3460, i64 0, i32 7
store i32 %val3463, i32* %val3464
%val3465 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
%val3466 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
; tuple ref
%val3467 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3466, i64 0, i32 8
%val3468 = load [16 x {i32,i32,i32,i32}], [16 x {i32,i32,i32,i32}]* %val3467
; set tuple
%val3469 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val3465, i64 0, i32 8
store [16 x {i32,i32,i32,i32}] %val3468, [16 x {i32,i32,i32,i32}]* %val3469
%oldzone3470 = call %mzone* @llvm_pop_zone_stack()
%newzone3471 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3472 = bitcast %mzone* %newzone3471 to i8*
store i8* %zone_ptr3472, i8** %_impzPtr
%val3473 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %objPtr
ret %SF_INSTRUMENT* %val3473

else3411:
%val3474 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %xPtr
ret %SF_INSTRUMENT* %val3474
}
@gsxtmsndfile141 = hidden constant [126 x i8] c"zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3494 = load i8*, i8** %_impzPtr
%zone3495 = bitcast i8* %tzone3494 to %mzone*

; let assign value to symbol zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3495, i64 8)
%zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}***
%tzone3475 = load i8*, i8** %_impzPtr
%zone3476 = bitcast i8* %tzone3475 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3476)
; malloc closure structure
%clsptr3477 = call i8* @llvm_zone_malloc(%mzone* %zone3476, i64 24)
%closure3478 = bitcast i8* %clsptr3477 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr3479 = call i8* @llvm_zone_malloc(%mzone* %zone3476, i64 8)
%environment3480 = bitcast i8* %envptr3479 to {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable3481 = call %clsvar* @new_address_table()
%var3482 = bitcast [73 x i8]* @gsxtmsndfile139 to i8*
%var3483 = bitcast [77 x i8]* @gsxtmsndfile140 to i8*
%addytable3484 = call %clsvar* @add_address_table(%mzone* %zone3476, i8* %var3482, i32 0, i8* %var3483, i32 3, %clsvar* %addytable3481)
%address-table3485 = bitcast %clsvar* %addytable3484 to i8*

; insert table, function and environment into closure struct
%closure.table3488 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}* %closure3478, i32 0, i32 0
store i8* %address-table3485, i8** %closure.table3488
%closure.env3489 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}* %closure3478, i32 0, i32 1
store i8* %envptr3479, i8** %closure.env3489
%closure.func3490 = getelementptr { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}* %closure3478, i32 0, i32 2
store %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)* @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd__3409, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)** %closure.func3490
%closure_size3491 = call i64 @llvm_zone_mark_size(%mzone* %zone3476)
call void @llvm_zone_ptr_set_size(i8* %clsptr3477, i64 %closure_size3491)
%wrapper_ptr3492 = call i8* @llvm_zone_malloc(%mzone* %zone3476, i64 8)
%closure_wrapper3493 = bitcast i8* %wrapper_ptr3492 to { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}**
store { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}* %closure3478, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}** %closure_wrapper3493

; let value assignment
%zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}** %closure_wrapper3493, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}** %closure_wrapper3493
store { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd, { i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd
%tmp_envptr3487 = getelementptr {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}***}* %environment3480, i32 0, i32 0
store {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}**** %tmp_envptr3487


%val3496 = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}**, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}** %val3496
}


@zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_INSTRUMENT* @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd(%SF_INSTRUMENT* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*,  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %SF_INSTRUMENT* %result
}


define dllexport ccc %SF_INSTRUMENT* @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_native(%SF_INSTRUMENT* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*,  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %SF_INSTRUMENT* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3497 = bitcast [126 x i8]* @gsxtmsndfile141 to i8*
call i32 (i8*, ...) @printf(i8* %var3497)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INSTRUMENT*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3498 = bitcast [126 x i8]* @gsxtmsndfile141 to i8*
call i32 (i8*, ...) @printf(i8* %var3498)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3499 = bitcast [126 x i8]* @gsxtmsndfile141 to i8*
call i32 (i8*, ...) @printf(i8* %var3499)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*,  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %SF_INSTRUMENT* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INSTRUMENT*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%SF_INSTRUMENT*, %mzone*, %mzone*}, {%SF_INSTRUMENT*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %arg_p_0
%arg_p_1 = getelementptr {%SF_INSTRUMENT*, %mzone*, %mzone*}, {%SF_INSTRUMENT*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%SF_INSTRUMENT*, %mzone*, %mzone*}, {%SF_INSTRUMENT*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0lOU1RSVU1FTlQqLFNGX0lOU1RSVU1FTlQqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)*,  %SF_INSTRUMENT* (i8*, i8*, %SF_INSTRUMENT*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_INSTRUMENT* %ff(i8* %_impz, i8* %ee, %SF_INSTRUMENT* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%SF_LOOP_INFO = type {[2 x i8],[2 x i8],i32,i32,float,i32,[6 x i32]}
@gsxtmsndfile142 = hidden constant [94 x i8] c"SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ\00"
@gsxtmsndfile143 = hidden constant [94 x i8] c"{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**\00"
define dllexport fastcc %SF_LOOP_INFO* @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ__3500(i8* %_impz,i8* %_impenv, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3501 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}*
%SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr_ = getelementptr {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}, {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}* %impenv, i32 0, i32 0
%SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**** %SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr_

; setup arguments
%arg_0Ptr = alloca [2 x i8]
store [2 x i8] %arg_0, [2 x i8]* %arg_0Ptr
%arg_1Ptr = alloca [2 x i8]
store [2 x i8] %arg_1, [2 x i8]* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca float
store float %arg_4, float* %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr
%arg_6Ptr = alloca [6 x i32]
store [6 x i32] %arg_6, [6 x i32]* %arg_6Ptr


%tzone3506 = load i8*, i8** %_impzPtr
%zone3507 = bitcast i8* %tzone3506 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_LOOP_INFO*
%tzone3502 = load i8*, i8** %_impzPtr
%zone3503 = bitcast i8* %tzone3502 to %mzone*
%dat3504 = call i8* @llvm_zone_malloc(%mzone* %zone3503, i64 44)
call i8* @memset(i8* %dat3504, i32 0, i64 44)
%val3505 = bitcast i8* %dat3504 to %SF_LOOP_INFO*

; let value assignment
%obj = select i1 true, %SF_LOOP_INFO* %val3505, %SF_LOOP_INFO* %val3505
store %SF_LOOP_INFO* %obj, %SF_LOOP_INFO** %objPtr

%val3508 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3509 = load [2 x i8], [2 x i8]* %arg_0Ptr
; set tuple
%val3510 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3508, i64 0, i32 0
store [2 x i8] %val3509, [2 x i8]* %val3510
%val3511 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3512 = load [2 x i8], [2 x i8]* %arg_1Ptr
; set tuple
%val3513 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3511, i64 0, i32 1
store [2 x i8] %val3512, [2 x i8]* %val3513
%val3514 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3515 = load i32, i32* %arg_2Ptr
; set tuple
%val3516 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3514, i64 0, i32 2
store i32 %val3515, i32* %val3516
%val3517 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3518 = load i32, i32* %arg_3Ptr
; set tuple
%val3519 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3517, i64 0, i32 3
store i32 %val3518, i32* %val3519
%val3520 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3521 = load float, float* %arg_4Ptr
; set tuple
%val3522 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3520, i64 0, i32 4
store float %val3521, float* %val3522
%val3523 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3524 = load i32, i32* %arg_5Ptr
; set tuple
%val3525 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3523, i64 0, i32 5
store i32 %val3524, i32* %val3525
%val3526 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3527 = load [6 x i32], [6 x i32]* %arg_6Ptr
; set tuple
%val3528 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3526, i64 0, i32 6
store [6 x i32] %val3527, [6 x i32]* %val3528
%val3529 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
ret %SF_LOOP_INFO* %val3529
}
@gsxtmsndfile144 = hidden constant [147 x i8] c"SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3549 = load i8*, i8** %_impzPtr
%zone3550 = bitcast i8* %tzone3549 to %mzone*

; let assign value to symbol SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ
%dat_SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ = call i8* @llvm_zone_malloc(%mzone* %zone3550, i64 8)
%SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr = bitcast i8* %dat_SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***
%tzone3530 = load i8*, i8** %_impzPtr
%zone3531 = bitcast i8* %tzone3530 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3531)
; malloc closure structure
%clsptr3532 = call i8* @llvm_zone_malloc(%mzone* %zone3531, i64 24)
%closure3533 = bitcast i8* %clsptr3532 to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*

; malloc environment structure
%envptr3534 = call i8* @llvm_zone_malloc(%mzone* %zone3531, i64 8)
%environment3535 = bitcast i8* %envptr3534 to {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}*

; malloc closure address table
%addytable3536 = call %clsvar* @new_address_table()
%var3537 = bitcast [94 x i8]* @gsxtmsndfile142 to i8*
%var3538 = bitcast [94 x i8]* @gsxtmsndfile143 to i8*
%addytable3539 = call %clsvar* @add_address_table(%mzone* %zone3531, i8* %var3537, i32 0, i8* %var3538, i32 3, %clsvar* %addytable3536)
%address-table3540 = bitcast %clsvar* %addytable3539 to i8*

; insert table, function and environment into closure struct
%closure.table3543 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure3533, i32 0, i32 0
store i8* %address-table3540, i8** %closure.table3543
%closure.env3544 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure3533, i32 0, i32 1
store i8* %envptr3534, i8** %closure.env3544
%closure.func3545 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure3533, i32 0, i32 2
store %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])* @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ__3500, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %closure.func3545
%closure_size3546 = call i64 @llvm_zone_mark_size(%mzone* %zone3531)
call void @llvm_zone_ptr_set_size(i8* %clsptr3532, i64 %closure_size3546)
%wrapper_ptr3547 = call i8* @llvm_zone_malloc(%mzone* %zone3531, i64 8)
%closure_wrapper3548 = bitcast i8* %wrapper_ptr3547 to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
store { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure3533, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_wrapper3548

; let value assignment
%SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ = select i1 true, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_wrapper3548, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_wrapper3548
store { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*** %SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr

; add data to environment
; don't need to alloc for env var SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ
%tmp_envptr3542 = getelementptr {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}, {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}* %environment3535, i32 0, i32 0
store {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*** %SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**** %tmp_envptr3542


%val3551 = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*** %SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr
ret {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %val3551
}


@SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var = dllexport global [1 x i8*] [ i8* null ]

@SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_LOOP_INFO* @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ([2 x i8] %arg_0,[2 x i8] %arg_1,i32 %arg_2,i32 %arg_3,float %arg_4,i32 %arg_5,[6 x i32] %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*,  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6)
ret %SF_LOOP_INFO* %result
}


define dllexport ccc %SF_LOOP_INFO* @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_native([2 x i8] %arg_0,[2 x i8] %arg_1,i32 %arg_2,i32 %arg_3,float %arg_4,i32 %arg_5,[6 x i32] %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*,  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6)
ret %SF_LOOP_INFO* %result
}


define dllexport ccc void @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}*
%arg_p_0 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 0
%arg_0 = load [2 x i8], [2 x i8]* %arg_p_0
%arg_p_1 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 1
%arg_1 = load [2 x i8], [2 x i8]* %arg_p_1
%arg_p_2 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 6
%arg_6 = load [6 x i32], [6 x i32]* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*,  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile145 = hidden constant [96 x i8] c"SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ\00"
define dllexport fastcc %SF_LOOP_INFO* @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ__3556(i8* %_impz,i8* %_impenv, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3557 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}*
%SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr_ = getelementptr {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}, {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}* %impenv, i32 0, i32 0
%SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**** %SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr_

; setup arguments
%arg_0Ptr = alloca [2 x i8]
store [2 x i8] %arg_0, [2 x i8]* %arg_0Ptr
%arg_1Ptr = alloca [2 x i8]
store [2 x i8] %arg_1, [2 x i8]* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca float
store float %arg_4, float* %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr
%arg_6Ptr = alloca [6 x i32]
store [6 x i32] %arg_6, [6 x i32]* %arg_6Ptr


%tzone3562 = load i8*, i8** %_impzPtr
%zone3563 = bitcast i8* %tzone3562 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_LOOP_INFO*
%tzone3558 = load i8*, i8** %_impzPtr
%zone3559 = bitcast i8* %tzone3558 to %mzone*
%dat3560 = call i8* @llvm_zone_malloc(%mzone* %zone3559, i64 44)
call i8* @memset(i8* %dat3560, i32 0, i64 44)
%val3561 = bitcast i8* %dat3560 to %SF_LOOP_INFO*

; let value assignment
%obj = select i1 true, %SF_LOOP_INFO* %val3561, %SF_LOOP_INFO* %val3561
store %SF_LOOP_INFO* %obj, %SF_LOOP_INFO** %objPtr

%val3564 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3565 = load [2 x i8], [2 x i8]* %arg_0Ptr
; set tuple
%val3566 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3564, i64 0, i32 0
store [2 x i8] %val3565, [2 x i8]* %val3566
%val3567 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3568 = load [2 x i8], [2 x i8]* %arg_1Ptr
; set tuple
%val3569 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3567, i64 0, i32 1
store [2 x i8] %val3568, [2 x i8]* %val3569
%val3570 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3571 = load i32, i32* %arg_2Ptr
; set tuple
%val3572 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3570, i64 0, i32 2
store i32 %val3571, i32* %val3572
%val3573 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3574 = load i32, i32* %arg_3Ptr
; set tuple
%val3575 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3573, i64 0, i32 3
store i32 %val3574, i32* %val3575
%val3576 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3577 = load float, float* %arg_4Ptr
; set tuple
%val3578 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3576, i64 0, i32 4
store float %val3577, float* %val3578
%val3579 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3580 = load i32, i32* %arg_5Ptr
; set tuple
%val3581 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3579, i64 0, i32 5
store i32 %val3580, i32* %val3581
%val3582 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3583 = load [6 x i32], [6 x i32]* %arg_6Ptr
; set tuple
%val3584 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3582, i64 0, i32 6
store [6 x i32] %val3583, [6 x i32]* %val3584
%val3585 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
ret %SF_LOOP_INFO* %val3585
}
@gsxtmsndfile146 = hidden constant [149 x i8] c"SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3605 = load i8*, i8** %_impzPtr
%zone3606 = bitcast i8* %tzone3605 to %mzone*

; let assign value to symbol SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ
%dat_SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ = call i8* @llvm_zone_malloc(%mzone* %zone3606, i64 8)
%SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr = bitcast i8* %dat_SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***
%tzone3586 = load i8*, i8** %_impzPtr
%zone3587 = bitcast i8* %tzone3586 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3587)
; malloc closure structure
%clsptr3588 = call i8* @llvm_zone_malloc(%mzone* %zone3587, i64 24)
%closure3589 = bitcast i8* %clsptr3588 to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*

; malloc environment structure
%envptr3590 = call i8* @llvm_zone_malloc(%mzone* %zone3587, i64 8)
%environment3591 = bitcast i8* %envptr3590 to {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}*

; malloc closure address table
%addytable3592 = call %clsvar* @new_address_table()
%var3593 = bitcast [96 x i8]* @gsxtmsndfile145 to i8*
%var3594 = bitcast [94 x i8]* @gsxtmsndfile143 to i8*
%addytable3595 = call %clsvar* @add_address_table(%mzone* %zone3587, i8* %var3593, i32 0, i8* %var3594, i32 3, %clsvar* %addytable3592)
%address-table3596 = bitcast %clsvar* %addytable3595 to i8*

; insert table, function and environment into closure struct
%closure.table3599 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure3589, i32 0, i32 0
store i8* %address-table3596, i8** %closure.table3599
%closure.env3600 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure3589, i32 0, i32 1
store i8* %envptr3590, i8** %closure.env3600
%closure.func3601 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure3589, i32 0, i32 2
store %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])* @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ__3556, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %closure.func3601
%closure_size3602 = call i64 @llvm_zone_mark_size(%mzone* %zone3587)
call void @llvm_zone_ptr_set_size(i8* %clsptr3588, i64 %closure_size3602)
%wrapper_ptr3603 = call i8* @llvm_zone_malloc(%mzone* %zone3587, i64 8)
%closure_wrapper3604 = bitcast i8* %wrapper_ptr3603 to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
store { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure3589, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_wrapper3604

; let value assignment
%SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ = select i1 true, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_wrapper3604, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_wrapper3604
store { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*** %SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr

; add data to environment
; don't need to alloc for env var SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ
%tmp_envptr3598 = getelementptr {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}, {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}* %environment3591, i32 0, i32 0
store {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*** %SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**** %tmp_envptr3598


%val3607 = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*** %SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr
ret {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %val3607
}


@SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var = dllexport global [1 x i8*] [ i8* null ]

@SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_LOOP_INFO* @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ([2 x i8] %arg_0,[2 x i8] %arg_1,i32 %arg_2,i32 %arg_3,float %arg_4,i32 %arg_5,[6 x i32] %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*,  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6)
ret %SF_LOOP_INFO* %result
}


define dllexport ccc %SF_LOOP_INFO* @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_native([2 x i8] %arg_0,[2 x i8] %arg_1,i32 %arg_2,i32 %arg_3,float %arg_4,i32 %arg_5,[6 x i32] %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*,  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6)
ret %SF_LOOP_INFO* %result
}


define dllexport ccc void @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}*
%arg_p_0 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 0
%arg_0 = load [2 x i8], [2 x i8]* %arg_p_0
%arg_p_1 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 1
%arg_1 = load [2 x i8], [2 x i8]* %arg_p_1
%arg_p_2 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 6
%arg_6 = load [6 x i32], [6 x i32]* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_z_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*,  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile147 = hidden constant [96 x i8] c"SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ\00"
define dllexport fastcc %SF_LOOP_INFO* @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ__3612(i8* %_impz,i8* %_impenv, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3613 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}*
%SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr_ = getelementptr {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}, {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}* %impenv, i32 0, i32 0
%SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**** %SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr_

; setup arguments
%arg_0Ptr = alloca [2 x i8]
store [2 x i8] %arg_0, [2 x i8]* %arg_0Ptr
%arg_1Ptr = alloca [2 x i8]
store [2 x i8] %arg_1, [2 x i8]* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca float
store float %arg_4, float* %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr
%arg_6Ptr = alloca [6 x i32]
store [6 x i32] %arg_6, [6 x i32]* %arg_6Ptr


%tzone3616 = load i8*, i8** %_impzPtr
%zone3617 = bitcast i8* %tzone3616 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_LOOP_INFO*
%dat3614 = call i8* @malloc(i64 44)
call i8* @memset(i8* %dat3614, i32 0, i64 44)
%val3615 = bitcast i8* %dat3614 to %SF_LOOP_INFO*

; let value assignment
%obj = select i1 true, %SF_LOOP_INFO* %val3615, %SF_LOOP_INFO* %val3615
store %SF_LOOP_INFO* %obj, %SF_LOOP_INFO** %objPtr

%val3618 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3619 = load [2 x i8], [2 x i8]* %arg_0Ptr
; set tuple
%val3620 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3618, i64 0, i32 0
store [2 x i8] %val3619, [2 x i8]* %val3620
%val3621 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3622 = load [2 x i8], [2 x i8]* %arg_1Ptr
; set tuple
%val3623 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3621, i64 0, i32 1
store [2 x i8] %val3622, [2 x i8]* %val3623
%val3624 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3625 = load i32, i32* %arg_2Ptr
; set tuple
%val3626 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3624, i64 0, i32 2
store i32 %val3625, i32* %val3626
%val3627 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3628 = load i32, i32* %arg_3Ptr
; set tuple
%val3629 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3627, i64 0, i32 3
store i32 %val3628, i32* %val3629
%val3630 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3631 = load float, float* %arg_4Ptr
; set tuple
%val3632 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3630, i64 0, i32 4
store float %val3631, float* %val3632
%val3633 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3634 = load i32, i32* %arg_5Ptr
; set tuple
%val3635 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3633, i64 0, i32 5
store i32 %val3634, i32* %val3635
%val3636 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val3637 = load [6 x i32], [6 x i32]* %arg_6Ptr
; set tuple
%val3638 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3636, i64 0, i32 6
store [6 x i32] %val3637, [6 x i32]* %val3638
%val3639 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
ret %SF_LOOP_INFO* %val3639
}
@gsxtmsndfile148 = hidden constant [149 x i8] c"SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3659 = load i8*, i8** %_impzPtr
%zone3660 = bitcast i8* %tzone3659 to %mzone*

; let assign value to symbol SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ
%dat_SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ = call i8* @llvm_zone_malloc(%mzone* %zone3660, i64 8)
%SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr = bitcast i8* %dat_SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***
%tzone3640 = load i8*, i8** %_impzPtr
%zone3641 = bitcast i8* %tzone3640 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3641)
; malloc closure structure
%clsptr3642 = call i8* @llvm_zone_malloc(%mzone* %zone3641, i64 24)
%closure3643 = bitcast i8* %clsptr3642 to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*

; malloc environment structure
%envptr3644 = call i8* @llvm_zone_malloc(%mzone* %zone3641, i64 8)
%environment3645 = bitcast i8* %envptr3644 to {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}*

; malloc closure address table
%addytable3646 = call %clsvar* @new_address_table()
%var3647 = bitcast [96 x i8]* @gsxtmsndfile147 to i8*
%var3648 = bitcast [94 x i8]* @gsxtmsndfile143 to i8*
%addytable3649 = call %clsvar* @add_address_table(%mzone* %zone3641, i8* %var3647, i32 0, i8* %var3648, i32 3, %clsvar* %addytable3646)
%address-table3650 = bitcast %clsvar* %addytable3649 to i8*

; insert table, function and environment into closure struct
%closure.table3653 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure3643, i32 0, i32 0
store i8* %address-table3650, i8** %closure.table3653
%closure.env3654 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure3643, i32 0, i32 1
store i8* %envptr3644, i8** %closure.env3654
%closure.func3655 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure3643, i32 0, i32 2
store %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])* @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ__3612, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %closure.func3655
%closure_size3656 = call i64 @llvm_zone_mark_size(%mzone* %zone3641)
call void @llvm_zone_ptr_set_size(i8* %clsptr3642, i64 %closure_size3656)
%wrapper_ptr3657 = call i8* @llvm_zone_malloc(%mzone* %zone3641, i64 8)
%closure_wrapper3658 = bitcast i8* %wrapper_ptr3657 to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
store { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure3643, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_wrapper3658

; let value assignment
%SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ = select i1 true, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_wrapper3658, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_wrapper3658
store { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*** %SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr

; add data to environment
; don't need to alloc for env var SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ
%tmp_envptr3652 = getelementptr {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}, {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}* %environment3645, i32 0, i32 0
store {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*** %SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**** %tmp_envptr3652


%val3661 = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*** %SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQPtr
ret {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %val3661
}


@SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var = dllexport global [1 x i8*] [ i8* null ]

@SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_LOOP_INFO* @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ([2 x i8] %arg_0,[2 x i8] %arg_1,i32 %arg_2,i32 %arg_3,float %arg_4,i32 %arg_5,[6 x i32] %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*,  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6)
ret %SF_LOOP_INFO* %result
}


define dllexport ccc %SF_LOOP_INFO* @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_native([2 x i8] %arg_0,[2 x i8] %arg_1,i32 %arg_2,i32 %arg_3,float %arg_4,i32 %arg_5,[6 x i32] %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*,  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6)
ret %SF_LOOP_INFO* %result
}


define dllexport ccc void @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}*
%arg_p_0 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 0
%arg_0 = load [2 x i8], [2 x i8]* %arg_p_0
%arg_p_1 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 1
%arg_1 = load [2 x i8], [2 x i8]* %arg_p_1
%arg_p_2 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 6
%arg_6 = load [6 x i32], [6 x i32]* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_h_adhoc_W1NGX0xPT1BfSU5GTyosfDIsaTh8LHwyLGk4fCxpMzIsaTMyLGZsb2F0LGkzMix8NixpMzJ8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*,  %SF_LOOP_INFO* (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile149 = hidden constant [38 x i8] c"toString_poly_W1N0cmluZyosfDIsaTh8XSo\00"
@gsxtmsndfile150 = hidden constant [45 x i8] c"{i8*, i8*, %String* (i8*, i8*, [2 x i8])*}**\00"
define dllexport fastcc %String* @toString_poly_W1N0cmluZyosfDIsaTh8XSo__3667(i8* %_impz,i8* %_impenv, [2 x i8] %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3668 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, [2 x i8])*}***}*
%toString_poly_W1N0cmluZyosfDIsaTh8XSoPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, [2 x i8])*}***}, {{i8*, i8*, %String* (i8*, i8*, [2 x i8])*}***}* %impenv, i32 0, i32 0
%toString_poly_W1N0cmluZyosfDIsaTh8XSoPtr = load {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}***, {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}**** %toString_poly_W1N0cmluZyosfDIsaTh8XSoPtr_

; setup arguments
%xPtr = alloca [2 x i8]
store [2 x i8] %x, [2 x i8]* %xPtr


%var3669 = bitcast [2 x i8]* @gsxtmsndfile114 to i8*
%res3670 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var3669)
ret %String* %res3670
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}** @toString_poly_W1N0cmluZyosfDIsaTh8XSo_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3690 = load i8*, i8** %_impzPtr
%zone3691 = bitcast i8* %tzone3690 to %mzone*

; let assign value to symbol toString_poly_W1N0cmluZyosfDIsaTh8XSo
%dat_toString_poly_W1N0cmluZyosfDIsaTh8XSo = call i8* @llvm_zone_malloc(%mzone* %zone3691, i64 8)
%toString_poly_W1N0cmluZyosfDIsaTh8XSoPtr = bitcast i8* %dat_toString_poly_W1N0cmluZyosfDIsaTh8XSo to { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}***
%tzone3671 = load i8*, i8** %_impzPtr
%zone3672 = bitcast i8* %tzone3671 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3672)
; malloc closure structure
%clsptr3673 = call i8* @llvm_zone_malloc(%mzone* %zone3672, i64 24)
%closure3674 = bitcast i8* %clsptr3673 to { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}*

; malloc environment structure
%envptr3675 = call i8* @llvm_zone_malloc(%mzone* %zone3672, i64 8)
%environment3676 = bitcast i8* %envptr3675 to {{i8*, i8*, %String* (i8*, i8*, [2 x i8])*}***}*

; malloc closure address table
%addytable3677 = call %clsvar* @new_address_table()
%var3678 = bitcast [38 x i8]* @gsxtmsndfile149 to i8*
%var3679 = bitcast [45 x i8]* @gsxtmsndfile150 to i8*
%addytable3680 = call %clsvar* @add_address_table(%mzone* %zone3672, i8* %var3678, i32 0, i8* %var3679, i32 3, %clsvar* %addytable3677)
%address-table3681 = bitcast %clsvar* %addytable3680 to i8*

; insert table, function and environment into closure struct
%closure.table3684 = getelementptr { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}, { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}* %closure3674, i32 0, i32 0
store i8* %address-table3681, i8** %closure.table3684
%closure.env3685 = getelementptr { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}, { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}* %closure3674, i32 0, i32 1
store i8* %envptr3675, i8** %closure.env3685
%closure.func3686 = getelementptr { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}, { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}* %closure3674, i32 0, i32 2
store %String* (i8*, i8*, [2 x i8])* @toString_poly_W1N0cmluZyosfDIsaTh8XSo__3667, %String* (i8*, i8*, [2 x i8])** %closure.func3686
%closure_size3687 = call i64 @llvm_zone_mark_size(%mzone* %zone3672)
call void @llvm_zone_ptr_set_size(i8* %clsptr3673, i64 %closure_size3687)
%wrapper_ptr3688 = call i8* @llvm_zone_malloc(%mzone* %zone3672, i64 8)
%closure_wrapper3689 = bitcast i8* %wrapper_ptr3688 to { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}**
store { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}* %closure3674, { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}** %closure_wrapper3689

; let value assignment
%toString_poly_W1N0cmluZyosfDIsaTh8XSo = select i1 true, { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}** %closure_wrapper3689, { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}** %closure_wrapper3689
store { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}** %toString_poly_W1N0cmluZyosfDIsaTh8XSo, { i8*, i8*, %String* (i8*, i8*, [2 x i8])*}*** %toString_poly_W1N0cmluZyosfDIsaTh8XSoPtr

; add data to environment
; don't need to alloc for env var toString_poly_W1N0cmluZyosfDIsaTh8XSo
%tmp_envptr3683 = getelementptr {{i8*, i8*, %String* (i8*, i8*, [2 x i8])*}***}, {{i8*, i8*, %String* (i8*, i8*, [2 x i8])*}***}* %environment3676, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}*** %toString_poly_W1N0cmluZyosfDIsaTh8XSoPtr, {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}**** %tmp_envptr3683


%val3692 = load {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}**, {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}*** %toString_poly_W1N0cmluZyosfDIsaTh8XSoPtr
ret {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}** %val3692
}


@toString_poly_W1N0cmluZyosfDIsaTh8XSo_var = dllexport global [1 x i8*] [ i8* null ]

@toString_poly_W1N0cmluZyosfDIsaTh8XSo_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_poly_W1N0cmluZyosfDIsaTh8XSo_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDIsaTh8XSo_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}** @toString_poly_W1N0cmluZyosfDIsaTh8XSo_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_poly_W1N0cmluZyosfDIsaTh8XSo_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_poly_W1N0cmluZyosfDIsaTh8XSo_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDIsaTh8XSo_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_poly_W1N0cmluZyosfDIsaTh8XSo([2 x i8] %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDIsaTh8XSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}*, {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}, {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}, {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, [2 x i8])*,  %String* (i8*, i8*, [2 x i8])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_poly_W1N0cmluZyosfDIsaTh8XSo_native([2 x i8] %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDIsaTh8XSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}*, {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}, {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}, {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, [2 x i8])*,  %String* (i8*, i8*, [2 x i8])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0)
ret %String* %result
}


define dllexport ccc void @toString_poly_W1N0cmluZyosfDIsaTh8XSo_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[2 x i8]}*
%arg_p_0 = getelementptr {[2 x i8]}, {[2 x i8]}* %fstruct, i32 0, i32 0
%arg_0 = load [2 x i8], [2 x i8]* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDIsaTh8XSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}*, {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}, {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}, {i8*, i8*, %String* (i8*, i8*, [2 x i8])*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, [2 x i8])*,  %String* (i8*, i8*, [2 x i8])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile151 = hidden constant [39 x i8] c"toString_poly_W1N0cmluZyosfDYsaTMyfF0q\00"
@gsxtmsndfile152 = hidden constant [46 x i8] c"{i8*, i8*, %String* (i8*, i8*, [6 x i32])*}**\00"
define dllexport fastcc %String* @toString_poly_W1N0cmluZyosfDYsaTMyfF0q__3693(i8* %_impz,i8* %_impenv, [6 x i32] %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3694 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, [6 x i32])*}***}*
%toString_poly_W1N0cmluZyosfDYsaTMyfF0qPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, [6 x i32])*}***}, {{i8*, i8*, %String* (i8*, i8*, [6 x i32])*}***}* %impenv, i32 0, i32 0
%toString_poly_W1N0cmluZyosfDYsaTMyfF0qPtr = load {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}***, {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}**** %toString_poly_W1N0cmluZyosfDYsaTMyfF0qPtr_

; setup arguments
%xPtr = alloca [6 x i32]
store [6 x i32] %x, [6 x i32]* %xPtr


%var3695 = bitcast [2 x i8]* @gsxtmsndfile114 to i8*
%res3696 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var3695)
ret %String* %res3696
}
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}** @toString_poly_W1N0cmluZyosfDYsaTMyfF0q_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3716 = load i8*, i8** %_impzPtr
%zone3717 = bitcast i8* %tzone3716 to %mzone*

; let assign value to symbol toString_poly_W1N0cmluZyosfDYsaTMyfF0q
%dat_toString_poly_W1N0cmluZyosfDYsaTMyfF0q = call i8* @llvm_zone_malloc(%mzone* %zone3717, i64 8)
%toString_poly_W1N0cmluZyosfDYsaTMyfF0qPtr = bitcast i8* %dat_toString_poly_W1N0cmluZyosfDYsaTMyfF0q to { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}***
%tzone3697 = load i8*, i8** %_impzPtr
%zone3698 = bitcast i8* %tzone3697 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3698)
; malloc closure structure
%clsptr3699 = call i8* @llvm_zone_malloc(%mzone* %zone3698, i64 24)
%closure3700 = bitcast i8* %clsptr3699 to { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}*

; malloc environment structure
%envptr3701 = call i8* @llvm_zone_malloc(%mzone* %zone3698, i64 8)
%environment3702 = bitcast i8* %envptr3701 to {{i8*, i8*, %String* (i8*, i8*, [6 x i32])*}***}*

; malloc closure address table
%addytable3703 = call %clsvar* @new_address_table()
%var3704 = bitcast [39 x i8]* @gsxtmsndfile151 to i8*
%var3705 = bitcast [46 x i8]* @gsxtmsndfile152 to i8*
%addytable3706 = call %clsvar* @add_address_table(%mzone* %zone3698, i8* %var3704, i32 0, i8* %var3705, i32 3, %clsvar* %addytable3703)
%address-table3707 = bitcast %clsvar* %addytable3706 to i8*

; insert table, function and environment into closure struct
%closure.table3710 = getelementptr { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}, { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}* %closure3700, i32 0, i32 0
store i8* %address-table3707, i8** %closure.table3710
%closure.env3711 = getelementptr { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}, { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}* %closure3700, i32 0, i32 1
store i8* %envptr3701, i8** %closure.env3711
%closure.func3712 = getelementptr { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}, { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}* %closure3700, i32 0, i32 2
store %String* (i8*, i8*, [6 x i32])* @toString_poly_W1N0cmluZyosfDYsaTMyfF0q__3693, %String* (i8*, i8*, [6 x i32])** %closure.func3712
%closure_size3713 = call i64 @llvm_zone_mark_size(%mzone* %zone3698)
call void @llvm_zone_ptr_set_size(i8* %clsptr3699, i64 %closure_size3713)
%wrapper_ptr3714 = call i8* @llvm_zone_malloc(%mzone* %zone3698, i64 8)
%closure_wrapper3715 = bitcast i8* %wrapper_ptr3714 to { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}**
store { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}* %closure3700, { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}** %closure_wrapper3715

; let value assignment
%toString_poly_W1N0cmluZyosfDYsaTMyfF0q = select i1 true, { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}** %closure_wrapper3715, { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}** %closure_wrapper3715
store { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}** %toString_poly_W1N0cmluZyosfDYsaTMyfF0q, { i8*, i8*, %String* (i8*, i8*, [6 x i32])*}*** %toString_poly_W1N0cmluZyosfDYsaTMyfF0qPtr

; add data to environment
; don't need to alloc for env var toString_poly_W1N0cmluZyosfDYsaTMyfF0q
%tmp_envptr3709 = getelementptr {{i8*, i8*, %String* (i8*, i8*, [6 x i32])*}***}, {{i8*, i8*, %String* (i8*, i8*, [6 x i32])*}***}* %environment3702, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}*** %toString_poly_W1N0cmluZyosfDYsaTMyfF0qPtr, {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}**** %tmp_envptr3709


%val3718 = load {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}**, {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}*** %toString_poly_W1N0cmluZyosfDYsaTMyfF0qPtr
ret {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}** %val3718
}


@toString_poly_W1N0cmluZyosfDYsaTMyfF0q_var = dllexport global [1 x i8*] [ i8* null ]

@toString_poly_W1N0cmluZyosfDYsaTMyfF0q_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_poly_W1N0cmluZyosfDYsaTMyfF0q_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDYsaTMyfF0q_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}** @toString_poly_W1N0cmluZyosfDYsaTMyfF0q_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_poly_W1N0cmluZyosfDYsaTMyfF0q_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_poly_W1N0cmluZyosfDYsaTMyfF0q_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDYsaTMyfF0q_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_poly_W1N0cmluZyosfDYsaTMyfF0q([6 x i32] %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDYsaTMyfF0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}*, {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}, {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}, {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, [6 x i32])*,  %String* (i8*, i8*, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, [6 x i32] %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_poly_W1N0cmluZyosfDYsaTMyfF0q_native([6 x i32] %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDYsaTMyfF0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}*, {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}, {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}, {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, [6 x i32])*,  %String* (i8*, i8*, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, [6 x i32] %arg_0)
ret %String* %result
}


define dllexport ccc void @toString_poly_W1N0cmluZyosfDYsaTMyfF0q_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[6 x i32]}*
%arg_p_0 = getelementptr {[6 x i32]}, {[6 x i32]}* %fstruct, i32 0, i32 0
%arg_0 = load [6 x i32], [6 x i32]* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_poly_W1N0cmluZyosfDYsaTMyfF0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}*, {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}, {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}, {i8*, i8*, %String* (i8*, i8*, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, [6 x i32])*,  %String* (i8*, i8*, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, [6 x i32] %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile153 = hidden constant [20 x i8] c"<SF_LOOP_INFO:null>\00"
@gsxtmsndfile154 = hidden constant [15 x i8] c"<SF_LOOP_INFO:\00"
@gsxtmsndfile155 = hidden constant [47 x i8] c"toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0\00"
@gsxtmsndfile156 = hidden constant [51 x i8] c"{i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0__3666(i8* %_impz,i8* %_impenv, %SF_LOOP_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3719 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}***}*
%toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}***, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}**** %toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0Ptr_

; setup arguments
%xPtr = alloca %SF_LOOP_INFO*
store %SF_LOOP_INFO* %x, %SF_LOOP_INFO** %xPtr


%val3721 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
%val3722 = icmp eq %SF_LOOP_INFO* %val3721, null
br i1 %val3722, label %then3720, label %else3720

then3720:
%zone3723 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone3723)
%zone_ptr3724 = bitcast %mzone* %zone3723 to i8*
store i8* %zone_ptr3724, i8** %_impzPtr
%tzone3734 = load i8*, i8** %_impzPtr
%zone3735 = bitcast i8* %tzone3734 to %mzone*

; let assign value to symbol res10
%res10Ptr = alloca %String*
%tzone3739 = load i8*, i8** %_impzPtr
%zone3740 = bitcast i8* %tzone3739 to %mzone*

; let assign value to symbol zone10
%zone10Ptr = alloca %mzone*
%tzone3742 = load i8*, i8** %_impzPtr
%zone3743 = bitcast i8* %tzone3742 to %mzone*

; let assign value to symbol newz10
%newz10Ptr = alloca %mzone*
%tzone3726 = load i8*, i8** %_impzPtr
%zone3727 = bitcast i8* %tzone3726 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat3725 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat3725, i8* %dat3725
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val3728 = load i8*, i8** %xx_t_mstPtr
%var3729 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3730 = bitcast [20 x i8]* @gsxtmsndfile153 to i8*

%val3731 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3728, i8* %var3729, i8* %var3730)
%val3732 = load i8*, i8** %xx_t_mstPtr
%res3733 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3732)

; let value assignment
%res10 = select i1 true, %String* %res3733, %String* %res3733
store %String* %res10, %String** %res10Ptr

%oldzone3736 = call %mzone* @llvm_pop_zone_stack()
%newzone3737 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3738 = bitcast %mzone* %newzone3737 to i8*
store i8* %zone_ptr3738, i8** %_impzPtr

; let value assignment
%zone10 = select i1 true, %mzone* %oldzone3736, %mzone* %oldzone3736
store %mzone* %zone10, %mzone** %zone10Ptr

%res3741 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz10 = select i1 true, %mzone* %res3741, %mzone* %res3741
store %mzone* %newz10, %mzone** %newz10Ptr

%tzone3748 = load i8*, i8** %_impzPtr
%zone3749 = bitcast i8* %tzone3748 to %mzone*

; let assign value to symbol rescopy10
%rescopy10Ptr = alloca %String*
%tzone3754 = load i8*, i8** %_impzPtr
%zone3755 = bitcast i8* %tzone3754 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone3757 = load i8*, i8** %_impzPtr
%zone3758 = bitcast i8* %tzone3757 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val3744 = load %String*, %String** %res10Ptr
%val3745 = load %mzone*, %mzone** %zone10Ptr
%val3746 = load %mzone*, %mzone** %newz10Ptr
%res3747 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val3744, %mzone* %val3745, %mzone* %val3746)

; let value assignment
%rescopy10 = select i1 true, %String* %res3747, %String* %res3747
store %String* %rescopy10, %String** %rescopy10Ptr

%val3750 = load %mzone*, %mzone** %zone10Ptr
; tuple ref
%val3751 = getelementptr %mzone, %mzone* %val3750, i64 0, i32 4
%val3752 = load i8*, i8** %val3751
%val3753 = bitcast i8* %val3752 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val3753, {i64,i8*,i8*}* %val3753
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null3756 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null3756, {i8*, i8*, void (i8*, i8*)*}** %null3756
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone3794 = load i8*, i8** %_impzPtr
%zone3795 = bitcast i8* %tzone3794 to %mzone*
%ifptr3784 = alloca i1
%ifptr3760 = alloca i1
; while loop
%val3761 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val3762 = icmp eq {i64,i8*,i8*}* %val3761, null
br i1 %val3762, label %then3760, label %else3760

then3760:
%res3763 = call ccc i1 @impc_false()
store i1 %res3763, i1* %ifptr3760
br label %ifcont3760

else3760:
%res3764 = call ccc i1 @impc_true()
store i1 %res3764, i1* %ifptr3760
br label %ifcont3760

ifcont3760:
%ifres3765 = load i1, i1* %ifptr3760

br i1 %ifres3765, label %loop3759, label %after3759

loop3759:
; do set!
%val3766 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val3767 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val3766, i64 0, i32 1
%val3768 = load i8*, i8** %val3767
%val3769 = bitcast i8* %val3768 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val3769, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval3770 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val3771 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval3770
%fPtr3772 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val3771, i32 0, i32 2
%ePtr3773 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val3771, i32 0, i32 1
%f3774 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr3772
%e3775 = load i8*, i8** %ePtr3773
%tzone3776 = load i8*, i8** %_impzPtr
%zone3777 = bitcast i8* %tzone3776 to %mzone*
%z3778 = bitcast %mzone* %zone3777 to i8*
tail call fastcc void %f3774(i8* %z3778, i8* %e3775)
; do set!
%val3780 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val3781 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val3780, i64 0, i32 2
%val3782 = load i8*, i8** %val3781
%val3783 = bitcast i8* %val3782 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val3783, {i64,i8*,i8*}** %hookPtr
%val3785 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val3786 = icmp eq {i64,i8*,i8*}* %val3785, null
br i1 %val3786, label %then3784, label %else3784

then3784:
%res3787 = call ccc i1 @impc_false()
store i1 %res3787, i1* %ifptr3784
br label %ifcont3784

else3784:
%res3788 = call ccc i1 @impc_true()
store i1 %res3788, i1* %ifptr3784
br label %ifcont3784

ifcont3784:
%ifres3789 = load i1, i1* %ifptr3784

br i1 %ifres3789, label %loop3759, label %after3759

after3759:
%val3791 = load %mzone*, %mzone** %zone10Ptr
call ccc void @llvm_zone_destroy(%mzone* %val3791)
%val3793 = load %String*, %String** %rescopy10Ptr
ret %String* %val3793

else3720:
%zone3796 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone3796)
%zone_ptr3797 = bitcast %mzone* %zone3796 to i8*
store i8* %zone_ptr3797, i8** %_impzPtr
%tzone3912 = load i8*, i8** %_impzPtr
%zone3913 = bitcast i8* %tzone3912 to %mzone*

; let assign value to symbol res11
%res11Ptr = alloca %String*
%tzone3917 = load i8*, i8** %_impzPtr
%zone3918 = bitcast i8* %tzone3917 to %mzone*

; let assign value to symbol zone11
%zone11Ptr = alloca %mzone*
%tzone3920 = load i8*, i8** %_impzPtr
%zone3921 = bitcast i8* %tzone3920 to %mzone*

; let assign value to symbol newz11
%newz11Ptr = alloca %mzone*
%tzone3799 = load i8*, i8** %_impzPtr
%zone3800 = bitcast i8* %tzone3799 to %mzone*

; let assign value to symbol xx_t_mst_s_40
%xx_t_mst_s_40Ptr = alloca i8*
%dat3798 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_40 = select i1 true, i8* %dat3798, i8* %dat3798
store i8* %xx_t_mst_s_40, i8** %xx_t_mst_s_40Ptr

%val3801 = load i8*, i8** %xx_t_mst_s_40Ptr
%var3802 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3803 = bitcast [15 x i8]* @gsxtmsndfile154 to i8*

%val3804 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3801, i8* %var3802, i8* %var3803)
%val3805 = load i8*, i8** %xx_t_mst_s_40Ptr
%res3806 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3805)
%val3807 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val3808 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3807, i64 0, i32 0
%val3809 = load [2 x i8], [2 x i8]* %val3808
%res3810 = call fastcc %String* @toString_poly_W1N0cmluZyosfDIsaTh8XSo([2 x i8] %val3809)
%res3811 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3806, %String* %res3810)
%tzone3813 = load i8*, i8** %_impzPtr
%zone3814 = bitcast i8* %tzone3813 to %mzone*

; let assign value to symbol xx_t_mst_s_41
%xx_t_mst_s_41Ptr = alloca i8*
%dat3812 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_41 = select i1 true, i8* %dat3812, i8* %dat3812
store i8* %xx_t_mst_s_41, i8** %xx_t_mst_s_41Ptr

%val3815 = load i8*, i8** %xx_t_mst_s_41Ptr
%var3816 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3817 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3818 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3815, i8* %var3816, i8* %var3817)
%val3819 = load i8*, i8** %xx_t_mst_s_41Ptr
%res3820 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3819)
%res3821 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3811, %String* %res3820)
%val3822 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val3823 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3822, i64 0, i32 1
%val3824 = load [2 x i8], [2 x i8]* %val3823
%res3825 = call fastcc %String* @toString_poly_W1N0cmluZyosfDIsaTh8XSo([2 x i8] %val3824)
%res3826 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3821, %String* %res3825)
%tzone3828 = load i8*, i8** %_impzPtr
%zone3829 = bitcast i8* %tzone3828 to %mzone*

; let assign value to symbol xx_t_mst_s_42
%xx_t_mst_s_42Ptr = alloca i8*
%dat3827 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_42 = select i1 true, i8* %dat3827, i8* %dat3827
store i8* %xx_t_mst_s_42, i8** %xx_t_mst_s_42Ptr

%val3830 = load i8*, i8** %xx_t_mst_s_42Ptr
%var3831 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3832 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3833 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3830, i8* %var3831, i8* %var3832)
%val3834 = load i8*, i8** %xx_t_mst_s_42Ptr
%res3835 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3834)
%res3836 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3826, %String* %res3835)
%val3837 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val3838 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3837, i64 0, i32 2
%val3839 = load i32, i32* %val3838
%res3840 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val3839)
%res3841 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3836, %String* %res3840)
%tzone3843 = load i8*, i8** %_impzPtr
%zone3844 = bitcast i8* %tzone3843 to %mzone*

; let assign value to symbol xx_t_mst_s_43
%xx_t_mst_s_43Ptr = alloca i8*
%dat3842 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_43 = select i1 true, i8* %dat3842, i8* %dat3842
store i8* %xx_t_mst_s_43, i8** %xx_t_mst_s_43Ptr

%val3845 = load i8*, i8** %xx_t_mst_s_43Ptr
%var3846 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3847 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3848 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3845, i8* %var3846, i8* %var3847)
%val3849 = load i8*, i8** %xx_t_mst_s_43Ptr
%res3850 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3849)
%res3851 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3841, %String* %res3850)
%val3852 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val3853 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3852, i64 0, i32 3
%val3854 = load i32, i32* %val3853
%res3855 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val3854)
%res3856 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3851, %String* %res3855)
%tzone3858 = load i8*, i8** %_impzPtr
%zone3859 = bitcast i8* %tzone3858 to %mzone*

; let assign value to symbol xx_t_mst_s_44
%xx_t_mst_s_44Ptr = alloca i8*
%dat3857 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_44 = select i1 true, i8* %dat3857, i8* %dat3857
store i8* %xx_t_mst_s_44, i8** %xx_t_mst_s_44Ptr

%val3860 = load i8*, i8** %xx_t_mst_s_44Ptr
%var3861 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3862 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3863 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3860, i8* %var3861, i8* %var3862)
%val3864 = load i8*, i8** %xx_t_mst_s_44Ptr
%res3865 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3864)
%res3866 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3856, %String* %res3865)
%val3867 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val3868 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3867, i64 0, i32 4
%val3869 = load float, float* %val3868
%res3870 = call fastcc %String* @toString_adhoc_W1N0cmluZyosZmxvYXRd(float %val3869)
%res3871 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3866, %String* %res3870)
%tzone3873 = load i8*, i8** %_impzPtr
%zone3874 = bitcast i8* %tzone3873 to %mzone*

; let assign value to symbol xx_t_mst_s_45
%xx_t_mst_s_45Ptr = alloca i8*
%dat3872 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_45 = select i1 true, i8* %dat3872, i8* %dat3872
store i8* %xx_t_mst_s_45, i8** %xx_t_mst_s_45Ptr

%val3875 = load i8*, i8** %xx_t_mst_s_45Ptr
%var3876 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3877 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3878 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3875, i8* %var3876, i8* %var3877)
%val3879 = load i8*, i8** %xx_t_mst_s_45Ptr
%res3880 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3879)
%res3881 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3871, %String* %res3880)
%val3882 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val3883 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3882, i64 0, i32 5
%val3884 = load i32, i32* %val3883
%res3885 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val3884)
%res3886 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3881, %String* %res3885)
%tzone3888 = load i8*, i8** %_impzPtr
%zone3889 = bitcast i8* %tzone3888 to %mzone*

; let assign value to symbol xx_t_mst_s_46
%xx_t_mst_s_46Ptr = alloca i8*
%dat3887 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_46 = select i1 true, i8* %dat3887, i8* %dat3887
store i8* %xx_t_mst_s_46, i8** %xx_t_mst_s_46Ptr

%val3890 = load i8*, i8** %xx_t_mst_s_46Ptr
%var3891 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3892 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val3893 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3890, i8* %var3891, i8* %var3892)
%val3894 = load i8*, i8** %xx_t_mst_s_46Ptr
%res3895 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3894)
%res3896 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3886, %String* %res3895)
%val3897 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val3898 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val3897, i64 0, i32 6
%val3899 = load [6 x i32], [6 x i32]* %val3898
%res3900 = call fastcc %String* @toString_poly_W1N0cmluZyosfDYsaTMyfF0q([6 x i32] %val3899)
%res3901 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3896, %String* %res3900)
%tzone3903 = load i8*, i8** %_impzPtr
%zone3904 = bitcast i8* %tzone3903 to %mzone*

; let assign value to symbol xx_t_mst_s_47
%xx_t_mst_s_47Ptr = alloca i8*
%dat3902 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_47 = select i1 true, i8* %dat3902, i8* %dat3902
store i8* %xx_t_mst_s_47, i8** %xx_t_mst_s_47Ptr

%val3905 = load i8*, i8** %xx_t_mst_s_47Ptr
%var3906 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var3907 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val3908 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3905, i8* %var3906, i8* %var3907)
%val3909 = load i8*, i8** %xx_t_mst_s_47Ptr
%res3910 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3909)
%res3911 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res3901, %String* %res3910)

; let value assignment
%res11 = select i1 true, %String* %res3911, %String* %res3911
store %String* %res11, %String** %res11Ptr

%oldzone3914 = call %mzone* @llvm_pop_zone_stack()
%newzone3915 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3916 = bitcast %mzone* %newzone3915 to i8*
store i8* %zone_ptr3916, i8** %_impzPtr

; let value assignment
%zone11 = select i1 true, %mzone* %oldzone3914, %mzone* %oldzone3914
store %mzone* %zone11, %mzone** %zone11Ptr

%res3919 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz11 = select i1 true, %mzone* %res3919, %mzone* %res3919
store %mzone* %newz11, %mzone** %newz11Ptr

%tzone3926 = load i8*, i8** %_impzPtr
%zone3927 = bitcast i8* %tzone3926 to %mzone*

; let assign value to symbol rescopy11
%rescopy11Ptr = alloca %String*
%tzone3932 = load i8*, i8** %_impzPtr
%zone3933 = bitcast i8* %tzone3932 to %mzone*

; let assign value to symbol hook_s_48
%hook_s_48Ptr = alloca {i64,i8*,i8*}*
%tzone3935 = load i8*, i8** %_impzPtr
%zone3936 = bitcast i8* %tzone3935 to %mzone*

; let assign value to symbol f_s_49
%f_s_49Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val3922 = load %String*, %String** %res11Ptr
%val3923 = load %mzone*, %mzone** %zone11Ptr
%val3924 = load %mzone*, %mzone** %newz11Ptr
%res3925 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val3922, %mzone* %val3923, %mzone* %val3924)

; let value assignment
%rescopy11 = select i1 true, %String* %res3925, %String* %res3925
store %String* %rescopy11, %String** %rescopy11Ptr

%val3928 = load %mzone*, %mzone** %zone11Ptr
; tuple ref
%val3929 = getelementptr %mzone, %mzone* %val3928, i64 0, i32 4
%val3930 = load i8*, i8** %val3929
%val3931 = bitcast i8* %val3930 to {i64,i8*,i8*}*

; let value assignment
%hook_s_48 = select i1 true, {i64,i8*,i8*}* %val3931, {i64,i8*,i8*}* %val3931
store {i64,i8*,i8*}* %hook_s_48, {i64,i8*,i8*}** %hook_s_48Ptr

%null3934 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_49 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null3934, {i8*, i8*, void (i8*, i8*)*}** %null3934
store {i8*, i8*, void (i8*, i8*)*}** %f_s_49, {i8*, i8*, void (i8*, i8*)*}*** %f_s_49Ptr

; promote local stack var allocations
%tzone3972 = load i8*, i8** %_impzPtr
%zone3973 = bitcast i8* %tzone3972 to %mzone*
%ifptr3962 = alloca i1
%ifptr3938 = alloca i1
; while loop
%val3939 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_48Ptr
%val3940 = icmp eq {i64,i8*,i8*}* %val3939, null
br i1 %val3940, label %then3938, label %else3938

then3938:
%res3941 = call ccc i1 @impc_false()
store i1 %res3941, i1* %ifptr3938
br label %ifcont3938

else3938:
%res3942 = call ccc i1 @impc_true()
store i1 %res3942, i1* %ifptr3938
br label %ifcont3938

ifcont3938:
%ifres3943 = load i1, i1* %ifptr3938

br i1 %ifres3943, label %loop3937, label %after3937

loop3937:
; do set!
%val3944 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_48Ptr
; tuple ref
%val3945 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val3944, i64 0, i32 1
%val3946 = load i8*, i8** %val3945
%val3947 = bitcast i8* %val3946 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val3947, {i8*, i8*, void (i8*, i8*)*}*** %f_s_49Ptr

; apply closure 
%vval3948 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_49Ptr
%val3949 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval3948
%fPtr3950 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val3949, i32 0, i32 2
%ePtr3951 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val3949, i32 0, i32 1
%f3952 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr3950
%e3953 = load i8*, i8** %ePtr3951
%tzone3954 = load i8*, i8** %_impzPtr
%zone3955 = bitcast i8* %tzone3954 to %mzone*
%z3956 = bitcast %mzone* %zone3955 to i8*
tail call fastcc void %f3952(i8* %z3956, i8* %e3953)
; do set!
%val3958 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_48Ptr
; tuple ref
%val3959 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val3958, i64 0, i32 2
%val3960 = load i8*, i8** %val3959
%val3961 = bitcast i8* %val3960 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val3961, {i64,i8*,i8*}** %hook_s_48Ptr
%val3963 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_48Ptr
%val3964 = icmp eq {i64,i8*,i8*}* %val3963, null
br i1 %val3964, label %then3962, label %else3962

then3962:
%res3965 = call ccc i1 @impc_false()
store i1 %res3965, i1* %ifptr3962
br label %ifcont3962

else3962:
%res3966 = call ccc i1 @impc_true()
store i1 %res3966, i1* %ifptr3962
br label %ifcont3962

ifcont3962:
%ifres3967 = load i1, i1* %ifptr3962

br i1 %ifres3967, label %loop3937, label %after3937

after3937:
%val3969 = load %mzone*, %mzone** %zone11Ptr
call ccc void @llvm_zone_destroy(%mzone* %val3969)
%val3971 = load %String*, %String** %rescopy11Ptr
ret %String* %val3971
}
@gsxtmsndfile157 = hidden constant [100 x i8] c"toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}** @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3993 = load i8*, i8** %_impzPtr
%zone3994 = bitcast i8* %tzone3993 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0
%dat_toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3994, i64 8)
%toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0 to { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}***
%tzone3974 = load i8*, i8** %_impzPtr
%zone3975 = bitcast i8* %tzone3974 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3975)
; malloc closure structure
%clsptr3976 = call i8* @llvm_zone_malloc(%mzone* %zone3975, i64 24)
%closure3977 = bitcast i8* %clsptr3976 to { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}*

; malloc environment structure
%envptr3978 = call i8* @llvm_zone_malloc(%mzone* %zone3975, i64 8)
%environment3979 = bitcast i8* %envptr3978 to {{i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}***}*

; malloc closure address table
%addytable3980 = call %clsvar* @new_address_table()
%var3981 = bitcast [47 x i8]* @gsxtmsndfile155 to i8*
%var3982 = bitcast [51 x i8]* @gsxtmsndfile156 to i8*
%addytable3983 = call %clsvar* @add_address_table(%mzone* %zone3975, i8* %var3981, i32 0, i8* %var3982, i32 3, %clsvar* %addytable3980)
%address-table3984 = bitcast %clsvar* %addytable3983 to i8*

; insert table, function and environment into closure struct
%closure.table3987 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure3977, i32 0, i32 0
store i8* %address-table3984, i8** %closure.table3987
%closure.env3988 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure3977, i32 0, i32 1
store i8* %envptr3978, i8** %closure.env3988
%closure.func3989 = getelementptr { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}, { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure3977, i32 0, i32 2
store %String* (i8*, i8*, %SF_LOOP_INFO*)* @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0__3666, %String* (i8*, i8*, %SF_LOOP_INFO*)** %closure.func3989
%closure_size3990 = call i64 @llvm_zone_mark_size(%mzone* %zone3975)
call void @llvm_zone_ptr_set_size(i8* %clsptr3976, i64 %closure_size3990)
%wrapper_ptr3991 = call i8* @llvm_zone_malloc(%mzone* %zone3975, i64 8)
%closure_wrapper3992 = bitcast i8* %wrapper_ptr3991 to { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}**
store { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure3977, { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_wrapper3992

; let value assignment
%toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_wrapper3992, { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_wrapper3992
store { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}** %toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0, { i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0
%tmp_envptr3986 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}***}* %environment3979, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}**** %tmp_envptr3986


%val3995 = load {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}**, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}*** %toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}** %val3995
}


@toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}** @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0(%SF_LOOP_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_LOOP_INFO*)*,  %String* (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_native(%SF_LOOP_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_LOOP_INFO*)*,  %String* (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3996 = bitcast [100 x i8]* @gsxtmsndfile157 to i8*
call i32 (i8*, ...) @printf(i8* %var3996)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_LOOP_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_LOOP_INFO*)*,  %String* (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_LOOP_INFO*}*
%arg_p_0 = getelementptr {%SF_LOOP_INFO*}, {%SF_LOOP_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %String* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %SF_LOOP_INFO*)*,  %String* (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile158 = hidden constant [31 x i8] c"print_poly_W3ZvaWQsfDIsaTh8XSo\00"
@gsxtmsndfile159 = hidden constant [41 x i8] c"{i8*, i8*, void (i8*, i8*, [2 x i8])*}**\00"
define dllexport fastcc void @print_poly_W3ZvaWQsfDIsaTh8XSo__3998(i8* %_impz,i8* %_impenv, [2 x i8] %arr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3999 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, [2 x i8])*}***}*
%print_poly_W3ZvaWQsfDIsaTh8XSoPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, [2 x i8])*}***}, {{i8*, i8*, void (i8*, i8*, [2 x i8])*}***}* %impenv, i32 0, i32 0
%print_poly_W3ZvaWQsfDIsaTh8XSoPtr = load {i8*, i8*, void (i8*, i8*, [2 x i8])*}***, {i8*, i8*, void (i8*, i8*, [2 x i8])*}**** %print_poly_W3ZvaWQsfDIsaTh8XSoPtr_

; setup arguments
%arrPtr = alloca [2 x i8]
store [2 x i8] %arr, [2 x i8]* %arrPtr


%tzone4000 = load i8*, i8** %_impzPtr
%zone4001 = bitcast i8* %tzone4000 to %mzone*

; let assign value to symbol a1
%a1Ptr = alloca [2 x i8]*

; let value assignment
%a1 = select i1 true, [2 x i8]* %arrPtr, [2 x i8]* %arrPtr
store [2 x i8]* %a1, [2 x i8]** %a1Ptr

%var4002 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4003 = bitcast [2 x i8]* @gsxtmsndfile125 to i8*

%val4004 = call i32 (i8*, ...) @printf(i8* %var4002, i8* %var4003)
%val4005 = load [2 x i8]*, [2 x i8]** %a1Ptr
; array ref
%_val4006 = getelementptr [2 x i8], [2 x i8]* %val4005, i32 0, i64 0
%val4007 = load i8, i8* %_val4006
call fastcc void @print_adhoc_W3ZvaWQsaThd(i8 %val4007)
%tzone4011 = load i8*, i8** %_impzPtr
%zone4012 = bitcast i8* %tzone4011 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val4010 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val4010, i64 %val4010
store i64 %i, i64* %iPtr

; setup loop
%val4015 = sub i64 2, 1
store i64 0, i64* %iPtr
%val4026 = load i64, i64* %iPtr
%num4027 = add i64 %val4015, %val4026
%comp4028 = icmp ult i64 %val4015, 1
br i1 %comp4028, label %after4013, label %loop4013

loop4013:
%var4016 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4017 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val4018 = call i32 (i8*, ...) @printf(i8* %var4016, i8* %var4017)
%val4019 = load i64, i64* %iPtr
%val4020 = add i64 1, %val4019
%val4021 = load [2 x i8]*, [2 x i8]** %a1Ptr
; array ref
%_val4022 = getelementptr [2 x i8], [2 x i8]* %val4021, i32 0, i64 %val4020
%val4023 = load i8, i8* %_val4022
call fastcc void @print_adhoc_W3ZvaWQsaThd(i8 %val4023)
%loop_cnt4013 = load i64, i64* %iPtr
%next4013 = add i64 %loop_cnt4013, 1
store i64 %next4013, i64* %iPtr
%cmp4013 = icmp ult i64 %next4013, %num4027
br i1 %cmp4013, label %loop4013, label %after4013

after4013:
%var4030 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4031 = bitcast [2 x i8]* @gsxtmsndfile125 to i8*

%val4032 = call i32 (i8*, ...) @printf(i8* %var4030, i8* %var4031)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*, [2 x i8])*}** @print_poly_W3ZvaWQsfDIsaTh8XSo_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4054 = load i8*, i8** %_impzPtr
%zone4055 = bitcast i8* %tzone4054 to %mzone*

; let assign value to symbol print_poly_W3ZvaWQsfDIsaTh8XSo
%dat_print_poly_W3ZvaWQsfDIsaTh8XSo = call i8* @llvm_zone_malloc(%mzone* %zone4055, i64 8)
%print_poly_W3ZvaWQsfDIsaTh8XSoPtr = bitcast i8* %dat_print_poly_W3ZvaWQsfDIsaTh8XSo to { i8*, i8*, void (i8*, i8*, [2 x i8])*}***
%tzone4035 = load i8*, i8** %_impzPtr
%zone4036 = bitcast i8* %tzone4035 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4036)
; malloc closure structure
%clsptr4037 = call i8* @llvm_zone_malloc(%mzone* %zone4036, i64 24)
%closure4038 = bitcast i8* %clsptr4037 to { i8*, i8*, void (i8*, i8*, [2 x i8])*}*

; malloc environment structure
%envptr4039 = call i8* @llvm_zone_malloc(%mzone* %zone4036, i64 8)
%environment4040 = bitcast i8* %envptr4039 to {{i8*, i8*, void (i8*, i8*, [2 x i8])*}***}*

; malloc closure address table
%addytable4041 = call %clsvar* @new_address_table()
%var4042 = bitcast [31 x i8]* @gsxtmsndfile158 to i8*
%var4043 = bitcast [41 x i8]* @gsxtmsndfile159 to i8*
%addytable4044 = call %clsvar* @add_address_table(%mzone* %zone4036, i8* %var4042, i32 0, i8* %var4043, i32 3, %clsvar* %addytable4041)
%address-table4045 = bitcast %clsvar* %addytable4044 to i8*

; insert table, function and environment into closure struct
%closure.table4048 = getelementptr { i8*, i8*, void (i8*, i8*, [2 x i8])*}, { i8*, i8*, void (i8*, i8*, [2 x i8])*}* %closure4038, i32 0, i32 0
store i8* %address-table4045, i8** %closure.table4048
%closure.env4049 = getelementptr { i8*, i8*, void (i8*, i8*, [2 x i8])*}, { i8*, i8*, void (i8*, i8*, [2 x i8])*}* %closure4038, i32 0, i32 1
store i8* %envptr4039, i8** %closure.env4049
%closure.func4050 = getelementptr { i8*, i8*, void (i8*, i8*, [2 x i8])*}, { i8*, i8*, void (i8*, i8*, [2 x i8])*}* %closure4038, i32 0, i32 2
store void (i8*, i8*, [2 x i8])* @print_poly_W3ZvaWQsfDIsaTh8XSo__3998, void (i8*, i8*, [2 x i8])** %closure.func4050
%closure_size4051 = call i64 @llvm_zone_mark_size(%mzone* %zone4036)
call void @llvm_zone_ptr_set_size(i8* %clsptr4037, i64 %closure_size4051)
%wrapper_ptr4052 = call i8* @llvm_zone_malloc(%mzone* %zone4036, i64 8)
%closure_wrapper4053 = bitcast i8* %wrapper_ptr4052 to { i8*, i8*, void (i8*, i8*, [2 x i8])*}**
store { i8*, i8*, void (i8*, i8*, [2 x i8])*}* %closure4038, { i8*, i8*, void (i8*, i8*, [2 x i8])*}** %closure_wrapper4053

; let value assignment
%print_poly_W3ZvaWQsfDIsaTh8XSo = select i1 true, { i8*, i8*, void (i8*, i8*, [2 x i8])*}** %closure_wrapper4053, { i8*, i8*, void (i8*, i8*, [2 x i8])*}** %closure_wrapper4053
store { i8*, i8*, void (i8*, i8*, [2 x i8])*}** %print_poly_W3ZvaWQsfDIsaTh8XSo, { i8*, i8*, void (i8*, i8*, [2 x i8])*}*** %print_poly_W3ZvaWQsfDIsaTh8XSoPtr

; add data to environment
; don't need to alloc for env var print_poly_W3ZvaWQsfDIsaTh8XSo
%tmp_envptr4047 = getelementptr {{i8*, i8*, void (i8*, i8*, [2 x i8])*}***}, {{i8*, i8*, void (i8*, i8*, [2 x i8])*}***}* %environment4040, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, [2 x i8])*}*** %print_poly_W3ZvaWQsfDIsaTh8XSoPtr, {i8*, i8*, void (i8*, i8*, [2 x i8])*}**** %tmp_envptr4047


%val4056 = load {i8*, i8*, void (i8*, i8*, [2 x i8])*}**, {i8*, i8*, void (i8*, i8*, [2 x i8])*}*** %print_poly_W3ZvaWQsfDIsaTh8XSoPtr
ret {i8*, i8*, void (i8*, i8*, [2 x i8])*}** %val4056
}


@print_poly_W3ZvaWQsfDIsaTh8XSo_var = dllexport global [1 x i8*] [ i8* null ]

@print_poly_W3ZvaWQsfDIsaTh8XSo_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_poly_W3ZvaWQsfDIsaTh8XSo_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDIsaTh8XSo_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, [2 x i8])*}** @print_poly_W3ZvaWQsfDIsaTh8XSo_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, [2 x i8])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_poly_W3ZvaWQsfDIsaTh8XSo_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_poly_W3ZvaWQsfDIsaTh8XSo_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDIsaTh8XSo_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_poly_W3ZvaWQsfDIsaTh8XSo([2 x i8] %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDIsaTh8XSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, [2 x i8])*}**
%closure = load {i8*, i8*, void (i8*, i8*, [2 x i8])*}*, {i8*, i8*, void (i8*, i8*, [2 x i8])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, [2 x i8])*}, {i8*, i8*, void (i8*, i8*, [2 x i8])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, [2 x i8])*}, {i8*, i8*, void (i8*, i8*, [2 x i8])*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, [2 x i8])*,  void (i8*, i8*, [2 x i8])** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0)
ret void
}


define dllexport ccc void @print_poly_W3ZvaWQsfDIsaTh8XSo_native([2 x i8] %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDIsaTh8XSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, [2 x i8])*}**
%closure = load {i8*, i8*, void (i8*, i8*, [2 x i8])*}*, {i8*, i8*, void (i8*, i8*, [2 x i8])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, [2 x i8])*}, {i8*, i8*, void (i8*, i8*, [2 x i8])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, [2 x i8])*}, {i8*, i8*, void (i8*, i8*, [2 x i8])*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, [2 x i8])*,  void (i8*, i8*, [2 x i8])** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0)
ret void
}


define dllexport ccc void @print_poly_W3ZvaWQsfDIsaTh8XSo_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[2 x i8]}*
%arg_p_0 = getelementptr {[2 x i8]}, {[2 x i8]}* %fstruct, i32 0, i32 0
%arg_0 = load [2 x i8], [2 x i8]* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDIsaTh8XSo_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, [2 x i8])*}**
%closure = load {i8*, i8*, void (i8*, i8*, [2 x i8])*}*, {i8*, i8*, void (i8*, i8*, [2 x i8])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, [2 x i8])*}, {i8*, i8*, void (i8*, i8*, [2 x i8])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, [2 x i8])*}, {i8*, i8*, void (i8*, i8*, [2 x i8])*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, [2 x i8])*,  void (i8*, i8*, [2 x i8])** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile160 = hidden constant [32 x i8] c"print_poly_W3ZvaWQsfDYsaTMyfF0q\00"
@gsxtmsndfile161 = hidden constant [42 x i8] c"{i8*, i8*, void (i8*, i8*, [6 x i32])*}**\00"
define dllexport fastcc void @print_poly_W3ZvaWQsfDYsaTMyfF0q__4057(i8* %_impz,i8* %_impenv, [6 x i32] %arr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4058 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, [6 x i32])*}***}*
%print_poly_W3ZvaWQsfDYsaTMyfF0qPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, [6 x i32])*}***}, {{i8*, i8*, void (i8*, i8*, [6 x i32])*}***}* %impenv, i32 0, i32 0
%print_poly_W3ZvaWQsfDYsaTMyfF0qPtr = load {i8*, i8*, void (i8*, i8*, [6 x i32])*}***, {i8*, i8*, void (i8*, i8*, [6 x i32])*}**** %print_poly_W3ZvaWQsfDYsaTMyfF0qPtr_

; setup arguments
%arrPtr = alloca [6 x i32]
store [6 x i32] %arr, [6 x i32]* %arrPtr


%tzone4059 = load i8*, i8** %_impzPtr
%zone4060 = bitcast i8* %tzone4059 to %mzone*

; let assign value to symbol a1
%a1Ptr = alloca [6 x i32]*

; let value assignment
%a1 = select i1 true, [6 x i32]* %arrPtr, [6 x i32]* %arrPtr
store [6 x i32]* %a1, [6 x i32]** %a1Ptr

%var4061 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4062 = bitcast [2 x i8]* @gsxtmsndfile125 to i8*

%val4063 = call i32 (i8*, ...) @printf(i8* %var4061, i8* %var4062)
%val4064 = load [6 x i32]*, [6 x i32]** %a1Ptr
; array ref
%_val4065 = getelementptr [6 x i32], [6 x i32]* %val4064, i32 0, i64 0
%val4066 = load i32, i32* %_val4065
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4066)
%tzone4070 = load i8*, i8** %_impzPtr
%zone4071 = bitcast i8* %tzone4070 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val4069 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val4069, i64 %val4069
store i64 %i, i64* %iPtr

; setup loop
%val4074 = sub i64 6, 1
store i64 0, i64* %iPtr
%val4085 = load i64, i64* %iPtr
%num4086 = add i64 %val4074, %val4085
%comp4087 = icmp ult i64 %val4074, 1
br i1 %comp4087, label %after4072, label %loop4072

loop4072:
%var4075 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4076 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val4077 = call i32 (i8*, ...) @printf(i8* %var4075, i8* %var4076)
%val4078 = load i64, i64* %iPtr
%val4079 = add i64 1, %val4078
%val4080 = load [6 x i32]*, [6 x i32]** %a1Ptr
; array ref
%_val4081 = getelementptr [6 x i32], [6 x i32]* %val4080, i32 0, i64 %val4079
%val4082 = load i32, i32* %_val4081
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4082)
%loop_cnt4072 = load i64, i64* %iPtr
%next4072 = add i64 %loop_cnt4072, 1
store i64 %next4072, i64* %iPtr
%cmp4072 = icmp ult i64 %next4072, %num4086
br i1 %cmp4072, label %loop4072, label %after4072

after4072:
%var4089 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4090 = bitcast [2 x i8]* @gsxtmsndfile125 to i8*

%val4091 = call i32 (i8*, ...) @printf(i8* %var4089, i8* %var4090)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*, [6 x i32])*}** @print_poly_W3ZvaWQsfDYsaTMyfF0q_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4113 = load i8*, i8** %_impzPtr
%zone4114 = bitcast i8* %tzone4113 to %mzone*

; let assign value to symbol print_poly_W3ZvaWQsfDYsaTMyfF0q
%dat_print_poly_W3ZvaWQsfDYsaTMyfF0q = call i8* @llvm_zone_malloc(%mzone* %zone4114, i64 8)
%print_poly_W3ZvaWQsfDYsaTMyfF0qPtr = bitcast i8* %dat_print_poly_W3ZvaWQsfDYsaTMyfF0q to { i8*, i8*, void (i8*, i8*, [6 x i32])*}***
%tzone4094 = load i8*, i8** %_impzPtr
%zone4095 = bitcast i8* %tzone4094 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4095)
; malloc closure structure
%clsptr4096 = call i8* @llvm_zone_malloc(%mzone* %zone4095, i64 24)
%closure4097 = bitcast i8* %clsptr4096 to { i8*, i8*, void (i8*, i8*, [6 x i32])*}*

; malloc environment structure
%envptr4098 = call i8* @llvm_zone_malloc(%mzone* %zone4095, i64 8)
%environment4099 = bitcast i8* %envptr4098 to {{i8*, i8*, void (i8*, i8*, [6 x i32])*}***}*

; malloc closure address table
%addytable4100 = call %clsvar* @new_address_table()
%var4101 = bitcast [32 x i8]* @gsxtmsndfile160 to i8*
%var4102 = bitcast [42 x i8]* @gsxtmsndfile161 to i8*
%addytable4103 = call %clsvar* @add_address_table(%mzone* %zone4095, i8* %var4101, i32 0, i8* %var4102, i32 3, %clsvar* %addytable4100)
%address-table4104 = bitcast %clsvar* %addytable4103 to i8*

; insert table, function and environment into closure struct
%closure.table4107 = getelementptr { i8*, i8*, void (i8*, i8*, [6 x i32])*}, { i8*, i8*, void (i8*, i8*, [6 x i32])*}* %closure4097, i32 0, i32 0
store i8* %address-table4104, i8** %closure.table4107
%closure.env4108 = getelementptr { i8*, i8*, void (i8*, i8*, [6 x i32])*}, { i8*, i8*, void (i8*, i8*, [6 x i32])*}* %closure4097, i32 0, i32 1
store i8* %envptr4098, i8** %closure.env4108
%closure.func4109 = getelementptr { i8*, i8*, void (i8*, i8*, [6 x i32])*}, { i8*, i8*, void (i8*, i8*, [6 x i32])*}* %closure4097, i32 0, i32 2
store void (i8*, i8*, [6 x i32])* @print_poly_W3ZvaWQsfDYsaTMyfF0q__4057, void (i8*, i8*, [6 x i32])** %closure.func4109
%closure_size4110 = call i64 @llvm_zone_mark_size(%mzone* %zone4095)
call void @llvm_zone_ptr_set_size(i8* %clsptr4096, i64 %closure_size4110)
%wrapper_ptr4111 = call i8* @llvm_zone_malloc(%mzone* %zone4095, i64 8)
%closure_wrapper4112 = bitcast i8* %wrapper_ptr4111 to { i8*, i8*, void (i8*, i8*, [6 x i32])*}**
store { i8*, i8*, void (i8*, i8*, [6 x i32])*}* %closure4097, { i8*, i8*, void (i8*, i8*, [6 x i32])*}** %closure_wrapper4112

; let value assignment
%print_poly_W3ZvaWQsfDYsaTMyfF0q = select i1 true, { i8*, i8*, void (i8*, i8*, [6 x i32])*}** %closure_wrapper4112, { i8*, i8*, void (i8*, i8*, [6 x i32])*}** %closure_wrapper4112
store { i8*, i8*, void (i8*, i8*, [6 x i32])*}** %print_poly_W3ZvaWQsfDYsaTMyfF0q, { i8*, i8*, void (i8*, i8*, [6 x i32])*}*** %print_poly_W3ZvaWQsfDYsaTMyfF0qPtr

; add data to environment
; don't need to alloc for env var print_poly_W3ZvaWQsfDYsaTMyfF0q
%tmp_envptr4106 = getelementptr {{i8*, i8*, void (i8*, i8*, [6 x i32])*}***}, {{i8*, i8*, void (i8*, i8*, [6 x i32])*}***}* %environment4099, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, [6 x i32])*}*** %print_poly_W3ZvaWQsfDYsaTMyfF0qPtr, {i8*, i8*, void (i8*, i8*, [6 x i32])*}**** %tmp_envptr4106


%val4115 = load {i8*, i8*, void (i8*, i8*, [6 x i32])*}**, {i8*, i8*, void (i8*, i8*, [6 x i32])*}*** %print_poly_W3ZvaWQsfDYsaTMyfF0qPtr
ret {i8*, i8*, void (i8*, i8*, [6 x i32])*}** %val4115
}


@print_poly_W3ZvaWQsfDYsaTMyfF0q_var = dllexport global [1 x i8*] [ i8* null ]

@print_poly_W3ZvaWQsfDYsaTMyfF0q_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_poly_W3ZvaWQsfDYsaTMyfF0q_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDYsaTMyfF0q_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, [6 x i32])*}** @print_poly_W3ZvaWQsfDYsaTMyfF0q_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, [6 x i32])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_poly_W3ZvaWQsfDYsaTMyfF0q_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_poly_W3ZvaWQsfDYsaTMyfF0q_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDYsaTMyfF0q_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_poly_W3ZvaWQsfDYsaTMyfF0q([6 x i32] %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDYsaTMyfF0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, [6 x i32])*}**
%closure = load {i8*, i8*, void (i8*, i8*, [6 x i32])*}*, {i8*, i8*, void (i8*, i8*, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, [6 x i32])*}, {i8*, i8*, void (i8*, i8*, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, [6 x i32])*}, {i8*, i8*, void (i8*, i8*, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, [6 x i32])*,  void (i8*, i8*, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, [6 x i32] %arg_0)
ret void
}


define dllexport ccc void @print_poly_W3ZvaWQsfDYsaTMyfF0q_native([6 x i32] %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDYsaTMyfF0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, [6 x i32])*}**
%closure = load {i8*, i8*, void (i8*, i8*, [6 x i32])*}*, {i8*, i8*, void (i8*, i8*, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, [6 x i32])*}, {i8*, i8*, void (i8*, i8*, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, [6 x i32])*}, {i8*, i8*, void (i8*, i8*, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, [6 x i32])*,  void (i8*, i8*, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, [6 x i32] %arg_0)
ret void
}


define dllexport ccc void @print_poly_W3ZvaWQsfDYsaTMyfF0q_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[6 x i32]}*
%arg_p_0 = getelementptr {[6 x i32]}, {[6 x i32]}* %fstruct, i32 0, i32 0
%arg_0 = load [6 x i32], [6 x i32]* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_poly_W3ZvaWQsfDYsaTMyfF0q_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, [6 x i32])*}**
%closure = load {i8*, i8*, void (i8*, i8*, [6 x i32])*}*, {i8*, i8*, void (i8*, i8*, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, [6 x i32])*}, {i8*, i8*, void (i8*, i8*, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, [6 x i32])*}, {i8*, i8*, void (i8*, i8*, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, [6 x i32])*,  void (i8*, i8*, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, [6 x i32] %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile162 = hidden constant [40 x i8] c"print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0\00"
@gsxtmsndfile163 = hidden constant [47 x i8] c"{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0__3997(i8* %_impz,i8* %_impenv, %SF_LOOP_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4116 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***}*
%print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**** %print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr_

; setup arguments
%xPtr = alloca %SF_LOOP_INFO*
store %SF_LOOP_INFO* %x, %SF_LOOP_INFO** %xPtr


%val4118 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
%val4119 = icmp eq %SF_LOOP_INFO* %val4118, null
br i1 %val4119, label %then4117, label %else4117

then4117:
%var4120 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4121 = bitcast [20 x i8]* @gsxtmsndfile153 to i8*

%val4122 = call i32 (i8*, ...) @printf(i8* %var4120, i8* %var4121)
br label %ifcont4117

else4117:
%var4124 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4125 = bitcast [15 x i8]* @gsxtmsndfile154 to i8*

%val4126 = call i32 (i8*, ...) @printf(i8* %var4124, i8* %var4125)
%val4127 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4128 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4127, i64 0, i32 0
%val4129 = load [2 x i8], [2 x i8]* %val4128
call fastcc void @print_poly_W3ZvaWQsfDIsaTh8XSo([2 x i8] %val4129)
%var4131 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4132 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val4133 = call i32 (i8*, ...) @printf(i8* %var4131, i8* %var4132)
%val4134 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4135 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4134, i64 0, i32 1
%val4136 = load [2 x i8], [2 x i8]* %val4135
call fastcc void @print_poly_W3ZvaWQsfDIsaTh8XSo([2 x i8] %val4136)
%var4138 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4139 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val4140 = call i32 (i8*, ...) @printf(i8* %var4138, i8* %var4139)
%val4141 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4142 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4141, i64 0, i32 2
%val4143 = load i32, i32* %val4142
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4143)
%var4145 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4146 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val4147 = call i32 (i8*, ...) @printf(i8* %var4145, i8* %var4146)
%val4148 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4149 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4148, i64 0, i32 3
%val4150 = load i32, i32* %val4149
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4150)
%var4152 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4153 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val4154 = call i32 (i8*, ...) @printf(i8* %var4152, i8* %var4153)
%val4155 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4156 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4155, i64 0, i32 4
%val4157 = load float, float* %val4156
call fastcc void @print_adhoc_W3ZvaWQsZmxvYXRd(float %val4157)
%var4159 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4160 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val4161 = call i32 (i8*, ...) @printf(i8* %var4159, i8* %var4160)
%val4162 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4163 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4162, i64 0, i32 5
%val4164 = load i32, i32* %val4163
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4164)
%var4166 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4167 = bitcast [2 x i8]* @gsxtmsndfile10 to i8*

%val4168 = call i32 (i8*, ...) @printf(i8* %var4166, i8* %var4167)
%val4169 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4170 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4169, i64 0, i32 6
%val4171 = load [6 x i32], [6 x i32]* %val4170
call fastcc void @print_poly_W3ZvaWQsfDYsaTMyfF0q([6 x i32] %val4171)
%var4173 = bitcast [3 x i8]* @gsxtmsndfile7 to i8*
%var4174 = bitcast [2 x i8]* @gsxtmsndfile11 to i8*

%val4175 = call i32 (i8*, ...) @printf(i8* %var4173, i8* %var4174)
br label %ifcont4117

ifcont4117:
ret void
}
@gsxtmsndfile164 = hidden constant [93 x i8] c"print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4197 = load i8*, i8** %_impzPtr
%zone4198 = bitcast i8* %tzone4197 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0
%dat_print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4198, i64 8)
%print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0 to { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***
%tzone4178 = load i8*, i8** %_impzPtr
%zone4179 = bitcast i8* %tzone4178 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4179)
; malloc closure structure
%clsptr4180 = call i8* @llvm_zone_malloc(%mzone* %zone4179, i64 24)
%closure4181 = bitcast i8* %clsptr4180 to { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*

; malloc environment structure
%envptr4182 = call i8* @llvm_zone_malloc(%mzone* %zone4179, i64 8)
%environment4183 = bitcast i8* %envptr4182 to {{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***}*

; malloc closure address table
%addytable4184 = call %clsvar* @new_address_table()
%var4185 = bitcast [40 x i8]* @gsxtmsndfile162 to i8*
%var4186 = bitcast [47 x i8]* @gsxtmsndfile163 to i8*
%addytable4187 = call %clsvar* @add_address_table(%mzone* %zone4179, i8* %var4185, i32 0, i8* %var4186, i32 3, %clsvar* %addytable4184)
%address-table4188 = bitcast %clsvar* %addytable4187 to i8*

; insert table, function and environment into closure struct
%closure.table4191 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure4181, i32 0, i32 0
store i8* %address-table4188, i8** %closure.table4191
%closure.env4192 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure4181, i32 0, i32 1
store i8* %envptr4182, i8** %closure.env4192
%closure.func4193 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure4181, i32 0, i32 2
store void (i8*, i8*, %SF_LOOP_INFO*)* @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0__3997, void (i8*, i8*, %SF_LOOP_INFO*)** %closure.func4193
%closure_size4194 = call i64 @llvm_zone_mark_size(%mzone* %zone4179)
call void @llvm_zone_ptr_set_size(i8* %clsptr4180, i64 %closure_size4194)
%wrapper_ptr4195 = call i8* @llvm_zone_malloc(%mzone* %zone4179, i64 8)
%closure_wrapper4196 = bitcast i8* %wrapper_ptr4195 to { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**
store { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure4181, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_wrapper4196

; let value assignment
%print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_wrapper4196, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_wrapper4196
store { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0
%tmp_envptr4190 = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***}* %environment4183, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**** %tmp_envptr4190


%val4199 = load {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*** %print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %val4199
}


@print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0(%SF_LOOP_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_LOOP_INFO*)*,  void (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_native(%SF_LOOP_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_LOOP_INFO*)*,  void (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4200 = bitcast [93 x i8]* @gsxtmsndfile164 to i8*
call i32 (i8*, ...) @printf(i8* %var4200)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_LOOP_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_LOOP_INFO*)*,  void (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_LOOP_INFO*}*
%arg_p_0 = getelementptr {%SF_LOOP_INFO*}, {%SF_LOOP_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_LOOP_INFO*)*,  void (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile165 = hidden constant [96 x i8] c"SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd\00"
@gsxtmsndfile166 = hidden constant [93 x i8] c"{i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**\00"
define dllexport fastcc %SF_LOOP_INFO @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd__4201(i8* %_impz,i8* %_impenv, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4202 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}*
%SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxdPtr_ = getelementptr {{i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}, {{i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}* %impenv, i32 0, i32 0
%SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxdPtr = load {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***, {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**** %SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxdPtr_

; setup arguments
%arg_0Ptr = alloca [2 x i8]
store [2 x i8] %arg_0, [2 x i8]* %arg_0Ptr
%arg_1Ptr = alloca [2 x i8]
store [2 x i8] %arg_1, [2 x i8]* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca float
store float %arg_4, float* %arg_4Ptr
%arg_5Ptr = alloca i32
store i32 %arg_5, i32* %arg_5Ptr
%arg_6Ptr = alloca [6 x i32]
store [6 x i32] %arg_6, [6 x i32]* %arg_6Ptr


%tzone4204 = load i8*, i8** %_impzPtr
%zone4205 = bitcast i8* %tzone4204 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_LOOP_INFO*
%dat4203 = alloca %SF_LOOP_INFO, align 16

; let value assignment
%obj = select i1 true, %SF_LOOP_INFO* %dat4203, %SF_LOOP_INFO* %dat4203
store %SF_LOOP_INFO* %obj, %SF_LOOP_INFO** %objPtr

%val4206 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4207 = load [2 x i8], [2 x i8]* %arg_0Ptr
; set tuple
%val4208 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4206, i64 0, i32 0
store [2 x i8] %val4207, [2 x i8]* %val4208
%val4209 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4210 = load [2 x i8], [2 x i8]* %arg_1Ptr
; set tuple
%val4211 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4209, i64 0, i32 1
store [2 x i8] %val4210, [2 x i8]* %val4211
%val4212 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4213 = load i32, i32* %arg_2Ptr
; set tuple
%val4214 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4212, i64 0, i32 2
store i32 %val4213, i32* %val4214
%val4215 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4216 = load i32, i32* %arg_3Ptr
; set tuple
%val4217 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4215, i64 0, i32 3
store i32 %val4216, i32* %val4217
%val4218 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4219 = load float, float* %arg_4Ptr
; set tuple
%val4220 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4218, i64 0, i32 4
store float %val4219, float* %val4220
%val4221 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4222 = load i32, i32* %arg_5Ptr
; set tuple
%val4223 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4221, i64 0, i32 5
store i32 %val4222, i32* %val4223
%val4224 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4225 = load [6 x i32], [6 x i32]* %arg_6Ptr
; set tuple
%val4226 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4224, i64 0, i32 6
store [6 x i32] %val4225, [6 x i32]* %val4226
%val4227 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
; pointer ref
%val4228 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4227, i64 0
%val4229 = load %SF_LOOP_INFO, %SF_LOOP_INFO* %val4228
ret %SF_LOOP_INFO %val4229
}
@gsxtmsndfile167 = hidden constant [149 x i8] c"SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4249 = load i8*, i8** %_impzPtr
%zone4250 = bitcast i8* %tzone4249 to %mzone*

; let assign value to symbol SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd
%dat_SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd = call i8* @llvm_zone_malloc(%mzone* %zone4250, i64 8)
%SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxdPtr = bitcast i8* %dat_SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd to { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***
%tzone4230 = load i8*, i8** %_impzPtr
%zone4231 = bitcast i8* %tzone4230 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4231)
; malloc closure structure
%clsptr4232 = call i8* @llvm_zone_malloc(%mzone* %zone4231, i64 24)
%closure4233 = bitcast i8* %clsptr4232 to { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*

; malloc environment structure
%envptr4234 = call i8* @llvm_zone_malloc(%mzone* %zone4231, i64 8)
%environment4235 = bitcast i8* %envptr4234 to {{i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}*

; malloc closure address table
%addytable4236 = call %clsvar* @new_address_table()
%var4237 = bitcast [96 x i8]* @gsxtmsndfile165 to i8*
%var4238 = bitcast [93 x i8]* @gsxtmsndfile166 to i8*
%addytable4239 = call %clsvar* @add_address_table(%mzone* %zone4231, i8* %var4237, i32 0, i8* %var4238, i32 3, %clsvar* %addytable4236)
%address-table4240 = bitcast %clsvar* %addytable4239 to i8*

; insert table, function and environment into closure struct
%closure.table4243 = getelementptr { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure4233, i32 0, i32 0
store i8* %address-table4240, i8** %closure.table4243
%closure.env4244 = getelementptr { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure4233, i32 0, i32 1
store i8* %envptr4234, i8** %closure.env4244
%closure.func4245 = getelementptr { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure4233, i32 0, i32 2
store %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])* @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd__4201, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %closure.func4245
%closure_size4246 = call i64 @llvm_zone_mark_size(%mzone* %zone4231)
call void @llvm_zone_ptr_set_size(i8* %clsptr4232, i64 %closure_size4246)
%wrapper_ptr4247 = call i8* @llvm_zone_malloc(%mzone* %zone4231, i64 8)
%closure_wrapper4248 = bitcast i8* %wrapper_ptr4247 to { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
store { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure4233, { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_wrapper4248

; let value assignment
%SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd = select i1 true, { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_wrapper4248, { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_wrapper4248
store { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd, { i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*** %SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxdPtr

; add data to environment
; don't need to alloc for env var SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd
%tmp_envptr4242 = getelementptr {{i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}, {{i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}***}* %environment4235, i32 0, i32 0
store {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*** %SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxdPtr, {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**** %tmp_envptr4242


%val4251 = load {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**, {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*** %SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxdPtr
ret {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %val4251
}


@SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_var = dllexport global [1 x i8*] [ i8* null ]

@SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_LOOP_INFO @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd([2 x i8] %arg_0,[2 x i8] %arg_1,i32 %arg_2,i32 %arg_3,float %arg_4,i32 %arg_5,[6 x i32] %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*, {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*,  %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6)
ret %SF_LOOP_INFO %result
}


define dllexport ccc %SF_LOOP_INFO @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_native([2 x i8] %arg_0,[2 x i8] %arg_1,i32 %arg_2,i32 %arg_3,float %arg_4,i32 %arg_5,[6 x i32] %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*, {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*,  %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6)
ret %SF_LOOP_INFO %result
}


define dllexport ccc void @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}*
%arg_p_0 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 0
%arg_0 = load [2 x i8], [2 x i8]* %arg_p_0
%arg_p_1 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 1
%arg_1 = load [2 x i8], [2 x i8]* %arg_p_1
%arg_p_2 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
%arg_p_5 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}, {[2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32]}* %fstruct, i32 0, i32 6
%arg_6 = load [6 x i32], [6 x i32]* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @SF_LOOP_INFO_val_adhoc_W1NGX0xPT1BfSU5GTyx8MixpOHwsfDIsaTh8LGkzMixpMzIsZmxvYXQsaTMyLHw2LGkzMnxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}*, {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}, {i8*, i8*, %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])*,  %SF_LOOP_INFO (i8*, i8*, [2 x i8], [2 x i8], i32, i32, float, i32, [6 x i32])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO %ff(i8* %_impz, i8* %ee, [2 x i8] %arg_0, [2 x i8] %arg_1, i32 %arg_2, i32 %arg_3, float %arg_4, i32 %arg_5, [6 x i32] %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile168 = hidden constant [52 x i8] c"hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0\00"
@gsxtmsndfile169 = hidden constant [57 x i8] c"{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}**\00"
define dllexport fastcc %SF_LOOP_INFO* @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0__4256(i8* %_impz,i8* %_impenv, %SF_LOOP_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4257 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}***}*
%hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}***}, {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0Ptr = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}***, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}**** %hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0Ptr_

; setup arguments
%xPtr = alloca %SF_LOOP_INFO*
store %SF_LOOP_INFO* %x, %SF_LOOP_INFO** %xPtr


%tzone4260 = load i8*, i8** %_impzPtr
%zone4261 = bitcast i8* %tzone4260 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_LOOP_INFO*
%dat4258 = call i8* @malloc(i64 44)
call i8* @memset(i8* %dat4258, i32 0, i64 44)
%val4259 = bitcast i8* %dat4258 to %SF_LOOP_INFO*

; let value assignment
%obj = select i1 true, %SF_LOOP_INFO* %val4259, %SF_LOOP_INFO* %val4259
store %SF_LOOP_INFO* %obj, %SF_LOOP_INFO** %objPtr

%val4262 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4263 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4264 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4263, i64 0, i32 0
%val4265 = load [2 x i8], [2 x i8]* %val4264
; set tuple
%val4266 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4262, i64 0, i32 0
store [2 x i8] %val4265, [2 x i8]* %val4266
%val4267 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4268 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4269 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4268, i64 0, i32 1
%val4270 = load [2 x i8], [2 x i8]* %val4269
; set tuple
%val4271 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4267, i64 0, i32 1
store [2 x i8] %val4270, [2 x i8]* %val4271
%val4272 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4273 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4274 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4273, i64 0, i32 2
%val4275 = load i32, i32* %val4274
; set tuple
%val4276 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4272, i64 0, i32 2
store i32 %val4275, i32* %val4276
%val4277 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4278 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4279 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4278, i64 0, i32 3
%val4280 = load i32, i32* %val4279
; set tuple
%val4281 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4277, i64 0, i32 3
store i32 %val4280, i32* %val4281
%val4282 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4283 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4284 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4283, i64 0, i32 4
%val4285 = load float, float* %val4284
; set tuple
%val4286 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4282, i64 0, i32 4
store float %val4285, float* %val4286
%val4287 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4288 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4289 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4288, i64 0, i32 5
%val4290 = load i32, i32* %val4289
; set tuple
%val4291 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4287, i64 0, i32 5
store i32 %val4290, i32* %val4291
%val4292 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4293 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4294 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4293, i64 0, i32 6
%val4295 = load [6 x i32], [6 x i32]* %val4294
; set tuple
%val4296 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4292, i64 0, i32 6
store [6 x i32] %val4295, [6 x i32]* %val4296
%val4297 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
ret %SF_LOOP_INFO* %val4297
}
@gsxtmsndfile170 = hidden constant [105 x i8] c"hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}** @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4317 = load i8*, i8** %_impzPtr
%zone4318 = bitcast i8* %tzone4317 to %mzone*

; let assign value to symbol hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0
%dat_hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4318, i64 8)
%hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0 to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}***
%tzone4298 = load i8*, i8** %_impzPtr
%zone4299 = bitcast i8* %tzone4298 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4299)
; malloc closure structure
%clsptr4300 = call i8* @llvm_zone_malloc(%mzone* %zone4299, i64 24)
%closure4301 = bitcast i8* %clsptr4300 to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}*

; malloc environment structure
%envptr4302 = call i8* @llvm_zone_malloc(%mzone* %zone4299, i64 8)
%environment4303 = bitcast i8* %envptr4302 to {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}***}*

; malloc closure address table
%addytable4304 = call %clsvar* @new_address_table()
%var4305 = bitcast [52 x i8]* @gsxtmsndfile168 to i8*
%var4306 = bitcast [57 x i8]* @gsxtmsndfile169 to i8*
%addytable4307 = call %clsvar* @add_address_table(%mzone* %zone4299, i8* %var4305, i32 0, i8* %var4306, i32 3, %clsvar* %addytable4304)
%address-table4308 = bitcast %clsvar* %addytable4307 to i8*

; insert table, function and environment into closure struct
%closure.table4311 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure4301, i32 0, i32 0
store i8* %address-table4308, i8** %closure.table4311
%closure.env4312 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure4301, i32 0, i32 1
store i8* %envptr4302, i8** %closure.env4312
%closure.func4313 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure4301, i32 0, i32 2
store %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)* @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0__4256, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)** %closure.func4313
%closure_size4314 = call i64 @llvm_zone_mark_size(%mzone* %zone4299)
call void @llvm_zone_ptr_set_size(i8* %clsptr4300, i64 %closure_size4314)
%wrapper_ptr4315 = call i8* @llvm_zone_malloc(%mzone* %zone4299, i64 8)
%closure_wrapper4316 = bitcast i8* %wrapper_ptr4315 to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}**
store { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure4301, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_wrapper4316

; let value assignment
%hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0 = select i1 true, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_wrapper4316, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_wrapper4316
store { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}** %hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}*** %hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0
%tmp_envptr4310 = getelementptr {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}***}, {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}***}* %environment4303, i32 0, i32 0
store {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}*** %hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0Ptr, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}**** %tmp_envptr4310


%val4319 = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}**, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}*** %hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0Ptr
ret {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}** %val4319
}


@hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}** @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_LOOP_INFO* @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0(%SF_LOOP_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*,  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
ret %SF_LOOP_INFO* %result
}


define dllexport ccc %SF_LOOP_INFO* @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_native(%SF_LOOP_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*,  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
ret %SF_LOOP_INFO* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4320 = bitcast [105 x i8]* @gsxtmsndfile170 to i8*
call i32 (i8*, ...) @printf(i8* %var4320)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_LOOP_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*,  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
%tmpres = bitcast %SF_LOOP_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_LOOP_INFO*}*
%arg_p_0 = getelementptr {%SF_LOOP_INFO*}, {%SF_LOOP_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)*,  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile171 = hidden constant [40 x i8] c"hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0__4321(i8* %_impz,i8* %_impenv, %SF_LOOP_INFO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4322 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***}*
%hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**** %hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr_

; setup arguments
%xPtr = alloca %SF_LOOP_INFO*
store %SF_LOOP_INFO* %x, %SF_LOOP_INFO** %xPtr


%val4323 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
%val4324 = bitcast %SF_LOOP_INFO* %val4323 to i8*
call ccc void @free(i8* %val4324)
ret void
}
@gsxtmsndfile172 = hidden constant [93 x i8] c"hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4346 = load i8*, i8** %_impzPtr
%zone4347 = bitcast i8* %tzone4346 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0
%dat_hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4347, i64 8)
%hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0 to { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***
%tzone4327 = load i8*, i8** %_impzPtr
%zone4328 = bitcast i8* %tzone4327 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4328)
; malloc closure structure
%clsptr4329 = call i8* @llvm_zone_malloc(%mzone* %zone4328, i64 24)
%closure4330 = bitcast i8* %clsptr4329 to { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*

; malloc environment structure
%envptr4331 = call i8* @llvm_zone_malloc(%mzone* %zone4328, i64 8)
%environment4332 = bitcast i8* %envptr4331 to {{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***}*

; malloc closure address table
%addytable4333 = call %clsvar* @new_address_table()
%var4334 = bitcast [40 x i8]* @gsxtmsndfile171 to i8*
%var4335 = bitcast [47 x i8]* @gsxtmsndfile163 to i8*
%addytable4336 = call %clsvar* @add_address_table(%mzone* %zone4328, i8* %var4334, i32 0, i8* %var4335, i32 3, %clsvar* %addytable4333)
%address-table4337 = bitcast %clsvar* %addytable4336 to i8*

; insert table, function and environment into closure struct
%closure.table4340 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure4330, i32 0, i32 0
store i8* %address-table4337, i8** %closure.table4340
%closure.env4341 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure4330, i32 0, i32 1
store i8* %envptr4331, i8** %closure.env4341
%closure.func4342 = getelementptr { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure4330, i32 0, i32 2
store void (i8*, i8*, %SF_LOOP_INFO*)* @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0__4321, void (i8*, i8*, %SF_LOOP_INFO*)** %closure.func4342
%closure_size4343 = call i64 @llvm_zone_mark_size(%mzone* %zone4328)
call void @llvm_zone_ptr_set_size(i8* %clsptr4329, i64 %closure_size4343)
%wrapper_ptr4344 = call i8* @llvm_zone_malloc(%mzone* %zone4328, i64 8)
%closure_wrapper4345 = bitcast i8* %wrapper_ptr4344 to { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**
store { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure4330, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_wrapper4345

; let value assignment
%hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_wrapper4345, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_wrapper4345
store { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0, { i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0
%tmp_envptr4339 = getelementptr {{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***}, {{i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}***}* %environment4332, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**** %tmp_envptr4339


%val4348 = load {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*** %hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %val4348
}


@hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0(%SF_LOOP_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_LOOP_INFO*)*,  void (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_native(%SF_LOOP_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_LOOP_INFO*)*,  void (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4349 = bitcast [93 x i8]* @gsxtmsndfile172 to i8*
call i32 (i8*, ...) @printf(i8* %var4349)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_LOOP_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_LOOP_INFO*)*,  void (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_LOOP_INFO*}*
%arg_p_0 = getelementptr {%SF_LOOP_INFO*}, {%SF_LOOP_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU0ZfTE9PUF9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}*, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}, {i8*, i8*, void (i8*, i8*, %SF_LOOP_INFO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %SF_LOOP_INFO*)*,  void (i8*, i8*, %SF_LOOP_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile173 = hidden constant [71 x i8] c"zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmsndfile174 = hidden constant [75 x i8] c"{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %SF_LOOP_INFO* @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ__4350(i8* %_impz,i8* %_impenv, %SF_LOOP_INFO* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4351 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}***, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %SF_LOOP_INFO*
store %SF_LOOP_INFO* %x, %SF_LOOP_INFO** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val4353 = load %mzone*, %mzone** %fromzPtr
%val4354 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
%val4355 = bitcast %SF_LOOP_INFO* %val4354 to i8*
%res4356 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val4353, i8* %val4355)
br i1 %res4356, label %then4352, label %else4352

then4352:
%val4357 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val4357)
%zone_ptr4358 = bitcast %mzone* %val4357 to i8*
store i8* %zone_ptr4358, i8** %_impzPtr
%tzone4364 = load i8*, i8** %_impzPtr
%zone4365 = bitcast i8* %tzone4364 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %SF_LOOP_INFO*
%tzone4360 = load i8*, i8** %_impzPtr
%zone4361 = bitcast i8* %tzone4360 to %mzone*
%dat4362 = call i8* @llvm_zone_malloc(%mzone* %zone4361, i64 44)
call i8* @memset(i8* %dat4362, i32 0, i64 44)
%val4363 = bitcast i8* %dat4362 to %SF_LOOP_INFO*

; let value assignment
%obj = select i1 true, %SF_LOOP_INFO* %val4363, %SF_LOOP_INFO* %val4363
store %SF_LOOP_INFO* %obj, %SF_LOOP_INFO** %objPtr

%val4366 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4367 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4368 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4367, i64 0, i32 0
%val4369 = load [2 x i8], [2 x i8]* %val4368
; set tuple
%val4370 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4366, i64 0, i32 0
store [2 x i8] %val4369, [2 x i8]* %val4370
%val4371 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4372 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4373 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4372, i64 0, i32 1
%val4374 = load [2 x i8], [2 x i8]* %val4373
; set tuple
%val4375 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4371, i64 0, i32 1
store [2 x i8] %val4374, [2 x i8]* %val4375
%val4376 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4377 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4378 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4377, i64 0, i32 2
%val4379 = load i32, i32* %val4378
; set tuple
%val4380 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4376, i64 0, i32 2
store i32 %val4379, i32* %val4380
%val4381 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4382 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4383 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4382, i64 0, i32 3
%val4384 = load i32, i32* %val4383
; set tuple
%val4385 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4381, i64 0, i32 3
store i32 %val4384, i32* %val4385
%val4386 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4387 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4388 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4387, i64 0, i32 4
%val4389 = load float, float* %val4388
; set tuple
%val4390 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4386, i64 0, i32 4
store float %val4389, float* %val4390
%val4391 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4392 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4393 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4392, i64 0, i32 5
%val4394 = load i32, i32* %val4393
; set tuple
%val4395 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4391, i64 0, i32 5
store i32 %val4394, i32* %val4395
%val4396 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
%val4397 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
; tuple ref
%val4398 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4397, i64 0, i32 6
%val4399 = load [6 x i32], [6 x i32]* %val4398
; set tuple
%val4400 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val4396, i64 0, i32 6
store [6 x i32] %val4399, [6 x i32]* %val4400
%oldzone4401 = call %mzone* @llvm_pop_zone_stack()
%newzone4402 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr4403 = bitcast %mzone* %newzone4402 to i8*
store i8* %zone_ptr4403, i8** %_impzPtr
%val4404 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %objPtr
ret %SF_LOOP_INFO* %val4404

else4352:
%val4405 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %xPtr
ret %SF_LOOP_INFO* %val4405
}
@gsxtmsndfile175 = hidden constant [124 x i8] c"zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4425 = load i8*, i8** %_impzPtr
%zone4426 = bitcast i8* %tzone4425 to %mzone*

; let assign value to symbol zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone4426, i64 8)
%zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}***
%tzone4406 = load i8*, i8** %_impzPtr
%zone4407 = bitcast i8* %tzone4406 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4407)
; malloc closure structure
%clsptr4408 = call i8* @llvm_zone_malloc(%mzone* %zone4407, i64 24)
%closure4409 = bitcast i8* %clsptr4408 to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr4410 = call i8* @llvm_zone_malloc(%mzone* %zone4407, i64 8)
%environment4411 = bitcast i8* %envptr4410 to {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable4412 = call %clsvar* @new_address_table()
%var4413 = bitcast [71 x i8]* @gsxtmsndfile173 to i8*
%var4414 = bitcast [75 x i8]* @gsxtmsndfile174 to i8*
%addytable4415 = call %clsvar* @add_address_table(%mzone* %zone4407, i8* %var4413, i32 0, i8* %var4414, i32 3, %clsvar* %addytable4412)
%address-table4416 = bitcast %clsvar* %addytable4415 to i8*

; insert table, function and environment into closure struct
%closure.table4419 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}* %closure4409, i32 0, i32 0
store i8* %address-table4416, i8** %closure.table4419
%closure.env4420 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}* %closure4409, i32 0, i32 1
store i8* %envptr4410, i8** %closure.env4420
%closure.func4421 = getelementptr { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}* %closure4409, i32 0, i32 2
store %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)* @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ__4350, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)** %closure.func4421
%closure_size4422 = call i64 @llvm_zone_mark_size(%mzone* %zone4407)
call void @llvm_zone_ptr_set_size(i8* %clsptr4408, i64 %closure_size4422)
%wrapper_ptr4423 = call i8* @llvm_zone_malloc(%mzone* %zone4407, i64 8)
%closure_wrapper4424 = bitcast i8* %wrapper_ptr4423 to { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}**
store { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}* %closure4409, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}** %closure_wrapper4424

; let value assignment
%zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}** %closure_wrapper4424, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}** %closure_wrapper4424
store { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ
%tmp_envptr4418 = getelementptr {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}***}* %environment4411, i32 0, i32 0
store {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}**** %tmp_envptr4418


%val4427 = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}**, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}** %val4427
}


@zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %SF_LOOP_INFO* @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ(%SF_LOOP_INFO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*,  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %SF_LOOP_INFO* %result
}


define dllexport ccc %SF_LOOP_INFO* @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_native(%SF_LOOP_INFO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*,  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %SF_LOOP_INFO* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4428 = bitcast [124 x i8]* @gsxtmsndfile175 to i8*
call i32 (i8*, ...) @printf(i8* %var4428)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_LOOP_INFO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4429 = bitcast [124 x i8]* @gsxtmsndfile175 to i8*
call i32 (i8*, ...) @printf(i8* %var4429)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4430 = bitcast [124 x i8]* @gsxtmsndfile175 to i8*
call i32 (i8*, ...) @printf(i8* %var4430)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*,  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %SF_LOOP_INFO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_LOOP_INFO*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%SF_LOOP_INFO*, %mzone*, %mzone*}, {%SF_LOOP_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %arg_p_0
%arg_p_1 = getelementptr {%SF_LOOP_INFO*, %mzone*, %mzone*}, {%SF_LOOP_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%SF_LOOP_INFO*, %mzone*, %mzone*}, {%SF_LOOP_INFO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NGX0xPT1BfSU5GTyosU0ZfTE9PUF9JTkZPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}*, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}, {i8*, i8*, %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)*,  %SF_LOOP_INFO* (i8*, i8*, %SF_LOOP_INFO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %SF_LOOP_INFO* %ff(i8* %_impz, i8* %ee, %SF_LOOP_INFO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


declare cc 0 i8* @sf_open(i8*,i32,%SF_INFO*) nounwind
declare cc 0 i8* @sf_open_fd(i32,i32,%SF_INFO*,i32) nounwind
declare cc 0 i32 @sf_error(i8*) nounwind
declare cc 0 i8* @sf_strerror(i8*) nounwind
declare cc 0 i8* @sf_error_number(i32) nounwind
declare cc 0 i32 @sf_perror(i8*) nounwind
declare cc 0 i32 @sf_error_str(i8*,i8*,i64) nounwind
declare cc 0 i32 @sf_command(i8*,i32,i8*,i32) nounwind
declare cc 0 i32 @sf_format_check(%SF_INFO*) nounwind
declare cc 0 i64 @sf_seek(i8*,i64,i32) nounwind
declare cc 0 i32 @sf_set_string(i8*,i32,i8*) nounwind
declare cc 0 i8* @sf_get_string(i8*,i32) nounwind
declare cc 0 i8* @sf_version_string() nounwind
declare cc 0 i64 @sf_read_raw(i8*,i8*,i64) nounwind
declare cc 0 i64 @sf_write_raw(i8*,i8*,i64) nounwind
declare cc 0 i64 @sf_readf_short(i8*,i16*,i64) nounwind
declare cc 0 i64 @sf_writef_short(i8*,i16*,i64) nounwind
declare cc 0 i64 @sf_readf_int(i8*,i32*,i64) nounwind
declare cc 0 i64 @sf_writef_int(i8*,i32*,i64) nounwind
declare cc 0 i64 @sf_readf_float(i8*,float*,i64) nounwind
declare cc 0 i64 @sf_writef_float(i8*,float*,i64) nounwind
declare cc 0 i64 @sf_readf_double(i8*,double*,i64) nounwind
declare cc 0 i64 @sf_writef_double(i8*,double*,i64) nounwind
declare cc 0 i64 @sf_read_short(i8*,i16*,i64) nounwind
declare cc 0 i64 @sf_write_short(i8*,i16*,i64) nounwind
declare cc 0 i64 @sf_read_int(i8*,i32*,i64) nounwind
declare cc 0 i64 @sf_write_int(i8*,i32*,i64) nounwind
declare cc 0 i64 @sf_read_float(i8*,float*,i64) nounwind
declare cc 0 i64 @sf_write_float(i8*,float*,i64) nounwind
declare cc 0 i64 @sf_read_double(i8*,double*,i64) nounwind
declare cc 0 i64 @sf_write_double(i8*,double*,i64) nounwind
declare cc 0 i32 @sf_close(i8*) nounwind
declare cc 0 void @sf_write_sync(i8*) nounwind
@gsxtmsndfile176 = hidden constant [36 x i8] c"sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0\00"
@gsxtmsndfile177 = hidden constant [41 x i8] c"{i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}**\00"
define dllexport fastcc i64 @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0__4431(i8* %_impz,i8* %_impenv, %SF_INFO* %info) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4432 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}***}*
%sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}***}* %impenv, i32 0, i32 0
%sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0Ptr = load {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}***, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}**** %sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0Ptr_

; setup arguments
%infoPtr = alloca %SF_INFO*
store %SF_INFO* %info, %SF_INFO** %infoPtr


%val4433 = load %SF_INFO*, %SF_INFO** %infoPtr
; tuple ref
%val4434 = getelementptr %SF_INFO, %SF_INFO* %val4433, i64 0, i32 0
%val4435 = load i64, i64* %val4434
ret i64 %val4435
}
@gsxtmsndfile178 = hidden constant [89 x i8] c"sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}** @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4455 = load i8*, i8** %_impzPtr
%zone4456 = bitcast i8* %tzone4455 to %mzone*

; let assign value to symbol sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0
%dat_sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4456, i64 8)
%sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0Ptr = bitcast i8* %dat_sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0 to { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}***
%tzone4436 = load i8*, i8** %_impzPtr
%zone4437 = bitcast i8* %tzone4436 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4437)
; malloc closure structure
%clsptr4438 = call i8* @llvm_zone_malloc(%mzone* %zone4437, i64 24)
%closure4439 = bitcast i8* %clsptr4438 to { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}*

; malloc environment structure
%envptr4440 = call i8* @llvm_zone_malloc(%mzone* %zone4437, i64 8)
%environment4441 = bitcast i8* %envptr4440 to {{i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}***}*

; malloc closure address table
%addytable4442 = call %clsvar* @new_address_table()
%var4443 = bitcast [36 x i8]* @gsxtmsndfile176 to i8*
%var4444 = bitcast [41 x i8]* @gsxtmsndfile177 to i8*
%addytable4445 = call %clsvar* @add_address_table(%mzone* %zone4437, i8* %var4443, i32 0, i8* %var4444, i32 3, %clsvar* %addytable4442)
%address-table4446 = bitcast %clsvar* %addytable4445 to i8*

; insert table, function and environment into closure struct
%closure.table4449 = getelementptr { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}* %closure4439, i32 0, i32 0
store i8* %address-table4446, i8** %closure.table4449
%closure.env4450 = getelementptr { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}* %closure4439, i32 0, i32 1
store i8* %envptr4440, i8** %closure.env4450
%closure.func4451 = getelementptr { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}* %closure4439, i32 0, i32 2
store i64 (i8*, i8*, %SF_INFO*)* @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0__4431, i64 (i8*, i8*, %SF_INFO*)** %closure.func4451
%closure_size4452 = call i64 @llvm_zone_mark_size(%mzone* %zone4437)
call void @llvm_zone_ptr_set_size(i8* %clsptr4438, i64 %closure_size4452)
%wrapper_ptr4453 = call i8* @llvm_zone_malloc(%mzone* %zone4437, i64 8)
%closure_wrapper4454 = bitcast i8* %wrapper_ptr4453 to { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}**
store { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}* %closure4439, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4454

; let value assignment
%sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0 = select i1 true, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4454, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4454
store { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}** %sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}*** %sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0
%tmp_envptr4448 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}***}* %environment4441, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}*** %sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0Ptr, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}**** %tmp_envptr4448


%val4457 = load {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}**, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}*** %sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0Ptr
ret {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}** %val4457
}


@sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}** @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %SF_INFO*)*,  i64 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_native(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %SF_INFO*)*,  i64 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4458 = bitcast [89 x i8]* @gsxtmsndfile178 to i8*
call i32 (i8*, ...) @printf(i8* %var4458)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %SF_INFO*)*,  i64 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*}*
%arg_p_0 = getelementptr {%SF_INFO*}, {%SF_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %SF_INFO*)*,  i64 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile179 = hidden constant [45 x i8] c"sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd\00"
@gsxtmsndfile180 = hidden constant [46 x i8] c"{i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}**\00"
define dllexport fastcc i64 @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd__4459(i8* %_impz,i8* %_impenv, %SF_INFO* %info, i64 %frames) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4460 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}***}*
%sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRdPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}***}, {{i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}***}* %impenv, i32 0, i32 0
%sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRdPtr = load {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}***, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}**** %sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRdPtr_

; setup arguments
%infoPtr = alloca %SF_INFO*
store %SF_INFO* %info, %SF_INFO** %infoPtr
%framesPtr = alloca i64
store i64 %frames, i64* %framesPtr


%val4461 = load %SF_INFO*, %SF_INFO** %infoPtr
%val4462 = load i64, i64* %framesPtr
; set tuple
%val4463 = getelementptr %SF_INFO, %SF_INFO* %val4461, i64 0, i32 0
store i64 %val4462, i64* %val4463
ret i64 %val4462
}
@gsxtmsndfile181 = hidden constant [98 x i8] c"sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}** @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4483 = load i8*, i8** %_impzPtr
%zone4484 = bitcast i8* %tzone4483 to %mzone*

; let assign value to symbol sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd
%dat_sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone4484, i64 8)
%sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRdPtr = bitcast i8* %dat_sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd to { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}***
%tzone4464 = load i8*, i8** %_impzPtr
%zone4465 = bitcast i8* %tzone4464 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4465)
; malloc closure structure
%clsptr4466 = call i8* @llvm_zone_malloc(%mzone* %zone4465, i64 24)
%closure4467 = bitcast i8* %clsptr4466 to { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}*

; malloc environment structure
%envptr4468 = call i8* @llvm_zone_malloc(%mzone* %zone4465, i64 8)
%environment4469 = bitcast i8* %envptr4468 to {{i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}***}*

; malloc closure address table
%addytable4470 = call %clsvar* @new_address_table()
%var4471 = bitcast [45 x i8]* @gsxtmsndfile179 to i8*
%var4472 = bitcast [46 x i8]* @gsxtmsndfile180 to i8*
%addytable4473 = call %clsvar* @add_address_table(%mzone* %zone4465, i8* %var4471, i32 0, i8* %var4472, i32 3, %clsvar* %addytable4470)
%address-table4474 = bitcast %clsvar* %addytable4473 to i8*

; insert table, function and environment into closure struct
%closure.table4477 = getelementptr { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}* %closure4467, i32 0, i32 0
store i8* %address-table4474, i8** %closure.table4477
%closure.env4478 = getelementptr { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}* %closure4467, i32 0, i32 1
store i8* %envptr4468, i8** %closure.env4478
%closure.func4479 = getelementptr { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}* %closure4467, i32 0, i32 2
store i64 (i8*, i8*, %SF_INFO*, i64)* @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd__4459, i64 (i8*, i8*, %SF_INFO*, i64)** %closure.func4479
%closure_size4480 = call i64 @llvm_zone_mark_size(%mzone* %zone4465)
call void @llvm_zone_ptr_set_size(i8* %clsptr4466, i64 %closure_size4480)
%wrapper_ptr4481 = call i8* @llvm_zone_malloc(%mzone* %zone4465, i64 8)
%closure_wrapper4482 = bitcast i8* %wrapper_ptr4481 to { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}**
store { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}* %closure4467, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}** %closure_wrapper4482

; let value assignment
%sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd = select i1 true, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}** %closure_wrapper4482, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}** %closure_wrapper4482
store { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}** %sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd, { i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}*** %sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRdPtr

; add data to environment
; don't need to alloc for env var sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd
%tmp_envptr4476 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}***}, {{i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}***}* %environment4469, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}*** %sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRdPtr, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}**** %tmp_envptr4476


%val4485 = load {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}**, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}*** %sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRdPtr
ret {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}** %val4485
}


@sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}** @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd(%SF_INFO* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %SF_INFO*, i64)*,  i64 (i8*, i8*, %SF_INFO*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i64 %arg_1)
ret i64 %result
}


define dllexport ccc i64 @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_native(%SF_INFO* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %SF_INFO*, i64)*,  i64 (i8*, i8*, %SF_INFO*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i64 %arg_1)
ret i64 %result
}


define dllexport ccc i8*  @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4486 = bitcast [98 x i8]* @gsxtmsndfile181 to i8*
call i32 (i8*, ...) @printf(i8* %var4486)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4487 = bitcast [98 x i8]* @gsxtmsndfile181 to i8*
call i32 (i8*, ...) @printf(i8* %var4487)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %SF_INFO*, i64)*,  i64 (i8*, i8*, %SF_INFO*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*, i64}*
%arg_p_0 = getelementptr {%SF_INFO*, i64}, {%SF_INFO*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
%arg_p_1 = getelementptr {%SF_INFO*, i64}, {%SF_INFO*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_frames_adhoc_W2k2NCxTRl9JTkZPKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}*, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}, {i8*, i8*, i64 (i8*, i8*, %SF_INFO*, i64)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %SF_INFO*, i64)*,  i64 (i8*, i8*, %SF_INFO*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile182 = hidden constant [40 x i8] c"sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0\00"
@gsxtmsndfile183 = hidden constant [41 x i8] c"{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**\00"
define dllexport fastcc i32 @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0__4488(i8* %_impz,i8* %_impenv, %SF_INFO* %info) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4489 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}*
%sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}* %impenv, i32 0, i32 0
%sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**** %sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0Ptr_

; setup arguments
%infoPtr = alloca %SF_INFO*
store %SF_INFO* %info, %SF_INFO** %infoPtr


%val4490 = load %SF_INFO*, %SF_INFO** %infoPtr
; tuple ref
%val4491 = getelementptr %SF_INFO, %SF_INFO* %val4490, i64 0, i32 1
%val4492 = load i32, i32* %val4491
ret i32 %val4492
}
@gsxtmsndfile184 = hidden constant [93 x i8] c"sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4512 = load i8*, i8** %_impzPtr
%zone4513 = bitcast i8* %tzone4512 to %mzone*

; let assign value to symbol sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0
%dat_sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4513, i64 8)
%sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0Ptr = bitcast i8* %dat_sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***
%tzone4493 = load i8*, i8** %_impzPtr
%zone4494 = bitcast i8* %tzone4493 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4494)
; malloc closure structure
%clsptr4495 = call i8* @llvm_zone_malloc(%mzone* %zone4494, i64 24)
%closure4496 = bitcast i8* %clsptr4495 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*

; malloc environment structure
%envptr4497 = call i8* @llvm_zone_malloc(%mzone* %zone4494, i64 8)
%environment4498 = bitcast i8* %envptr4497 to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}*

; malloc closure address table
%addytable4499 = call %clsvar* @new_address_table()
%var4500 = bitcast [40 x i8]* @gsxtmsndfile182 to i8*
%var4501 = bitcast [41 x i8]* @gsxtmsndfile183 to i8*
%addytable4502 = call %clsvar* @add_address_table(%mzone* %zone4494, i8* %var4500, i32 0, i8* %var4501, i32 3, %clsvar* %addytable4499)
%address-table4503 = bitcast %clsvar* %addytable4502 to i8*

; insert table, function and environment into closure struct
%closure.table4506 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4496, i32 0, i32 0
store i8* %address-table4503, i8** %closure.table4506
%closure.env4507 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4496, i32 0, i32 1
store i8* %envptr4497, i8** %closure.env4507
%closure.func4508 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4496, i32 0, i32 2
store i32 (i8*, i8*, %SF_INFO*)* @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0__4488, i32 (i8*, i8*, %SF_INFO*)** %closure.func4508
%closure_size4509 = call i64 @llvm_zone_mark_size(%mzone* %zone4494)
call void @llvm_zone_ptr_set_size(i8* %clsptr4495, i64 %closure_size4509)
%wrapper_ptr4510 = call i8* @llvm_zone_malloc(%mzone* %zone4494, i64 8)
%closure_wrapper4511 = bitcast i8* %wrapper_ptr4510 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4496, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4511

; let value assignment
%sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4511, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4511
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0
%tmp_envptr4505 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}* %environment4498, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0Ptr, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**** %tmp_envptr4505


%val4514 = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %val4514
}


@sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_native(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4515 = bitcast [93 x i8]* @gsxtmsndfile184 to i8*
call i32 (i8*, ...) @printf(i8* %var4515)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*}*
%arg_p_0 = getelementptr {%SF_INFO*}, {%SF_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile185 = hidden constant [49 x i8] c"sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd\00"
@gsxtmsndfile186 = hidden constant [46 x i8] c"{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**\00"
define dllexport fastcc i32 @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd__4516(i8* %_impz,i8* %_impenv, %SF_INFO* %info, i32 %samplerate) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4517 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}*
%sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}* %impenv, i32 0, i32 0
%sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**** %sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr_

; setup arguments
%infoPtr = alloca %SF_INFO*
store %SF_INFO* %info, %SF_INFO** %infoPtr
%sampleratePtr = alloca i32
store i32 %samplerate, i32* %sampleratePtr


%val4518 = load %SF_INFO*, %SF_INFO** %infoPtr
%val4519 = load i32, i32* %sampleratePtr
; set tuple
%val4520 = getelementptr %SF_INFO, %SF_INFO* %val4518, i64 0, i32 1
store i32 %val4519, i32* %val4520
ret i32 %val4519
}
@gsxtmsndfile187 = hidden constant [102 x i8] c"sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4540 = load i8*, i8** %_impzPtr
%zone4541 = bitcast i8* %tzone4540 to %mzone*

; let assign value to symbol sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd
%dat_sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone4541, i64 8)
%sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr = bitcast i8* %dat_sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***
%tzone4521 = load i8*, i8** %_impzPtr
%zone4522 = bitcast i8* %tzone4521 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4522)
; malloc closure structure
%clsptr4523 = call i8* @llvm_zone_malloc(%mzone* %zone4522, i64 24)
%closure4524 = bitcast i8* %clsptr4523 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*

; malloc environment structure
%envptr4525 = call i8* @llvm_zone_malloc(%mzone* %zone4522, i64 8)
%environment4526 = bitcast i8* %envptr4525 to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}*

; malloc closure address table
%addytable4527 = call %clsvar* @new_address_table()
%var4528 = bitcast [49 x i8]* @gsxtmsndfile185 to i8*
%var4529 = bitcast [46 x i8]* @gsxtmsndfile186 to i8*
%addytable4530 = call %clsvar* @add_address_table(%mzone* %zone4522, i8* %var4528, i32 0, i8* %var4529, i32 3, %clsvar* %addytable4527)
%address-table4531 = bitcast %clsvar* %addytable4530 to i8*

; insert table, function and environment into closure struct
%closure.table4534 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4524, i32 0, i32 0
store i8* %address-table4531, i8** %closure.table4534
%closure.env4535 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4524, i32 0, i32 1
store i8* %envptr4525, i8** %closure.env4535
%closure.func4536 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4524, i32 0, i32 2
store i32 (i8*, i8*, %SF_INFO*, i32)* @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd__4516, i32 (i8*, i8*, %SF_INFO*, i32)** %closure.func4536
%closure_size4537 = call i64 @llvm_zone_mark_size(%mzone* %zone4522)
call void @llvm_zone_ptr_set_size(i8* %clsptr4523, i64 %closure_size4537)
%wrapper_ptr4538 = call i8* @llvm_zone_malloc(%mzone* %zone4522, i64 8)
%closure_wrapper4539 = bitcast i8* %wrapper_ptr4538 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4524, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4539

; let value assignment
%sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4539, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4539
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr

; add data to environment
; don't need to alloc for env var sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd
%tmp_envptr4533 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}* %environment4526, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**** %tmp_envptr4533


%val4542 = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr
ret {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %val4542
}


@sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd(%SF_INFO* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_native(%SF_INFO* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4543 = bitcast [102 x i8]* @gsxtmsndfile187 to i8*
call i32 (i8*, ...) @printf(i8* %var4543)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4544 = bitcast [102 x i8]* @gsxtmsndfile187 to i8*
call i32 (i8*, ...) @printf(i8* %var4544)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*, i32}*
%arg_p_0 = getelementptr {%SF_INFO*, i32}, {%SF_INFO*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
%arg_p_1 = getelementptr {%SF_INFO*, i32}, {%SF_INFO*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_samplerate_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile188 = hidden constant [38 x i8] c"sf_channels_adhoc_W2kzMixTRl9JTkZPKl0\00"
define dllexport fastcc i32 @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0__4545(i8* %_impz,i8* %_impenv, %SF_INFO* %info) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4546 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}*
%sf_channels_adhoc_W2kzMixTRl9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}* %impenv, i32 0, i32 0
%sf_channels_adhoc_W2kzMixTRl9JTkZPKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**** %sf_channels_adhoc_W2kzMixTRl9JTkZPKl0Ptr_

; setup arguments
%infoPtr = alloca %SF_INFO*
store %SF_INFO* %info, %SF_INFO** %infoPtr


%val4547 = load %SF_INFO*, %SF_INFO** %infoPtr
; tuple ref
%val4548 = getelementptr %SF_INFO, %SF_INFO* %val4547, i64 0, i32 2
%val4549 = load i32, i32* %val4548
ret i32 %val4549
}
@gsxtmsndfile189 = hidden constant [91 x i8] c"sf_channels_adhoc_W2kzMixTRl9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4569 = load i8*, i8** %_impzPtr
%zone4570 = bitcast i8* %tzone4569 to %mzone*

; let assign value to symbol sf_channels_adhoc_W2kzMixTRl9JTkZPKl0
%dat_sf_channels_adhoc_W2kzMixTRl9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4570, i64 8)
%sf_channels_adhoc_W2kzMixTRl9JTkZPKl0Ptr = bitcast i8* %dat_sf_channels_adhoc_W2kzMixTRl9JTkZPKl0 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***
%tzone4550 = load i8*, i8** %_impzPtr
%zone4551 = bitcast i8* %tzone4550 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4551)
; malloc closure structure
%clsptr4552 = call i8* @llvm_zone_malloc(%mzone* %zone4551, i64 24)
%closure4553 = bitcast i8* %clsptr4552 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*

; malloc environment structure
%envptr4554 = call i8* @llvm_zone_malloc(%mzone* %zone4551, i64 8)
%environment4555 = bitcast i8* %envptr4554 to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}*

; malloc closure address table
%addytable4556 = call %clsvar* @new_address_table()
%var4557 = bitcast [38 x i8]* @gsxtmsndfile188 to i8*
%var4558 = bitcast [41 x i8]* @gsxtmsndfile183 to i8*
%addytable4559 = call %clsvar* @add_address_table(%mzone* %zone4551, i8* %var4557, i32 0, i8* %var4558, i32 3, %clsvar* %addytable4556)
%address-table4560 = bitcast %clsvar* %addytable4559 to i8*

; insert table, function and environment into closure struct
%closure.table4563 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4553, i32 0, i32 0
store i8* %address-table4560, i8** %closure.table4563
%closure.env4564 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4553, i32 0, i32 1
store i8* %envptr4554, i8** %closure.env4564
%closure.func4565 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4553, i32 0, i32 2
store i32 (i8*, i8*, %SF_INFO*)* @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0__4545, i32 (i8*, i8*, %SF_INFO*)** %closure.func4565
%closure_size4566 = call i64 @llvm_zone_mark_size(%mzone* %zone4551)
call void @llvm_zone_ptr_set_size(i8* %clsptr4552, i64 %closure_size4566)
%wrapper_ptr4567 = call i8* @llvm_zone_malloc(%mzone* %zone4551, i64 8)
%closure_wrapper4568 = bitcast i8* %wrapper_ptr4567 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4553, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4568

; let value assignment
%sf_channels_adhoc_W2kzMixTRl9JTkZPKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4568, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4568
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %sf_channels_adhoc_W2kzMixTRl9JTkZPKl0, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_channels_adhoc_W2kzMixTRl9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var sf_channels_adhoc_W2kzMixTRl9JTkZPKl0
%tmp_envptr4562 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}* %environment4555, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_channels_adhoc_W2kzMixTRl9JTkZPKl0Ptr, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**** %tmp_envptr4562


%val4571 = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_channels_adhoc_W2kzMixTRl9JTkZPKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %val4571
}


@sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_native(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4572 = bitcast [91 x i8]* @gsxtmsndfile189 to i8*
call i32 (i8*, ...) @printf(i8* %var4572)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*}*
%arg_p_0 = getelementptr {%SF_INFO*}, {%SF_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile190 = hidden constant [47 x i8] c"sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd\00"
define dllexport fastcc i32 @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd__4573(i8* %_impz,i8* %_impenv, %SF_INFO* %info, i32 %channels) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4574 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}*
%sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}* %impenv, i32 0, i32 0
%sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**** %sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr_

; setup arguments
%infoPtr = alloca %SF_INFO*
store %SF_INFO* %info, %SF_INFO** %infoPtr
%channelsPtr = alloca i32
store i32 %channels, i32* %channelsPtr


%val4575 = load %SF_INFO*, %SF_INFO** %infoPtr
%val4576 = load i32, i32* %channelsPtr
; set tuple
%val4577 = getelementptr %SF_INFO, %SF_INFO* %val4575, i64 0, i32 2
store i32 %val4576, i32* %val4577
ret i32 %val4576
}
@gsxtmsndfile191 = hidden constant [100 x i8] c"sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4597 = load i8*, i8** %_impzPtr
%zone4598 = bitcast i8* %tzone4597 to %mzone*

; let assign value to symbol sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd
%dat_sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone4598, i64 8)
%sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr = bitcast i8* %dat_sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***
%tzone4578 = load i8*, i8** %_impzPtr
%zone4579 = bitcast i8* %tzone4578 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4579)
; malloc closure structure
%clsptr4580 = call i8* @llvm_zone_malloc(%mzone* %zone4579, i64 24)
%closure4581 = bitcast i8* %clsptr4580 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*

; malloc environment structure
%envptr4582 = call i8* @llvm_zone_malloc(%mzone* %zone4579, i64 8)
%environment4583 = bitcast i8* %envptr4582 to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}*

; malloc closure address table
%addytable4584 = call %clsvar* @new_address_table()
%var4585 = bitcast [47 x i8]* @gsxtmsndfile190 to i8*
%var4586 = bitcast [46 x i8]* @gsxtmsndfile186 to i8*
%addytable4587 = call %clsvar* @add_address_table(%mzone* %zone4579, i8* %var4585, i32 0, i8* %var4586, i32 3, %clsvar* %addytable4584)
%address-table4588 = bitcast %clsvar* %addytable4587 to i8*

; insert table, function and environment into closure struct
%closure.table4591 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4581, i32 0, i32 0
store i8* %address-table4588, i8** %closure.table4591
%closure.env4592 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4581, i32 0, i32 1
store i8* %envptr4582, i8** %closure.env4592
%closure.func4593 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4581, i32 0, i32 2
store i32 (i8*, i8*, %SF_INFO*, i32)* @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd__4573, i32 (i8*, i8*, %SF_INFO*, i32)** %closure.func4593
%closure_size4594 = call i64 @llvm_zone_mark_size(%mzone* %zone4579)
call void @llvm_zone_ptr_set_size(i8* %clsptr4580, i64 %closure_size4594)
%wrapper_ptr4595 = call i8* @llvm_zone_malloc(%mzone* %zone4579, i64 8)
%closure_wrapper4596 = bitcast i8* %wrapper_ptr4595 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4581, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4596

; let value assignment
%sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4596, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4596
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr

; add data to environment
; don't need to alloc for env var sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd
%tmp_envptr4590 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}* %environment4583, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**** %tmp_envptr4590


%val4599 = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr
ret {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %val4599
}


@sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd(%SF_INFO* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_native(%SF_INFO* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4600 = bitcast [100 x i8]* @gsxtmsndfile191 to i8*
call i32 (i8*, ...) @printf(i8* %var4600)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4601 = bitcast [100 x i8]* @gsxtmsndfile191 to i8*
call i32 (i8*, ...) @printf(i8* %var4601)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*, i32}*
%arg_p_0 = getelementptr {%SF_INFO*, i32}, {%SF_INFO*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
%arg_p_1 = getelementptr {%SF_INFO*, i32}, {%SF_INFO*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_channels_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile192 = hidden constant [36 x i8] c"sf_format_adhoc_W2kzMixTRl9JTkZPKl0\00"
define dllexport fastcc i32 @sf_format_adhoc_W2kzMixTRl9JTkZPKl0__4602(i8* %_impz,i8* %_impenv, %SF_INFO* %info) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4603 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}*
%sf_format_adhoc_W2kzMixTRl9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}* %impenv, i32 0, i32 0
%sf_format_adhoc_W2kzMixTRl9JTkZPKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**** %sf_format_adhoc_W2kzMixTRl9JTkZPKl0Ptr_

; setup arguments
%infoPtr = alloca %SF_INFO*
store %SF_INFO* %info, %SF_INFO** %infoPtr


%val4604 = load %SF_INFO*, %SF_INFO** %infoPtr
; tuple ref
%val4605 = getelementptr %SF_INFO, %SF_INFO* %val4604, i64 0, i32 3
%val4606 = load i32, i32* %val4605
ret i32 %val4606
}
@gsxtmsndfile193 = hidden constant [89 x i8] c"sf_format_adhoc_W2kzMixTRl9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4626 = load i8*, i8** %_impzPtr
%zone4627 = bitcast i8* %tzone4626 to %mzone*

; let assign value to symbol sf_format_adhoc_W2kzMixTRl9JTkZPKl0
%dat_sf_format_adhoc_W2kzMixTRl9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4627, i64 8)
%sf_format_adhoc_W2kzMixTRl9JTkZPKl0Ptr = bitcast i8* %dat_sf_format_adhoc_W2kzMixTRl9JTkZPKl0 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***
%tzone4607 = load i8*, i8** %_impzPtr
%zone4608 = bitcast i8* %tzone4607 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4608)
; malloc closure structure
%clsptr4609 = call i8* @llvm_zone_malloc(%mzone* %zone4608, i64 24)
%closure4610 = bitcast i8* %clsptr4609 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*

; malloc environment structure
%envptr4611 = call i8* @llvm_zone_malloc(%mzone* %zone4608, i64 8)
%environment4612 = bitcast i8* %envptr4611 to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}*

; malloc closure address table
%addytable4613 = call %clsvar* @new_address_table()
%var4614 = bitcast [36 x i8]* @gsxtmsndfile192 to i8*
%var4615 = bitcast [41 x i8]* @gsxtmsndfile183 to i8*
%addytable4616 = call %clsvar* @add_address_table(%mzone* %zone4608, i8* %var4614, i32 0, i8* %var4615, i32 3, %clsvar* %addytable4613)
%address-table4617 = bitcast %clsvar* %addytable4616 to i8*

; insert table, function and environment into closure struct
%closure.table4620 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4610, i32 0, i32 0
store i8* %address-table4617, i8** %closure.table4620
%closure.env4621 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4610, i32 0, i32 1
store i8* %envptr4611, i8** %closure.env4621
%closure.func4622 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4610, i32 0, i32 2
store i32 (i8*, i8*, %SF_INFO*)* @sf_format_adhoc_W2kzMixTRl9JTkZPKl0__4602, i32 (i8*, i8*, %SF_INFO*)** %closure.func4622
%closure_size4623 = call i64 @llvm_zone_mark_size(%mzone* %zone4608)
call void @llvm_zone_ptr_set_size(i8* %clsptr4609, i64 %closure_size4623)
%wrapper_ptr4624 = call i8* @llvm_zone_malloc(%mzone* %zone4608, i64 8)
%closure_wrapper4625 = bitcast i8* %wrapper_ptr4624 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4610, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4625

; let value assignment
%sf_format_adhoc_W2kzMixTRl9JTkZPKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4625, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4625
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %sf_format_adhoc_W2kzMixTRl9JTkZPKl0, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_format_adhoc_W2kzMixTRl9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var sf_format_adhoc_W2kzMixTRl9JTkZPKl0
%tmp_envptr4619 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}* %environment4612, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_format_adhoc_W2kzMixTRl9JTkZPKl0Ptr, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**** %tmp_envptr4619


%val4628 = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_format_adhoc_W2kzMixTRl9JTkZPKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %val4628
}


@sf_format_adhoc_W2kzMixTRl9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@sf_format_adhoc_W2kzMixTRl9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @sf_format_adhoc_W2kzMixTRl9JTkZPKl0(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_native(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4629 = bitcast [89 x i8]* @gsxtmsndfile193 to i8*
call i32 (i8*, ...) @printf(i8* %var4629)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*}*
%arg_p_0 = getelementptr {%SF_INFO*}, {%SF_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_format_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile194 = hidden constant [45 x i8] c"sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd\00"
define dllexport fastcc i32 @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd__4630(i8* %_impz,i8* %_impenv, %SF_INFO* %info, i32 %format_s_50) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4631 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}*
%sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}* %impenv, i32 0, i32 0
%sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**** %sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr_

; setup arguments
%infoPtr = alloca %SF_INFO*
store %SF_INFO* %info, %SF_INFO** %infoPtr
%format_s_50Ptr = alloca i32
store i32 %format_s_50, i32* %format_s_50Ptr


%val4632 = load %SF_INFO*, %SF_INFO** %infoPtr
%val4633 = load i32, i32* %format_s_50Ptr
; set tuple
%val4634 = getelementptr %SF_INFO, %SF_INFO* %val4632, i64 0, i32 3
store i32 %val4633, i32* %val4634
ret i32 %val4633
}
@gsxtmsndfile195 = hidden constant [98 x i8] c"sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4654 = load i8*, i8** %_impzPtr
%zone4655 = bitcast i8* %tzone4654 to %mzone*

; let assign value to symbol sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd
%dat_sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone4655, i64 8)
%sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr = bitcast i8* %dat_sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***
%tzone4635 = load i8*, i8** %_impzPtr
%zone4636 = bitcast i8* %tzone4635 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4636)
; malloc closure structure
%clsptr4637 = call i8* @llvm_zone_malloc(%mzone* %zone4636, i64 24)
%closure4638 = bitcast i8* %clsptr4637 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*

; malloc environment structure
%envptr4639 = call i8* @llvm_zone_malloc(%mzone* %zone4636, i64 8)
%environment4640 = bitcast i8* %envptr4639 to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}*

; malloc closure address table
%addytable4641 = call %clsvar* @new_address_table()
%var4642 = bitcast [45 x i8]* @gsxtmsndfile194 to i8*
%var4643 = bitcast [46 x i8]* @gsxtmsndfile186 to i8*
%addytable4644 = call %clsvar* @add_address_table(%mzone* %zone4636, i8* %var4642, i32 0, i8* %var4643, i32 3, %clsvar* %addytable4641)
%address-table4645 = bitcast %clsvar* %addytable4644 to i8*

; insert table, function and environment into closure struct
%closure.table4648 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4638, i32 0, i32 0
store i8* %address-table4645, i8** %closure.table4648
%closure.env4649 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4638, i32 0, i32 1
store i8* %envptr4639, i8** %closure.env4649
%closure.func4650 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4638, i32 0, i32 2
store i32 (i8*, i8*, %SF_INFO*, i32)* @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd__4630, i32 (i8*, i8*, %SF_INFO*, i32)** %closure.func4650
%closure_size4651 = call i64 @llvm_zone_mark_size(%mzone* %zone4636)
call void @llvm_zone_ptr_set_size(i8* %clsptr4637, i64 %closure_size4651)
%wrapper_ptr4652 = call i8* @llvm_zone_malloc(%mzone* %zone4636, i64 8)
%closure_wrapper4653 = bitcast i8* %wrapper_ptr4652 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4638, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4653

; let value assignment
%sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4653, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4653
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr

; add data to environment
; don't need to alloc for env var sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd
%tmp_envptr4647 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}* %environment4640, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**** %tmp_envptr4647


%val4656 = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr
ret {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %val4656
}


@sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd(%SF_INFO* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_native(%SF_INFO* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4657 = bitcast [98 x i8]* @gsxtmsndfile195 to i8*
call i32 (i8*, ...) @printf(i8* %var4657)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4658 = bitcast [98 x i8]* @gsxtmsndfile195 to i8*
call i32 (i8*, ...) @printf(i8* %var4658)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*, i32}*
%arg_p_0 = getelementptr {%SF_INFO*, i32}, {%SF_INFO*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
%arg_p_1 = getelementptr {%SF_INFO*, i32}, {%SF_INFO*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_format_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile196 = hidden constant [38 x i8] c"sf_sections_adhoc_W2kzMixTRl9JTkZPKl0\00"
define dllexport fastcc i32 @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0__4659(i8* %_impz,i8* %_impenv, %SF_INFO* %info) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4660 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}*
%sf_sections_adhoc_W2kzMixTRl9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}* %impenv, i32 0, i32 0
%sf_sections_adhoc_W2kzMixTRl9JTkZPKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**** %sf_sections_adhoc_W2kzMixTRl9JTkZPKl0Ptr_

; setup arguments
%infoPtr = alloca %SF_INFO*
store %SF_INFO* %info, %SF_INFO** %infoPtr


%val4661 = load %SF_INFO*, %SF_INFO** %infoPtr
; tuple ref
%val4662 = getelementptr %SF_INFO, %SF_INFO* %val4661, i64 0, i32 4
%val4663 = load i32, i32* %val4662
ret i32 %val4663
}
@gsxtmsndfile197 = hidden constant [91 x i8] c"sf_sections_adhoc_W2kzMixTRl9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4683 = load i8*, i8** %_impzPtr
%zone4684 = bitcast i8* %tzone4683 to %mzone*

; let assign value to symbol sf_sections_adhoc_W2kzMixTRl9JTkZPKl0
%dat_sf_sections_adhoc_W2kzMixTRl9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4684, i64 8)
%sf_sections_adhoc_W2kzMixTRl9JTkZPKl0Ptr = bitcast i8* %dat_sf_sections_adhoc_W2kzMixTRl9JTkZPKl0 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***
%tzone4664 = load i8*, i8** %_impzPtr
%zone4665 = bitcast i8* %tzone4664 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4665)
; malloc closure structure
%clsptr4666 = call i8* @llvm_zone_malloc(%mzone* %zone4665, i64 24)
%closure4667 = bitcast i8* %clsptr4666 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*

; malloc environment structure
%envptr4668 = call i8* @llvm_zone_malloc(%mzone* %zone4665, i64 8)
%environment4669 = bitcast i8* %envptr4668 to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}*

; malloc closure address table
%addytable4670 = call %clsvar* @new_address_table()
%var4671 = bitcast [38 x i8]* @gsxtmsndfile196 to i8*
%var4672 = bitcast [41 x i8]* @gsxtmsndfile183 to i8*
%addytable4673 = call %clsvar* @add_address_table(%mzone* %zone4665, i8* %var4671, i32 0, i8* %var4672, i32 3, %clsvar* %addytable4670)
%address-table4674 = bitcast %clsvar* %addytable4673 to i8*

; insert table, function and environment into closure struct
%closure.table4677 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4667, i32 0, i32 0
store i8* %address-table4674, i8** %closure.table4677
%closure.env4678 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4667, i32 0, i32 1
store i8* %envptr4668, i8** %closure.env4678
%closure.func4679 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4667, i32 0, i32 2
store i32 (i8*, i8*, %SF_INFO*)* @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0__4659, i32 (i8*, i8*, %SF_INFO*)** %closure.func4679
%closure_size4680 = call i64 @llvm_zone_mark_size(%mzone* %zone4665)
call void @llvm_zone_ptr_set_size(i8* %clsptr4666, i64 %closure_size4680)
%wrapper_ptr4681 = call i8* @llvm_zone_malloc(%mzone* %zone4665, i64 8)
%closure_wrapper4682 = bitcast i8* %wrapper_ptr4681 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4667, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4682

; let value assignment
%sf_sections_adhoc_W2kzMixTRl9JTkZPKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4682, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4682
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %sf_sections_adhoc_W2kzMixTRl9JTkZPKl0, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_sections_adhoc_W2kzMixTRl9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var sf_sections_adhoc_W2kzMixTRl9JTkZPKl0
%tmp_envptr4676 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}* %environment4669, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_sections_adhoc_W2kzMixTRl9JTkZPKl0Ptr, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**** %tmp_envptr4676


%val4685 = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_sections_adhoc_W2kzMixTRl9JTkZPKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %val4685
}


@sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_native(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4686 = bitcast [91 x i8]* @gsxtmsndfile197 to i8*
call i32 (i8*, ...) @printf(i8* %var4686)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*}*
%arg_p_0 = getelementptr {%SF_INFO*}, {%SF_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_sections_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile198 = hidden constant [47 x i8] c"sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd\00"
define dllexport fastcc i32 @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd__4687(i8* %_impz,i8* %_impenv, %SF_INFO* %info, i32 %sections) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4688 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}*
%sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}* %impenv, i32 0, i32 0
%sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**** %sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr_

; setup arguments
%infoPtr = alloca %SF_INFO*
store %SF_INFO* %info, %SF_INFO** %infoPtr
%sectionsPtr = alloca i32
store i32 %sections, i32* %sectionsPtr


%val4689 = load %SF_INFO*, %SF_INFO** %infoPtr
%val4690 = load i32, i32* %sectionsPtr
; set tuple
%val4691 = getelementptr %SF_INFO, %SF_INFO* %val4689, i64 0, i32 4
store i32 %val4690, i32* %val4691
ret i32 %val4690
}
@gsxtmsndfile199 = hidden constant [100 x i8] c"sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4711 = load i8*, i8** %_impzPtr
%zone4712 = bitcast i8* %tzone4711 to %mzone*

; let assign value to symbol sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd
%dat_sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone4712, i64 8)
%sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr = bitcast i8* %dat_sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***
%tzone4692 = load i8*, i8** %_impzPtr
%zone4693 = bitcast i8* %tzone4692 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4693)
; malloc closure structure
%clsptr4694 = call i8* @llvm_zone_malloc(%mzone* %zone4693, i64 24)
%closure4695 = bitcast i8* %clsptr4694 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*

; malloc environment structure
%envptr4696 = call i8* @llvm_zone_malloc(%mzone* %zone4693, i64 8)
%environment4697 = bitcast i8* %envptr4696 to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}*

; malloc closure address table
%addytable4698 = call %clsvar* @new_address_table()
%var4699 = bitcast [47 x i8]* @gsxtmsndfile198 to i8*
%var4700 = bitcast [46 x i8]* @gsxtmsndfile186 to i8*
%addytable4701 = call %clsvar* @add_address_table(%mzone* %zone4693, i8* %var4699, i32 0, i8* %var4700, i32 3, %clsvar* %addytable4698)
%address-table4702 = bitcast %clsvar* %addytable4701 to i8*

; insert table, function and environment into closure struct
%closure.table4705 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4695, i32 0, i32 0
store i8* %address-table4702, i8** %closure.table4705
%closure.env4706 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4695, i32 0, i32 1
store i8* %envptr4696, i8** %closure.env4706
%closure.func4707 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4695, i32 0, i32 2
store i32 (i8*, i8*, %SF_INFO*, i32)* @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd__4687, i32 (i8*, i8*, %SF_INFO*, i32)** %closure.func4707
%closure_size4708 = call i64 @llvm_zone_mark_size(%mzone* %zone4693)
call void @llvm_zone_ptr_set_size(i8* %clsptr4694, i64 %closure_size4708)
%wrapper_ptr4709 = call i8* @llvm_zone_malloc(%mzone* %zone4693, i64 8)
%closure_wrapper4710 = bitcast i8* %wrapper_ptr4709 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4695, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4710

; let value assignment
%sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4710, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4710
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr

; add data to environment
; don't need to alloc for env var sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd
%tmp_envptr4704 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}* %environment4697, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**** %tmp_envptr4704


%val4713 = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr
ret {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %val4713
}


@sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd(%SF_INFO* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_native(%SF_INFO* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4714 = bitcast [100 x i8]* @gsxtmsndfile199 to i8*
call i32 (i8*, ...) @printf(i8* %var4714)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4715 = bitcast [100 x i8]* @gsxtmsndfile199 to i8*
call i32 (i8*, ...) @printf(i8* %var4715)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*, i32}*
%arg_p_0 = getelementptr {%SF_INFO*, i32}, {%SF_INFO*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
%arg_p_1 = getelementptr {%SF_INFO*, i32}, {%SF_INFO*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_sections_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile200 = hidden constant [38 x i8] c"sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0\00"
define dllexport fastcc i32 @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0__4716(i8* %_impz,i8* %_impenv, %SF_INFO* %info) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4717 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}*
%sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}* %impenv, i32 0, i32 0
%sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**** %sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0Ptr_

; setup arguments
%infoPtr = alloca %SF_INFO*
store %SF_INFO* %info, %SF_INFO** %infoPtr


%val4718 = load %SF_INFO*, %SF_INFO** %infoPtr
; tuple ref
%val4719 = getelementptr %SF_INFO, %SF_INFO* %val4718, i64 0, i32 5
%val4720 = load i32, i32* %val4719
ret i32 %val4720
}
@gsxtmsndfile201 = hidden constant [91 x i8] c"sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4740 = load i8*, i8** %_impzPtr
%zone4741 = bitcast i8* %tzone4740 to %mzone*

; let assign value to symbol sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0
%dat_sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4741, i64 8)
%sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0Ptr = bitcast i8* %dat_sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***
%tzone4721 = load i8*, i8** %_impzPtr
%zone4722 = bitcast i8* %tzone4721 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4722)
; malloc closure structure
%clsptr4723 = call i8* @llvm_zone_malloc(%mzone* %zone4722, i64 24)
%closure4724 = bitcast i8* %clsptr4723 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*

; malloc environment structure
%envptr4725 = call i8* @llvm_zone_malloc(%mzone* %zone4722, i64 8)
%environment4726 = bitcast i8* %envptr4725 to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}*

; malloc closure address table
%addytable4727 = call %clsvar* @new_address_table()
%var4728 = bitcast [38 x i8]* @gsxtmsndfile200 to i8*
%var4729 = bitcast [41 x i8]* @gsxtmsndfile183 to i8*
%addytable4730 = call %clsvar* @add_address_table(%mzone* %zone4722, i8* %var4728, i32 0, i8* %var4729, i32 3, %clsvar* %addytable4727)
%address-table4731 = bitcast %clsvar* %addytable4730 to i8*

; insert table, function and environment into closure struct
%closure.table4734 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4724, i32 0, i32 0
store i8* %address-table4731, i8** %closure.table4734
%closure.env4735 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4724, i32 0, i32 1
store i8* %envptr4725, i8** %closure.env4735
%closure.func4736 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4724, i32 0, i32 2
store i32 (i8*, i8*, %SF_INFO*)* @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0__4716, i32 (i8*, i8*, %SF_INFO*)** %closure.func4736
%closure_size4737 = call i64 @llvm_zone_mark_size(%mzone* %zone4722)
call void @llvm_zone_ptr_set_size(i8* %clsptr4723, i64 %closure_size4737)
%wrapper_ptr4738 = call i8* @llvm_zone_malloc(%mzone* %zone4722, i64 8)
%closure_wrapper4739 = bitcast i8* %wrapper_ptr4738 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure4724, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4739

; let value assignment
%sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4739, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_wrapper4739
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0Ptr

; add data to environment
; don't need to alloc for env var sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0
%tmp_envptr4733 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}***}* %environment4726, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0Ptr, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**** %tmp_envptr4733


%val4742 = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*** %sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %val4742
}


@sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_native(%SF_INFO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4743 = bitcast [91 x i8]* @gsxtmsndfile201 to i8*
call i32 (i8*, ...) @printf(i8* %var4743)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*}*
%arg_p_0 = getelementptr {%SF_INFO*}, {%SF_INFO*}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_seekable_adhoc_W2kzMixTRl9JTkZPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*)*,  i32 (i8*, i8*, %SF_INFO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile202 = hidden constant [47 x i8] c"sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd\00"
define dllexport fastcc i32 @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd__4744(i8* %_impz,i8* %_impenv, %SF_INFO* %info, i32 %seekable) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4745 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}*
%sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}* %impenv, i32 0, i32 0
%sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**** %sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr_

; setup arguments
%infoPtr = alloca %SF_INFO*
store %SF_INFO* %info, %SF_INFO** %infoPtr
%seekablePtr = alloca i32
store i32 %seekable, i32* %seekablePtr


%val4746 = load %SF_INFO*, %SF_INFO** %infoPtr
%val4747 = load i32, i32* %seekablePtr
; set tuple
%val4748 = getelementptr %SF_INFO, %SF_INFO* %val4746, i64 0, i32 5
store i32 %val4747, i32* %val4748
ret i32 %val4747
}
@gsxtmsndfile203 = hidden constant [100 x i8] c"sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4768 = load i8*, i8** %_impzPtr
%zone4769 = bitcast i8* %tzone4768 to %mzone*

; let assign value to symbol sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd
%dat_sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone4769, i64 8)
%sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr = bitcast i8* %dat_sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***
%tzone4749 = load i8*, i8** %_impzPtr
%zone4750 = bitcast i8* %tzone4749 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4750)
; malloc closure structure
%clsptr4751 = call i8* @llvm_zone_malloc(%mzone* %zone4750, i64 24)
%closure4752 = bitcast i8* %clsptr4751 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*

; malloc environment structure
%envptr4753 = call i8* @llvm_zone_malloc(%mzone* %zone4750, i64 8)
%environment4754 = bitcast i8* %envptr4753 to {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}*

; malloc closure address table
%addytable4755 = call %clsvar* @new_address_table()
%var4756 = bitcast [47 x i8]* @gsxtmsndfile202 to i8*
%var4757 = bitcast [46 x i8]* @gsxtmsndfile186 to i8*
%addytable4758 = call %clsvar* @add_address_table(%mzone* %zone4750, i8* %var4756, i32 0, i8* %var4757, i32 3, %clsvar* %addytable4755)
%address-table4759 = bitcast %clsvar* %addytable4758 to i8*

; insert table, function and environment into closure struct
%closure.table4762 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4752, i32 0, i32 0
store i8* %address-table4759, i8** %closure.table4762
%closure.env4763 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4752, i32 0, i32 1
store i8* %envptr4753, i8** %closure.env4763
%closure.func4764 = getelementptr { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4752, i32 0, i32 2
store i32 (i8*, i8*, %SF_INFO*, i32)* @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd__4744, i32 (i8*, i8*, %SF_INFO*, i32)** %closure.func4764
%closure_size4765 = call i64 @llvm_zone_mark_size(%mzone* %zone4750)
call void @llvm_zone_ptr_set_size(i8* %clsptr4751, i64 %closure_size4765)
%wrapper_ptr4766 = call i8* @llvm_zone_malloc(%mzone* %zone4750, i64 8)
%closure_wrapper4767 = bitcast i8* %wrapper_ptr4766 to { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure4752, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4767

; let value assignment
%sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4767, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_wrapper4767
store { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd, { i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr

; add data to environment
; don't need to alloc for env var sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd
%tmp_envptr4761 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}***}* %environment4754, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**** %tmp_envptr4761


%val4770 = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*** %sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJdPtr
ret {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %val4770
}


@sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd(%SF_INFO* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_native(%SF_INFO* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4771 = bitcast [100 x i8]* @gsxtmsndfile203 to i8*
call i32 (i8*, ...) @printf(i8* %var4771)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %SF_INFO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4772 = bitcast [100 x i8]* @gsxtmsndfile203 to i8*
call i32 (i8*, ...) @printf(i8* %var4772)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%SF_INFO*, i32}*
%arg_p_0 = getelementptr {%SF_INFO*, i32}, {%SF_INFO*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %SF_INFO*, %SF_INFO** %arg_p_0
%arg_p_1 = getelementptr {%SF_INFO*, i32}, {%SF_INFO*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_set_seekable_adhoc_W2kzMixTRl9JTkZPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %SF_INFO*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %SF_INFO*, i32)*,  i32 (i8*, i8*, %SF_INFO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %SF_INFO* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile204 = hidden constant [39 x i8] c"sf_frames_from_file_adhoc_W2k2NCxpOCpd\00"
@gsxtmsndfile205 = hidden constant [35 x i8] c"{i8*, i8*, i64 (i8*, i8*, i8*)*}**\00"
define dllexport fastcc i64 @sf_frames_from_file_adhoc_W2k2NCxpOCpd__4773(i8* %_impz,i8* %_impenv, i8* %filename) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4774 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}*
%sf_frames_from_file_adhoc_W2k2NCxpOCpdPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%sf_frames_from_file_adhoc_W2k2NCxpOCpdPtr = load {i8*, i8*, i64 (i8*, i8*, i8*)*}***, {i8*, i8*, i64 (i8*, i8*, i8*)*}**** %sf_frames_from_file_adhoc_W2k2NCxpOCpdPtr_

; setup arguments
%filenamePtr = alloca i8*
store i8* %filename, i8** %filenamePtr


%tzone4776 = load i8*, i8** %_impzPtr
%zone4777 = bitcast i8* %tzone4776 to %mzone*

; let assign value to symbol info
%infoPtr = alloca %SF_INFO*
%tzone4782 = load i8*, i8** %_impzPtr
%zone4783 = bitcast i8* %tzone4782 to %mzone*

; let assign value to symbol audiofile
%audiofilePtr = alloca i8*
%dat4775 = alloca %SF_INFO, align 16

; let value assignment
%info = select i1 true, %SF_INFO* %dat4775, %SF_INFO* %dat4775
store %SF_INFO* %info, %SF_INFO** %infoPtr

%val4778 = load i8*, i8** %filenamePtr
%val4779 = load i32, i32* @SFM_READ
%val4780 = load %SF_INFO*, %SF_INFO** %infoPtr
%res4781 = call ccc i8* @sf_open(i8* %val4778, i32 %val4779, %SF_INFO* %val4780)

; let value assignment
%audiofile = select i1 true, i8* %res4781, i8* %res4781
store i8* %audiofile, i8** %audiofilePtr

%val4785 = load i8*, i8** %audiofilePtr
%val4786 = icmp eq i8* %val4785, null
br i1 %val4786, label %then4784, label %else4784

then4784:
ret i64 -1

else4784:
%val4787 = load i8*, i8** %audiofilePtr
%res4788 = call ccc i32 @sf_close(i8* %val4787)
%val4789 = load %SF_INFO*, %SF_INFO** %infoPtr
%res4790 = call fastcc i64 @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0(%SF_INFO* %val4789)
ret i64 %res4790
}
@gsxtmsndfile206 = hidden constant [92 x i8] c"sf_frames_from_file_adhoc_W2k2NCxpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, i8*)*}** @sf_frames_from_file_adhoc_W2k2NCxpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4810 = load i8*, i8** %_impzPtr
%zone4811 = bitcast i8* %tzone4810 to %mzone*

; let assign value to symbol sf_frames_from_file_adhoc_W2k2NCxpOCpd
%dat_sf_frames_from_file_adhoc_W2k2NCxpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone4811, i64 8)
%sf_frames_from_file_adhoc_W2k2NCxpOCpdPtr = bitcast i8* %dat_sf_frames_from_file_adhoc_W2k2NCxpOCpd to { i8*, i8*, i64 (i8*, i8*, i8*)*}***
%tzone4791 = load i8*, i8** %_impzPtr
%zone4792 = bitcast i8* %tzone4791 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4792)
; malloc closure structure
%clsptr4793 = call i8* @llvm_zone_malloc(%mzone* %zone4792, i64 24)
%closure4794 = bitcast i8* %clsptr4793 to { i8*, i8*, i64 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr4795 = call i8* @llvm_zone_malloc(%mzone* %zone4792, i64 8)
%environment4796 = bitcast i8* %envptr4795 to {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable4797 = call %clsvar* @new_address_table()
%var4798 = bitcast [39 x i8]* @gsxtmsndfile204 to i8*
%var4799 = bitcast [35 x i8]* @gsxtmsndfile205 to i8*
%addytable4800 = call %clsvar* @add_address_table(%mzone* %zone4792, i8* %var4798, i32 0, i8* %var4799, i32 3, %clsvar* %addytable4797)
%address-table4801 = bitcast %clsvar* %addytable4800 to i8*

; insert table, function and environment into closure struct
%closure.table4804 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*)*}, { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure4794, i32 0, i32 0
store i8* %address-table4801, i8** %closure.table4804
%closure.env4805 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*)*}, { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure4794, i32 0, i32 1
store i8* %envptr4795, i8** %closure.env4805
%closure.func4806 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*)*}, { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure4794, i32 0, i32 2
store i64 (i8*, i8*, i8*)* @sf_frames_from_file_adhoc_W2k2NCxpOCpd__4773, i64 (i8*, i8*, i8*)** %closure.func4806
%closure_size4807 = call i64 @llvm_zone_mark_size(%mzone* %zone4792)
call void @llvm_zone_ptr_set_size(i8* %clsptr4793, i64 %closure_size4807)
%wrapper_ptr4808 = call i8* @llvm_zone_malloc(%mzone* %zone4792, i64 8)
%closure_wrapper4809 = bitcast i8* %wrapper_ptr4808 to { i8*, i8*, i64 (i8*, i8*, i8*)*}**
store { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure4794, { i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_wrapper4809

; let value assignment
%sf_frames_from_file_adhoc_W2k2NCxpOCpd = select i1 true, { i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_wrapper4809, { i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_wrapper4809
store { i8*, i8*, i64 (i8*, i8*, i8*)*}** %sf_frames_from_file_adhoc_W2k2NCxpOCpd, { i8*, i8*, i64 (i8*, i8*, i8*)*}*** %sf_frames_from_file_adhoc_W2k2NCxpOCpdPtr

; add data to environment
; don't need to alloc for env var sf_frames_from_file_adhoc_W2k2NCxpOCpd
%tmp_envptr4803 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}* %environment4796, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, i8*)*}*** %sf_frames_from_file_adhoc_W2k2NCxpOCpdPtr, {i8*, i8*, i64 (i8*, i8*, i8*)*}**** %tmp_envptr4803


%val4812 = load {i8*, i8*, i64 (i8*, i8*, i8*)*}**, {i8*, i8*, i64 (i8*, i8*, i8*)*}*** %sf_frames_from_file_adhoc_W2k2NCxpOCpdPtr
ret {i8*, i8*, i64 (i8*, i8*, i8*)*}** %val4812
}


@sf_frames_from_file_adhoc_W2k2NCxpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@sf_frames_from_file_adhoc_W2k2NCxpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_frames_from_file_adhoc_W2k2NCxpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_frames_from_file_adhoc_W2k2NCxpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, i8*)*}** @sf_frames_from_file_adhoc_W2k2NCxpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_frames_from_file_adhoc_W2k2NCxpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_frames_from_file_adhoc_W2k2NCxpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_frames_from_file_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @sf_frames_from_file_adhoc_W2k2NCxpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_frames_from_file_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @sf_frames_from_file_adhoc_W2k2NCxpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_frames_from_file_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @sf_frames_from_file_adhoc_W2k2NCxpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4813 = bitcast [92 x i8]* @gsxtmsndfile206 to i8*
call i32 (i8*, ...) @printf(i8* %var4813)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_frames_from_file_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @sf_frames_from_file_adhoc_W2k2NCxpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_frames_from_file_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile207 = hidden constant [41 x i8] c"sf_channels_from_file_adhoc_W2kzMixpOCpd\00"
@gsxtmsndfile208 = hidden constant [35 x i8] c"{i8*, i8*, i32 (i8*, i8*, i8*)*}**\00"
define dllexport fastcc i32 @sf_channels_from_file_adhoc_W2kzMixpOCpd__4814(i8* %_impz,i8* %_impenv, i8* %filename) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4815 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}*
%sf_channels_from_file_adhoc_W2kzMixpOCpdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%sf_channels_from_file_adhoc_W2kzMixpOCpdPtr = load {i8*, i8*, i32 (i8*, i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %sf_channels_from_file_adhoc_W2kzMixpOCpdPtr_

; setup arguments
%filenamePtr = alloca i8*
store i8* %filename, i8** %filenamePtr


%tzone4817 = load i8*, i8** %_impzPtr
%zone4818 = bitcast i8* %tzone4817 to %mzone*

; let assign value to symbol info
%infoPtr = alloca %SF_INFO*
%tzone4823 = load i8*, i8** %_impzPtr
%zone4824 = bitcast i8* %tzone4823 to %mzone*

; let assign value to symbol audiofile
%audiofilePtr = alloca i8*
%dat4816 = alloca %SF_INFO, align 16

; let value assignment
%info = select i1 true, %SF_INFO* %dat4816, %SF_INFO* %dat4816
store %SF_INFO* %info, %SF_INFO** %infoPtr

%val4819 = load i8*, i8** %filenamePtr
%val4820 = load i32, i32* @SFM_READ
%val4821 = load %SF_INFO*, %SF_INFO** %infoPtr
%res4822 = call ccc i8* @sf_open(i8* %val4819, i32 %val4820, %SF_INFO* %val4821)

; let value assignment
%audiofile = select i1 true, i8* %res4822, i8* %res4822
store i8* %audiofile, i8** %audiofilePtr

%val4826 = load i8*, i8** %audiofilePtr
%val4827 = icmp eq i8* %val4826, null
br i1 %val4827, label %then4825, label %else4825

then4825:
ret i32 -1

else4825:
%val4828 = load i8*, i8** %audiofilePtr
%res4829 = call ccc i32 @sf_close(i8* %val4828)
%val4830 = load %SF_INFO*, %SF_INFO** %infoPtr
%res4831 = call fastcc i32 @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0(%SF_INFO* %val4830)
ret i32 %res4831
}
@gsxtmsndfile209 = hidden constant [94 x i8] c"sf_channels_from_file_adhoc_W2kzMixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i8*)*}** @sf_channels_from_file_adhoc_W2kzMixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4851 = load i8*, i8** %_impzPtr
%zone4852 = bitcast i8* %tzone4851 to %mzone*

; let assign value to symbol sf_channels_from_file_adhoc_W2kzMixpOCpd
%dat_sf_channels_from_file_adhoc_W2kzMixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone4852, i64 8)
%sf_channels_from_file_adhoc_W2kzMixpOCpdPtr = bitcast i8* %dat_sf_channels_from_file_adhoc_W2kzMixpOCpd to { i8*, i8*, i32 (i8*, i8*, i8*)*}***
%tzone4832 = load i8*, i8** %_impzPtr
%zone4833 = bitcast i8* %tzone4832 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4833)
; malloc closure structure
%clsptr4834 = call i8* @llvm_zone_malloc(%mzone* %zone4833, i64 24)
%closure4835 = bitcast i8* %clsptr4834 to { i8*, i8*, i32 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr4836 = call i8* @llvm_zone_malloc(%mzone* %zone4833, i64 8)
%environment4837 = bitcast i8* %envptr4836 to {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable4838 = call %clsvar* @new_address_table()
%var4839 = bitcast [41 x i8]* @gsxtmsndfile207 to i8*
%var4840 = bitcast [35 x i8]* @gsxtmsndfile208 to i8*
%addytable4841 = call %clsvar* @add_address_table(%mzone* %zone4833, i8* %var4839, i32 0, i8* %var4840, i32 3, %clsvar* %addytable4838)
%address-table4842 = bitcast %clsvar* %addytable4841 to i8*

; insert table, function and environment into closure struct
%closure.table4845 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure4835, i32 0, i32 0
store i8* %address-table4842, i8** %closure.table4845
%closure.env4846 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure4835, i32 0, i32 1
store i8* %envptr4836, i8** %closure.env4846
%closure.func4847 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure4835, i32 0, i32 2
store i32 (i8*, i8*, i8*)* @sf_channels_from_file_adhoc_W2kzMixpOCpd__4814, i32 (i8*, i8*, i8*)** %closure.func4847
%closure_size4848 = call i64 @llvm_zone_mark_size(%mzone* %zone4833)
call void @llvm_zone_ptr_set_size(i8* %clsptr4834, i64 %closure_size4848)
%wrapper_ptr4849 = call i8* @llvm_zone_malloc(%mzone* %zone4833, i64 8)
%closure_wrapper4850 = bitcast i8* %wrapper_ptr4849 to { i8*, i8*, i32 (i8*, i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure4835, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper4850

; let value assignment
%sf_channels_from_file_adhoc_W2kzMixpOCpd = select i1 true, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper4850, { i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_wrapper4850
store { i8*, i8*, i32 (i8*, i8*, i8*)*}** %sf_channels_from_file_adhoc_W2kzMixpOCpd, { i8*, i8*, i32 (i8*, i8*, i8*)*}*** %sf_channels_from_file_adhoc_W2kzMixpOCpdPtr

; add data to environment
; don't need to alloc for env var sf_channels_from_file_adhoc_W2kzMixpOCpd
%tmp_envptr4844 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*)*}***}* %environment4837, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %sf_channels_from_file_adhoc_W2kzMixpOCpdPtr, {i8*, i8*, i32 (i8*, i8*, i8*)*}**** %tmp_envptr4844


%val4853 = load {i8*, i8*, i32 (i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*)*}*** %sf_channels_from_file_adhoc_W2kzMixpOCpdPtr
ret {i8*, i8*, i32 (i8*, i8*, i8*)*}** %val4853
}


@sf_channels_from_file_adhoc_W2kzMixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@sf_channels_from_file_adhoc_W2kzMixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_channels_from_file_adhoc_W2kzMixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_channels_from_file_adhoc_W2kzMixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i8*)*}** @sf_channels_from_file_adhoc_W2kzMixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_channels_from_file_adhoc_W2kzMixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_channels_from_file_adhoc_W2kzMixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_channels_from_file_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @sf_channels_from_file_adhoc_W2kzMixpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_channels_from_file_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @sf_channels_from_file_adhoc_W2kzMixpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_channels_from_file_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @sf_channels_from_file_adhoc_W2kzMixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4854 = bitcast [94 x i8]* @gsxtmsndfile209 to i8*
call i32 (i8*, ...) @printf(i8* %var4854)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_channels_from_file_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @sf_channels_from_file_adhoc_W2kzMixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_channels_from_file_adhoc_W2kzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile210 = hidden constant [40 x i8] c"sf_samples_from_file_adhoc_W2k2NCxpOCpd\00"
define dllexport fastcc i64 @sf_samples_from_file_adhoc_W2k2NCxpOCpd__4855(i8* %_impz,i8* %_impenv, i8* %filename) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4856 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}*
%sf_samples_from_file_adhoc_W2k2NCxpOCpdPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%sf_samples_from_file_adhoc_W2k2NCxpOCpdPtr = load {i8*, i8*, i64 (i8*, i8*, i8*)*}***, {i8*, i8*, i64 (i8*, i8*, i8*)*}**** %sf_samples_from_file_adhoc_W2k2NCxpOCpdPtr_

; setup arguments
%filenamePtr = alloca i8*
store i8* %filename, i8** %filenamePtr


%tzone4858 = load i8*, i8** %_impzPtr
%zone4859 = bitcast i8* %tzone4858 to %mzone*

; let assign value to symbol info
%infoPtr = alloca %SF_INFO*
%tzone4864 = load i8*, i8** %_impzPtr
%zone4865 = bitcast i8* %tzone4864 to %mzone*

; let assign value to symbol audiofile
%audiofilePtr = alloca i8*
%dat4857 = alloca %SF_INFO, align 16

; let value assignment
%info = select i1 true, %SF_INFO* %dat4857, %SF_INFO* %dat4857
store %SF_INFO* %info, %SF_INFO** %infoPtr

%val4860 = load i8*, i8** %filenamePtr
%val4861 = load i32, i32* @SFM_READ
%val4862 = load %SF_INFO*, %SF_INFO** %infoPtr
%res4863 = call ccc i8* @sf_open(i8* %val4860, i32 %val4861, %SF_INFO* %val4862)

; let value assignment
%audiofile = select i1 true, i8* %res4863, i8* %res4863
store i8* %audiofile, i8** %audiofilePtr

%val4867 = load i8*, i8** %audiofilePtr
%val4868 = icmp eq i8* %val4867, null
br i1 %val4868, label %then4866, label %else4866

then4866:
ret i64 -1

else4866:
%val4869 = load i8*, i8** %audiofilePtr
%res4870 = call ccc i32 @sf_close(i8* %val4869)
%val4871 = load %SF_INFO*, %SF_INFO** %infoPtr
%res4872 = call fastcc i64 @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0(%SF_INFO* %val4871)
%val4873 = load %SF_INFO*, %SF_INFO** %infoPtr
%res4874 = call fastcc i32 @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0(%SF_INFO* %val4873)
%val4875 = sext i32 %res4874 to i64
%val4876 = mul i64 %res4872, %val4875
ret i64 %val4876
}
@gsxtmsndfile211 = hidden constant [93 x i8] c"sf_samples_from_file_adhoc_W2k2NCxpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, i8*)*}** @sf_samples_from_file_adhoc_W2k2NCxpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4896 = load i8*, i8** %_impzPtr
%zone4897 = bitcast i8* %tzone4896 to %mzone*

; let assign value to symbol sf_samples_from_file_adhoc_W2k2NCxpOCpd
%dat_sf_samples_from_file_adhoc_W2k2NCxpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone4897, i64 8)
%sf_samples_from_file_adhoc_W2k2NCxpOCpdPtr = bitcast i8* %dat_sf_samples_from_file_adhoc_W2k2NCxpOCpd to { i8*, i8*, i64 (i8*, i8*, i8*)*}***
%tzone4877 = load i8*, i8** %_impzPtr
%zone4878 = bitcast i8* %tzone4877 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4878)
; malloc closure structure
%clsptr4879 = call i8* @llvm_zone_malloc(%mzone* %zone4878, i64 24)
%closure4880 = bitcast i8* %clsptr4879 to { i8*, i8*, i64 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr4881 = call i8* @llvm_zone_malloc(%mzone* %zone4878, i64 8)
%environment4882 = bitcast i8* %envptr4881 to {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable4883 = call %clsvar* @new_address_table()
%var4884 = bitcast [40 x i8]* @gsxtmsndfile210 to i8*
%var4885 = bitcast [35 x i8]* @gsxtmsndfile205 to i8*
%addytable4886 = call %clsvar* @add_address_table(%mzone* %zone4878, i8* %var4884, i32 0, i8* %var4885, i32 3, %clsvar* %addytable4883)
%address-table4887 = bitcast %clsvar* %addytable4886 to i8*

; insert table, function and environment into closure struct
%closure.table4890 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*)*}, { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure4880, i32 0, i32 0
store i8* %address-table4887, i8** %closure.table4890
%closure.env4891 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*)*}, { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure4880, i32 0, i32 1
store i8* %envptr4881, i8** %closure.env4891
%closure.func4892 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*)*}, { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure4880, i32 0, i32 2
store i64 (i8*, i8*, i8*)* @sf_samples_from_file_adhoc_W2k2NCxpOCpd__4855, i64 (i8*, i8*, i8*)** %closure.func4892
%closure_size4893 = call i64 @llvm_zone_mark_size(%mzone* %zone4878)
call void @llvm_zone_ptr_set_size(i8* %clsptr4879, i64 %closure_size4893)
%wrapper_ptr4894 = call i8* @llvm_zone_malloc(%mzone* %zone4878, i64 8)
%closure_wrapper4895 = bitcast i8* %wrapper_ptr4894 to { i8*, i8*, i64 (i8*, i8*, i8*)*}**
store { i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure4880, { i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_wrapper4895

; let value assignment
%sf_samples_from_file_adhoc_W2k2NCxpOCpd = select i1 true, { i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_wrapper4895, { i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_wrapper4895
store { i8*, i8*, i64 (i8*, i8*, i8*)*}** %sf_samples_from_file_adhoc_W2k2NCxpOCpd, { i8*, i8*, i64 (i8*, i8*, i8*)*}*** %sf_samples_from_file_adhoc_W2k2NCxpOCpdPtr

; add data to environment
; don't need to alloc for env var sf_samples_from_file_adhoc_W2k2NCxpOCpd
%tmp_envptr4889 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i64 (i8*, i8*, i8*)*}***}* %environment4882, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, i8*)*}*** %sf_samples_from_file_adhoc_W2k2NCxpOCpdPtr, {i8*, i8*, i64 (i8*, i8*, i8*)*}**** %tmp_envptr4889


%val4898 = load {i8*, i8*, i64 (i8*, i8*, i8*)*}**, {i8*, i8*, i64 (i8*, i8*, i8*)*}*** %sf_samples_from_file_adhoc_W2k2NCxpOCpdPtr
ret {i8*, i8*, i64 (i8*, i8*, i8*)*}** %val4898
}


@sf_samples_from_file_adhoc_W2k2NCxpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@sf_samples_from_file_adhoc_W2k2NCxpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_samples_from_file_adhoc_W2k2NCxpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_samples_from_file_adhoc_W2k2NCxpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, i8*)*}** @sf_samples_from_file_adhoc_W2k2NCxpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_samples_from_file_adhoc_W2k2NCxpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_samples_from_file_adhoc_W2k2NCxpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_samples_from_file_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @sf_samples_from_file_adhoc_W2k2NCxpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_samples_from_file_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @sf_samples_from_file_adhoc_W2k2NCxpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_samples_from_file_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @sf_samples_from_file_adhoc_W2k2NCxpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4899 = bitcast [93 x i8]* @gsxtmsndfile211 to i8*
call i32 (i8*, ...) @printf(i8* %var4899)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_samples_from_file_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @sf_samples_from_file_adhoc_W2k2NCxpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_samples_from_file_adhoc_W2k2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*)*}*, {i8*, i8*, i64 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*)*}, {i8*, i8*, i64 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*)*,  i64 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile212 = hidden constant [17 x i8] c"---------------
\00"
@gsxtmsndfile213 = hidden constant [19 x i8] c"file name:     %s
\00"
@gsxtmsndfile214 = hidden constant [19 x i8] c"samplerate:    %d
\00"
@gsxtmsndfile215 = hidden constant [19 x i8] c"channels:      %d
\00"
@gsxtmsndfile216 = hidden constant [19 x i8] c"frames:        %d
\00"
@gsxtmsndfile217 = hidden constant [21 x i8] c"samples read:  %lld
\00"
@gsxtmsndfile218 = hidden constant [13 x i8] c"errors:  %s
\00"
@gsxtmsndfile219 = hidden constant [68 x i8] c"sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd\00"
@gsxtmsndfile220 = hidden constant [57 x i8] c"{i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}**\00"
define dllexport fastcc i64 @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd__4900(i8* %_impz,i8* %_impenv, i8* %filename, float* %data, i64 %start, i64 %nframes, i1 %print_p) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4901 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}***}*
%sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFdPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}***}, {{i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}***}* %impenv, i32 0, i32 0
%sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFdPtr = load {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}***, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}**** %sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFdPtr_

; setup arguments
%filenamePtr = alloca i8*
store i8* %filename, i8** %filenamePtr
%dataPtr = alloca float*
store float* %data, float** %dataPtr
%startPtr = alloca i64
store i64 %start, i64* %startPtr
%nframesPtr = alloca i64
store i64 %nframes, i64* %nframesPtr
%print_pPtr = alloca i1
store i1 %print_p, i1* %print_pPtr


%tzone4903 = load i8*, i8** %_impzPtr
%zone4904 = bitcast i8* %tzone4903 to %mzone*

; let assign value to symbol info
%infoPtr = alloca %SF_INFO*
%tzone4909 = load i8*, i8** %_impzPtr
%zone4910 = bitcast i8* %tzone4909 to %mzone*

; let assign value to symbol audiofile
%audiofilePtr = alloca i8*
%tzone4915 = load i8*, i8** %_impzPtr
%zone4916 = bitcast i8* %tzone4915 to %mzone*

; let assign value to symbol channels
%channelsPtr = alloca i64
%tzone4920 = load i8*, i8** %_impzPtr
%zone4921 = bitcast i8* %tzone4920 to %mzone*

; let assign value to symbol nsamples
%nsamplesPtr = alloca i64
%tzone4925 = load i8*, i8** %_impzPtr
%zone4926 = bitcast i8* %tzone4925 to %mzone*

; let assign value to symbol sample_idx
%sample_idxPtr = alloca i64
%tzone4930 = load i8*, i8** %_impzPtr
%zone4931 = bitcast i8* %tzone4930 to %mzone*

; let assign value to symbol cnt
%cntPtr = alloca i64
%tzone4936 = load i8*, i8** %_impzPtr
%zone4937 = bitcast i8* %tzone4936 to %mzone*

; let assign value to symbol nread
%nreadPtr = alloca i64
%dat4902 = alloca %SF_INFO, align 16

; let value assignment
%info = select i1 true, %SF_INFO* %dat4902, %SF_INFO* %dat4902
store %SF_INFO* %info, %SF_INFO** %infoPtr

%val4905 = load i8*, i8** %filenamePtr
%val4906 = load i32, i32* @SFM_READ
%val4907 = load %SF_INFO*, %SF_INFO** %infoPtr
%res4908 = call ccc i8* @sf_open(i8* %val4905, i32 %val4906, %SF_INFO* %val4907)

; let value assignment
%audiofile = select i1 true, i8* %res4908, i8* %res4908
store i8* %audiofile, i8** %audiofilePtr

%val4911 = load %SF_INFO*, %SF_INFO** %infoPtr
; tuple ref
%val4912 = getelementptr %SF_INFO, %SF_INFO* %val4911, i64 0, i32 2
%val4913 = load i32, i32* %val4912
%val4914 = sext i32 %val4913 to i64

; let value assignment
%channels = select i1 true, i64 %val4914, i64 %val4914
store i64 %channels, i64* %channelsPtr

%val4917 = load i64, i64* %nframesPtr
%val4918 = load i64, i64* %channelsPtr
%val4919 = mul i64 %val4917, %val4918

; let value assignment
%nsamples = select i1 true, i64 %val4919, i64 %val4919
store i64 %nsamples, i64* %nsamplesPtr

%val4922 = load i64, i64* %startPtr
%val4923 = load i64, i64* %channelsPtr
%val4924 = mul i64 %val4922, %val4923

; let value assignment
%sample_idx = select i1 true, i64 %val4924, i64 %val4924
store i64 %sample_idx, i64* %sample_idxPtr

%val4927 = load i8*, i8** %audiofilePtr
%val4928 = load i64, i64* %sample_idxPtr
%res4929 = call ccc i64 @sf_seek(i8* %val4927, i64 %val4928, i32 0)

; let value assignment
%cnt = select i1 true, i64 %res4929, i64 %res4929
store i64 %cnt, i64* %cntPtr

%val4932 = load i8*, i8** %audiofilePtr
%val4933 = load float*, float** %dataPtr
%val4934 = load i64, i64* %nsamplesPtr
%res4935 = call ccc i64 @sf_read_float(i8* %val4932, float* %val4933, i64 %val4934)

; let value assignment
%nread = select i1 true, i64 %res4935, i64 %res4935
store i64 %nread, i64* %nreadPtr

; promote local stack var allocations
%tzone4979 = load i8*, i8** %_impzPtr
%zone4980 = bitcast i8* %tzone4979 to %mzone*
%ifptr4938 = alloca i32
%ifptr4945 = alloca i32
%ifptr4939 = alloca i1
%val4940 = load i8*, i8** %audiofilePtr
%val4941 = icmp eq i8* %val4940, null
br i1 %val4941, label %then4939, label %else4939

then4939:
%res4942 = call ccc i1 @impc_false()
store i1 %res4942, i1* %ifptr4939
br label %ifcont4939

else4939:
%res4943 = call ccc i1 @impc_true()
store i1 %res4943, i1* %ifptr4939
br label %ifcont4939

ifcont4939:
%ifres4944 = load i1, i1* %ifptr4939

br i1 %ifres4944, label %then4938, label %else4938

then4938:
%val4946 = load i1, i1* %print_pPtr
br i1 %val4946, label %then4945, label %else4945

then4945:
%var4947 = bitcast [17 x i8]* @gsxtmsndfile212 to i8*

%val4948 = call i32 (i8*, ...) @printf(i8* %var4947)
%var4949 = bitcast [19 x i8]* @gsxtmsndfile213 to i8*
%val4950 = load i8*, i8** %filenamePtr

%val4951 = call i32 (i8*, ...) @printf(i8* %var4949, i8* %val4950)
%var4952 = bitcast [19 x i8]* @gsxtmsndfile214 to i8*
%val4953 = load %SF_INFO*, %SF_INFO** %infoPtr
; tuple ref
%val4954 = getelementptr %SF_INFO, %SF_INFO* %val4953, i64 0, i32 1
%val4955 = load i32, i32* %val4954

%val4956 = call i32 (i8*, ...) @printf(i8* %var4952, i32 %val4955)
%var4957 = bitcast [19 x i8]* @gsxtmsndfile215 to i8*
%val4958 = load %SF_INFO*, %SF_INFO** %infoPtr
; tuple ref
%val4959 = getelementptr %SF_INFO, %SF_INFO* %val4958, i64 0, i32 2
%val4960 = load i32, i32* %val4959

%val4961 = call i32 (i8*, ...) @printf(i8* %var4957, i32 %val4960)
%var4962 = bitcast [19 x i8]* @gsxtmsndfile216 to i8*
%val4963 = load %SF_INFO*, %SF_INFO** %infoPtr
; tuple ref
%val4964 = getelementptr %SF_INFO, %SF_INFO* %val4963, i64 0, i32 0
%val4965 = load i64, i64* %val4964

%val4966 = call i32 (i8*, ...) @printf(i8* %var4962, i64 %val4965)
%var4967 = bitcast [21 x i8]* @gsxtmsndfile217 to i8*
%val4968 = load i64, i64* %nreadPtr

%val4969 = call i32 (i8*, ...) @printf(i8* %var4967, i64 %val4968)
store i32 %val4969, i32* %ifptr4945
br label %ifcont4945

else4945:
br label %ifcont4945

ifcont4945:
%ifres4970 = load i32, i32* %ifptr4945

%val4971 = load i8*, i8** %audiofilePtr
%res4972 = call ccc i32 @sf_close(i8* %val4971)
store i32 %res4972, i32* %ifptr4938
br label %ifcont4938

else4938:
%var4973 = bitcast [13 x i8]* @gsxtmsndfile218 to i8*
%val4974 = load i8*, i8** %audiofilePtr
%res4975 = call ccc i8* @sf_strerror(i8* %val4974)

%val4976 = call i32 (i8*, ...) @printf(i8* %var4973, i8* %res4975)
store i32 %val4976, i32* %ifptr4938
br label %ifcont4938

ifcont4938:
%ifres4977 = load i32, i32* %ifptr4938

%val4978 = load i64, i64* %nreadPtr
ret i64 %val4978
}
@gsxtmsndfile221 = hidden constant [121 x i8] c"sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}** @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5000 = load i8*, i8** %_impzPtr
%zone5001 = bitcast i8* %tzone5000 to %mzone*

; let assign value to symbol sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd
%dat_sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd = call i8* @llvm_zone_malloc(%mzone* %zone5001, i64 8)
%sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFdPtr = bitcast i8* %dat_sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd to { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}***
%tzone4981 = load i8*, i8** %_impzPtr
%zone4982 = bitcast i8* %tzone4981 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4982)
; malloc closure structure
%clsptr4983 = call i8* @llvm_zone_malloc(%mzone* %zone4982, i64 24)
%closure4984 = bitcast i8* %clsptr4983 to { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}*

; malloc environment structure
%envptr4985 = call i8* @llvm_zone_malloc(%mzone* %zone4982, i64 8)
%environment4986 = bitcast i8* %envptr4985 to {{i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}***}*

; malloc closure address table
%addytable4987 = call %clsvar* @new_address_table()
%var4988 = bitcast [68 x i8]* @gsxtmsndfile219 to i8*
%var4989 = bitcast [57 x i8]* @gsxtmsndfile220 to i8*
%addytable4990 = call %clsvar* @add_address_table(%mzone* %zone4982, i8* %var4988, i32 0, i8* %var4989, i32 3, %clsvar* %addytable4987)
%address-table4991 = bitcast %clsvar* %addytable4990 to i8*

; insert table, function and environment into closure struct
%closure.table4994 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}, { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}* %closure4984, i32 0, i32 0
store i8* %address-table4991, i8** %closure.table4994
%closure.env4995 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}, { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}* %closure4984, i32 0, i32 1
store i8* %envptr4985, i8** %closure.env4995
%closure.func4996 = getelementptr { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}, { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}* %closure4984, i32 0, i32 2
store i64 (i8*, i8*, i8*, float*, i64, i64, i1)* @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd__4900, i64 (i8*, i8*, i8*, float*, i64, i64, i1)** %closure.func4996
%closure_size4997 = call i64 @llvm_zone_mark_size(%mzone* %zone4982)
call void @llvm_zone_ptr_set_size(i8* %clsptr4983, i64 %closure_size4997)
%wrapper_ptr4998 = call i8* @llvm_zone_malloc(%mzone* %zone4982, i64 8)
%closure_wrapper4999 = bitcast i8* %wrapper_ptr4998 to { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}**
store { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}* %closure4984, { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}** %closure_wrapper4999

; let value assignment
%sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd = select i1 true, { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}** %closure_wrapper4999, { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}** %closure_wrapper4999
store { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}** %sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd, { i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}*** %sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFdPtr

; add data to environment
; don't need to alloc for env var sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd
%tmp_envptr4993 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}***}, {{i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}***}* %environment4986, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}*** %sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFdPtr, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}**** %tmp_envptr4993


%val5002 = load {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}**, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}*** %sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFdPtr
ret {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}** %val5002
}


@sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}** @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd(i8* %arg_0,float* %arg_1,i64 %arg_2,i64 %arg_3,i1 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}*, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*, float*, i64, i64, i1)*,  i64 (i8*, i8*, i8*, float*, i64, i64, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i1 %arg_4)
ret i64 %result
}


define dllexport ccc i64 @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_native(i8* %arg_0,float* %arg_1,i64 %arg_2,i64 %arg_3,i1 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}*, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*, float*, i64, i64, i1)*,  i64 (i8*, i8*, i8*, float*, i64, i64, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i1 %arg_4)
ret i64 %result
}


define dllexport ccc i8*  @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5003 = bitcast [121 x i8]* @gsxtmsndfile221 to i8*
call i32 (i8*, ...) @printf(i8* %var5003)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5004 = bitcast [121 x i8]* @gsxtmsndfile221 to i8*
call i32 (i8*, ...) @printf(i8* %var5004)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5005 = bitcast [121 x i8]* @gsxtmsndfile221 to i8*
call i32 (i8*, ...) @printf(i8* %var5005)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var5006 = bitcast [121 x i8]* @gsxtmsndfile221 to i8*
call i32 (i8*, ...) @printf(i8* %var5006)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var5007 = bitcast [121 x i8]* @gsxtmsndfile221 to i8*
call i32 (i8*, ...) @printf(i8* %var5007)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i1  @i1value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}*, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*, float*, i64, i64, i1)*,  i64 (i8*, i8*, i8*, float*, i64, i64, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i1 %arg_4)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float*, i64, i64, i1}*
%arg_p_0 = getelementptr {i8*, float*, i64, i64, i1}, {i8*, float*, i64, i64, i1}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float*, i64, i64, i1}, {i8*, float*, i64, i64, i1}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {i8*, float*, i64, i64, i1}, {i8*, float*, i64, i64, i1}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i8*, float*, i64, i64, i1}, {i8*, float*, i64, i64, i1}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {i8*, float*, i64, i64, i1}, {i8*, float*, i64, i64, i1}* %fstruct, i32 0, i32 4
%arg_4 = load i1, i1* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_read_file_into_buffer_adhoc_W2k2NCxpOCosZmxvYXQqLGk2NCxpNjQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}*, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}, {i8*, i8*, i64 (i8*, i8*, i8*, float*, i64, i64, i1)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i8*, float*, i64, i64, i1)*,  i64 (i8*, i8*, i8*, float*, i64, i64, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i1 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmsndfile222 = hidden constant [17 x i8] c"Bad audio file!
\00"
@gsxtmsndfile223 = hidden constant [14 x i8] c"filename: %s
\00"
@gsxtmsndfile224 = hidden constant [16 x i8] c"samplerate: %d
\00"
@gsxtmsndfile225 = hidden constant [14 x i8] c"channels: %d
\00"
@gsxtmsndfile226 = hidden constant [13 x i8] c"format: %#x
\00"
@gsxtmsndfile227 = hidden constant [14 x i8] c"frames: %lld
\00"
@gsxtmsndfile228 = hidden constant [13 x i8] c"seconds: %f
\00"
@gsxtmsndfile229 = hidden constant [13 x i8] c"minutes: %f
\00"
@gsxtmsndfile230 = hidden constant [11 x i8] c"hours: %f
\00"
@gsxtmsndfile231 = hidden constant [25 x i8] c"loop-mode: %d - bpm(%f)
\00"
@gsxtmsndfile232 = hidden constant [12 x i8] c"loop-mode:
\00"
@gsxtmsndfile233 = hidden constant [19 x i8] c"nframes loops: %d
\00"
@gsxtmsndfile234 = hidden constant [18 x i8] c"nframes loops: 0
\00"
@gsxtmsndfile235 = hidden constant [46 x i8] c"sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ\00"
@gsxtmsndfile236 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i8*)*}**\00"
define dllexport fastcc void @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ__5008(i8* %_impz,i8* %_impenv, i8* %filename) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5009 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*
%sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQPtr = load {i8*, i8*, void (i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*)*}**** %sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQPtr_

; setup arguments
%filenamePtr = alloca i8*
store i8* %filename, i8** %filenamePtr


%tzone5011 = load i8*, i8** %_impzPtr
%zone5012 = bitcast i8* %tzone5011 to %mzone*

; let assign value to symbol info
%infoPtr = alloca %SF_INFO*
%tzone5017 = load i8*, i8** %_impzPtr
%zone5018 = bitcast i8* %tzone5017 to %mzone*

; let assign value to symbol audiofile
%audiofilePtr = alloca i8*
%tzone5021 = load i8*, i8** %_impzPtr
%zone5022 = bitcast i8* %tzone5021 to %mzone*

; let assign value to symbol channels
%channelsPtr = alloca i32
%dat5010 = alloca %SF_INFO, align 16

; let value assignment
%info = select i1 true, %SF_INFO* %dat5010, %SF_INFO* %dat5010
store %SF_INFO* %info, %SF_INFO** %infoPtr

%val5013 = load i8*, i8** %filenamePtr
%val5014 = load i32, i32* @SFM_READ
%val5015 = load %SF_INFO*, %SF_INFO** %infoPtr
%res5016 = call ccc i8* @sf_open(i8* %val5013, i32 %val5014, %SF_INFO* %val5015)

; let value assignment
%audiofile = select i1 true, i8* %res5016, i8* %res5016
store i8* %audiofile, i8** %audiofilePtr

%val5019 = load %SF_INFO*, %SF_INFO** %infoPtr
%res5020 = call fastcc i32 @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0(%SF_INFO* %val5019)

; let value assignment
%channels = select i1 true, i32 %res5020, i32 %res5020
store i32 %channels, i32* %channelsPtr

%val5024 = load i8*, i8** %audiofilePtr
%val5025 = icmp eq i8* %val5024, null
br i1 %val5025, label %then5023, label %else5023

then5023:
%var5026 = bitcast [17 x i8]* @gsxtmsndfile222 to i8*

%val5027 = call i32 (i8*, ...) @printf(i8* %var5026)
ret void

else5023:
%tzone5031 = load i8*, i8** %_impzPtr
%zone5032 = bitcast i8* %tzone5031 to %mzone*

; let assign value to symbol nframes
%nframesPtr = alloca i64
%tzone5036 = load i8*, i8** %_impzPtr
%zone5037 = bitcast i8* %tzone5036 to %mzone*

; let assign value to symbol rate
%ratePtr = alloca i64
%tzone5041 = load i8*, i8** %_impzPtr
%zone5042 = bitcast i8* %tzone5041 to %mzone*

; let assign value to symbol nseconds
%nsecondsPtr = alloca i64
%val5029 = load %SF_INFO*, %SF_INFO** %infoPtr
%res5030 = call fastcc i64 @sf_frames_adhoc_W2k2NCxTRl9JTkZPKl0(%SF_INFO* %val5029)

; let value assignment
%nframes = select i1 true, i64 %res5030, i64 %res5030
store i64 %nframes, i64* %nframesPtr

%val5033 = load %SF_INFO*, %SF_INFO** %infoPtr
%res5034 = call fastcc i32 @sf_samplerate_adhoc_W2kzMixTRl9JTkZPKl0(%SF_INFO* %val5033)
%val5035 = sext i32 %res5034 to i64

; let value assignment
%rate = select i1 true, i64 %val5035, i64 %val5035
store i64 %rate, i64* %ratePtr

%val5038 = load i64, i64* %nframesPtr
%val5039 = load i64, i64* %ratePtr
%val5040 = sdiv i64 %val5038, %val5039

; let value assignment
%nseconds = select i1 true, i64 %val5040, i64 %val5040
store i64 %nseconds, i64* %nsecondsPtr

; promote local stack var allocations
%tzone5149 = load i8*, i8** %_impzPtr
%zone5150 = bitcast i8* %tzone5149 to %mzone*
%ifptr5062 = alloca i32
%ifptr5070 = alloca i32
%var5043 = bitcast [17 x i8]* @gsxtmsndfile212 to i8*

%val5044 = call i32 (i8*, ...) @printf(i8* %var5043)
%var5045 = bitcast [14 x i8]* @gsxtmsndfile223 to i8*
%val5046 = load i8*, i8** %filenamePtr

%val5047 = call i32 (i8*, ...) @printf(i8* %var5045, i8* %val5046)
%var5048 = bitcast [16 x i8]* @gsxtmsndfile224 to i8*
%val5049 = load i64, i64* %ratePtr

%val5050 = call i32 (i8*, ...) @printf(i8* %var5048, i64 %val5049)
%var5051 = bitcast [14 x i8]* @gsxtmsndfile225 to i8*
%val5052 = load %SF_INFO*, %SF_INFO** %infoPtr
%res5053 = call fastcc i32 @sf_channels_adhoc_W2kzMixTRl9JTkZPKl0(%SF_INFO* %val5052)

%val5054 = call i32 (i8*, ...) @printf(i8* %var5051, i32 %res5053)
%var5055 = bitcast [13 x i8]* @gsxtmsndfile226 to i8*
%val5056 = load %SF_INFO*, %SF_INFO** %infoPtr
%res5057 = call fastcc i32 @sf_format_adhoc_W2kzMixTRl9JTkZPKl0(%SF_INFO* %val5056)

%val5058 = call i32 (i8*, ...) @printf(i8* %var5055, i32 %res5057)
%var5059 = bitcast [14 x i8]* @gsxtmsndfile227 to i8*
%val5060 = load i64, i64* %nframesPtr

%val5061 = call i32 (i8*, ...) @printf(i8* %var5059, i64 %val5060)
%val5063 = load i64, i64* %nframesPtr
%val5064 = mul i64 44100, 60
%val5065 = mul i64 %val5064, 1
%cmp5066 = icmp slt i64 %val5063, %val5065
br i1 %cmp5066, label %then5062, label %else5062

then5062:
%var5067 = bitcast [13 x i8]* @gsxtmsndfile228 to i8*
%val5068 = load i64, i64* %nsecondsPtr

%val5069 = call i32 (i8*, ...) @printf(i8* %var5067, i64 %val5068)
store i32 %val5069, i32* %ifptr5062
br label %ifcont5062

else5062:
%val5071 = load i64, i64* %nframesPtr
%val5072 = mul i64 44100, 60
%val5073 = mul i64 %val5072, 60
%cmp5074 = icmp slt i64 %val5071, %val5073
br i1 %cmp5074, label %then5070, label %else5070

then5070:
%var5075 = bitcast [13 x i8]* @gsxtmsndfile229 to i8*
%val5076 = load i64, i64* %nsecondsPtr
%val5077 = sitofp i64 %val5076 to double
%val5078 = fdiv double %val5077, 60.000000000000000000

%val5079 = call i32 (i8*, ...) @printf(i8* %var5075, double %val5078)
store i32 %val5079, i32* %ifptr5070
br label %ifcont5070

else5070:
%var5080 = bitcast [11 x i8]* @gsxtmsndfile230 to i8*
%val5081 = load i64, i64* %nsecondsPtr
%val5082 = sitofp i64 %val5081 to double
%val5083 = fmul double 60.000000000000000000, 60.000000000000000000
%val5084 = fdiv double %val5082, %val5083

%val5085 = call i32 (i8*, ...) @printf(i8* %var5080, double %val5084)
store i32 %val5085, i32* %ifptr5070
br label %ifcont5070

ifcont5070:
%ifres5086 = load i32, i32* %ifptr5070

store i32 %ifres5086, i32* %ifptr5062
br label %ifcont5062

ifcont5062:
%ifres5087 = load i32, i32* %ifptr5062

%tzone5092 = load i8*, i8** %_impzPtr
%zone5093 = bitcast i8* %tzone5092 to %mzone*

; let assign value to symbol loops
%loopsPtr = alloca %SF_LOOP_INFO*
%tzone5099 = load i8*, i8** %_impzPtr
%zone5100 = bitcast i8* %tzone5099 to %mzone*

; let assign value to symbol lp1
%lp1Ptr = alloca i32
%tzone5088 = load i8*, i8** %_impzPtr
%zone5089 = bitcast i8* %tzone5088 to %mzone*
%dat5090 = call i8* @llvm_zone_malloc(%mzone* %zone5089, i64 44)
call i8* @memset(i8* %dat5090, i32 0, i64 44)
%val5091 = bitcast i8* %dat5090 to %SF_LOOP_INFO*

; let value assignment
%loops = select i1 true, %SF_LOOP_INFO* %val5091, %SF_LOOP_INFO* %val5091
store %SF_LOOP_INFO* %loops, %SF_LOOP_INFO** %loopsPtr

%val5094 = load i8*, i8** %audiofilePtr
%val5095 = load i32, i32* @SFC_GET_LOOP_INFO
%val5096 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %loopsPtr
%val5097 = bitcast %SF_LOOP_INFO* %val5096 to i8*
%res5098 = call ccc i32 @sf_command(i8* %val5094, i32 %val5095, i8* %val5097, i32 44)

; let value assignment
%lp1 = select i1 true, i32 %res5098, i32 %res5098
store i32 %lp1, i32* %lp1Ptr

; promote local stack var allocations
%tzone5117 = load i8*, i8** %_impzPtr
%zone5118 = bitcast i8* %tzone5117 to %mzone*
%ifptr5101 = alloca i32
%val5102 = load i32, i32* %lp1Ptr
%val5103 = load i32, i32* @SF_TRUE
%cmp5104 = icmp eq i32 %val5102, %val5103
br i1 %cmp5104, label %then5101, label %else5101

then5101:
%var5105 = bitcast [25 x i8]* @gsxtmsndfile231 to i8*
%val5106 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %loopsPtr
; tuple ref
%val5107 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val5106, i64 0, i32 2
%val5108 = load i32, i32* %val5107
%val5109 = load %SF_LOOP_INFO*, %SF_LOOP_INFO** %loopsPtr
; tuple ref
%val5110 = getelementptr %SF_LOOP_INFO, %SF_LOOP_INFO* %val5109, i64 0, i32 4
%val5111 = load float, float* %val5110
%res5112 = call ccc double @ftod(float %val5111)

%val5113 = call i32 (i8*, ...) @printf(i8* %var5105, i32 %val5108, double %res5112)
store i32 %val5113, i32* %ifptr5101
br label %ifcont5101

else5101:
%var5114 = bitcast [12 x i8]* @gsxtmsndfile232 to i8*

%val5115 = call i32 (i8*, ...) @printf(i8* %var5114)
store i32 %val5115, i32* %ifptr5101
br label %ifcont5101

ifcont5101:
%ifres5116 = load i32, i32* %ifptr5101

%tzone5123 = load i8*, i8** %_impzPtr
%zone5124 = bitcast i8* %tzone5123 to %mzone*

; let assign value to symbol inst
%instPtr = alloca %SF_INSTRUMENT*
%tzone5130 = load i8*, i8** %_impzPtr
%zone5131 = bitcast i8* %tzone5130 to %mzone*

; let assign value to symbol lp2
%lp2Ptr = alloca i32
%tzone5119 = load i8*, i8** %_impzPtr
%zone5120 = bitcast i8* %tzone5119 to %mzone*
%dat5121 = call i8* @llvm_zone_malloc(%mzone* %zone5120, i64 272)
call i8* @memset(i8* %dat5121, i32 0, i64 272)
%val5122 = bitcast i8* %dat5121 to %SF_INSTRUMENT*

; let value assignment
%inst = select i1 true, %SF_INSTRUMENT* %val5122, %SF_INSTRUMENT* %val5122
store %SF_INSTRUMENT* %inst, %SF_INSTRUMENT** %instPtr

%val5125 = load i8*, i8** %audiofilePtr
%val5126 = load i32, i32* @SFC_GET_INSTRUMENT
%val5127 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %instPtr
%val5128 = bitcast %SF_INSTRUMENT* %val5127 to i8*
%res5129 = call ccc i32 @sf_command(i8* %val5125, i32 %val5126, i8* %val5128, i32 270)

; let value assignment
%lp2 = select i1 true, i32 %res5129, i32 %res5129
store i32 %lp2, i32* %lp2Ptr

; promote local stack var allocations
%tzone5144 = load i8*, i8** %_impzPtr
%zone5145 = bitcast i8* %tzone5144 to %mzone*
%ifptr5132 = alloca i32
%val5133 = load i32, i32* %lp2Ptr
%val5134 = load i32, i32* @SF_TRUE
%cmp5135 = icmp eq i32 %val5133, %val5134
br i1 %cmp5135, label %then5132, label %else5132

then5132:
%var5136 = bitcast [19 x i8]* @gsxtmsndfile233 to i8*
%val5137 = load %SF_INSTRUMENT*, %SF_INSTRUMENT** %instPtr
; tuple ref
%val5138 = getelementptr %SF_INSTRUMENT, %SF_INSTRUMENT* %val5137, i64 0, i32 7
%val5139 = load i32, i32* %val5138

%val5140 = call i32 (i8*, ...) @printf(i8* %var5136, i32 %val5139)
store i32 %val5140, i32* %ifptr5132
br label %ifcont5132

else5132:
%var5141 = bitcast [18 x i8]* @gsxtmsndfile234 to i8*

%val5142 = call i32 (i8*, ...) @printf(i8* %var5141)
store i32 %val5142, i32* %ifptr5132
br label %ifcont5132

ifcont5132:
%ifres5143 = load i32, i32* %ifptr5132

%val5146 = load i8*, i8** %audiofilePtr
%res5147 = call ccc i32 @sf_close(i8* %val5146)
ret void
}
@gsxtmsndfile237 = hidden constant [99 x i8] c"sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5170 = load i8*, i8** %_impzPtr
%zone5171 = bitcast i8* %tzone5170 to %mzone*

; let assign value to symbol sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ
%dat_sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone5171, i64 8)
%sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQPtr = bitcast i8* %dat_sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ to { i8*, i8*, void (i8*, i8*, i8*)*}***
%tzone5151 = load i8*, i8** %_impzPtr
%zone5152 = bitcast i8* %tzone5151 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5152)
; malloc closure structure
%clsptr5153 = call i8* @llvm_zone_malloc(%mzone* %zone5152, i64 24)
%closure5154 = bitcast i8* %clsptr5153 to { i8*, i8*, void (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr5155 = call i8* @llvm_zone_malloc(%mzone* %zone5152, i64 8)
%environment5156 = bitcast i8* %envptr5155 to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable5157 = call %clsvar* @new_address_table()
%var5158 = bitcast [46 x i8]* @gsxtmsndfile235 to i8*
%var5159 = bitcast [36 x i8]* @gsxtmsndfile236 to i8*
%addytable5160 = call %clsvar* @add_address_table(%mzone* %zone5152, i8* %var5158, i32 0, i8* %var5159, i32 3, %clsvar* %addytable5157)
%address-table5161 = bitcast %clsvar* %addytable5160 to i8*

; insert table, function and environment into closure struct
%closure.table5164 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure5154, i32 0, i32 0
store i8* %address-table5161, i8** %closure.table5164
%closure.env5165 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure5154, i32 0, i32 1
store i8* %envptr5155, i8** %closure.env5165
%closure.func5166 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure5154, i32 0, i32 2
store void (i8*, i8*, i8*)* @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ__5008, void (i8*, i8*, i8*)** %closure.func5166
%closure_size5167 = call i64 @llvm_zone_mark_size(%mzone* %zone5152)
call void @llvm_zone_ptr_set_size(i8* %clsptr5153, i64 %closure_size5167)
%wrapper_ptr5168 = call i8* @llvm_zone_malloc(%mzone* %zone5152, i64 8)
%closure_wrapper5169 = bitcast i8* %wrapper_ptr5168 to { i8*, i8*, void (i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*)*}* %closure5154, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper5169

; let value assignment
%sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper5169, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper5169
store { i8*, i8*, void (i8*, i8*, i8*)*}** %sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ, { i8*, i8*, void (i8*, i8*, i8*)*}*** %sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ
%tmp_envptr5163 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %environment5156, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*)*}*** %sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQPtr, {i8*, i8*, void (i8*, i8*, i8*)*}**** %tmp_envptr5163


%val5172 = load {i8*, i8*, void (i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*)*}*** %sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQPtr
ret {i8*, i8*, void (i8*, i8*, i8*)*}** %val5172
}


@sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc void @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc i8*  @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5173 = bitcast [99 x i8]* @gsxtmsndfile237 to i8*
call i32 (i8*, ...) @printf(i8* %var5173)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @sf_print_audio_file_info_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


