define dllexport ccc float @hermite_interp_local(float %fractional, float %y1, float %x0, float %x1, float %x2) nounwind inlinehint {
entry:
%zone2 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone2 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%fractionalPtr = alloca float
store float %fractional, float* %fractionalPtr
%y1Ptr = alloca float
store float %y1, float* %y1Ptr
%x0Ptr = alloca float
store float %x0, float* %x0Ptr
%x1Ptr = alloca float
store float %x1, float* %x1Ptr
%x2Ptr = alloca float
store float %x2, float* %x2Ptr


%tzone7 = load i8*, i8** %_impzPtr
%zone8 = bitcast i8* %tzone7 to %mzone*

; let assign value to symbol c
%cPtr = alloca float
%tzone12 = load i8*, i8** %_impzPtr
%zone13 = bitcast i8* %tzone12 to %mzone*

; let assign value to symbol v
%vPtr = alloca float
%tzone17 = load i8*, i8** %_impzPtr
%zone18 = bitcast i8* %tzone17 to %mzone*

; let assign value to symbol w
%wPtr = alloca float
%tzone27 = load i8*, i8** %_impzPtr
%zone28 = bitcast i8* %tzone27 to %mzone*

; let assign value to symbol a
%aPtr = alloca float
%tzone32 = load i8*, i8** %_impzPtr
%zone33 = bitcast i8* %tzone32 to %mzone*

; let assign value to symbol b
%bPtr = alloca float
%val3 = load float, float* %x1Ptr
%val4 = load float, float* %y1Ptr
%val5 = fsub float %val3, %val4
%val6 = fmul float 0x3fe0000000000000, %val5

; let value assignment
%c = select i1 true, float %val6, float %val6
store float %c, float* %cPtr

%val9 = load float, float* %x0Ptr
%val10 = load float, float* %x1Ptr
%val11 = fsub float %val9, %val10

; let value assignment
%v = select i1 true, float %val11, float %val11
store float %v, float* %vPtr

%val14 = load float, float* %cPtr
%val15 = load float, float* %vPtr
%val16 = fadd float %val14, %val15

; let value assignment
%w = select i1 true, float %val16, float %val16
store float %w, float* %wPtr

%val19 = load float, float* %wPtr
%val20 = load float, float* %vPtr
%val21 = fadd float %val19, %val20
%val22 = load float, float* %x2Ptr
%val23 = load float, float* %x0Ptr
%val24 = fsub float %val22, %val23
%val25 = fmul float %val24, 0x3fe0000000000000
%val26 = fadd float %val21, %val25

; let value assignment
%a = select i1 true, float %val26, float %val26
store float %a, float* %aPtr

%val29 = load float, float* %wPtr
%val30 = load float, float* %aPtr
%val31 = fadd float %val29, %val30

; let value assignment
%b = select i1 true, float %val31, float %val31
store float %b, float* %bPtr

%val34 = load float, float* %aPtr
%val35 = load float, float* %fractionalPtr
%val36 = fmul float %val34, %val35
%val37 = load float, float* %bPtr
%val38 = fsub float %val36, %val37
%val39 = load float, float* %fractionalPtr
%val40 = fmul float %val38, %val39
%val41 = load float, float* %cPtr
%val42 = fadd float %val40, %val41
%val43 = load float, float* %fractionalPtr
%val44 = fmul float %val42, %val43
%val45 = load float, float* %x0Ptr
%val46 = fadd float %val44, %val45
ret float %val46
}
@gsxtmaudiobuffer0 = hidden constant [74 x i8] c"hermite_interp_local Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @hermite_interp_local_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var48 = bitcast [74 x i8]* @gsxtmaudiobuffer0 to i8*
call i32 (i8*, ...) @printf(i8* %var48)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var49 = bitcast [74 x i8]* @gsxtmaudiobuffer0 to i8*
call i32 (i8*, ...) @printf(i8* %var49)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var50 = bitcast [74 x i8]* @gsxtmaudiobuffer0 to i8*
call i32 (i8*, ...) @printf(i8* %var50)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var51 = bitcast [74 x i8]* @gsxtmaudiobuffer0 to i8*
call i32 (i8*, ...) @printf(i8* %var51)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var52 = bitcast [74 x i8]* @gsxtmaudiobuffer0 to i8*
call i32 (i8*, ...) @printf(i8* %var52)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%result = call ccc float @hermite_interp_local(float %arg_0, float %arg_1, float %arg_2, float %arg_3, float %arg_4)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc float @midi2frq_local(float %pitch) nounwind inlinehint {
entry:
%zone54 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone54 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%pitchPtr = alloca float
store float %pitch, float* %pitchPtr

; promote local stack var allocations
%tzone74 = load i8*, i8** %_impzPtr
%zone75 = bitcast i8* %tzone74 to %mzone*
%ifptr56 = alloca i1
%ifptr61 = alloca i1

%val57 = load float, float* %pitchPtr
%cmp58 = fcmp ult float %val57, 0x0
br i1 %cmp58, label %then56, label %else56

then56:
%val59 = load float, float* %pitchPtr
%cmp60 = fcmp ult float %val59, 0x0
store i1 %cmp60, i1* %ifptr56
br label %ifcont56

else56:
%val62 = load float, float* %pitchPtr
%cmp63 = fcmp ueq float %val62, 0x0
br i1 %cmp63, label %then61, label %else61

then61:
%val64 = load float, float* %pitchPtr
%cmp65 = fcmp ueq float %val64, 0x0
store i1 %cmp65, i1* %ifptr61
br label %ifcont61

else61:
%res66 = call ccc i1 @impc_false()
store i1 %res66, i1* %ifptr61
br label %ifcont61

ifcont61:
%ifres67 = load i1, i1* %ifptr61

store i1 %ifres67, i1* %ifptr56
br label %ifcont56

ifcont56:
%ifres68 = load i1, i1* %ifptr56

br i1 %ifres68, label %then55, label %else55

then55:
ret float 0x0

else55:
%val69 = load float, float* %pitchPtr
%val70 = fsub float %val69, 0x4051400000000000
%val71 = fdiv float %val70, 0x4028000000000000
%val72 = call float @llvm.pow.f32(float 0x4000000000000000, float %val71)
%val73 = fmul float 0x407b800000000000, %val72
ret float %val73
}
@gsxtmaudiobuffer1 = hidden constant [68 x i8] c"midi2frq_local Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @midi2frq_local_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_real(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var77 = bitcast [68 x i8]* @gsxtmaudiobuffer1 to i8*
call i32 (i8*, ...) @printf(i8* %var77)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc float  @r32value(i8* %arg_0_val)
%result = call ccc float @midi2frq_local(float %arg_0)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


%AudioBuffer = type {%String*,i64,i64,i64,float*,double,i64,i64,i64,double}
@gsxtmaudiobuffer2 = hidden constant [109 x i8] c"AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ\00"
@gsxtmaudiobuffer3 = hidden constant [104 x i8] c"{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ__78(i8* %_impz,i8* %_impenv, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone79 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}*
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr_

; setup arguments
%arg_0Ptr = alloca %String*
store %String* %arg_0, %String** %arg_0Ptr
%arg_1Ptr = alloca i64
store i64 %arg_1, i64* %arg_1Ptr
%arg_2Ptr = alloca i64
store i64 %arg_2, i64* %arg_2Ptr
%arg_3Ptr = alloca i64
store i64 %arg_3, i64* %arg_3Ptr
%arg_4Ptr = alloca float*
store float* %arg_4, float** %arg_4Ptr
%arg_5Ptr = alloca double
store double %arg_5, double* %arg_5Ptr
%arg_6Ptr = alloca i64
store i64 %arg_6, i64* %arg_6Ptr
%arg_7Ptr = alloca i64
store i64 %arg_7, i64* %arg_7Ptr
%arg_8Ptr = alloca i64
store i64 %arg_8, i64* %arg_8Ptr
%arg_9Ptr = alloca double
store double %arg_9, double* %arg_9Ptr


%tzone84 = load i8*, i8** %_impzPtr
%zone85 = bitcast i8* %tzone84 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %AudioBuffer*
%tzone80 = load i8*, i8** %_impzPtr
%zone81 = bitcast i8* %tzone80 to %mzone*
%dat82 = call i8* @llvm_zone_malloc(%mzone* %zone81, i64 80)
call i8* @memset(i8* %dat82, i32 0, i64 80)
%val83 = bitcast i8* %dat82 to %AudioBuffer*

; let value assignment
%obj = select i1 true, %AudioBuffer* %val83, %AudioBuffer* %val83
store %AudioBuffer* %obj, %AudioBuffer** %objPtr

%val86 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val87 = load %String*, %String** %arg_0Ptr
; set tuple
%val88 = getelementptr %AudioBuffer, %AudioBuffer* %val86, i64 0, i32 0
store %String* %val87, %String** %val88
%val89 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val90 = load i64, i64* %arg_1Ptr
; set tuple
%val91 = getelementptr %AudioBuffer, %AudioBuffer* %val89, i64 0, i32 1
store i64 %val90, i64* %val91
%val92 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val93 = load i64, i64* %arg_2Ptr
; set tuple
%val94 = getelementptr %AudioBuffer, %AudioBuffer* %val92, i64 0, i32 2
store i64 %val93, i64* %val94
%val95 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val96 = load i64, i64* %arg_3Ptr
; set tuple
%val97 = getelementptr %AudioBuffer, %AudioBuffer* %val95, i64 0, i32 3
store i64 %val96, i64* %val97
%val98 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val99 = load float*, float** %arg_4Ptr
; set tuple
%val100 = getelementptr %AudioBuffer, %AudioBuffer* %val98, i64 0, i32 4
store float* %val99, float** %val100
%val101 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val102 = load double, double* %arg_5Ptr
; set tuple
%val103 = getelementptr %AudioBuffer, %AudioBuffer* %val101, i64 0, i32 5
store double %val102, double* %val103
%val104 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val105 = load i64, i64* %arg_6Ptr
; set tuple
%val106 = getelementptr %AudioBuffer, %AudioBuffer* %val104, i64 0, i32 6
store i64 %val105, i64* %val106
%val107 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val108 = load i64, i64* %arg_7Ptr
; set tuple
%val109 = getelementptr %AudioBuffer, %AudioBuffer* %val107, i64 0, i32 7
store i64 %val108, i64* %val109
%val110 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val111 = load i64, i64* %arg_8Ptr
; set tuple
%val112 = getelementptr %AudioBuffer, %AudioBuffer* %val110, i64 0, i32 8
store i64 %val111, i64* %val112
%val113 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val114 = load double, double* %arg_9Ptr
; set tuple
%val115 = getelementptr %AudioBuffer, %AudioBuffer* %val113, i64 0, i32 9
store double %val114, double* %val115
%val116 = load %AudioBuffer*, %AudioBuffer** %objPtr
ret %AudioBuffer* %val116
}
@gsxtmaudiobuffer4 = hidden constant [162 x i8] c"AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone136 = load i8*, i8** %_impzPtr
%zone137 = bitcast i8* %tzone136 to %mzone*

; let assign value to symbol AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ
%dat_AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ = call i8* @llvm_zone_malloc(%mzone* %zone137, i64 8)
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr = bitcast i8* %dat_AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ to { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***
%tzone117 = load i8*, i8** %_impzPtr
%zone118 = bitcast i8* %tzone117 to %mzone*
call void @llvm_zone_mark(%mzone* %zone118)
; malloc closure structure
%clsptr119 = call i8* @llvm_zone_malloc(%mzone* %zone118, i64 24)
%closure120 = bitcast i8* %clsptr119 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*

; malloc environment structure
%envptr121 = call i8* @llvm_zone_malloc(%mzone* %zone118, i64 8)
%environment122 = bitcast i8* %envptr121 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}*

; malloc closure address table
%addytable123 = call %clsvar* @new_address_table()
%var124 = bitcast [109 x i8]* @gsxtmaudiobuffer2 to i8*
%var125 = bitcast [104 x i8]* @gsxtmaudiobuffer3 to i8*
%addytable126 = call %clsvar* @add_address_table(%mzone* %zone118, i8* %var124, i32 0, i8* %var125, i32 3, %clsvar* %addytable123)
%address-table127 = bitcast %clsvar* %addytable126 to i8*

; insert table, function and environment into closure struct
%closure.table130 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure120, i32 0, i32 0
store i8* %address-table127, i8** %closure.table130
%closure.env131 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure120, i32 0, i32 1
store i8* %envptr121, i8** %closure.env131
%closure.func132 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure120, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ__78, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %closure.func132
%closure_size133 = call i64 @llvm_zone_mark_size(%mzone* %zone118)
call void @llvm_zone_ptr_set_size(i8* %clsptr119, i64 %closure_size133)
%wrapper_ptr134 = call i8* @llvm_zone_malloc(%mzone* %zone118, i64 8)
%closure_wrapper135 = bitcast i8* %wrapper_ptr134 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure120, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_wrapper135

; let value assignment
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_wrapper135, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_wrapper135
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ
%tmp_envptr129 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}* %environment122, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**** %tmp_envptr129


%val138 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %val138
}


@AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ(%String* %arg_0,i64 %arg_1,i64 %arg_2,i64 %arg_3,float* %arg_4,double %arg_5,i64 %arg_6,i64 %arg_7,i64 %arg_8,double %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_native(%String* %arg_0,i64 %arg_1,i64 %arg_2,i64 %arg_3,float* %arg_4,double %arg_5,i64 %arg_6,i64 %arg_7,i64 %arg_8,double %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var139 = bitcast [162 x i8]* @gsxtmaudiobuffer4 to i8*
call i32 (i8*, ...) @printf(i8* %var139)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var140 = bitcast [162 x i8]* @gsxtmaudiobuffer4 to i8*
call i32 (i8*, ...) @printf(i8* %var140)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var141 = bitcast [162 x i8]* @gsxtmaudiobuffer4 to i8*
call i32 (i8*, ...) @printf(i8* %var141)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var142 = bitcast [162 x i8]* @gsxtmaudiobuffer4 to i8*
call i32 (i8*, ...) @printf(i8* %var142)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var143 = bitcast [162 x i8]* @gsxtmaudiobuffer4 to i8*
call i32 (i8*, ...) @printf(i8* %var143)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_real(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var144 = bitcast [162 x i8]* @gsxtmaudiobuffer4 to i8*
call i32 (i8*, ...) @printf(i8* %var144)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc double @r64value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_integer(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var145 = bitcast [162 x i8]* @gsxtmaudiobuffer4 to i8*
call i32 (i8*, ...) @printf(i8* %var145)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc i64  @i64value(i8* %arg_6_val)
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_integer(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var146 = bitcast [162 x i8]* @gsxtmaudiobuffer4 to i8*
call i32 (i8*, ...) @printf(i8* %var146)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc i64  @i64value(i8* %arg_7_val)
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_integer(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var147 = bitcast [162 x i8]* @gsxtmaudiobuffer4 to i8*
call i32 (i8*, ...) @printf(i8* %var147)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%arg_8 = call ccc i64  @i64value(i8* %arg_8_val)
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_real(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var148 = bitcast [162 x i8]* @gsxtmaudiobuffer4 to i8*
call i32 (i8*, ...) @printf(i8* %var148)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc double @r64value(i8* %arg_9_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}*
%arg_p_0 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 5
%arg_5 = load double, double* %arg_p_5
%arg_p_6 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 6
%arg_6 = load i64, i64* %arg_p_6
%arg_p_7 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 7
%arg_7 = load i64, i64* %arg_p_7
%arg_p_8 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 8
%arg_8 = load i64, i64* %arg_p_8
%arg_p_9 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 9
%arg_9 = load double, double* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer5 = hidden constant [111 x i8] c"AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ__149(i8* %_impz,i8* %_impenv, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone150 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}*
%AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**** %AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr_

; setup arguments
%arg_0Ptr = alloca %String*
store %String* %arg_0, %String** %arg_0Ptr
%arg_1Ptr = alloca i64
store i64 %arg_1, i64* %arg_1Ptr
%arg_2Ptr = alloca i64
store i64 %arg_2, i64* %arg_2Ptr
%arg_3Ptr = alloca i64
store i64 %arg_3, i64* %arg_3Ptr
%arg_4Ptr = alloca float*
store float* %arg_4, float** %arg_4Ptr
%arg_5Ptr = alloca double
store double %arg_5, double* %arg_5Ptr
%arg_6Ptr = alloca i64
store i64 %arg_6, i64* %arg_6Ptr
%arg_7Ptr = alloca i64
store i64 %arg_7, i64* %arg_7Ptr
%arg_8Ptr = alloca i64
store i64 %arg_8, i64* %arg_8Ptr
%arg_9Ptr = alloca double
store double %arg_9, double* %arg_9Ptr


%tzone155 = load i8*, i8** %_impzPtr
%zone156 = bitcast i8* %tzone155 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %AudioBuffer*
%tzone151 = load i8*, i8** %_impzPtr
%zone152 = bitcast i8* %tzone151 to %mzone*
%dat153 = call i8* @llvm_zone_malloc(%mzone* %zone152, i64 80)
call i8* @memset(i8* %dat153, i32 0, i64 80)
%val154 = bitcast i8* %dat153 to %AudioBuffer*

; let value assignment
%obj = select i1 true, %AudioBuffer* %val154, %AudioBuffer* %val154
store %AudioBuffer* %obj, %AudioBuffer** %objPtr

%val157 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val158 = load %String*, %String** %arg_0Ptr
; set tuple
%val159 = getelementptr %AudioBuffer, %AudioBuffer* %val157, i64 0, i32 0
store %String* %val158, %String** %val159
%val160 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val161 = load i64, i64* %arg_1Ptr
; set tuple
%val162 = getelementptr %AudioBuffer, %AudioBuffer* %val160, i64 0, i32 1
store i64 %val161, i64* %val162
%val163 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val164 = load i64, i64* %arg_2Ptr
; set tuple
%val165 = getelementptr %AudioBuffer, %AudioBuffer* %val163, i64 0, i32 2
store i64 %val164, i64* %val165
%val166 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val167 = load i64, i64* %arg_3Ptr
; set tuple
%val168 = getelementptr %AudioBuffer, %AudioBuffer* %val166, i64 0, i32 3
store i64 %val167, i64* %val168
%val169 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val170 = load float*, float** %arg_4Ptr
; set tuple
%val171 = getelementptr %AudioBuffer, %AudioBuffer* %val169, i64 0, i32 4
store float* %val170, float** %val171
%val172 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val173 = load double, double* %arg_5Ptr
; set tuple
%val174 = getelementptr %AudioBuffer, %AudioBuffer* %val172, i64 0, i32 5
store double %val173, double* %val174
%val175 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val176 = load i64, i64* %arg_6Ptr
; set tuple
%val177 = getelementptr %AudioBuffer, %AudioBuffer* %val175, i64 0, i32 6
store i64 %val176, i64* %val177
%val178 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val179 = load i64, i64* %arg_7Ptr
; set tuple
%val180 = getelementptr %AudioBuffer, %AudioBuffer* %val178, i64 0, i32 7
store i64 %val179, i64* %val180
%val181 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val182 = load i64, i64* %arg_8Ptr
; set tuple
%val183 = getelementptr %AudioBuffer, %AudioBuffer* %val181, i64 0, i32 8
store i64 %val182, i64* %val183
%val184 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val185 = load double, double* %arg_9Ptr
; set tuple
%val186 = getelementptr %AudioBuffer, %AudioBuffer* %val184, i64 0, i32 9
store double %val185, double* %val186
%val187 = load %AudioBuffer*, %AudioBuffer** %objPtr
ret %AudioBuffer* %val187
}
@gsxtmaudiobuffer6 = hidden constant [164 x i8] c"AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone207 = load i8*, i8** %_impzPtr
%zone208 = bitcast i8* %tzone207 to %mzone*

; let assign value to symbol AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ
%dat_AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ = call i8* @llvm_zone_malloc(%mzone* %zone208, i64 8)
%AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr = bitcast i8* %dat_AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ to { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***
%tzone188 = load i8*, i8** %_impzPtr
%zone189 = bitcast i8* %tzone188 to %mzone*
call void @llvm_zone_mark(%mzone* %zone189)
; malloc closure structure
%clsptr190 = call i8* @llvm_zone_malloc(%mzone* %zone189, i64 24)
%closure191 = bitcast i8* %clsptr190 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*

; malloc environment structure
%envptr192 = call i8* @llvm_zone_malloc(%mzone* %zone189, i64 8)
%environment193 = bitcast i8* %envptr192 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}*

; malloc closure address table
%addytable194 = call %clsvar* @new_address_table()
%var195 = bitcast [111 x i8]* @gsxtmaudiobuffer5 to i8*
%var196 = bitcast [104 x i8]* @gsxtmaudiobuffer3 to i8*
%addytable197 = call %clsvar* @add_address_table(%mzone* %zone189, i8* %var195, i32 0, i8* %var196, i32 3, %clsvar* %addytable194)
%address-table198 = bitcast %clsvar* %addytable197 to i8*

; insert table, function and environment into closure struct
%closure.table201 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure191, i32 0, i32 0
store i8* %address-table198, i8** %closure.table201
%closure.env202 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure191, i32 0, i32 1
store i8* %envptr192, i8** %closure.env202
%closure.func203 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure191, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ__149, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %closure.func203
%closure_size204 = call i64 @llvm_zone_mark_size(%mzone* %zone189)
call void @llvm_zone_ptr_set_size(i8* %clsptr190, i64 %closure_size204)
%wrapper_ptr205 = call i8* @llvm_zone_malloc(%mzone* %zone189, i64 8)
%closure_wrapper206 = bitcast i8* %wrapper_ptr205 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure191, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_wrapper206

; let value assignment
%AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_wrapper206, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_wrapper206
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*** %AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ
%tmp_envptr200 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}* %environment193, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*** %AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**** %tmp_envptr200


%val209 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*** %AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %val209
}


@AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ(%String* %arg_0,i64 %arg_1,i64 %arg_2,i64 %arg_3,float* %arg_4,double %arg_5,i64 %arg_6,i64 %arg_7,i64 %arg_8,double %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_native(%String* %arg_0,i64 %arg_1,i64 %arg_2,i64 %arg_3,float* %arg_4,double %arg_5,i64 %arg_6,i64 %arg_7,i64 %arg_8,double %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var210 = bitcast [164 x i8]* @gsxtmaudiobuffer6 to i8*
call i32 (i8*, ...) @printf(i8* %var210)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var211 = bitcast [164 x i8]* @gsxtmaudiobuffer6 to i8*
call i32 (i8*, ...) @printf(i8* %var211)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var212 = bitcast [164 x i8]* @gsxtmaudiobuffer6 to i8*
call i32 (i8*, ...) @printf(i8* %var212)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var213 = bitcast [164 x i8]* @gsxtmaudiobuffer6 to i8*
call i32 (i8*, ...) @printf(i8* %var213)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var214 = bitcast [164 x i8]* @gsxtmaudiobuffer6 to i8*
call i32 (i8*, ...) @printf(i8* %var214)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_real(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var215 = bitcast [164 x i8]* @gsxtmaudiobuffer6 to i8*
call i32 (i8*, ...) @printf(i8* %var215)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc double @r64value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_integer(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var216 = bitcast [164 x i8]* @gsxtmaudiobuffer6 to i8*
call i32 (i8*, ...) @printf(i8* %var216)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc i64  @i64value(i8* %arg_6_val)
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_integer(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var217 = bitcast [164 x i8]* @gsxtmaudiobuffer6 to i8*
call i32 (i8*, ...) @printf(i8* %var217)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc i64  @i64value(i8* %arg_7_val)
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_integer(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var218 = bitcast [164 x i8]* @gsxtmaudiobuffer6 to i8*
call i32 (i8*, ...) @printf(i8* %var218)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%arg_8 = call ccc i64  @i64value(i8* %arg_8_val)
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_real(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var219 = bitcast [164 x i8]* @gsxtmaudiobuffer6 to i8*
call i32 (i8*, ...) @printf(i8* %var219)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc double @r64value(i8* %arg_9_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}*
%arg_p_0 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 5
%arg_5 = load double, double* %arg_p_5
%arg_p_6 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 6
%arg_6 = load i64, i64* %arg_p_6
%arg_p_7 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 7
%arg_7 = load i64, i64* %arg_p_7
%arg_p_8 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 8
%arg_8 = load i64, i64* %arg_p_8
%arg_p_9 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 9
%arg_9 = load double, double* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer7 = hidden constant [111 x i8] c"AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ__220(i8* %_impz,i8* %_impenv, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone221 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}*
%AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**** %AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr_

; setup arguments
%arg_0Ptr = alloca %String*
store %String* %arg_0, %String** %arg_0Ptr
%arg_1Ptr = alloca i64
store i64 %arg_1, i64* %arg_1Ptr
%arg_2Ptr = alloca i64
store i64 %arg_2, i64* %arg_2Ptr
%arg_3Ptr = alloca i64
store i64 %arg_3, i64* %arg_3Ptr
%arg_4Ptr = alloca float*
store float* %arg_4, float** %arg_4Ptr
%arg_5Ptr = alloca double
store double %arg_5, double* %arg_5Ptr
%arg_6Ptr = alloca i64
store i64 %arg_6, i64* %arg_6Ptr
%arg_7Ptr = alloca i64
store i64 %arg_7, i64* %arg_7Ptr
%arg_8Ptr = alloca i64
store i64 %arg_8, i64* %arg_8Ptr
%arg_9Ptr = alloca double
store double %arg_9, double* %arg_9Ptr


%tzone224 = load i8*, i8** %_impzPtr
%zone225 = bitcast i8* %tzone224 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %AudioBuffer*
%dat222 = call i8* @malloc(i64 80)
call i8* @memset(i8* %dat222, i32 0, i64 80)
%val223 = bitcast i8* %dat222 to %AudioBuffer*

; let value assignment
%obj = select i1 true, %AudioBuffer* %val223, %AudioBuffer* %val223
store %AudioBuffer* %obj, %AudioBuffer** %objPtr

%val226 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val227 = load %String*, %String** %arg_0Ptr
; set tuple
%val228 = getelementptr %AudioBuffer, %AudioBuffer* %val226, i64 0, i32 0
store %String* %val227, %String** %val228
%val229 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val230 = load i64, i64* %arg_1Ptr
; set tuple
%val231 = getelementptr %AudioBuffer, %AudioBuffer* %val229, i64 0, i32 1
store i64 %val230, i64* %val231
%val232 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val233 = load i64, i64* %arg_2Ptr
; set tuple
%val234 = getelementptr %AudioBuffer, %AudioBuffer* %val232, i64 0, i32 2
store i64 %val233, i64* %val234
%val235 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val236 = load i64, i64* %arg_3Ptr
; set tuple
%val237 = getelementptr %AudioBuffer, %AudioBuffer* %val235, i64 0, i32 3
store i64 %val236, i64* %val237
%val238 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val239 = load float*, float** %arg_4Ptr
; set tuple
%val240 = getelementptr %AudioBuffer, %AudioBuffer* %val238, i64 0, i32 4
store float* %val239, float** %val240
%val241 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val242 = load double, double* %arg_5Ptr
; set tuple
%val243 = getelementptr %AudioBuffer, %AudioBuffer* %val241, i64 0, i32 5
store double %val242, double* %val243
%val244 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val245 = load i64, i64* %arg_6Ptr
; set tuple
%val246 = getelementptr %AudioBuffer, %AudioBuffer* %val244, i64 0, i32 6
store i64 %val245, i64* %val246
%val247 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val248 = load i64, i64* %arg_7Ptr
; set tuple
%val249 = getelementptr %AudioBuffer, %AudioBuffer* %val247, i64 0, i32 7
store i64 %val248, i64* %val249
%val250 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val251 = load i64, i64* %arg_8Ptr
; set tuple
%val252 = getelementptr %AudioBuffer, %AudioBuffer* %val250, i64 0, i32 8
store i64 %val251, i64* %val252
%val253 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val254 = load double, double* %arg_9Ptr
; set tuple
%val255 = getelementptr %AudioBuffer, %AudioBuffer* %val253, i64 0, i32 9
store double %val254, double* %val255
%val256 = load %AudioBuffer*, %AudioBuffer** %objPtr
ret %AudioBuffer* %val256
}
@gsxtmaudiobuffer8 = hidden constant [164 x i8] c"AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone276 = load i8*, i8** %_impzPtr
%zone277 = bitcast i8* %tzone276 to %mzone*

; let assign value to symbol AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ
%dat_AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ = call i8* @llvm_zone_malloc(%mzone* %zone277, i64 8)
%AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr = bitcast i8* %dat_AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ to { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***
%tzone257 = load i8*, i8** %_impzPtr
%zone258 = bitcast i8* %tzone257 to %mzone*
call void @llvm_zone_mark(%mzone* %zone258)
; malloc closure structure
%clsptr259 = call i8* @llvm_zone_malloc(%mzone* %zone258, i64 24)
%closure260 = bitcast i8* %clsptr259 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*

; malloc environment structure
%envptr261 = call i8* @llvm_zone_malloc(%mzone* %zone258, i64 8)
%environment262 = bitcast i8* %envptr261 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}*

; malloc closure address table
%addytable263 = call %clsvar* @new_address_table()
%var264 = bitcast [111 x i8]* @gsxtmaudiobuffer7 to i8*
%var265 = bitcast [104 x i8]* @gsxtmaudiobuffer3 to i8*
%addytable266 = call %clsvar* @add_address_table(%mzone* %zone258, i8* %var264, i32 0, i8* %var265, i32 3, %clsvar* %addytable263)
%address-table267 = bitcast %clsvar* %addytable266 to i8*

; insert table, function and environment into closure struct
%closure.table270 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure260, i32 0, i32 0
store i8* %address-table267, i8** %closure.table270
%closure.env271 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure260, i32 0, i32 1
store i8* %envptr261, i8** %closure.env271
%closure.func272 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure260, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ__220, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %closure.func272
%closure_size273 = call i64 @llvm_zone_mark_size(%mzone* %zone258)
call void @llvm_zone_ptr_set_size(i8* %clsptr259, i64 %closure_size273)
%wrapper_ptr274 = call i8* @llvm_zone_malloc(%mzone* %zone258, i64 8)
%closure_wrapper275 = bitcast i8* %wrapper_ptr274 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure260, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_wrapper275

; let value assignment
%AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_wrapper275, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_wrapper275
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ, { i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*** %AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ
%tmp_envptr269 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}* %environment262, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*** %AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**** %tmp_envptr269


%val278 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*** %AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQPtr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %val278
}


@AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ(%String* %arg_0,i64 %arg_1,i64 %arg_2,i64 %arg_3,float* %arg_4,double %arg_5,i64 %arg_6,i64 %arg_7,i64 %arg_8,double %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_native(%String* %arg_0,i64 %arg_1,i64 %arg_2,i64 %arg_3,float* %arg_4,double %arg_5,i64 %arg_6,i64 %arg_7,i64 %arg_8,double %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var279 = bitcast [164 x i8]* @gsxtmaudiobuffer8 to i8*
call i32 (i8*, ...) @printf(i8* %var279)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var280 = bitcast [164 x i8]* @gsxtmaudiobuffer8 to i8*
call i32 (i8*, ...) @printf(i8* %var280)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var281 = bitcast [164 x i8]* @gsxtmaudiobuffer8 to i8*
call i32 (i8*, ...) @printf(i8* %var281)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var282 = bitcast [164 x i8]* @gsxtmaudiobuffer8 to i8*
call i32 (i8*, ...) @printf(i8* %var282)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var283 = bitcast [164 x i8]* @gsxtmaudiobuffer8 to i8*
call i32 (i8*, ...) @printf(i8* %var283)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to float*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_real(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var284 = bitcast [164 x i8]* @gsxtmaudiobuffer8 to i8*
call i32 (i8*, ...) @printf(i8* %var284)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc double @r64value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_integer(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var285 = bitcast [164 x i8]* @gsxtmaudiobuffer8 to i8*
call i32 (i8*, ...) @printf(i8* %var285)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc i64  @i64value(i8* %arg_6_val)
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_integer(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var286 = bitcast [164 x i8]* @gsxtmaudiobuffer8 to i8*
call i32 (i8*, ...) @printf(i8* %var286)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc i64  @i64value(i8* %arg_7_val)
%arg_8_val = call ccc i8* @list_ref(i8* %_sc, i32 8,i8* %args)
%arg_8_rt_check = call i32 @is_integer(i8* %arg_8_val)
%arg_8_bool = icmp ne i32 %arg_8_rt_check, 0
br i1 %arg_8_bool, label %arg_8_true, label %arg_8_false

arg_8_true:
br label %arg_8_continue

arg_8_false:
%var287 = bitcast [164 x i8]* @gsxtmaudiobuffer8 to i8*
call i32 (i8*, ...) @printf(i8* %var287)
%arg_8_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_8_errret

arg_8_continue:
%arg_8 = call ccc i64  @i64value(i8* %arg_8_val)
%arg_9_val = call ccc i8* @list_ref(i8* %_sc, i32 9,i8* %args)
%arg_9_rt_check = call i32 @is_real(i8* %arg_9_val)
%arg_9_bool = icmp ne i32 %arg_9_rt_check, 0
br i1 %arg_9_bool, label %arg_9_true, label %arg_9_false

arg_9_true:
br label %arg_9_continue

arg_9_false:
%var288 = bitcast [164 x i8]* @gsxtmaudiobuffer8 to i8*
call i32 (i8*, ...) @printf(i8* %var288)
%arg_9_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_9_errret

arg_9_continue:
%arg_9 = call ccc double @r64value(i8* %arg_9_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}*
%arg_p_0 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 5
%arg_5 = load double, double* %arg_p_5
%arg_p_6 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 6
%arg_6 = load i64, i64* %arg_p_6
%arg_p_7 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 7
%arg_7 = load i64, i64* %arg_p_7
%arg_p_8 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 8
%arg_8 = load i64, i64* %arg_p_8
%arg_p_9 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 9
%arg_9 = load double, double* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer9 = hidden constant [111 x i8] c"AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd\00"
@gsxtmaudiobuffer10 = hidden constant [103 x i8] c"{i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**\00"
define dllexport fastcc %AudioBuffer @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd__289(i8* %_impz,i8* %_impenv, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone290 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}*
%AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVdPtr_ = getelementptr {{i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}, {{i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVdPtr = load {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***, {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**** %AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVdPtr_

; setup arguments
%arg_0Ptr = alloca %String*
store %String* %arg_0, %String** %arg_0Ptr
%arg_1Ptr = alloca i64
store i64 %arg_1, i64* %arg_1Ptr
%arg_2Ptr = alloca i64
store i64 %arg_2, i64* %arg_2Ptr
%arg_3Ptr = alloca i64
store i64 %arg_3, i64* %arg_3Ptr
%arg_4Ptr = alloca float*
store float* %arg_4, float** %arg_4Ptr
%arg_5Ptr = alloca double
store double %arg_5, double* %arg_5Ptr
%arg_6Ptr = alloca i64
store i64 %arg_6, i64* %arg_6Ptr
%arg_7Ptr = alloca i64
store i64 %arg_7, i64* %arg_7Ptr
%arg_8Ptr = alloca i64
store i64 %arg_8, i64* %arg_8Ptr
%arg_9Ptr = alloca double
store double %arg_9, double* %arg_9Ptr


%tzone292 = load i8*, i8** %_impzPtr
%zone293 = bitcast i8* %tzone292 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %AudioBuffer*
%dat291 = alloca %AudioBuffer, align 16

; let value assignment
%obj = select i1 true, %AudioBuffer* %dat291, %AudioBuffer* %dat291
store %AudioBuffer* %obj, %AudioBuffer** %objPtr

%val294 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val295 = load %String*, %String** %arg_0Ptr
; set tuple
%val296 = getelementptr %AudioBuffer, %AudioBuffer* %val294, i64 0, i32 0
store %String* %val295, %String** %val296
%val297 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val298 = load i64, i64* %arg_1Ptr
; set tuple
%val299 = getelementptr %AudioBuffer, %AudioBuffer* %val297, i64 0, i32 1
store i64 %val298, i64* %val299
%val300 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val301 = load i64, i64* %arg_2Ptr
; set tuple
%val302 = getelementptr %AudioBuffer, %AudioBuffer* %val300, i64 0, i32 2
store i64 %val301, i64* %val302
%val303 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val304 = load i64, i64* %arg_3Ptr
; set tuple
%val305 = getelementptr %AudioBuffer, %AudioBuffer* %val303, i64 0, i32 3
store i64 %val304, i64* %val305
%val306 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val307 = load float*, float** %arg_4Ptr
; set tuple
%val308 = getelementptr %AudioBuffer, %AudioBuffer* %val306, i64 0, i32 4
store float* %val307, float** %val308
%val309 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val310 = load double, double* %arg_5Ptr
; set tuple
%val311 = getelementptr %AudioBuffer, %AudioBuffer* %val309, i64 0, i32 5
store double %val310, double* %val311
%val312 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val313 = load i64, i64* %arg_6Ptr
; set tuple
%val314 = getelementptr %AudioBuffer, %AudioBuffer* %val312, i64 0, i32 6
store i64 %val313, i64* %val314
%val315 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val316 = load i64, i64* %arg_7Ptr
; set tuple
%val317 = getelementptr %AudioBuffer, %AudioBuffer* %val315, i64 0, i32 7
store i64 %val316, i64* %val317
%val318 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val319 = load i64, i64* %arg_8Ptr
; set tuple
%val320 = getelementptr %AudioBuffer, %AudioBuffer* %val318, i64 0, i32 8
store i64 %val319, i64* %val320
%val321 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val322 = load double, double* %arg_9Ptr
; set tuple
%val323 = getelementptr %AudioBuffer, %AudioBuffer* %val321, i64 0, i32 9
store double %val322, double* %val323
%val324 = load %AudioBuffer*, %AudioBuffer** %objPtr
; pointer ref
%val325 = getelementptr %AudioBuffer, %AudioBuffer* %val324, i64 0
%val326 = load %AudioBuffer, %AudioBuffer* %val325
ret %AudioBuffer %val326
}
@gsxtmaudiobuffer11 = hidden constant [164 x i8] c"AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone346 = load i8*, i8** %_impzPtr
%zone347 = bitcast i8* %tzone346 to %mzone*

; let assign value to symbol AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd
%dat_AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd = call i8* @llvm_zone_malloc(%mzone* %zone347, i64 8)
%AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVdPtr = bitcast i8* %dat_AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd to { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***
%tzone327 = load i8*, i8** %_impzPtr
%zone328 = bitcast i8* %tzone327 to %mzone*
call void @llvm_zone_mark(%mzone* %zone328)
; malloc closure structure
%clsptr329 = call i8* @llvm_zone_malloc(%mzone* %zone328, i64 24)
%closure330 = bitcast i8* %clsptr329 to { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*

; malloc environment structure
%envptr331 = call i8* @llvm_zone_malloc(%mzone* %zone328, i64 8)
%environment332 = bitcast i8* %envptr331 to {{i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}*

; malloc closure address table
%addytable333 = call %clsvar* @new_address_table()
%var334 = bitcast [111 x i8]* @gsxtmaudiobuffer9 to i8*
%var335 = bitcast [103 x i8]* @gsxtmaudiobuffer10 to i8*
%addytable336 = call %clsvar* @add_address_table(%mzone* %zone328, i8* %var334, i32 0, i8* %var335, i32 3, %clsvar* %addytable333)
%address-table337 = bitcast %clsvar* %addytable336 to i8*

; insert table, function and environment into closure struct
%closure.table340 = getelementptr { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure330, i32 0, i32 0
store i8* %address-table337, i8** %closure.table340
%closure.env341 = getelementptr { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure330, i32 0, i32 1
store i8* %envptr331, i8** %closure.env341
%closure.func342 = getelementptr { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure330, i32 0, i32 2
store %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)* @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd__289, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %closure.func342
%closure_size343 = call i64 @llvm_zone_mark_size(%mzone* %zone328)
call void @llvm_zone_ptr_set_size(i8* %clsptr329, i64 %closure_size343)
%wrapper_ptr344 = call i8* @llvm_zone_malloc(%mzone* %zone328, i64 8)
%closure_wrapper345 = bitcast i8* %wrapper_ptr344 to { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
store { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure330, { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_wrapper345

; let value assignment
%AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd = select i1 true, { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_wrapper345, { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_wrapper345
store { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd, { i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*** %AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVdPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd
%tmp_envptr339 = getelementptr {{i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}, {{i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}***}* %environment332, i32 0, i32 0
store {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*** %AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVdPtr, {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**** %tmp_envptr339


%val348 = load {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**, {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*** %AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVdPtr
ret {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %val348
}


@AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd(%String* %arg_0,i64 %arg_1,i64 %arg_2,i64 %arg_3,float* %arg_4,double %arg_5,i64 %arg_6,i64 %arg_7,i64 %arg_8,double %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
ret %AudioBuffer %result
}


define dllexport ccc %AudioBuffer @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_native(%String* %arg_0,i64 %arg_1,i64 %arg_2,i64 %arg_3,float* %arg_4,double %arg_5,i64 %arg_6,i64 %arg_7,i64 %arg_8,double %arg_9) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
ret %AudioBuffer %result
}


define dllexport ccc void @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}*
%arg_p_0 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 4
%arg_4 = load float*, float** %arg_p_4
%arg_p_5 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 5
%arg_5 = load double, double* %arg_p_5
%arg_p_6 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 6
%arg_6 = load i64, i64* %arg_p_6
%arg_p_7 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 7
%arg_7 = load i64, i64* %arg_p_7
%arg_p_8 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 8
%arg_8 = load i64, i64* %arg_p_8
%arg_p_9 = getelementptr {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}, {%String*, i64, i64, i64, float*, double, i64, i64, i64, double}* %fstruct, i32 0, i32 9
%arg_9 = load double, double* %arg_p_9
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_val_adhoc_W0F1ZGlvQnVmZmVyLFN0cmluZyosaTY0LGk2NCxpNjQsZmxvYXQqLGRvdWJsZSxpNjQsaTY0LGk2NCxkb3VibGVd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}, {i8*, i8*, %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)*,  %AudioBuffer (i8*, i8*, %String*, i64, i64, i64, float*, double, i64, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer %ff(i8* %_impz, i8* %ee, %String* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3, float* %arg_4, double %arg_5, i64 %arg_6, i64 %arg_7, i64 %arg_8, double %arg_9)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer12 = hidden constant [49 x i8] c"hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd\00"
@gsxtmaudiobuffer13 = hidden constant [55 x i8] c"{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**\00"
define dllexport fastcc %AudioBuffer* @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd__359(i8* %_impz,i8* %_impenv, %AudioBuffer* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone360 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}*
%hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**** %hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr_

; setup arguments
%xPtr = alloca %AudioBuffer*
store %AudioBuffer* %x, %AudioBuffer** %xPtr


%tzone363 = load i8*, i8** %_impzPtr
%zone364 = bitcast i8* %tzone363 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %AudioBuffer*
%dat361 = call i8* @malloc(i64 80)
call i8* @memset(i8* %dat361, i32 0, i64 80)
%val362 = bitcast i8* %dat361 to %AudioBuffer*

; let value assignment
%obj = select i1 true, %AudioBuffer* %val362, %AudioBuffer* %val362
store %AudioBuffer* %obj, %AudioBuffer** %objPtr

; promote local stack var allocations
%tzone427 = load i8*, i8** %_impzPtr
%zone428 = bitcast i8* %tzone427 to %mzone*
%ifptr365 = alloca %String*
%ifptr366 = alloca i1
%val367 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val368 = getelementptr %AudioBuffer, %AudioBuffer* %val367, i64 0, i32 0
%val369 = load %String*, %String** %val368
%val370 = icmp eq %String* %val369, null
br i1 %val370, label %then366, label %else366

then366:
%res371 = call ccc i1 @impc_false()
store i1 %res371, i1* %ifptr366
br label %ifcont366

else366:
%res372 = call ccc i1 @impc_true()
store i1 %res372, i1* %ifptr366
br label %ifcont366

ifcont366:
%ifres373 = load i1, i1* %ifptr366

br i1 %ifres373, label %then365, label %else365

then365:
%val374 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val375 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val376 = getelementptr %AudioBuffer, %AudioBuffer* %val375, i64 0, i32 0
%val377 = load %String*, %String** %val376
%res378 = call fastcc %String* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %val377)
; set tuple
%val379 = getelementptr %AudioBuffer, %AudioBuffer* %val374, i64 0, i32 0
store %String* %res378, %String** %val379
store %String* %res378, %String** %ifptr365
br label %ifcont365

else365:
br label %ifcont365

ifcont365:
%ifres380 = load %String*, %String** %ifptr365

%val381 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val382 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val383 = getelementptr %AudioBuffer, %AudioBuffer* %val382, i64 0, i32 1
%val384 = load i64, i64* %val383
; set tuple
%val385 = getelementptr %AudioBuffer, %AudioBuffer* %val381, i64 0, i32 1
store i64 %val384, i64* %val385
%val386 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val387 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val388 = getelementptr %AudioBuffer, %AudioBuffer* %val387, i64 0, i32 2
%val389 = load i64, i64* %val388
; set tuple
%val390 = getelementptr %AudioBuffer, %AudioBuffer* %val386, i64 0, i32 2
store i64 %val389, i64* %val390
%val391 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val392 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val393 = getelementptr %AudioBuffer, %AudioBuffer* %val392, i64 0, i32 3
%val394 = load i64, i64* %val393
; set tuple
%val395 = getelementptr %AudioBuffer, %AudioBuffer* %val391, i64 0, i32 3
store i64 %val394, i64* %val395
%val396 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val397 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val398 = getelementptr %AudioBuffer, %AudioBuffer* %val397, i64 0, i32 4
%val399 = load float*, float** %val398
; set tuple
%val400 = getelementptr %AudioBuffer, %AudioBuffer* %val396, i64 0, i32 4
store float* %val399, float** %val400
%val401 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val402 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val403 = getelementptr %AudioBuffer, %AudioBuffer* %val402, i64 0, i32 5
%val404 = load double, double* %val403
; set tuple
%val405 = getelementptr %AudioBuffer, %AudioBuffer* %val401, i64 0, i32 5
store double %val404, double* %val405
%val406 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val407 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val408 = getelementptr %AudioBuffer, %AudioBuffer* %val407, i64 0, i32 6
%val409 = load i64, i64* %val408
; set tuple
%val410 = getelementptr %AudioBuffer, %AudioBuffer* %val406, i64 0, i32 6
store i64 %val409, i64* %val410
%val411 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val412 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val413 = getelementptr %AudioBuffer, %AudioBuffer* %val412, i64 0, i32 7
%val414 = load i64, i64* %val413
; set tuple
%val415 = getelementptr %AudioBuffer, %AudioBuffer* %val411, i64 0, i32 7
store i64 %val414, i64* %val415
%val416 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val417 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val418 = getelementptr %AudioBuffer, %AudioBuffer* %val417, i64 0, i32 8
%val419 = load i64, i64* %val418
; set tuple
%val420 = getelementptr %AudioBuffer, %AudioBuffer* %val416, i64 0, i32 8
store i64 %val419, i64* %val420
%val421 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val422 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val423 = getelementptr %AudioBuffer, %AudioBuffer* %val422, i64 0, i32 9
%val424 = load double, double* %val423
; set tuple
%val425 = getelementptr %AudioBuffer, %AudioBuffer* %val421, i64 0, i32 9
store double %val424, double* %val425
%val426 = load %AudioBuffer*, %AudioBuffer** %objPtr
ret %AudioBuffer* %val426
}
@gsxtmaudiobuffer14 = hidden constant [102 x i8] c"hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone448 = load i8*, i8** %_impzPtr
%zone449 = bitcast i8* %tzone448 to %mzone*

; let assign value to symbol hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd
%dat_hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd = call i8* @llvm_zone_malloc(%mzone* %zone449, i64 8)
%hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr = bitcast i8* %dat_hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***
%tzone429 = load i8*, i8** %_impzPtr
%zone430 = bitcast i8* %tzone429 to %mzone*
call void @llvm_zone_mark(%mzone* %zone430)
; malloc closure structure
%clsptr431 = call i8* @llvm_zone_malloc(%mzone* %zone430, i64 24)
%closure432 = bitcast i8* %clsptr431 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*

; malloc environment structure
%envptr433 = call i8* @llvm_zone_malloc(%mzone* %zone430, i64 8)
%environment434 = bitcast i8* %envptr433 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}*

; malloc closure address table
%addytable435 = call %clsvar* @new_address_table()
%var436 = bitcast [49 x i8]* @gsxtmaudiobuffer12 to i8*
%var437 = bitcast [55 x i8]* @gsxtmaudiobuffer13 to i8*
%addytable438 = call %clsvar* @add_address_table(%mzone* %zone430, i8* %var436, i32 0, i8* %var437, i32 3, %clsvar* %addytable435)
%address-table439 = bitcast %clsvar* %addytable438 to i8*

; insert table, function and environment into closure struct
%closure.table442 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure432, i32 0, i32 0
store i8* %address-table439, i8** %closure.table442
%closure.env443 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure432, i32 0, i32 1
store i8* %envptr433, i8** %closure.env443
%closure.func444 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure432, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, %AudioBuffer*)* @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd__359, %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %closure.func444
%closure_size445 = call i64 @llvm_zone_mark_size(%mzone* %zone430)
call void @llvm_zone_ptr_set_size(i8* %clsptr431, i64 %closure_size445)
%wrapper_ptr446 = call i8* @llvm_zone_malloc(%mzone* %zone430, i64 8)
%closure_wrapper447 = bitcast i8* %wrapper_ptr446 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure432, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper447

; let value assignment
%hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper447, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper447
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*** %hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd
%tmp_envptr441 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}* %environment434, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*** %hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**** %tmp_envptr441


%val450 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*** %hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %val450
}


@hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_native(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var451 = bitcast [102 x i8]* @gsxtmaudiobuffer14 to i8*
call i32 (i8*, ...) @printf(i8* %var451)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*}*
%arg_p_0 = getelementptr {%AudioBuffer*}, {%AudioBuffer*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer15 = hidden constant [39 x i8] c"hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ\00"
@gsxtmaudiobuffer16 = hidden constant [46 x i8] c"{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ__452(i8* %_impz,i8* %_impenv, %AudioBuffer* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone453 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***}*
%hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**** %hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr_

; setup arguments
%xPtr = alloca %AudioBuffer*
store %AudioBuffer* %x, %AudioBuffer** %xPtr

; promote local stack var allocations
%tzone471 = load i8*, i8** %_impzPtr
%zone472 = bitcast i8* %tzone471 to %mzone*
%ifptr455 = alloca i1

%val456 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val457 = getelementptr %AudioBuffer, %AudioBuffer* %val456, i64 0, i32 0
%val458 = load %String*, %String** %val457
%val459 = icmp eq %String* %val458, null
br i1 %val459, label %then455, label %else455

then455:
%res460 = call ccc i1 @impc_false()
store i1 %res460, i1* %ifptr455
br label %ifcont455

else455:
%res461 = call ccc i1 @impc_true()
store i1 %res461, i1* %ifptr455
br label %ifcont455

ifcont455:
%ifres462 = load i1, i1* %ifptr455

br i1 %ifres462, label %then454, label %else454

then454:
%val463 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val464 = getelementptr %AudioBuffer, %AudioBuffer* %val463, i64 0, i32 0
%val465 = load %String*, %String** %val464
call fastcc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %val465)
br label %ifcont454

else454:
br label %ifcont454

ifcont454:
%val467 = load %AudioBuffer*, %AudioBuffer** %xPtr
%val468 = bitcast %AudioBuffer* %val467 to i8*
call ccc void @free(i8* %val468)
ret void
}
@gsxtmaudiobuffer17 = hidden constant [92 x i8] c"hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone492 = load i8*, i8** %_impzPtr
%zone493 = bitcast i8* %tzone492 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ
%dat_hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone493, i64 8)
%hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ to { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***
%tzone473 = load i8*, i8** %_impzPtr
%zone474 = bitcast i8* %tzone473 to %mzone*
call void @llvm_zone_mark(%mzone* %zone474)
; malloc closure structure
%clsptr475 = call i8* @llvm_zone_malloc(%mzone* %zone474, i64 24)
%closure476 = bitcast i8* %clsptr475 to { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*

; malloc environment structure
%envptr477 = call i8* @llvm_zone_malloc(%mzone* %zone474, i64 8)
%environment478 = bitcast i8* %envptr477 to {{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***}*

; malloc closure address table
%addytable479 = call %clsvar* @new_address_table()
%var480 = bitcast [39 x i8]* @gsxtmaudiobuffer15 to i8*
%var481 = bitcast [46 x i8]* @gsxtmaudiobuffer16 to i8*
%addytable482 = call %clsvar* @add_address_table(%mzone* %zone474, i8* %var480, i32 0, i8* %var481, i32 3, %clsvar* %addytable479)
%address-table483 = bitcast %clsvar* %addytable482 to i8*

; insert table, function and environment into closure struct
%closure.table486 = getelementptr { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure476, i32 0, i32 0
store i8* %address-table483, i8** %closure.table486
%closure.env487 = getelementptr { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure476, i32 0, i32 1
store i8* %envptr477, i8** %closure.env487
%closure.func488 = getelementptr { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure476, i32 0, i32 2
store void (i8*, i8*, %AudioBuffer*)* @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ__452, void (i8*, i8*, %AudioBuffer*)** %closure.func488
%closure_size489 = call i64 @llvm_zone_mark_size(%mzone* %zone474)
call void @llvm_zone_ptr_set_size(i8* %clsptr475, i64 %closure_size489)
%wrapper_ptr490 = call i8* @llvm_zone_malloc(%mzone* %zone474, i64 8)
%closure_wrapper491 = bitcast i8* %wrapper_ptr490 to { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**
store { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure476, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper491

; let value assignment
%hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper491, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper491
store { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*** %hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ
%tmp_envptr485 = getelementptr {{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***}* %environment478, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*** %hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**** %tmp_envptr485


%val494 = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*** %hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr
ret {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %val494
}


@hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %AudioBuffer*)*,  void (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_native(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %AudioBuffer*)*,  void (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var495 = bitcast [92 x i8]* @gsxtmaudiobuffer17 to i8*
call i32 (i8*, ...) @printf(i8* %var495)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %AudioBuffer*)*,  void (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*}*
%arg_p_0 = getelementptr {%AudioBuffer*}, {%AudioBuffer*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %AudioBuffer*)*,  void (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer18 = hidden constant [68 x i8] c"zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0\00"
@gsxtmaudiobuffer19 = hidden constant [73 x i8] c"{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %AudioBuffer* @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0__496(i8* %_impz,i8* %_impenv, %AudioBuffer* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone497 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca %AudioBuffer*
store %AudioBuffer* %x, %AudioBuffer** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val499 = load %mzone*, %mzone** %fromzPtr
%val500 = load %AudioBuffer*, %AudioBuffer** %xPtr
%val501 = bitcast %AudioBuffer* %val500 to i8*
%res502 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val499, i8* %val501)
br i1 %res502, label %then498, label %else498

then498:
%val503 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val503)
%zone_ptr504 = bitcast %mzone* %val503 to i8*
store i8* %zone_ptr504, i8** %_impzPtr
%tzone510 = load i8*, i8** %_impzPtr
%zone511 = bitcast i8* %tzone510 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %AudioBuffer*
%tzone506 = load i8*, i8** %_impzPtr
%zone507 = bitcast i8* %tzone506 to %mzone*
%dat508 = call i8* @llvm_zone_malloc(%mzone* %zone507, i64 80)
call i8* @memset(i8* %dat508, i32 0, i64 80)
%val509 = bitcast i8* %dat508 to %AudioBuffer*

; let value assignment
%obj = select i1 true, %AudioBuffer* %val509, %AudioBuffer* %val509
store %AudioBuffer* %obj, %AudioBuffer** %objPtr

; promote local stack var allocations
%tzone603 = load i8*, i8** %_impzPtr
%zone604 = bitcast i8* %tzone603 to %mzone*
%ifptr545 = alloca float*
%ifptr512 = alloca %String*
%ifptr513 = alloca i1
%val514 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val515 = getelementptr %AudioBuffer, %AudioBuffer* %val514, i64 0, i32 0
%val516 = load %String*, %String** %val515
%val517 = icmp eq %String* %val516, null
br i1 %val517, label %then513, label %else513

then513:
%res518 = call ccc i1 @impc_false()
store i1 %res518, i1* %ifptr513
br label %ifcont513

else513:
%res519 = call ccc i1 @impc_true()
store i1 %res519, i1* %ifptr513
br label %ifcont513

ifcont513:
%ifres520 = load i1, i1* %ifptr513

br i1 %ifres520, label %then512, label %else512

then512:
%val521 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val522 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val523 = getelementptr %AudioBuffer, %AudioBuffer* %val522, i64 0, i32 0
%val524 = load %String*, %String** %val523
%val525 = load %mzone*, %mzone** %fromzPtr
%val526 = load %mzone*, %mzone** %tozPtr
%res527 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val524, %mzone* %val525, %mzone* %val526)
; set tuple
%val528 = getelementptr %AudioBuffer, %AudioBuffer* %val521, i64 0, i32 0
store %String* %res527, %String** %val528
store %String* %res527, %String** %ifptr512
br label %ifcont512

else512:
br label %ifcont512

ifcont512:
%ifres529 = load %String*, %String** %ifptr512

%val530 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val531 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val532 = getelementptr %AudioBuffer, %AudioBuffer* %val531, i64 0, i32 1
%val533 = load i64, i64* %val532
; set tuple
%val534 = getelementptr %AudioBuffer, %AudioBuffer* %val530, i64 0, i32 1
store i64 %val533, i64* %val534
%val535 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val536 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val537 = getelementptr %AudioBuffer, %AudioBuffer* %val536, i64 0, i32 2
%val538 = load i64, i64* %val537
; set tuple
%val539 = getelementptr %AudioBuffer, %AudioBuffer* %val535, i64 0, i32 2
store i64 %val538, i64* %val539
%val540 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val541 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val542 = getelementptr %AudioBuffer, %AudioBuffer* %val541, i64 0, i32 3
%val543 = load i64, i64* %val542
; set tuple
%val544 = getelementptr %AudioBuffer, %AudioBuffer* %val540, i64 0, i32 3
store i64 %val543, i64* %val544
%val546 = load %mzone*, %mzone** %fromzPtr
%val547 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val548 = getelementptr %AudioBuffer, %AudioBuffer* %val547, i64 0, i32 4
%val549 = load float*, float** %val548
%val550 = bitcast float* %val549 to i8*
%res551 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val546, i8* %val550)
br i1 %res551, label %then545, label %else545

then545:
%tzone556 = load i8*, i8** %_impzPtr
%zone557 = bitcast i8* %tzone556 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca float*
%tzone552 = load i8*, i8** %_impzPtr
%zone553 = bitcast i8* %tzone552 to %mzone*
%dat554 = call i8* @llvm_zone_malloc(%mzone* %zone553, i64 4)
call i8* @memset(i8* %dat554, i32 0, i64 4)
%val555 = bitcast i8* %dat554 to float*

; let value assignment
%newptr = select i1 true, float* %val555, float* %val555
store float* %newptr, float** %newptrPtr

%val558 = load float*, float** %newptrPtr
%val559 = bitcast float* %val558 to i8*
%val560 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val561 = getelementptr %AudioBuffer, %AudioBuffer* %val560, i64 0, i32 4
%val562 = load float*, float** %val561
%val563 = bitcast float* %val562 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val559, i8* %val563, i64 4, i32 1, i1 0)
%val565 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val566 = load float*, float** %newptrPtr
; set tuple
%val567 = getelementptr %AudioBuffer, %AudioBuffer* %val565, i64 0, i32 4
store float* %val566, float** %val567
store float* %val566, float** %ifptr545
br label %ifcont545

else545:
%val568 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val569 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val570 = getelementptr %AudioBuffer, %AudioBuffer* %val569, i64 0, i32 4
%val571 = load float*, float** %val570
; set tuple
%val572 = getelementptr %AudioBuffer, %AudioBuffer* %val568, i64 0, i32 4
store float* %val571, float** %val572
store float* %val571, float** %ifptr545
br label %ifcont545

ifcont545:
%ifres573 = load float*, float** %ifptr545

%val574 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val575 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val576 = getelementptr %AudioBuffer, %AudioBuffer* %val575, i64 0, i32 5
%val577 = load double, double* %val576
; set tuple
%val578 = getelementptr %AudioBuffer, %AudioBuffer* %val574, i64 0, i32 5
store double %val577, double* %val578
%val579 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val580 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val581 = getelementptr %AudioBuffer, %AudioBuffer* %val580, i64 0, i32 6
%val582 = load i64, i64* %val581
; set tuple
%val583 = getelementptr %AudioBuffer, %AudioBuffer* %val579, i64 0, i32 6
store i64 %val582, i64* %val583
%val584 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val585 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val586 = getelementptr %AudioBuffer, %AudioBuffer* %val585, i64 0, i32 7
%val587 = load i64, i64* %val586
; set tuple
%val588 = getelementptr %AudioBuffer, %AudioBuffer* %val584, i64 0, i32 7
store i64 %val587, i64* %val588
%val589 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val590 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val591 = getelementptr %AudioBuffer, %AudioBuffer* %val590, i64 0, i32 8
%val592 = load i64, i64* %val591
; set tuple
%val593 = getelementptr %AudioBuffer, %AudioBuffer* %val589, i64 0, i32 8
store i64 %val592, i64* %val593
%val594 = load %AudioBuffer*, %AudioBuffer** %objPtr
%val595 = load %AudioBuffer*, %AudioBuffer** %xPtr
; tuple ref
%val596 = getelementptr %AudioBuffer, %AudioBuffer* %val595, i64 0, i32 9
%val597 = load double, double* %val596
; set tuple
%val598 = getelementptr %AudioBuffer, %AudioBuffer* %val594, i64 0, i32 9
store double %val597, double* %val598
%oldzone599 = call %mzone* @llvm_pop_zone_stack()
%newzone600 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr601 = bitcast %mzone* %newzone600 to i8*
store i8* %zone_ptr601, i8** %_impzPtr
%val602 = load %AudioBuffer*, %AudioBuffer** %objPtr
ret %AudioBuffer* %val602

else498:
%val605 = load %AudioBuffer*, %AudioBuffer** %xPtr
ret %AudioBuffer* %val605
}
@gsxtmaudiobuffer20 = hidden constant [121 x i8] c"zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone625 = load i8*, i8** %_impzPtr
%zone626 = bitcast i8* %tzone625 to %mzone*

; let assign value to symbol zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone626, i64 8)
%zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}***
%tzone606 = load i8*, i8** %_impzPtr
%zone607 = bitcast i8* %tzone606 to %mzone*
call void @llvm_zone_mark(%mzone* %zone607)
; malloc closure structure
%clsptr608 = call i8* @llvm_zone_malloc(%mzone* %zone607, i64 24)
%closure609 = bitcast i8* %clsptr608 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr610 = call i8* @llvm_zone_malloc(%mzone* %zone607, i64 8)
%environment611 = bitcast i8* %envptr610 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable612 = call %clsvar* @new_address_table()
%var613 = bitcast [68 x i8]* @gsxtmaudiobuffer18 to i8*
%var614 = bitcast [73 x i8]* @gsxtmaudiobuffer19 to i8*
%addytable615 = call %clsvar* @add_address_table(%mzone* %zone607, i8* %var613, i32 0, i8* %var614, i32 3, %clsvar* %addytable612)
%address-table616 = bitcast %clsvar* %addytable615 to i8*

; insert table, function and environment into closure struct
%closure.table619 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}* %closure609, i32 0, i32 0
store i8* %address-table616, i8** %closure.table619
%closure.env620 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}* %closure609, i32 0, i32 1
store i8* %envptr610, i8** %closure.env620
%closure.func621 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}* %closure609, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)* @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0__496, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)** %closure.func621
%closure_size622 = call i64 @llvm_zone_mark_size(%mzone* %zone607)
call void @llvm_zone_ptr_set_size(i8* %clsptr608, i64 %closure_size622)
%wrapper_ptr623 = call i8* @llvm_zone_malloc(%mzone* %zone607, i64 8)
%closure_wrapper624 = bitcast i8* %wrapper_ptr623 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}* %closure609, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}** %closure_wrapper624

; let value assignment
%zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}** %closure_wrapper624, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}** %closure_wrapper624
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}** %zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0
%tmp_envptr618 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}***}* %environment611, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}**** %tmp_envptr618


%val627 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}** %val627
}


@zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0(%AudioBuffer* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_native(%AudioBuffer* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var628 = bitcast [121 x i8]* @gsxtmaudiobuffer20 to i8*
call i32 (i8*, ...) @printf(i8* %var628)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var629 = bitcast [121 x i8]* @gsxtmaudiobuffer20 to i8*
call i32 (i8*, ...) @printf(i8* %var629)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var630 = bitcast [121 x i8]* @gsxtmaudiobuffer20 to i8*
call i32 (i8*, ...) @printf(i8* %var630)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%AudioBuffer*, %mzone*, %mzone*}, {%AudioBuffer*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
%arg_p_1 = getelementptr {%AudioBuffer*, %mzone*, %mzone*}, {%AudioBuffer*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%AudioBuffer*, %mzone*, %mzone*}, {%AudioBuffer*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer21 = hidden constant [1 x i8] c"\00"
@gsxtmaudiobuffer22 = hidden constant [49 x i8] c"AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ\00"
@gsxtmaudiobuffer23 = hidden constant [50 x i8] c"{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}**\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ__631(i8* %_impz,i8* %_impenv, i64 %frames, i64 %chans) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone632 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}***}*
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}**** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr_

; setup arguments
%framesPtr = alloca i64
store i64 %frames, i64* %framesPtr
%chansPtr = alloca i64
store i64 %chans, i64* %chansPtr


%tzone642 = load i8*, i8** %_impzPtr
%zone643 = bitcast i8* %tzone642 to %mzone*

; let assign value to symbol dat
%datPtr = alloca float*
%val633 = load i64, i64* %framesPtr
%val634 = load i64, i64* %chansPtr
%val635 = mul i64 %val633, %val634
%val636 = getelementptr i64, i64* null, i32 1
%zonesize637 = mul i64 4, %val635
%tzone638 = load i8*, i8** %_impzPtr
%zone639 = bitcast i8* %tzone638 to %mzone*
%dat640 = call i8* @llvm_zone_malloc(%mzone* %zone639, i64 %zonesize637)
call i8* @memset(i8* %dat640, i32 0, i64 %zonesize637)
%val641 = bitcast i8* %dat640 to float*

; let value assignment
%dat = select i1 true, float* %val641, float* %val641
store float* %dat, float** %datPtr

%var644 = bitcast [1 x i8]* @gsxtmaudiobuffer21 to i8*
%res645 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var644)
%val646 = load i64, i64* %framesPtr
%val647 = load i64, i64* %chansPtr
%val648 = load float*, float** %datPtr
%val649 = load i32, i32* @SAMPLE_RATE
%val650 = sitofp i32 %val649 to double
%res651 = call fastcc %AudioBuffer* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ(%String* %res645, i64 0, i64 %val646, i64 %val647, float* %val648, double %val650, i64 0, i64 0, i64 60, double 0.00000000000000000000)
ret %AudioBuffer* %res651
}
@gsxtmaudiobuffer24 = hidden constant [102 x i8] c"AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}** @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone671 = load i8*, i8** %_impzPtr
%zone672 = bitcast i8* %tzone671 to %mzone*

; let assign value to symbol AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ
%dat_AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone672, i64 8)
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr = bitcast i8* %dat_AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}***
%tzone652 = load i8*, i8** %_impzPtr
%zone653 = bitcast i8* %tzone652 to %mzone*
call void @llvm_zone_mark(%mzone* %zone653)
; malloc closure structure
%clsptr654 = call i8* @llvm_zone_malloc(%mzone* %zone653, i64 24)
%closure655 = bitcast i8* %clsptr654 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}*

; malloc environment structure
%envptr656 = call i8* @llvm_zone_malloc(%mzone* %zone653, i64 8)
%environment657 = bitcast i8* %envptr656 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable658 = call %clsvar* @new_address_table()
%var659 = bitcast [49 x i8]* @gsxtmaudiobuffer22 to i8*
%var660 = bitcast [50 x i8]* @gsxtmaudiobuffer23 to i8*
%addytable661 = call %clsvar* @add_address_table(%mzone* %zone653, i8* %var659, i32 0, i8* %var660, i32 3, %clsvar* %addytable658)
%address-table662 = bitcast %clsvar* %addytable661 to i8*

; insert table, function and environment into closure struct
%closure.table665 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}* %closure655, i32 0, i32 0
store i8* %address-table662, i8** %closure.table665
%closure.env666 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}* %closure655, i32 0, i32 1
store i8* %envptr656, i8** %closure.env666
%closure.func667 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}* %closure655, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, i64, i64)* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ__631, %AudioBuffer* (i8*, i8*, i64, i64)** %closure.func667
%closure_size668 = call i64 @llvm_zone_mark_size(%mzone* %zone653)
call void @llvm_zone_ptr_set_size(i8* %clsptr654, i64 %closure_size668)
%wrapper_ptr669 = call i8* @llvm_zone_malloc(%mzone* %zone653, i64 8)
%closure_wrapper670 = bitcast i8* %wrapper_ptr669 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}* %closure655, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}** %closure_wrapper670

; let value assignment
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}** %closure_wrapper670, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}** %closure_wrapper670
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ
%tmp_envptr664 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}***}* %environment657, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}**** %tmp_envptr664


%val673 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}** %val673
}


@AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}** @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64)*,  %AudioBuffer* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_native(i64 %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64)*,  %AudioBuffer* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var674 = bitcast [102 x i8]* @gsxtmaudiobuffer24 to i8*
call i32 (i8*, ...) @printf(i8* %var674)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var675 = bitcast [102 x i8]* @gsxtmaudiobuffer24 to i8*
call i32 (i8*, ...) @printf(i8* %var675)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64)*,  %AudioBuffer* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64}*
%arg_p_0 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64}, {i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64)*,  %AudioBuffer* (i8*, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer25 = hidden constant [58 x i8] c"AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0\00"
@gsxtmaudiobuffer26 = hidden constant [58 x i8] c"{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0__676(i8* %_impz,i8* %_impenv, i64 %frames, i64 %chans, double %samplerate) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone677 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***}*
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr_

; setup arguments
%framesPtr = alloca i64
store i64 %frames, i64* %framesPtr
%chansPtr = alloca i64
store i64 %chans, i64* %chansPtr
%sampleratePtr = alloca double
store double %samplerate, double* %sampleratePtr


%tzone687 = load i8*, i8** %_impzPtr
%zone688 = bitcast i8* %tzone687 to %mzone*

; let assign value to symbol dat
%datPtr = alloca float*
%val678 = load i64, i64* %framesPtr
%val679 = load i64, i64* %chansPtr
%val680 = mul i64 %val678, %val679
%val681 = getelementptr i64, i64* null, i32 1
%zonesize682 = mul i64 4, %val680
%tzone683 = load i8*, i8** %_impzPtr
%zone684 = bitcast i8* %tzone683 to %mzone*
%dat685 = call i8* @llvm_zone_malloc(%mzone* %zone684, i64 %zonesize682)
call i8* @memset(i8* %dat685, i32 0, i64 %zonesize682)
%val686 = bitcast i8* %dat685 to float*

; let value assignment
%dat = select i1 true, float* %val686, float* %val686
store float* %dat, float** %datPtr

%var689 = bitcast [1 x i8]* @gsxtmaudiobuffer21 to i8*
%res690 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var689)
%val691 = load i64, i64* %framesPtr
%val692 = load i64, i64* %chansPtr
%val693 = load float*, float** %datPtr
%val694 = load double, double* %sampleratePtr
%res695 = call fastcc %AudioBuffer* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ(%String* %res690, i64 0, i64 %val691, i64 %val692, float* %val693, double %val694, i64 0, i64 0, i64 60, double 0.00000000000000000000)
ret %AudioBuffer* %res695
}
@gsxtmaudiobuffer27 = hidden constant [111 x i8] c"AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone715 = load i8*, i8** %_impzPtr
%zone716 = bitcast i8* %tzone715 to %mzone*

; let assign value to symbol AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0
%dat_AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0 = call i8* @llvm_zone_malloc(%mzone* %zone716, i64 8)
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr = bitcast i8* %dat_AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***
%tzone696 = load i8*, i8** %_impzPtr
%zone697 = bitcast i8* %tzone696 to %mzone*
call void @llvm_zone_mark(%mzone* %zone697)
; malloc closure structure
%clsptr698 = call i8* @llvm_zone_malloc(%mzone* %zone697, i64 24)
%closure699 = bitcast i8* %clsptr698 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*

; malloc environment structure
%envptr700 = call i8* @llvm_zone_malloc(%mzone* %zone697, i64 8)
%environment701 = bitcast i8* %envptr700 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***}*

; malloc closure address table
%addytable702 = call %clsvar* @new_address_table()
%var703 = bitcast [58 x i8]* @gsxtmaudiobuffer25 to i8*
%var704 = bitcast [58 x i8]* @gsxtmaudiobuffer26 to i8*
%addytable705 = call %clsvar* @add_address_table(%mzone* %zone697, i8* %var703, i32 0, i8* %var704, i32 3, %clsvar* %addytable702)
%address-table706 = bitcast %clsvar* %addytable705 to i8*

; insert table, function and environment into closure struct
%closure.table709 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure699, i32 0, i32 0
store i8* %address-table706, i8** %closure.table709
%closure.env710 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure699, i32 0, i32 1
store i8* %envptr700, i8** %closure.env710
%closure.func711 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure699, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, i64, i64, double)* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0__676, %AudioBuffer* (i8*, i8*, i64, i64, double)** %closure.func711
%closure_size712 = call i64 @llvm_zone_mark_size(%mzone* %zone697)
call void @llvm_zone_ptr_set_size(i8* %clsptr698, i64 %closure_size712)
%wrapper_ptr713 = call i8* @llvm_zone_malloc(%mzone* %zone697, i64 8)
%closure_wrapper714 = bitcast i8* %wrapper_ptr713 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure699, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_wrapper714

; let value assignment
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0 = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_wrapper714, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_wrapper714
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr

; add data to environment
; don't need to alloc for env var AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0
%tmp_envptr708 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***}* %environment701, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**** %tmp_envptr708


%val717 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %val717
}


@AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0(i64 %arg_0,i64 %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_native(i64 %arg_0,i64 %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var718 = bitcast [111 x i8]* @gsxtmaudiobuffer27 to i8*
call i32 (i8*, ...) @printf(i8* %var718)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var719 = bitcast [111 x i8]* @gsxtmaudiobuffer27 to i8*
call i32 (i8*, ...) @printf(i8* %var719)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var720 = bitcast [111 x i8]* @gsxtmaudiobuffer27 to i8*
call i32 (i8*, ...) @printf(i8* %var720)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64, double}*
%arg_p_0 = getelementptr {i64, i64, double}, {i64, i64, double}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64, double}, {i64, i64, double}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i64, i64, double}, {i64, i64, double}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer28 = hidden constant [18 x i8] c"<AudioBuffer 0x0>\00"
@gsxtmaudiobuffer29 = hidden constant [229 x i8] c"<AudioBuffer %p
      filepath: %s
      playhead: %lld
        frames: %lld
      channels: %lld
          data: %p
    samplerate: %f
    loop_start: %lld
   loop_frames: %lld
      root_frq: %lld
         phase: %f>\00"
@gsxtmaudiobuffer30 = hidden constant [39 x i8] c"print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ__721(i8* %_impz,i8* %_impenv, %AudioBuffer* %ab) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone722 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***}*
%print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**** %print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr_

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr

; promote local stack var allocations
%tzone765 = load i8*, i8** %_impzPtr
%zone766 = bitcast i8* %tzone765 to %mzone*
%ifptr723 = alloca i32

%val724 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val725 = icmp eq %AudioBuffer* %val724, null
br i1 %val725, label %then723, label %else723

then723:
%var726 = bitcast [18 x i8]* @gsxtmaudiobuffer28 to i8*

%val727 = call i32 (i8*, ...) @printf(i8* %var726)
store i32 %val727, i32* %ifptr723
br label %ifcont723

else723:
%var728 = bitcast [229 x i8]* @gsxtmaudiobuffer29 to i8*
%val729 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val730 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val731 = getelementptr %AudioBuffer, %AudioBuffer* %val730, i64 0, i32 0
%val732 = load %String*, %String** %val731
; tuple ref
%val733 = getelementptr %String, %String* %val732, i64 0, i32 1
%val734 = load i8*, i8** %val733
%val735 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val736 = getelementptr %AudioBuffer, %AudioBuffer* %val735, i64 0, i32 1
%val737 = load i64, i64* %val736
%val738 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val739 = getelementptr %AudioBuffer, %AudioBuffer* %val738, i64 0, i32 2
%val740 = load i64, i64* %val739
%val741 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val742 = getelementptr %AudioBuffer, %AudioBuffer* %val741, i64 0, i32 3
%val743 = load i64, i64* %val742
%val744 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val745 = getelementptr %AudioBuffer, %AudioBuffer* %val744, i64 0, i32 4
%val746 = load float*, float** %val745
%val747 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val748 = getelementptr %AudioBuffer, %AudioBuffer* %val747, i64 0, i32 5
%val749 = load double, double* %val748
%val750 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val751 = getelementptr %AudioBuffer, %AudioBuffer* %val750, i64 0, i32 6
%val752 = load i64, i64* %val751
%val753 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val754 = getelementptr %AudioBuffer, %AudioBuffer* %val753, i64 0, i32 7
%val755 = load i64, i64* %val754
%val756 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val757 = getelementptr %AudioBuffer, %AudioBuffer* %val756, i64 0, i32 8
%val758 = load i64, i64* %val757
%val759 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val760 = getelementptr %AudioBuffer, %AudioBuffer* %val759, i64 0, i32 9
%val761 = load double, double* %val760

%val762 = call i32 (i8*, ...) @printf(i8* %var728, %AudioBuffer* %val729, i8* %val734, i64 %val737, i64 %val740, i64 %val743, float* %val746, double %val749, i64 %val752, i64 %val755, i64 %val758, double %val761)
store i32 %val762, i32* %ifptr723
br label %ifcont723

ifcont723:
%ifres763 = load i32, i32* %ifptr723

ret void
}
@gsxtmaudiobuffer31 = hidden constant [92 x i8] c"print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone786 = load i8*, i8** %_impzPtr
%zone787 = bitcast i8* %tzone786 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ
%dat_print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone787, i64 8)
%print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ to { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***
%tzone767 = load i8*, i8** %_impzPtr
%zone768 = bitcast i8* %tzone767 to %mzone*
call void @llvm_zone_mark(%mzone* %zone768)
; malloc closure structure
%clsptr769 = call i8* @llvm_zone_malloc(%mzone* %zone768, i64 24)
%closure770 = bitcast i8* %clsptr769 to { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*

; malloc environment structure
%envptr771 = call i8* @llvm_zone_malloc(%mzone* %zone768, i64 8)
%environment772 = bitcast i8* %envptr771 to {{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***}*

; malloc closure address table
%addytable773 = call %clsvar* @new_address_table()
%var774 = bitcast [39 x i8]* @gsxtmaudiobuffer30 to i8*
%var775 = bitcast [46 x i8]* @gsxtmaudiobuffer16 to i8*
%addytable776 = call %clsvar* @add_address_table(%mzone* %zone768, i8* %var774, i32 0, i8* %var775, i32 3, %clsvar* %addytable773)
%address-table777 = bitcast %clsvar* %addytable776 to i8*

; insert table, function and environment into closure struct
%closure.table780 = getelementptr { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure770, i32 0, i32 0
store i8* %address-table777, i8** %closure.table780
%closure.env781 = getelementptr { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure770, i32 0, i32 1
store i8* %envptr771, i8** %closure.env781
%closure.func782 = getelementptr { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure770, i32 0, i32 2
store void (i8*, i8*, %AudioBuffer*)* @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ__721, void (i8*, i8*, %AudioBuffer*)** %closure.func782
%closure_size783 = call i64 @llvm_zone_mark_size(%mzone* %zone768)
call void @llvm_zone_ptr_set_size(i8* %clsptr769, i64 %closure_size783)
%wrapper_ptr784 = call i8* @llvm_zone_malloc(%mzone* %zone768, i64 8)
%closure_wrapper785 = bitcast i8* %wrapper_ptr784 to { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**
store { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure770, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper785

; let value assignment
%print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper785, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper785
store { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ, { i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*** %print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ
%tmp_envptr779 = getelementptr {{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}***}* %environment772, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*** %print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**** %tmp_envptr779


%val788 = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*** %print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQPtr
ret {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %val788
}


@print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %AudioBuffer*)*,  void (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_native(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %AudioBuffer*)*,  void (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var789 = bitcast [92 x i8]* @gsxtmaudiobuffer31 to i8*
call i32 (i8*, ...) @printf(i8* %var789)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %AudioBuffer*)*,  void (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*}*
%arg_p_0 = getelementptr {%AudioBuffer*}, {%AudioBuffer*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %AudioBuffer*)*,  void (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer32 = hidden constant [46 x i8] c"toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ\00"
@gsxtmaudiobuffer33 = hidden constant [50 x i8] c"{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ__790(i8* %_impz,i8* %_impenv, %AudioBuffer* %ab) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone791 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***}*
%toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**** %toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr_

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%tzone793 = load i8*, i8** %_impzPtr
%zone794 = bitcast i8* %tzone793 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat792 = alloca i8, i64 1024, align 16

; let value assignment
%str = select i1 true, i8* %dat792, i8* %dat792
store i8* %str, i8** %strPtr

; promote local stack var allocations
%tzone838 = load i8*, i8** %_impzPtr
%zone839 = bitcast i8* %tzone838 to %mzone*
%ifptr795 = alloca i32
%val796 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val797 = icmp eq %AudioBuffer* %val796, null
br i1 %val797, label %then795, label %else795

then795:
%val798 = load i8*, i8** %strPtr
%var799 = bitcast [18 x i8]* @gsxtmaudiobuffer28 to i8*

%val800 = call i32 (i8*,i8*, ...) @sprintf(i8* %val798, i8* %var799)
store i32 %val800, i32* %ifptr795
br label %ifcont795

else795:
%val801 = load i8*, i8** %strPtr
%var802 = bitcast [229 x i8]* @gsxtmaudiobuffer29 to i8*
%val803 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val804 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val805 = getelementptr %AudioBuffer, %AudioBuffer* %val804, i64 0, i32 0
%val806 = load %String*, %String** %val805
%val807 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val808 = getelementptr %AudioBuffer, %AudioBuffer* %val807, i64 0, i32 1
%val809 = load i64, i64* %val808
%val810 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val811 = getelementptr %AudioBuffer, %AudioBuffer* %val810, i64 0, i32 2
%val812 = load i64, i64* %val811
%val813 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val814 = getelementptr %AudioBuffer, %AudioBuffer* %val813, i64 0, i32 3
%val815 = load i64, i64* %val814
%val816 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val817 = getelementptr %AudioBuffer, %AudioBuffer* %val816, i64 0, i32 4
%val818 = load float*, float** %val817
%val819 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val820 = getelementptr %AudioBuffer, %AudioBuffer* %val819, i64 0, i32 5
%val821 = load double, double* %val820
%val822 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val823 = getelementptr %AudioBuffer, %AudioBuffer* %val822, i64 0, i32 6
%val824 = load i64, i64* %val823
%val825 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val826 = getelementptr %AudioBuffer, %AudioBuffer* %val825, i64 0, i32 7
%val827 = load i64, i64* %val826
%val828 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val829 = getelementptr %AudioBuffer, %AudioBuffer* %val828, i64 0, i32 8
%val830 = load i64, i64* %val829
%val831 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val832 = getelementptr %AudioBuffer, %AudioBuffer* %val831, i64 0, i32 9
%val833 = load double, double* %val832

%val834 = call i32 (i8*,i8*, ...) @sprintf(i8* %val801, i8* %var802, %AudioBuffer* %val803, %String* %val806, i64 %val809, i64 %val812, i64 %val815, float* %val818, double %val821, i64 %val824, i64 %val827, i64 %val830, double %val833)
store i32 %val834, i32* %ifptr795
br label %ifcont795

ifcont795:
%ifres835 = load i32, i32* %ifptr795

%val836 = load i8*, i8** %strPtr
%res837 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val836)
ret %String* %res837
}
@gsxtmaudiobuffer34 = hidden constant [99 x i8] c"toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone859 = load i8*, i8** %_impzPtr
%zone860 = bitcast i8* %tzone859 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ
%dat_toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone860, i64 8)
%toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ to { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***
%tzone840 = load i8*, i8** %_impzPtr
%zone841 = bitcast i8* %tzone840 to %mzone*
call void @llvm_zone_mark(%mzone* %zone841)
; malloc closure structure
%clsptr842 = call i8* @llvm_zone_malloc(%mzone* %zone841, i64 24)
%closure843 = bitcast i8* %clsptr842 to { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*

; malloc environment structure
%envptr844 = call i8* @llvm_zone_malloc(%mzone* %zone841, i64 8)
%environment845 = bitcast i8* %envptr844 to {{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***}*

; malloc closure address table
%addytable846 = call %clsvar* @new_address_table()
%var847 = bitcast [46 x i8]* @gsxtmaudiobuffer32 to i8*
%var848 = bitcast [50 x i8]* @gsxtmaudiobuffer33 to i8*
%addytable849 = call %clsvar* @add_address_table(%mzone* %zone841, i8* %var847, i32 0, i8* %var848, i32 3, %clsvar* %addytable846)
%address-table850 = bitcast %clsvar* %addytable849 to i8*

; insert table, function and environment into closure struct
%closure.table853 = getelementptr { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure843, i32 0, i32 0
store i8* %address-table850, i8** %closure.table853
%closure.env854 = getelementptr { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure843, i32 0, i32 1
store i8* %envptr844, i8** %closure.env854
%closure.func855 = getelementptr { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure843, i32 0, i32 2
store %String* (i8*, i8*, %AudioBuffer*)* @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ__790, %String* (i8*, i8*, %AudioBuffer*)** %closure.func855
%closure_size856 = call i64 @llvm_zone_mark_size(%mzone* %zone841)
call void @llvm_zone_ptr_set_size(i8* %clsptr842, i64 %closure_size856)
%wrapper_ptr857 = call i8* @llvm_zone_malloc(%mzone* %zone841, i64 8)
%closure_wrapper858 = bitcast i8* %wrapper_ptr857 to { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**
store { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure843, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper858

; let value assignment
%toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper858, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper858
store { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*** %toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ
%tmp_envptr852 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***}* %environment845, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*** %toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**** %tmp_envptr852


%val861 = load {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*** %toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %val861
}


@toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %AudioBuffer*)*,  %String* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_native(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %AudioBuffer*)*,  %String* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var862 = bitcast [99 x i8]* @gsxtmaudiobuffer34 to i8*
call i32 (i8*, ...) @printf(i8* %var862)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %AudioBuffer*)*,  %String* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*}*
%arg_p_0 = getelementptr {%AudioBuffer*}, {%AudioBuffer*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %AudioBuffer*)*,  %String* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


define dllexport ccc %String* @AudioBuffer_filepath(%AudioBuffer* %ab) nounwind inlinehint {
entry:
%zone864 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone864 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%val865 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val866 = getelementptr %AudioBuffer, %AudioBuffer* %val865, i64 0, i32 0
%val867 = load %String*, %String** %val866
ret %String* %val867
}
@gsxtmaudiobuffer35 = hidden constant [74 x i8] c"AudioBuffer_filepath Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_filepath_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var869 = bitcast [74 x i8]* @gsxtmaudiobuffer35 to i8*
call i32 (i8*, ...) @printf(i8* %var869)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%result = call ccc %String* @AudioBuffer_filepath(%AudioBuffer* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc %String* @AudioBuffer_set_filepath(%AudioBuffer* %ab, %String* %filepath) nounwind inlinehint {
entry:
%zone871 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone871 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%filepathPtr = alloca %String*
store %String* %filepath, %String** %filepathPtr


%val872 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val873 = load %String*, %String** %filepathPtr
; set tuple
%val874 = getelementptr %AudioBuffer, %AudioBuffer* %val872, i64 0, i32 0
store %String* %val873, %String** %val874
ret %String* %val873
}
@gsxtmaudiobuffer36 = hidden constant [78 x i8] c"AudioBuffer_set_filepath Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_set_filepath_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var876 = bitcast [78 x i8]* @gsxtmaudiobuffer36 to i8*
call i32 (i8*, ...) @printf(i8* %var876)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var877 = bitcast [78 x i8]* @gsxtmaudiobuffer36 to i8*
call i32 (i8*, ...) @printf(i8* %var877)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%result = call ccc %String* @AudioBuffer_set_filepath(%AudioBuffer* %arg_0, %String* %arg_1)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_playhead(%AudioBuffer* %ab) nounwind inlinehint {
entry:
%zone879 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone879 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%val880 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val881 = getelementptr %AudioBuffer, %AudioBuffer* %val880, i64 0, i32 1
%val882 = load i64, i64* %val881
ret i64 %val882
}
@gsxtmaudiobuffer37 = hidden constant [74 x i8] c"AudioBuffer_playhead Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_playhead_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var884 = bitcast [74 x i8]* @gsxtmaudiobuffer37 to i8*
call i32 (i8*, ...) @printf(i8* %var884)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%result = call ccc i64 @AudioBuffer_playhead(%AudioBuffer* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_set_playhead(%AudioBuffer* %ab, i64 %playhead) nounwind inlinehint {
entry:
%zone886 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone886 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%playheadPtr = alloca i64
store i64 %playhead, i64* %playheadPtr


%val887 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val888 = load i64, i64* %playheadPtr
; set tuple
%val889 = getelementptr %AudioBuffer, %AudioBuffer* %val887, i64 0, i32 1
store i64 %val888, i64* %val889
ret i64 %val888
}
@gsxtmaudiobuffer38 = hidden constant [78 x i8] c"AudioBuffer_set_playhead Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_set_playhead_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var891 = bitcast [78 x i8]* @gsxtmaudiobuffer38 to i8*
call i32 (i8*, ...) @printf(i8* %var891)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var892 = bitcast [78 x i8]* @gsxtmaudiobuffer38 to i8*
call i32 (i8*, ...) @printf(i8* %var892)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%result = call ccc i64 @AudioBuffer_set_playhead(%AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_frames(%AudioBuffer* %ab) nounwind inlinehint {
entry:
%zone894 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone894 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%val895 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val896 = getelementptr %AudioBuffer, %AudioBuffer* %val895, i64 0, i32 2
%val897 = load i64, i64* %val896
ret i64 %val897
}
@gsxtmaudiobuffer39 = hidden constant [72 x i8] c"AudioBuffer_frames Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_frames_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var899 = bitcast [72 x i8]* @gsxtmaudiobuffer39 to i8*
call i32 (i8*, ...) @printf(i8* %var899)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%result = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_set_frames(%AudioBuffer* %ab, i64 %frames) nounwind inlinehint {
entry:
%zone901 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone901 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%framesPtr = alloca i64
store i64 %frames, i64* %framesPtr


%val902 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val903 = load i64, i64* %framesPtr
; set tuple
%val904 = getelementptr %AudioBuffer, %AudioBuffer* %val902, i64 0, i32 2
store i64 %val903, i64* %val904
ret i64 %val903
}
@gsxtmaudiobuffer40 = hidden constant [76 x i8] c"AudioBuffer_set_frames Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_set_frames_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var906 = bitcast [76 x i8]* @gsxtmaudiobuffer40 to i8*
call i32 (i8*, ...) @printf(i8* %var906)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var907 = bitcast [76 x i8]* @gsxtmaudiobuffer40 to i8*
call i32 (i8*, ...) @printf(i8* %var907)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%result = call ccc i64 @AudioBuffer_set_frames(%AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_channels(%AudioBuffer* %ab) nounwind inlinehint {
entry:
%zone909 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone909 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%val910 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val911 = getelementptr %AudioBuffer, %AudioBuffer* %val910, i64 0, i32 3
%val912 = load i64, i64* %val911
ret i64 %val912
}
@gsxtmaudiobuffer41 = hidden constant [74 x i8] c"AudioBuffer_channels Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_channels_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var914 = bitcast [74 x i8]* @gsxtmaudiobuffer41 to i8*
call i32 (i8*, ...) @printf(i8* %var914)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%result = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_set_channels(%AudioBuffer* %ab, i64 %channels) nounwind inlinehint {
entry:
%zone916 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone916 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%channelsPtr = alloca i64
store i64 %channels, i64* %channelsPtr


%val917 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val918 = load i64, i64* %channelsPtr
; set tuple
%val919 = getelementptr %AudioBuffer, %AudioBuffer* %val917, i64 0, i32 3
store i64 %val918, i64* %val919
ret i64 %val918
}
@gsxtmaudiobuffer42 = hidden constant [78 x i8] c"AudioBuffer_set_channels Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_set_channels_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var921 = bitcast [78 x i8]* @gsxtmaudiobuffer42 to i8*
call i32 (i8*, ...) @printf(i8* %var921)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var922 = bitcast [78 x i8]* @gsxtmaudiobuffer42 to i8*
call i32 (i8*, ...) @printf(i8* %var922)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%result = call ccc i64 @AudioBuffer_set_channels(%AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc float* @AudioBuffer_data(%AudioBuffer* %ab) nounwind inlinehint {
entry:
%zone924 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone924 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%val925 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val926 = getelementptr %AudioBuffer, %AudioBuffer* %val925, i64 0, i32 4
%val927 = load float*, float** %val926
ret float* %val927
}
@gsxtmaudiobuffer43 = hidden constant [70 x i8] c"AudioBuffer_data Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_data_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var929 = bitcast [70 x i8]* @gsxtmaudiobuffer43 to i8*
call i32 (i8*, ...) @printf(i8* %var929)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%result = call ccc float* @AudioBuffer_data(%AudioBuffer* %arg_0)
%tmpres = bitcast float* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


@gsxtmaudiobuffer44 = hidden constant [58 x i8] c"AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ\00"
define dllexport fastcc %String* @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ__930(i8* %_impz,i8* %_impenv, %AudioBuffer* %ab) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone931 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***}*
%AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**** %AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr_

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%tzone932 = load i8*, i8** %_impzPtr
%zone933 = bitcast i8* %tzone932 to %mzone*

; let assign value to symbol b64size
%b64sizePtr = alloca i64
%tzone940 = load i8*, i8** %_impzPtr
%zone941 = bitcast i8* %tzone940 to %mzone*

; let assign value to symbol datsize
%datsizePtr = alloca i64

; let value assignment
%b64size = select i1 true, i64 0, i64 0
store i64 %b64size, i64* %b64sizePtr

%val934 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res935 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val934)
%val936 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res937 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val936)
%val938 = mul i64 %res935, %res937
%val939 = mul i64 %val938, 4

; let value assignment
%datsize = select i1 true, i64 %val939, i64 %val939
store i64 %datsize, i64* %datsizePtr

%val942 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val943 = getelementptr %AudioBuffer, %AudioBuffer* %val942, i64 0, i32 4
%val944 = load float*, float** %val943
%val945 = bitcast float* %val944 to i8*
%val946 = load i64, i64* %datsizePtr
%res947 = call ccc i8* @base64_encode(i8* %val945, i64 %val946, i64* %b64sizePtr)
%res948 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %res947)
ret %String* %res948
}
@gsxtmaudiobuffer45 = hidden constant [111 x i8] c"AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone968 = load i8*, i8** %_impzPtr
%zone969 = bitcast i8* %tzone968 to %mzone*

; let assign value to symbol AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ
%dat_AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone969, i64 8)
%AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr = bitcast i8* %dat_AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ to { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***
%tzone949 = load i8*, i8** %_impzPtr
%zone950 = bitcast i8* %tzone949 to %mzone*
call void @llvm_zone_mark(%mzone* %zone950)
; malloc closure structure
%clsptr951 = call i8* @llvm_zone_malloc(%mzone* %zone950, i64 24)
%closure952 = bitcast i8* %clsptr951 to { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*

; malloc environment structure
%envptr953 = call i8* @llvm_zone_malloc(%mzone* %zone950, i64 8)
%environment954 = bitcast i8* %envptr953 to {{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***}*

; malloc closure address table
%addytable955 = call %clsvar* @new_address_table()
%var956 = bitcast [58 x i8]* @gsxtmaudiobuffer44 to i8*
%var957 = bitcast [50 x i8]* @gsxtmaudiobuffer33 to i8*
%addytable958 = call %clsvar* @add_address_table(%mzone* %zone950, i8* %var956, i32 0, i8* %var957, i32 3, %clsvar* %addytable955)
%address-table959 = bitcast %clsvar* %addytable958 to i8*

; insert table, function and environment into closure struct
%closure.table962 = getelementptr { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure952, i32 0, i32 0
store i8* %address-table959, i8** %closure.table962
%closure.env963 = getelementptr { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure952, i32 0, i32 1
store i8* %envptr953, i8** %closure.env963
%closure.func964 = getelementptr { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure952, i32 0, i32 2
store %String* (i8*, i8*, %AudioBuffer*)* @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ__930, %String* (i8*, i8*, %AudioBuffer*)** %closure.func964
%closure_size965 = call i64 @llvm_zone_mark_size(%mzone* %zone950)
call void @llvm_zone_ptr_set_size(i8* %clsptr951, i64 %closure_size965)
%wrapper_ptr966 = call i8* @llvm_zone_malloc(%mzone* %zone950, i64 8)
%closure_wrapper967 = bitcast i8* %wrapper_ptr966 to { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**
store { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure952, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper967

; let value assignment
%AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper967, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper967
store { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ, { i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*** %AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ
%tmp_envptr961 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}***}* %environment954, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*** %AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**** %tmp_envptr961


%val970 = load {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*** %AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %val970
}


@AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %AudioBuffer*)*,  %String* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_native(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %AudioBuffer*)*,  %String* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var971 = bitcast [111 x i8]* @gsxtmaudiobuffer45 to i8*
call i32 (i8*, ...) @printf(i8* %var971)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %AudioBuffer*)*,  %String* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*}*
%arg_p_0 = getelementptr {%AudioBuffer*}, {%AudioBuffer*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_data_b64_adhoc_W1N0cmluZyosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %String* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %AudioBuffer*)*,  %String* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer46 = hidden constant [60 x i8] c"AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd\00"
@gsxtmaudiobuffer47 = hidden constant [45 x i8] c"{i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}**\00"
define dllexport fastcc i8* @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd__972(i8* %_impz,i8* %_impenv, %AudioBuffer* %ab) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone973 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}***}*
%AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipdPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipdPtr = load {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}***, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}**** %AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipdPtr_

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%tzone974 = load i8*, i8** %_impzPtr
%zone975 = bitcast i8* %tzone974 to %mzone*

; let assign value to symbol b64size
%b64sizePtr = alloca i64
%tzone982 = load i8*, i8** %_impzPtr
%zone983 = bitcast i8* %tzone982 to %mzone*

; let assign value to symbol datsize
%datsizePtr = alloca i64

; let value assignment
%b64size = select i1 true, i64 0, i64 0
store i64 %b64size, i64* %b64sizePtr

%val976 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res977 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val976)
%val978 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res979 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val978)
%val980 = mul i64 %res977, %res979
%val981 = mul i64 %val980, 4

; let value assignment
%datsize = select i1 true, i64 %val981, i64 %val981
store i64 %datsize, i64* %datsizePtr

%val984 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val985 = getelementptr %AudioBuffer, %AudioBuffer* %val984, i64 0, i32 4
%val986 = load float*, float** %val985
%val987 = bitcast float* %val986 to i8*
%val988 = load i64, i64* %datsizePtr
%res989 = call ccc i8* @base64_encode(i8* %val987, i64 %val988, i64* %b64sizePtr)
ret i8* %res989
}
@gsxtmaudiobuffer48 = hidden constant [113 x i8] c"AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}** @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1009 = load i8*, i8** %_impzPtr
%zone1010 = bitcast i8* %tzone1009 to %mzone*

; let assign value to symbol AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd
%dat_AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd = call i8* @llvm_zone_malloc(%mzone* %zone1010, i64 8)
%AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipdPtr = bitcast i8* %dat_AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd to { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}***
%tzone990 = load i8*, i8** %_impzPtr
%zone991 = bitcast i8* %tzone990 to %mzone*
call void @llvm_zone_mark(%mzone* %zone991)
; malloc closure structure
%clsptr992 = call i8* @llvm_zone_malloc(%mzone* %zone991, i64 24)
%closure993 = bitcast i8* %clsptr992 to { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}*

; malloc environment structure
%envptr994 = call i8* @llvm_zone_malloc(%mzone* %zone991, i64 8)
%environment995 = bitcast i8* %envptr994 to {{i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}***}*

; malloc closure address table
%addytable996 = call %clsvar* @new_address_table()
%var997 = bitcast [60 x i8]* @gsxtmaudiobuffer46 to i8*
%var998 = bitcast [45 x i8]* @gsxtmaudiobuffer47 to i8*
%addytable999 = call %clsvar* @add_address_table(%mzone* %zone991, i8* %var997, i32 0, i8* %var998, i32 3, %clsvar* %addytable996)
%address-table1000 = bitcast %clsvar* %addytable999 to i8*

; insert table, function and environment into closure struct
%closure.table1003 = getelementptr { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}* %closure993, i32 0, i32 0
store i8* %address-table1000, i8** %closure.table1003
%closure.env1004 = getelementptr { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}* %closure993, i32 0, i32 1
store i8* %envptr994, i8** %closure.env1004
%closure.func1005 = getelementptr { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}* %closure993, i32 0, i32 2
store i8* (i8*, i8*, %AudioBuffer*)* @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd__972, i8* (i8*, i8*, %AudioBuffer*)** %closure.func1005
%closure_size1006 = call i64 @llvm_zone_mark_size(%mzone* %zone991)
call void @llvm_zone_ptr_set_size(i8* %clsptr992, i64 %closure_size1006)
%wrapper_ptr1007 = call i8* @llvm_zone_malloc(%mzone* %zone991, i64 8)
%closure_wrapper1008 = bitcast i8* %wrapper_ptr1007 to { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}**
store { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}* %closure993, { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper1008

; let value assignment
%AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd = select i1 true, { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper1008, { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper1008
store { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}** %AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd, { i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}*** %AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipdPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd
%tmp_envptr1002 = getelementptr {{i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}***}* %environment995, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}*** %AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipdPtr, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}**** %tmp_envptr1002


%val1011 = load {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}**, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}*** %AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipdPtr
ret {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}** %val1011
}


@AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}** @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %AudioBuffer*)*,  i8* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret i8* %result
}


define dllexport ccc i8* @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_native(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %AudioBuffer*)*,  i8* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1012 = bitcast [113 x i8]* @gsxtmaudiobuffer48 to i8*
call i32 (i8*, ...) @printf(i8* %var1012)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %AudioBuffer*)*,  i8* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*}*
%arg_p_0 = getelementptr {%AudioBuffer*}, {%AudioBuffer*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_data_b64_cstring_adhoc_W2k4KixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, i8* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %AudioBuffer*)*,  i8* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


define dllexport ccc float* @AudioBuffer_set_data(%AudioBuffer* %ab, float* %data) nounwind inlinehint {
entry:
%zone1014 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1014 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%dataPtr = alloca float*
store float* %data, float** %dataPtr


%val1015 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val1016 = load float*, float** %dataPtr
; set tuple
%val1017 = getelementptr %AudioBuffer, %AudioBuffer* %val1015, i64 0, i32 4
store float* %val1016, float** %val1017
ret float* %val1016
}
@gsxtmaudiobuffer49 = hidden constant [74 x i8] c"AudioBuffer_set_data Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_set_data_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1019 = bitcast [74 x i8]* @gsxtmaudiobuffer49 to i8*
call i32 (i8*, ...) @printf(i8* %var1019)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1020 = bitcast [74 x i8]* @gsxtmaudiobuffer49 to i8*
call i32 (i8*, ...) @printf(i8* %var1020)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%result = call ccc float* @AudioBuffer_set_data(%AudioBuffer* %arg_0, float* %arg_1)
%tmpres = bitcast float* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


@gsxtmaudiobuffer50 = hidden constant [3 x i8] c"%s\00"
@gsxtmaudiobuffer51 = hidden constant [37 x i8] c"error: AudioBuffer must be at least \00"
@gsxtmaudiobuffer52 = hidden constant [8 x i8] c" bytes.\00"
@gsxtmaudiobuffer53 = hidden constant [68 x i8] c"AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd\00"
@gsxtmaudiobuffer54 = hidden constant [56 x i8] c"{i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}**\00"
define dllexport fastcc void @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd__1021(i8* %_impz,i8* %_impenv, %AudioBuffer* %ab, %String* %b64) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1022 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}***}*
%AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypdPtr = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}***, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}**** %AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypdPtr_

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%b64Ptr = alloca %String*
store %String* %b64, %String** %b64Ptr


%tzone1023 = load i8*, i8** %_impzPtr
%zone1024 = bitcast i8* %tzone1023 to %mzone*

; let assign value to symbol size_s_1
%size_s_1Ptr = alloca i64
%tzone1030 = load i8*, i8** %_impzPtr
%zone1031 = bitcast i8* %tzone1030 to %mzone*

; let assign value to symbol out
%outPtr = alloca i8*

; let value assignment
%size_s_1 = select i1 true, i64 0, i64 0
store i64 %size_s_1, i64* %size_s_1Ptr

%val1025 = load %String*, %String** %b64Ptr
%res1026 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val1025)
%val1027 = load %String*, %String** %b64Ptr
%res1028 = call fastcc i64 @length_adhoc_W2k2NCxTdHJpbmcqXQ(%String* %val1027)
%res1029 = call ccc i8* @base64_decode(i8* %res1026, i64 %res1028, i64* %size_s_1Ptr)

; let value assignment
%out = select i1 true, i8* %res1029, i8* %res1029
store i8* %out, i8** %outPtr

; promote local stack var allocations
%tzone1089 = load i8*, i8** %_impzPtr
%zone1090 = bitcast i8* %tzone1089 to %mzone*
%ifptr1033 = alloca i1
%ifptr1050 = alloca i1
%val1034 = load i64, i64* %size_s_1Ptr
%val1035 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1036 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1035)
%val1037 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1038 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1037)
%val1039 = mul i64 %res1036, %res1038
%val1040 = mul i64 %val1039, 4
%cmp1041 = icmp slt i64 %val1034, %val1040
br i1 %cmp1041, label %then1033, label %else1033

then1033:
%val1042 = load i64, i64* %size_s_1Ptr
%val1043 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1044 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1043)
%val1045 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1046 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1045)
%val1047 = mul i64 %res1044, %res1046
%val1048 = mul i64 %val1047, 4
%cmp1049 = icmp slt i64 %val1042, %val1048
store i1 %cmp1049, i1* %ifptr1033
br label %ifcont1033

else1033:
%val1051 = load i64, i64* %size_s_1Ptr
%val1052 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1053 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1052)
%val1054 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1055 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1054)
%val1056 = mul i64 %res1053, %res1055
%val1057 = mul i64 %val1056, 4
%cmp1058 = icmp eq i64 %val1051, %val1057
br i1 %cmp1058, label %then1050, label %else1050

then1050:
%val1059 = load i64, i64* %size_s_1Ptr
%val1060 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1061 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1060)
%val1062 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1063 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1062)
%val1064 = mul i64 %res1061, %res1063
%val1065 = mul i64 %val1064, 4
%cmp1066 = icmp eq i64 %val1059, %val1065
store i1 %cmp1066, i1* %ifptr1050
br label %ifcont1050

else1050:
%res1067 = call ccc i1 @impc_false()
store i1 %res1067, i1* %ifptr1050
br label %ifcont1050

ifcont1050:
%ifres1068 = load i1, i1* %ifptr1050

store i1 %ifres1068, i1* %ifptr1033
br label %ifcont1033

ifcont1033:
%ifres1069 = load i1, i1* %ifptr1033

br i1 %ifres1069, label %then1032, label %else1032

then1032:
%val1070 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1071 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val1070)
%val1072 = bitcast float* %res1071 to i8*
%val1073 = load i8*, i8** %outPtr
%val1074 = load i64, i64* %size_s_1Ptr
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val1072, i8* %val1073, i64 %val1074, i32 1, i1 0)
ret void

else1032:
%var1077 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var1078 = bitcast [37 x i8]* @gsxtmaudiobuffer51 to i8*

%val1079 = call i32 (i8*, ...) @printf(i8* %var1077, i8* %var1078)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%val1081 = load i64, i64* %size_s_1Ptr
call fastcc void @print_adhoc_W3ZvaWQsaTY0XQ(i64 %val1081)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%var1084 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var1085 = bitcast [8 x i8]* @gsxtmaudiobuffer52 to i8*

%val1086 = call i32 (i8*, ...) @printf(i8* %var1084, i8* %var1085)
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret void
}
@gsxtmaudiobuffer55 = hidden constant [121 x i8] c"AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}** @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1110 = load i8*, i8** %_impzPtr
%zone1111 = bitcast i8* %tzone1110 to %mzone*

; let assign value to symbol AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd
%dat_AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone1111, i64 8)
%AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypdPtr = bitcast i8* %dat_AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd to { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}***
%tzone1091 = load i8*, i8** %_impzPtr
%zone1092 = bitcast i8* %tzone1091 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1092)
; malloc closure structure
%clsptr1093 = call i8* @llvm_zone_malloc(%mzone* %zone1092, i64 24)
%closure1094 = bitcast i8* %clsptr1093 to { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}*

; malloc environment structure
%envptr1095 = call i8* @llvm_zone_malloc(%mzone* %zone1092, i64 8)
%environment1096 = bitcast i8* %envptr1095 to {{i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}***}*

; malloc closure address table
%addytable1097 = call %clsvar* @new_address_table()
%var1098 = bitcast [68 x i8]* @gsxtmaudiobuffer53 to i8*
%var1099 = bitcast [56 x i8]* @gsxtmaudiobuffer54 to i8*
%addytable1100 = call %clsvar* @add_address_table(%mzone* %zone1092, i8* %var1098, i32 0, i8* %var1099, i32 3, %clsvar* %addytable1097)
%address-table1101 = bitcast %clsvar* %addytable1100 to i8*

; insert table, function and environment into closure struct
%closure.table1104 = getelementptr { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}, { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}* %closure1094, i32 0, i32 0
store i8* %address-table1101, i8** %closure.table1104
%closure.env1105 = getelementptr { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}, { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}* %closure1094, i32 0, i32 1
store i8* %envptr1095, i8** %closure.env1105
%closure.func1106 = getelementptr { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}, { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}* %closure1094, i32 0, i32 2
store void (i8*, i8*, %AudioBuffer*, %String*)* @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd__1021, void (i8*, i8*, %AudioBuffer*, %String*)** %closure.func1106
%closure_size1107 = call i64 @llvm_zone_mark_size(%mzone* %zone1092)
call void @llvm_zone_ptr_set_size(i8* %clsptr1093, i64 %closure_size1107)
%wrapper_ptr1108 = call i8* @llvm_zone_malloc(%mzone* %zone1092, i64 8)
%closure_wrapper1109 = bitcast i8* %wrapper_ptr1108 to { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}**
store { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}* %closure1094, { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}** %closure_wrapper1109

; let value assignment
%AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd = select i1 true, { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}** %closure_wrapper1109, { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}** %closure_wrapper1109
store { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}** %AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd, { i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}*** %AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd
%tmp_envptr1103 = getelementptr {{i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}***}* %environment1096, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}*** %AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypdPtr, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}**** %tmp_envptr1103


%val1112 = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}**, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}*** %AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypdPtr
ret {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}** %val1112
}


@AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}** @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd(%AudioBuffer* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %AudioBuffer*, %String*)*,  void (i8*, i8*, %AudioBuffer*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %String* %arg_1)
ret void
}


define dllexport ccc void @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_native(%AudioBuffer* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %AudioBuffer*, %String*)*,  void (i8*, i8*, %AudioBuffer*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %String* %arg_1)
ret void
}


define dllexport ccc i8*  @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1113 = bitcast [121 x i8]* @gsxtmaudiobuffer55 to i8*
call i32 (i8*, ...) @printf(i8* %var1113)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1114 = bitcast [121 x i8]* @gsxtmaudiobuffer55 to i8*
call i32 (i8*, ...) @printf(i8* %var1114)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %AudioBuffer*, %String*)*,  void (i8*, i8*, %AudioBuffer*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %String* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*, %String*}*
%arg_p_0 = getelementptr {%AudioBuffer*, %String*}, {%AudioBuffer*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
%arg_p_1 = getelementptr {%AudioBuffer*, %String*}, {%AudioBuffer*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}, {i8*, i8*, void (i8*, i8*, %AudioBuffer*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %AudioBuffer*, %String*)*,  void (i8*, i8*, %AudioBuffer*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %String* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


define dllexport ccc double @AudioBuffer_samplerate(%AudioBuffer* %ab) nounwind inlinehint {
entry:
%zone1116 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1116 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%val1117 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val1118 = getelementptr %AudioBuffer, %AudioBuffer* %val1117, i64 0, i32 5
%val1119 = load double, double* %val1118
ret double %val1119
}
@gsxtmaudiobuffer56 = hidden constant [76 x i8] c"AudioBuffer_samplerate Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_samplerate_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1121 = bitcast [76 x i8]* @gsxtmaudiobuffer56 to i8*
call i32 (i8*, ...) @printf(i8* %var1121)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%result = call ccc double @AudioBuffer_samplerate(%AudioBuffer* %arg_0)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc double @AudioBuffer_set_samplerate(%AudioBuffer* %ab, double %samplerate) nounwind inlinehint {
entry:
%zone1123 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1123 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%sampleratePtr = alloca double
store double %samplerate, double* %sampleratePtr


%val1124 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val1125 = load double, double* %sampleratePtr
; set tuple
%val1126 = getelementptr %AudioBuffer, %AudioBuffer* %val1124, i64 0, i32 5
store double %val1125, double* %val1126
ret double %val1125
}
@gsxtmaudiobuffer57 = hidden constant [80 x i8] c"AudioBuffer_set_samplerate Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_set_samplerate_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1128 = bitcast [80 x i8]* @gsxtmaudiobuffer57 to i8*
call i32 (i8*, ...) @printf(i8* %var1128)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1129 = bitcast [80 x i8]* @gsxtmaudiobuffer57 to i8*
call i32 (i8*, ...) @printf(i8* %var1129)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%result = call ccc double @AudioBuffer_set_samplerate(%AudioBuffer* %arg_0, double %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_loop_start(%AudioBuffer* %ab) nounwind inlinehint {
entry:
%zone1131 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1131 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%val1132 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val1133 = getelementptr %AudioBuffer, %AudioBuffer* %val1132, i64 0, i32 6
%val1134 = load i64, i64* %val1133
ret i64 %val1134
}
@gsxtmaudiobuffer58 = hidden constant [76 x i8] c"AudioBuffer_loop_start Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_loop_start_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1136 = bitcast [76 x i8]* @gsxtmaudiobuffer58 to i8*
call i32 (i8*, ...) @printf(i8* %var1136)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%result = call ccc i64 @AudioBuffer_loop_start(%AudioBuffer* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_set_loop_start(%AudioBuffer* %ab, i64 %loop_start) nounwind inlinehint {
entry:
%zone1138 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1138 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%loop_startPtr = alloca i64
store i64 %loop_start, i64* %loop_startPtr


%val1139 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val1140 = load i64, i64* %loop_startPtr
; set tuple
%val1141 = getelementptr %AudioBuffer, %AudioBuffer* %val1139, i64 0, i32 6
store i64 %val1140, i64* %val1141
ret i64 %val1140
}
@gsxtmaudiobuffer59 = hidden constant [80 x i8] c"AudioBuffer_set_loop_start Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_set_loop_start_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1143 = bitcast [80 x i8]* @gsxtmaudiobuffer59 to i8*
call i32 (i8*, ...) @printf(i8* %var1143)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1144 = bitcast [80 x i8]* @gsxtmaudiobuffer59 to i8*
call i32 (i8*, ...) @printf(i8* %var1144)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%result = call ccc i64 @AudioBuffer_set_loop_start(%AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_loop_frames(%AudioBuffer* %ab) nounwind inlinehint {
entry:
%zone1146 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1146 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%val1147 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val1148 = getelementptr %AudioBuffer, %AudioBuffer* %val1147, i64 0, i32 7
%val1149 = load i64, i64* %val1148
ret i64 %val1149
}
@gsxtmaudiobuffer60 = hidden constant [77 x i8] c"AudioBuffer_loop_frames Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_loop_frames_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1151 = bitcast [77 x i8]* @gsxtmaudiobuffer60 to i8*
call i32 (i8*, ...) @printf(i8* %var1151)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%result = call ccc i64 @AudioBuffer_loop_frames(%AudioBuffer* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_set_loop_frames(%AudioBuffer* %ab, i64 %loop_frames) nounwind inlinehint {
entry:
%zone1153 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1153 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%loop_framesPtr = alloca i64
store i64 %loop_frames, i64* %loop_framesPtr


%val1154 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val1155 = load i64, i64* %loop_framesPtr
; set tuple
%val1156 = getelementptr %AudioBuffer, %AudioBuffer* %val1154, i64 0, i32 7
store i64 %val1155, i64* %val1156
ret i64 %val1155
}
@gsxtmaudiobuffer61 = hidden constant [81 x i8] c"AudioBuffer_set_loop_frames Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_set_loop_frames_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1158 = bitcast [81 x i8]* @gsxtmaudiobuffer61 to i8*
call i32 (i8*, ...) @printf(i8* %var1158)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1159 = bitcast [81 x i8]* @gsxtmaudiobuffer61 to i8*
call i32 (i8*, ...) @printf(i8* %var1159)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%result = call ccc i64 @AudioBuffer_set_loop_frames(%AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_root_pitch(%AudioBuffer* %ab) nounwind inlinehint {
entry:
%zone1161 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1161 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%val1162 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val1163 = getelementptr %AudioBuffer, %AudioBuffer* %val1162, i64 0, i32 8
%val1164 = load i64, i64* %val1163
ret i64 %val1164
}
@gsxtmaudiobuffer62 = hidden constant [76 x i8] c"AudioBuffer_root_pitch Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_root_pitch_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1166 = bitcast [76 x i8]* @gsxtmaudiobuffer62 to i8*
call i32 (i8*, ...) @printf(i8* %var1166)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%result = call ccc i64 @AudioBuffer_root_pitch(%AudioBuffer* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_set_root_pitch(%AudioBuffer* %ab, i64 %root_pitch) nounwind inlinehint {
entry:
%zone1168 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1168 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%root_pitchPtr = alloca i64
store i64 %root_pitch, i64* %root_pitchPtr


%val1169 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val1170 = load i64, i64* %root_pitchPtr
; set tuple
%val1171 = getelementptr %AudioBuffer, %AudioBuffer* %val1169, i64 0, i32 8
store i64 %val1170, i64* %val1171
ret i64 %val1170
}
@gsxtmaudiobuffer63 = hidden constant [80 x i8] c"AudioBuffer_set_root_pitch Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_set_root_pitch_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1173 = bitcast [80 x i8]* @gsxtmaudiobuffer63 to i8*
call i32 (i8*, ...) @printf(i8* %var1173)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1174 = bitcast [80 x i8]* @gsxtmaudiobuffer63 to i8*
call i32 (i8*, ...) @printf(i8* %var1174)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%result = call ccc i64 @AudioBuffer_set_root_pitch(%AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc double @AudioBuffer_phase(%AudioBuffer* %ab) nounwind inlinehint {
entry:
%zone1176 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1176 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%val1177 = load %AudioBuffer*, %AudioBuffer** %abPtr
; tuple ref
%val1178 = getelementptr %AudioBuffer, %AudioBuffer* %val1177, i64 0, i32 9
%val1179 = load double, double* %val1178
ret double %val1179
}
@gsxtmaudiobuffer64 = hidden constant [71 x i8] c"AudioBuffer_phase Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_phase_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1181 = bitcast [71 x i8]* @gsxtmaudiobuffer64 to i8*
call i32 (i8*, ...) @printf(i8* %var1181)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%result = call ccc double @AudioBuffer_phase(%AudioBuffer* %arg_0)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc double @AudioBuffer_set_phase(%AudioBuffer* %ab, double %phase) nounwind inlinehint {
entry:
%zone1183 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1183 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%phasePtr = alloca double
store double %phase, double* %phasePtr


%val1184 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val1185 = load double, double* %phasePtr
; set tuple
%val1186 = getelementptr %AudioBuffer, %AudioBuffer* %val1184, i64 0, i32 9
store double %val1185, double* %val1186
ret double %val1185
}
@gsxtmaudiobuffer65 = hidden constant [75 x i8] c"AudioBuffer_set_phase Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_set_phase_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1188 = bitcast [75 x i8]* @gsxtmaudiobuffer65 to i8*
call i32 (i8*, ...) @printf(i8* %var1188)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1189 = bitcast [75 x i8]* @gsxtmaudiobuffer65 to i8*
call i32 (i8*, ...) @printf(i8* %var1189)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc double @r64value(i8* %arg_1_val)
%result = call ccc double @AudioBuffer_set_phase(%AudioBuffer* %arg_0, double %arg_1)
%res = call ccc i8* @mk_double(i8* %_sc, double %result)
ret i8* %res
}


define dllexport ccc i64 @AudioBuffer_num_samples(%AudioBuffer* %ab) nounwind inlinehint {
entry:
%zone1191 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1191 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%val1192 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1193 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1192)
%val1194 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1195 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1194)
%val1196 = mul i64 %res1193, %res1195
ret i64 %val1196
}
@gsxtmaudiobuffer66 = hidden constant [77 x i8] c"AudioBuffer_num_samples Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_num_samples_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1198 = bitcast [77 x i8]* @gsxtmaudiobuffer66 to i8*
call i32 (i8*, ...) @printf(i8* %var1198)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%result = call ccc i64 @AudioBuffer_num_samples(%AudioBuffer* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


@gsxtmaudiobuffer67 = hidden constant [35 x i8] c"AudioBuffer seek value must be > 0\00"
define dllexport ccc i1 @AudioBuffer_seek(%AudioBuffer* %ab, i64 %seek_to) nounwind inlinehint {
entry:
%zone1200 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1200 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%seek_toPtr = alloca i64
store i64 %seek_to, i64* %seek_toPtr


%val1202 = load i64, i64* %seek_toPtr
%cmp1203 = icmp slt i64 %val1202, 0
br i1 %cmp1203, label %then1201, label %else1201

then1201:
%var1204 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var1205 = bitcast [35 x i8]* @gsxtmaudiobuffer67 to i8*

%val1206 = call i32 (i8*, ...) @printf(i8* %var1204, i8* %var1205)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%res1208 = call ccc i1 @impc_false()
ret i1 %res1208

else1201:
%tzone1211 = load i8*, i8** %_impzPtr
%zone1212 = bitcast i8* %tzone1211 to %mzone*

; let assign value to symbol len
%lenPtr = alloca i64
%val1209 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1210 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1209)

; let value assignment
%len = select i1 true, i64 %res1210, i64 %res1210
store i64 %len, i64* %lenPtr

; promote local stack var allocations
%tzone1223 = load i8*, i8** %_impzPtr
%zone1224 = bitcast i8* %tzone1223 to %mzone*
%ifptr1214 = alloca i64
%val1213 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val1215 = load i64, i64* %seek_toPtr
%val1216 = load i64, i64* %lenPtr
%cmp1217 = icmp slt i64 %val1215, %val1216
br i1 %cmp1217, label %then1214, label %else1214

then1214:
%val1218 = load i64, i64* %seek_toPtr
store i64 %val1218, i64* %ifptr1214
br label %ifcont1214

else1214:
%val1219 = load i64, i64* %lenPtr
store i64 %val1219, i64* %ifptr1214
br label %ifcont1214

ifcont1214:
%ifres1220 = load i64, i64* %ifptr1214

%res1221 = call ccc i64 @AudioBuffer_set_playhead(%AudioBuffer* %val1213, i64 %ifres1220)
%res1222 = call ccc i1 @impc_true()
ret i1 %res1222
}
@gsxtmaudiobuffer68 = hidden constant [70 x i8] c"AudioBuffer_seek Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_seek_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1226 = bitcast [70 x i8]* @gsxtmaudiobuffer68 to i8*
call i32 (i8*, ...) @printf(i8* %var1226)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1227 = bitcast [70 x i8]* @gsxtmaudiobuffer68 to i8*
call i32 (i8*, ...) @printf(i8* %var1227)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%result = call ccc i1 @AudioBuffer_seek(%AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc float @AudioBuffer_peek(%AudioBuffer* %ab, i64 %chan) nounwind inlinehint {
entry:
%zone1229 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1229 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr


%tzone1232 = load i8*, i8** %_impzPtr
%zone1233 = bitcast i8* %tzone1232 to %mzone*

; let assign value to symbol ph
%phPtr = alloca i64
%val1230 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1231 = call ccc i64 @AudioBuffer_playhead(%AudioBuffer* %val1230)

; let value assignment
%ph = select i1 true, i64 %res1231, i64 %res1231
store i64 %ph, i64* %phPtr

%val1235 = load i64, i64* %phPtr
%val1236 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1237 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1236)
%cmp1238 = icmp slt i64 %val1235, %res1237
br i1 %cmp1238, label %then1234, label %else1234

then1234:
%val1239 = load i64, i64* %phPtr
%val1240 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1241 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1240)
%val1242 = mul i64 %val1239, %res1241
%val1243 = load i64, i64* %chanPtr
%val1244 = add i64 %val1242, %val1243
%val1245 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1246 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val1245)
; pointer ref
%val1247 = getelementptr float, float* %res1246, i64 %val1244
%val1248 = load float, float* %val1247
ret float %val1248

else1234:
ret float 0x0
}
@gsxtmaudiobuffer69 = hidden constant [70 x i8] c"AudioBuffer_peek Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_peek_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1250 = bitcast [70 x i8]* @gsxtmaudiobuffer69 to i8*
call i32 (i8*, ...) @printf(i8* %var1250)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1251 = bitcast [70 x i8]* @gsxtmaudiobuffer69 to i8*
call i32 (i8*, ...) @printf(i8* %var1251)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%result = call ccc float @AudioBuffer_peek(%AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc float @AudioBuffer_peek_looped(%AudioBuffer* %ab, i64 %chan) nounwind inlinehint {
entry:
%zone1253 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1253 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr


%tzone1256 = load i8*, i8** %_impzPtr
%zone1257 = bitcast i8* %tzone1256 to %mzone*

; let assign value to symbol ph
%phPtr = alloca i64
%val1254 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1255 = call ccc i64 @AudioBuffer_playhead(%AudioBuffer* %val1254)

; let value assignment
%ph = select i1 true, i64 %res1255, i64 %res1255
store i64 %ph, i64* %phPtr

%val1258 = load i64, i64* %phPtr
%val1259 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1260 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1259)
%val1261 = srem i64 %val1258, %res1260
%val1262 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1263 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1262)
%val1264 = mul i64 %val1261, %res1263
%val1265 = load i64, i64* %chanPtr
%val1266 = add i64 %val1264, %val1265
%val1267 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1268 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val1267)
; pointer ref
%val1269 = getelementptr float, float* %res1268, i64 %val1266
%val1270 = load float, float* %val1269
ret float %val1270
}
@gsxtmaudiobuffer70 = hidden constant [77 x i8] c"AudioBuffer_peek_looped Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_peek_looped_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1272 = bitcast [77 x i8]* @gsxtmaudiobuffer70 to i8*
call i32 (i8*, ...) @printf(i8* %var1272)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1273 = bitcast [77 x i8]* @gsxtmaudiobuffer70 to i8*
call i32 (i8*, ...) @printf(i8* %var1273)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%result = call ccc float @AudioBuffer_peek_looped(%AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


@gsxtmaudiobuffer71 = hidden constant [56 x i8] c"AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd\00"
@gsxtmaudiobuffer72 = hidden constant [52 x i8] c"{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**\00"
define dllexport fastcc float @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd__1274(i8* %_impz,i8* %_impenv, %AudioBuffer* %ab, i64 %chan) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1275 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***}*
%AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**** %AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr_

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr


%tzone1278 = load i8*, i8** %_impzPtr
%zone1279 = bitcast i8* %tzone1278 to %mzone*

; let assign value to symbol ph
%phPtr = alloca i64
%val1276 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1277 = call ccc i64 @AudioBuffer_playhead(%AudioBuffer* %val1276)

; let value assignment
%ph = select i1 true, i64 %res1277, i64 %res1277
store i64 %ph, i64* %phPtr

; promote local stack var allocations
%tzone1303 = load i8*, i8** %_impzPtr
%zone1304 = bitcast i8* %tzone1303 to %mzone*
%ifptr1285 = alloca i64
%val1281 = load i64, i64* %phPtr
%val1282 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1283 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1282)
%cmp1284 = icmp slt i64 %val1281, %res1283
br i1 %cmp1284, label %then1280, label %else1280

then1280:
%val1286 = load i64, i64* %chanPtr
%cmp1287 = icmp eq i64 %val1286, 0
br i1 %cmp1287, label %then1285, label %else1285

then1285:
%val1288 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val1289 = load i64, i64* %phPtr
%val1290 = add i64 %val1289, 1
%res1291 = call ccc i64 @AudioBuffer_set_playhead(%AudioBuffer* %val1288, i64 %val1290)
store i64 %res1291, i64* %ifptr1285
br label %ifcont1285

else1285:
br label %ifcont1285

ifcont1285:
%ifres1292 = load i64, i64* %ifptr1285

%val1293 = load i64, i64* %phPtr
%val1294 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1295 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1294)
%val1296 = mul i64 %val1293, %res1295
%val1297 = load i64, i64* %chanPtr
%val1298 = add i64 %val1296, %val1297
%val1299 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1300 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val1299)
; pointer ref
%val1301 = getelementptr float, float* %res1300, i64 %val1298
%val1302 = load float, float* %val1301
ret float %val1302

else1280:
ret float 0x0
}
@gsxtmaudiobuffer73 = hidden constant [109 x i8] c"AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1324 = load i8*, i8** %_impzPtr
%zone1325 = bitcast i8* %tzone1324 to %mzone*

; let assign value to symbol AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd
%dat_AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone1325, i64 8)
%AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr = bitcast i8* %dat_AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***
%tzone1305 = load i8*, i8** %_impzPtr
%zone1306 = bitcast i8* %tzone1305 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1306)
; malloc closure structure
%clsptr1307 = call i8* @llvm_zone_malloc(%mzone* %zone1306, i64 24)
%closure1308 = bitcast i8* %clsptr1307 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*

; malloc environment structure
%envptr1309 = call i8* @llvm_zone_malloc(%mzone* %zone1306, i64 8)
%environment1310 = bitcast i8* %envptr1309 to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***}*

; malloc closure address table
%addytable1311 = call %clsvar* @new_address_table()
%var1312 = bitcast [56 x i8]* @gsxtmaudiobuffer71 to i8*
%var1313 = bitcast [52 x i8]* @gsxtmaudiobuffer72 to i8*
%addytable1314 = call %clsvar* @add_address_table(%mzone* %zone1306, i8* %var1312, i32 0, i8* %var1313, i32 3, %clsvar* %addytable1311)
%address-table1315 = bitcast %clsvar* %addytable1314 to i8*

; insert table, function and environment into closure struct
%closure.table1318 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure1308, i32 0, i32 0
store i8* %address-table1315, i8** %closure.table1318
%closure.env1319 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure1308, i32 0, i32 1
store i8* %envptr1309, i8** %closure.env1319
%closure.func1320 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure1308, i32 0, i32 2
store float (i8*, i8*, %AudioBuffer*, i64)* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd__1274, float (i8*, i8*, %AudioBuffer*, i64)** %closure.func1320
%closure_size1321 = call i64 @llvm_zone_mark_size(%mzone* %zone1306)
call void @llvm_zone_ptr_set_size(i8* %clsptr1307, i64 %closure_size1321)
%wrapper_ptr1322 = call i8* @llvm_zone_malloc(%mzone* %zone1306, i64 8)
%closure_wrapper1323 = bitcast i8* %wrapper_ptr1322 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure1308, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_wrapper1323

; let value assignment
%AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd = select i1 true, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_wrapper1323, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_wrapper1323
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*** %AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd
%tmp_envptr1317 = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***}* %environment1310, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*** %AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**** %tmp_envptr1317


%val1326 = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*** %AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr
ret {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %val1326
}


@AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd(%AudioBuffer* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64)*,  float (i8*, i8*, %AudioBuffer*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc float @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_native(%AudioBuffer* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64)*,  float (i8*, i8*, %AudioBuffer*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc i8*  @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1327 = bitcast [109 x i8]* @gsxtmaudiobuffer73 to i8*
call i32 (i8*, ...) @printf(i8* %var1327)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1328 = bitcast [109 x i8]* @gsxtmaudiobuffer73 to i8*
call i32 (i8*, ...) @printf(i8* %var1328)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64)*,  float (i8*, i8*, %AudioBuffer*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*, i64}*
%arg_p_0 = getelementptr {%AudioBuffer*, i64}, {%AudioBuffer*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
%arg_p_1 = getelementptr {%AudioBuffer*, i64}, {%AudioBuffer*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64)*,  float (i8*, i8*, %AudioBuffer*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer74 = hidden constant [62 x i8] c"AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ\00"
@gsxtmaudiobuffer75 = hidden constant [57 x i8] c"{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**\00"
define dllexport fastcc float @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ__1329(i8* %_impz,i8* %_impenv, %AudioBuffer* %ab, i64 %frame, i64 %chan) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1330 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***}*
%AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**** %AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr_

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%framePtr = alloca i64
store i64 %frame, i64* %framePtr
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr

; promote local stack var allocations
%tzone1353 = load i8*, i8** %_impzPtr
%zone1354 = bitcast i8* %tzone1353 to %mzone*
%ifptr1336 = alloca i64

%val1332 = load i64, i64* %framePtr
%val1333 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1334 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1333)
%cmp1335 = icmp slt i64 %val1332, %res1334
br i1 %cmp1335, label %then1331, label %else1331

then1331:
%val1337 = load i64, i64* %chanPtr
%cmp1338 = icmp eq i64 %val1337, 0
br i1 %cmp1338, label %then1336, label %else1336

then1336:
%val1339 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val1340 = load i64, i64* %framePtr
%res1341 = call ccc i64 @AudioBuffer_set_playhead(%AudioBuffer* %val1339, i64 %val1340)
store i64 %res1341, i64* %ifptr1336
br label %ifcont1336

else1336:
br label %ifcont1336

ifcont1336:
%ifres1342 = load i64, i64* %ifptr1336

%val1343 = load i64, i64* %framePtr
%val1344 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1345 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1344)
%val1346 = mul i64 %val1343, %res1345
%val1347 = load i64, i64* %chanPtr
%val1348 = add i64 %val1346, %val1347
%val1349 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1350 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val1349)
; pointer ref
%val1351 = getelementptr float, float* %res1350, i64 %val1348
%val1352 = load float, float* %val1351
ret float %val1352

else1331:
ret float 0x0
}
@gsxtmaudiobuffer76 = hidden constant [115 x i8] c"AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1374 = load i8*, i8** %_impzPtr
%zone1375 = bitcast i8* %tzone1374 to %mzone*

; let assign value to symbol AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ
%dat_AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1375, i64 8)
%AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr = bitcast i8* %dat_AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***
%tzone1355 = load i8*, i8** %_impzPtr
%zone1356 = bitcast i8* %tzone1355 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1356)
; malloc closure structure
%clsptr1357 = call i8* @llvm_zone_malloc(%mzone* %zone1356, i64 24)
%closure1358 = bitcast i8* %clsptr1357 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*

; malloc environment structure
%envptr1359 = call i8* @llvm_zone_malloc(%mzone* %zone1356, i64 8)
%environment1360 = bitcast i8* %envptr1359 to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***}*

; malloc closure address table
%addytable1361 = call %clsvar* @new_address_table()
%var1362 = bitcast [62 x i8]* @gsxtmaudiobuffer74 to i8*
%var1363 = bitcast [57 x i8]* @gsxtmaudiobuffer75 to i8*
%addytable1364 = call %clsvar* @add_address_table(%mzone* %zone1356, i8* %var1362, i32 0, i8* %var1363, i32 3, %clsvar* %addytable1361)
%address-table1365 = bitcast %clsvar* %addytable1364 to i8*

; insert table, function and environment into closure struct
%closure.table1368 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure1358, i32 0, i32 0
store i8* %address-table1365, i8** %closure.table1368
%closure.env1369 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure1358, i32 0, i32 1
store i8* %envptr1359, i8** %closure.env1369
%closure.func1370 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure1358, i32 0, i32 2
store float (i8*, i8*, %AudioBuffer*, i64, i64)* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ__1329, float (i8*, i8*, %AudioBuffer*, i64, i64)** %closure.func1370
%closure_size1371 = call i64 @llvm_zone_mark_size(%mzone* %zone1356)
call void @llvm_zone_ptr_set_size(i8* %clsptr1357, i64 %closure_size1371)
%wrapper_ptr1372 = call i8* @llvm_zone_malloc(%mzone* %zone1356, i64 8)
%closure_wrapper1373 = bitcast i8* %wrapper_ptr1372 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure1358, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_wrapper1373

; let value assignment
%AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_wrapper1373, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_wrapper1373
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*** %AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ
%tmp_envptr1367 = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***}* %environment1360, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*** %AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**** %tmp_envptr1367


%val1376 = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*** %AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr
ret {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %val1376
}


@AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ(%AudioBuffer* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64, i64)*,  float (i8*, i8*, %AudioBuffer*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1, i64 %arg_2)
ret float %result
}


define dllexport ccc float @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_native(%AudioBuffer* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64, i64)*,  float (i8*, i8*, %AudioBuffer*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1, i64 %arg_2)
ret float %result
}


define dllexport ccc i8*  @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1377 = bitcast [115 x i8]* @gsxtmaudiobuffer76 to i8*
call i32 (i8*, ...) @printf(i8* %var1377)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1378 = bitcast [115 x i8]* @gsxtmaudiobuffer76 to i8*
call i32 (i8*, ...) @printf(i8* %var1378)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1379 = bitcast [115 x i8]* @gsxtmaudiobuffer76 to i8*
call i32 (i8*, ...) @printf(i8* %var1379)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64, i64)*,  float (i8*, i8*, %AudioBuffer*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*, i64, i64}*
%arg_p_0 = getelementptr {%AudioBuffer*, i64, i64}, {%AudioBuffer*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
%arg_p_1 = getelementptr {%AudioBuffer*, i64, i64}, {%AudioBuffer*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {%AudioBuffer*, i64, i64}, {%AudioBuffer*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64, i64)*,  float (i8*, i8*, %AudioBuffer*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer77 = hidden constant [63 x i8] c"AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd\00"
define dllexport fastcc float @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd__1380(i8* %_impz,i8* %_impenv, %AudioBuffer* %ab, i64 %chan) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1381 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***}*
%AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**** %AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr_

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr


%tzone1384 = load i8*, i8** %_impzPtr
%zone1385 = bitcast i8* %tzone1384 to %mzone*

; let assign value to symbol ph
%phPtr = alloca i64
%val1382 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1383 = call ccc i64 @AudioBuffer_playhead(%AudioBuffer* %val1382)

; let value assignment
%ph = select i1 true, i64 %res1383, i64 %res1383
store i64 %ph, i64* %phPtr

; promote local stack var allocations
%tzone1407 = load i8*, i8** %_impzPtr
%zone1408 = bitcast i8* %tzone1407 to %mzone*
%ifptr1386 = alloca i64
%val1387 = load i64, i64* %chanPtr
%cmp1388 = icmp eq i64 %val1387, 0
br i1 %cmp1388, label %then1386, label %else1386

then1386:
%val1389 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val1390 = load i64, i64* %phPtr
%val1391 = add i64 %val1390, 1
%val1392 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1393 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1392)
%val1394 = srem i64 %val1391, %res1393
%res1395 = call ccc i64 @AudioBuffer_set_playhead(%AudioBuffer* %val1389, i64 %val1394)
store i64 %res1395, i64* %ifptr1386
br label %ifcont1386

else1386:
br label %ifcont1386

ifcont1386:
%ifres1396 = load i64, i64* %ifptr1386

%val1397 = load i64, i64* %phPtr
%val1398 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1399 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1398)
%val1400 = mul i64 %val1397, %res1399
%val1401 = load i64, i64* %chanPtr
%val1402 = add i64 %val1400, %val1401
%val1403 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1404 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val1403)
; pointer ref
%val1405 = getelementptr float, float* %res1404, i64 %val1402
%val1406 = load float, float* %val1405
ret float %val1406
}
@gsxtmaudiobuffer78 = hidden constant [116 x i8] c"AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1428 = load i8*, i8** %_impzPtr
%zone1429 = bitcast i8* %tzone1428 to %mzone*

; let assign value to symbol AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd
%dat_AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone1429, i64 8)
%AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr = bitcast i8* %dat_AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***
%tzone1409 = load i8*, i8** %_impzPtr
%zone1410 = bitcast i8* %tzone1409 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1410)
; malloc closure structure
%clsptr1411 = call i8* @llvm_zone_malloc(%mzone* %zone1410, i64 24)
%closure1412 = bitcast i8* %clsptr1411 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*

; malloc environment structure
%envptr1413 = call i8* @llvm_zone_malloc(%mzone* %zone1410, i64 8)
%environment1414 = bitcast i8* %envptr1413 to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***}*

; malloc closure address table
%addytable1415 = call %clsvar* @new_address_table()
%var1416 = bitcast [63 x i8]* @gsxtmaudiobuffer77 to i8*
%var1417 = bitcast [52 x i8]* @gsxtmaudiobuffer72 to i8*
%addytable1418 = call %clsvar* @add_address_table(%mzone* %zone1410, i8* %var1416, i32 0, i8* %var1417, i32 3, %clsvar* %addytable1415)
%address-table1419 = bitcast %clsvar* %addytable1418 to i8*

; insert table, function and environment into closure struct
%closure.table1422 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure1412, i32 0, i32 0
store i8* %address-table1419, i8** %closure.table1422
%closure.env1423 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure1412, i32 0, i32 1
store i8* %envptr1413, i8** %closure.env1423
%closure.func1424 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure1412, i32 0, i32 2
store float (i8*, i8*, %AudioBuffer*, i64)* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd__1380, float (i8*, i8*, %AudioBuffer*, i64)** %closure.func1424
%closure_size1425 = call i64 @llvm_zone_mark_size(%mzone* %zone1410)
call void @llvm_zone_ptr_set_size(i8* %clsptr1411, i64 %closure_size1425)
%wrapper_ptr1426 = call i8* @llvm_zone_malloc(%mzone* %zone1410, i64 8)
%closure_wrapper1427 = bitcast i8* %wrapper_ptr1426 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure1412, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_wrapper1427

; let value assignment
%AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd = select i1 true, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_wrapper1427, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_wrapper1427
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*** %AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd
%tmp_envptr1421 = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}***}* %environment1414, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*** %AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**** %tmp_envptr1421


%val1430 = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*** %AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRdPtr
ret {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %val1430
}


@AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd(%AudioBuffer* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64)*,  float (i8*, i8*, %AudioBuffer*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc float @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_native(%AudioBuffer* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64)*,  float (i8*, i8*, %AudioBuffer*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1)
ret float %result
}


define dllexport ccc i8*  @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1431 = bitcast [116 x i8]* @gsxtmaudiobuffer78 to i8*
call i32 (i8*, ...) @printf(i8* %var1431)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1432 = bitcast [116 x i8]* @gsxtmaudiobuffer78 to i8*
call i32 (i8*, ...) @printf(i8* %var1432)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64)*,  float (i8*, i8*, %AudioBuffer*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*, i64}*
%arg_p_0 = getelementptr {%AudioBuffer*, i64}, {%AudioBuffer*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
%arg_p_1 = getelementptr {%AudioBuffer*, i64}, {%AudioBuffer*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64)*,  float (i8*, i8*, %AudioBuffer*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer79 = hidden constant [69 x i8] c"AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ\00"
define dllexport fastcc float @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ__1433(i8* %_impz,i8* %_impenv, %AudioBuffer* %ab, i64 %frame, i64 %chan) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1434 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***}*
%AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**** %AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr_

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%framePtr = alloca i64
store i64 %frame, i64* %framePtr
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr

; promote local stack var allocations
%tzone1460 = load i8*, i8** %_impzPtr
%zone1461 = bitcast i8* %tzone1460 to %mzone*
%ifptr1435 = alloca i64

%val1436 = load i64, i64* %chanPtr
%cmp1437 = icmp eq i64 %val1436, 0
br i1 %cmp1437, label %then1435, label %else1435

then1435:
%val1438 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val1439 = load i64, i64* %framePtr
%val1440 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1441 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1440)
%val1442 = srem i64 %val1439, %res1441
%res1443 = call ccc i64 @AudioBuffer_set_playhead(%AudioBuffer* %val1438, i64 %val1442)
store i64 %res1443, i64* %ifptr1435
br label %ifcont1435

else1435:
br label %ifcont1435

ifcont1435:
%ifres1444 = load i64, i64* %ifptr1435

%val1446 = load i64, i64* %framePtr
%val1447 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1448 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1447)
%cmp1449 = icmp sgt i64 %val1446, %res1448
br i1 %cmp1449, label %then1445, label %else1445

then1445:
ret float 0x0

else1445:
%val1450 = load i64, i64* %framePtr
%val1451 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1452 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1451)
%val1453 = mul i64 %val1450, %res1452
%val1454 = load i64, i64* %chanPtr
%val1455 = add i64 %val1453, %val1454
%val1456 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1457 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val1456)
; pointer ref
%val1458 = getelementptr float, float* %res1457, i64 %val1455
%val1459 = load float, float* %val1458
ret float %val1459
}
@gsxtmaudiobuffer80 = hidden constant [122 x i8] c"AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1481 = load i8*, i8** %_impzPtr
%zone1482 = bitcast i8* %tzone1481 to %mzone*

; let assign value to symbol AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ
%dat_AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1482, i64 8)
%AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr = bitcast i8* %dat_AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***
%tzone1462 = load i8*, i8** %_impzPtr
%zone1463 = bitcast i8* %tzone1462 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1463)
; malloc closure structure
%clsptr1464 = call i8* @llvm_zone_malloc(%mzone* %zone1463, i64 24)
%closure1465 = bitcast i8* %clsptr1464 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*

; malloc environment structure
%envptr1466 = call i8* @llvm_zone_malloc(%mzone* %zone1463, i64 8)
%environment1467 = bitcast i8* %envptr1466 to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***}*

; malloc closure address table
%addytable1468 = call %clsvar* @new_address_table()
%var1469 = bitcast [69 x i8]* @gsxtmaudiobuffer79 to i8*
%var1470 = bitcast [57 x i8]* @gsxtmaudiobuffer75 to i8*
%addytable1471 = call %clsvar* @add_address_table(%mzone* %zone1463, i8* %var1469, i32 0, i8* %var1470, i32 3, %clsvar* %addytable1468)
%address-table1472 = bitcast %clsvar* %addytable1471 to i8*

; insert table, function and environment into closure struct
%closure.table1475 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure1465, i32 0, i32 0
store i8* %address-table1472, i8** %closure.table1475
%closure.env1476 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure1465, i32 0, i32 1
store i8* %envptr1466, i8** %closure.env1476
%closure.func1477 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure1465, i32 0, i32 2
store float (i8*, i8*, %AudioBuffer*, i64, i64)* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ__1433, float (i8*, i8*, %AudioBuffer*, i64, i64)** %closure.func1477
%closure_size1478 = call i64 @llvm_zone_mark_size(%mzone* %zone1463)
call void @llvm_zone_ptr_set_size(i8* %clsptr1464, i64 %closure_size1478)
%wrapper_ptr1479 = call i8* @llvm_zone_malloc(%mzone* %zone1463, i64 8)
%closure_wrapper1480 = bitcast i8* %wrapper_ptr1479 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure1465, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_wrapper1480

; let value assignment
%AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_wrapper1480, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_wrapper1480
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*** %AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ
%tmp_envptr1474 = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}***}* %environment1467, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*** %AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**** %tmp_envptr1474


%val1483 = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*** %AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQPtr
ret {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %val1483
}


@AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ(%AudioBuffer* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64, i64)*,  float (i8*, i8*, %AudioBuffer*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1, i64 %arg_2)
ret float %result
}


define dllexport ccc float @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_native(%AudioBuffer* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64, i64)*,  float (i8*, i8*, %AudioBuffer*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1, i64 %arg_2)
ret float %result
}


define dllexport ccc i8*  @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1484 = bitcast [122 x i8]* @gsxtmaudiobuffer80 to i8*
call i32 (i8*, ...) @printf(i8* %var1484)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1485 = bitcast [122 x i8]* @gsxtmaudiobuffer80 to i8*
call i32 (i8*, ...) @printf(i8* %var1485)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1486 = bitcast [122 x i8]* @gsxtmaudiobuffer80 to i8*
call i32 (i8*, ...) @printf(i8* %var1486)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64, i64)*,  float (i8*, i8*, %AudioBuffer*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*, i64, i64}*
%arg_p_0 = getelementptr {%AudioBuffer*, i64, i64}, {%AudioBuffer*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
%arg_p_1 = getelementptr {%AudioBuffer*, i64, i64}, {%AudioBuffer*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {%AudioBuffer*, i64, i64}, {%AudioBuffer*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, i64, i64)*,  float (i8*, i8*, %AudioBuffer*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


define dllexport ccc float* @AudioBuffer_ptr(%AudioBuffer* %ab, i64 %frame, i64 %chan) nounwind inlinehint {
entry:
%zone1488 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone1488 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%framePtr = alloca i64
store i64 %frame, i64* %framePtr
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr

; promote local stack var allocations
%tzone1521 = load i8*, i8** %_impzPtr
%zone1522 = bitcast i8* %tzone1521 to %mzone*
%ifptr1489 = alloca i64

%val1490 = load i64, i64* %framePtr
%cmp1491 = icmp slt i64 %val1490, 0
br i1 %cmp1491, label %then1489, label %else1489

then1489:
; do set!
%val1492 = load i64, i64* %framePtr
%res1493 = call ccc i64 @llabs(i64 %val1492)
store i64 %res1493, i64* %framePtr
store i64 %res1493, i64* %ifptr1489
br label %ifcont1489

else1489:
br label %ifcont1489

ifcont1489:
%ifres1494 = load i64, i64* %ifptr1489

%val1496 = load i64, i64* %framePtr
%val1497 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1498 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1497)
%cmp1499 = icmp slt i64 %val1496, %res1498
br i1 %cmp1499, label %then1495, label %else1495

then1495:
%val1500 = load i64, i64* %framePtr
%val1501 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1502 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1501)
%val1503 = mul i64 %val1500, %res1502
%val1504 = load i64, i64* %chanPtr
%val1505 = add i64 %val1503, %val1504
%val1506 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1507 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val1506)
; pointer ref
%val1508 = getelementptr float, float* %res1507, i64 %val1505
ret float* %val1508

else1495:
%val1509 = load i64, i64* %framePtr
%val1510 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1511 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1510)
%val1512 = srem i64 %val1509, %res1511
%val1513 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1514 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1513)
%val1515 = mul i64 %val1512, %res1514
%val1516 = load i64, i64* %chanPtr
%val1517 = add i64 %val1515, %val1516
%val1518 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res1519 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val1518)
; pointer ref
%val1520 = getelementptr float, float* %res1519, i64 %val1517
ret float* %val1520
}
@gsxtmaudiobuffer81 = hidden constant [69 x i8] c"AudioBuffer_ptr Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @AudioBuffer_ptr_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1524 = bitcast [69 x i8]* @gsxtmaudiobuffer81 to i8*
call i32 (i8*, ...) @printf(i8* %var1524)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1525 = bitcast [69 x i8]* @gsxtmaudiobuffer81 to i8*
call i32 (i8*, ...) @printf(i8* %var1525)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1526 = bitcast [69 x i8]* @gsxtmaudiobuffer81 to i8*
call i32 (i8*, ...) @printf(i8* %var1526)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%result = call ccc float* @AudioBuffer_ptr(%AudioBuffer* %arg_0, i64 %arg_1, i64 %arg_2)
%tmpres = bitcast float* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


@gsxtmaudiobuffer82 = hidden constant [71 x i8] c"AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd\00"
@gsxtmaudiobuffer83 = hidden constant [59 x i8] c"{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}**\00"
define dllexport fastcc float @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd__1527(i8* %_impz,i8* %_impenv, %AudioBuffer* %buffer, float %freq, i64 %chan) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1528 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}***}*
%AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRdPtr = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}***, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}**** %AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRdPtr_

; setup arguments
%bufferPtr = alloca %AudioBuffer*
store %AudioBuffer* %buffer, %AudioBuffer** %bufferPtr
%freqPtr = alloca float
store float %freq, float* %freqPtr
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr

; promote local stack var allocations
%tzone1732 = load i8*, i8** %_impzPtr
%zone1733 = bitcast i8* %tzone1732 to %mzone*
%ifptr1603 = alloca i64
%ifptr1612 = alloca i64
%ifptr1574 = alloca i64
%ifptr1580 = alloca i64
%ifptr1589 = alloca i64
%ifptr1549 = alloca i64

%tzone1531 = load i8*, i8** %_impzPtr
%zone1532 = bitcast i8* %tzone1531 to %mzone*

; let assign value to symbol channels
%channelsPtr = alloca i64
%tzone1535 = load i8*, i8** %_impzPtr
%zone1536 = bitcast i8* %tzone1535 to %mzone*

; let assign value to symbol frames
%framesPtr = alloca i64
%tzone1539 = load i8*, i8** %_impzPtr
%zone1540 = bitcast i8* %tzone1539 to %mzone*

; let assign value to symbol looplgth
%looplgthPtr = alloca i64
%tzone1543 = load i8*, i8** %_impzPtr
%zone1544 = bitcast i8* %tzone1543 to %mzone*

; let assign value to symbol loopstart
%loopstartPtr = alloca i64
%tzone1547 = load i8*, i8** %_impzPtr
%zone1548 = bitcast i8* %tzone1547 to %mzone*

; let assign value to symbol oneshot
%oneshotPtr = alloca i1
%tzone1555 = load i8*, i8** %_impzPtr
%zone1556 = bitcast i8* %tzone1555 to %mzone*

; let assign value to symbol segments
%segmentsPtr = alloca i64
%tzone1559 = load i8*, i8** %_impzPtr
%zone1560 = bitcast i8* %tzone1559 to %mzone*

; let assign value to symbol phase
%phasePtr = alloca double
%tzone1569 = load i8*, i8** %_impzPtr
%zone1570 = bitcast i8* %tzone1569 to %mzone*

; let assign value to symbol rate
%ratePtr = alloca double
%tzone1572 = load i8*, i8** %_impzPtr
%zone1573 = bitcast i8* %tzone1572 to %mzone*

; let assign value to symbol pos
%posPtr = alloca double
%tzone1596 = load i8*, i8** %_impzPtr
%zone1597 = bitcast i8* %tzone1596 to %mzone*

; let assign value to symbol lgth
%lgthPtr = alloca i64
%tzone1600 = load i8*, i8** %_impzPtr
%zone1601 = bitcast i8* %tzone1600 to %mzone*

; let assign value to symbol lgthf
%lgthfPtr = alloca double
%tzone1620 = load i8*, i8** %_impzPtr
%zone1621 = bitcast i8* %tzone1620 to %mzone*

; let assign value to symbol dat
%datPtr = alloca float*
%tzone1622 = load i8*, i8** %_impzPtr
%zone1623 = bitcast i8* %tzone1622 to %mzone*

; let assign value to symbol y1
%y1Ptr = alloca float
%tzone1633 = load i8*, i8** %_impzPtr
%zone1634 = bitcast i8* %tzone1633 to %mzone*

; let assign value to symbol y1pos
%y1posPtr = alloca i64
%tzone1635 = load i8*, i8** %_impzPtr
%zone1636 = bitcast i8* %tzone1635 to %mzone*

; let assign value to symbol x0
%x0Ptr = alloca float
%tzone1642 = load i8*, i8** %_impzPtr
%zone1643 = bitcast i8* %tzone1642 to %mzone*

; let assign value to symbol x0pos
%x0posPtr = alloca i64
%tzone1644 = load i8*, i8** %_impzPtr
%zone1645 = bitcast i8* %tzone1644 to %mzone*

; let assign value to symbol x1
%x1Ptr = alloca float
%tzone1655 = load i8*, i8** %_impzPtr
%zone1656 = bitcast i8* %tzone1655 to %mzone*

; let assign value to symbol x1pos
%x1posPtr = alloca i64
%tzone1657 = load i8*, i8** %_impzPtr
%zone1658 = bitcast i8* %tzone1657 to %mzone*

; let assign value to symbol x2
%x2Ptr = alloca float
%tzone1670 = load i8*, i8** %_impzPtr
%zone1671 = bitcast i8* %tzone1670 to %mzone*

; let assign value to symbol x2pos
%x2posPtr = alloca i64
%val1529 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res1530 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1529)

; let value assignment
%channels = select i1 true, i64 %res1530, i64 %res1530
store i64 %channels, i64* %channelsPtr

%val1533 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res1534 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1533)

; let value assignment
%frames = select i1 true, i64 %res1534, i64 %res1534
store i64 %frames, i64* %framesPtr

%val1537 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res1538 = call ccc i64 @AudioBuffer_loop_frames(%AudioBuffer* %val1537)

; let value assignment
%looplgth = select i1 true, i64 %res1538, i64 %res1538
store i64 %looplgth, i64* %looplgthPtr

%val1541 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res1542 = call ccc i64 @AudioBuffer_loop_start(%AudioBuffer* %val1541)

; let value assignment
%loopstart = select i1 true, i64 %res1542, i64 %res1542
store i64 %loopstart, i64* %loopstartPtr

%val1545 = load i64, i64* %looplgthPtr
%cmp1546 = icmp eq i64 %val1545, 0

; let value assignment
%oneshot = select i1 true, i1 %cmp1546, i1 %cmp1546
store i1 %oneshot, i1* %oneshotPtr

%val1550 = load i1, i1* %oneshotPtr
br i1 %val1550, label %then1549, label %else1549

then1549:
store i64 0, i64* %ifptr1549
br label %ifcont1549

else1549:
%val1551 = load i64, i64* %framesPtr
%val1552 = load i64, i64* %looplgthPtr
%val1553 = sdiv i64 %val1551, %val1552
store i64 %val1553, i64* %ifptr1549
br label %ifcont1549

ifcont1549:
%ifres1554 = load i64, i64* %ifptr1549


; let value assignment
%segments = select i1 true, i64 %ifres1554, i64 %ifres1554
store i64 %segments, i64* %segmentsPtr

%val1557 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res1558 = call ccc double @AudioBuffer_phase(%AudioBuffer* %val1557)

; let value assignment
%phase = select i1 true, double %res1558, double %res1558
store double %phase, double* %phasePtr

%val1561 = load float, float* %freqPtr
%val1562 = fpext float %val1561 to double
%val1563 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res1564 = call ccc i64 @AudioBuffer_root_pitch(%AudioBuffer* %val1563)
%val1565 = sitofp i64 %res1564 to float
%res1566 = call ccc float @midi2frq_local(float %val1565)
%val1567 = fpext float %res1566 to double
%val1568 = fdiv double %val1562, %val1567

; let value assignment
%rate = select i1 true, double %val1568, double %val1568
store double %rate, double* %ratePtr

%val1571 = load double, double* %phasePtr

; let value assignment
%pos = select i1 true, double %val1571, double %val1571
store double %pos, double* %posPtr

%val1575 = load i1, i1* %oneshotPtr
br i1 %val1575, label %then1574, label %else1574

then1574:
%val1576 = load i64, i64* %framesPtr
%val1577 = sub i64 %val1576, 1
%val1578 = load i64, i64* %loopstartPtr
%val1579 = sub i64 %val1577, %val1578
store i64 %val1579, i64* %ifptr1574
br label %ifcont1574

else1574:
%val1581 = load i64, i64* %looplgthPtr
%val1582 = load i64, i64* %framesPtr
%val1583 = load i64, i64* %loopstartPtr
%val1584 = sub i64 %val1582, %val1583
%cmp1585 = icmp sgt i64 %val1581, %val1584
br i1 %cmp1585, label %then1580, label %else1580

then1580:
%val1586 = load i64, i64* %framesPtr
%val1587 = load i64, i64* %loopstartPtr
%val1588 = sub i64 %val1586, %val1587
store i64 %val1588, i64* %ifptr1580
br label %ifcont1580

else1580:
%val1590 = load i64, i64* %looplgthPtr
%cmp1591 = icmp slt i64 %val1590, 0
br i1 %cmp1591, label %then1589, label %else1589

then1589:
store i64 0, i64* %ifptr1589
br label %ifcont1589

else1589:
%val1592 = load i64, i64* %looplgthPtr
store i64 %val1592, i64* %ifptr1589
br label %ifcont1589

ifcont1589:
%ifres1593 = load i64, i64* %ifptr1589

store i64 %ifres1593, i64* %ifptr1580
br label %ifcont1580

ifcont1580:
%ifres1594 = load i64, i64* %ifptr1580

store i64 %ifres1594, i64* %ifptr1574
br label %ifcont1574

ifcont1574:
%ifres1595 = load i64, i64* %ifptr1574


; let value assignment
%lgth = select i1 true, i64 %ifres1595, i64 %ifres1595
store i64 %lgth, i64* %lgthPtr

%val1598 = load i64, i64* %lgthPtr
%val1599 = sitofp i64 %val1598 to double

; let value assignment
%lgthf = select i1 true, double %val1599, double %val1599
store double %lgthf, double* %lgthfPtr

%val1602 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%val1604 = load i64, i64* %loopstartPtr
%val1605 = load i64, i64* %framesPtr
%val1606 = load i64, i64* %looplgthPtr
%val1607 = sub i64 %val1605, %val1606
%cmp1608 = icmp sgt i64 %val1604, %val1607
br i1 %cmp1608, label %then1603, label %else1603

then1603:
%val1609 = load i64, i64* %framesPtr
%val1610 = load i64, i64* %looplgthPtr
%val1611 = sub i64 %val1609, %val1610
store i64 %val1611, i64* %ifptr1603
br label %ifcont1603

else1603:
%val1613 = load i64, i64* %loopstartPtr
%cmp1614 = icmp slt i64 %val1613, 0
br i1 %cmp1614, label %then1612, label %else1612

then1612:
store i64 0, i64* %ifptr1612
br label %ifcont1612

else1612:
%val1615 = load i64, i64* %loopstartPtr
store i64 %val1615, i64* %ifptr1612
br label %ifcont1612

ifcont1612:
%ifres1616 = load i64, i64* %ifptr1612

store i64 %ifres1616, i64* %ifptr1603
br label %ifcont1603

ifcont1603:
%ifres1617 = load i64, i64* %ifptr1603

%val1618 = load i64, i64* %chanPtr
%res1619 = call ccc float* @AudioBuffer_ptr(%AudioBuffer* %val1602, i64 %ifres1617, i64 %val1618)

; let value assignment
%dat = select i1 true, float* %res1619, float* %res1619
store float* %dat, float** %datPtr


; let value assignment
%y1 = select i1 true, float 0x0, float 0x0
store float %y1, float* %y1Ptr

%val1624 = load i64, i64* %channelsPtr
%val1625 = load double, double* %posPtr
%val1626 = load double, double* %ratePtr
%val1627 = fsub double %val1625, %val1626
%val1628 = load double, double* %lgthfPtr
%val1629 = frem double %val1627, %val1628
%val1630 = call double @llvm.floor.f64(double %val1629)
%val1631 = fptosi double %val1630 to i64
%val1632 = mul i64 %val1624, %val1631

; let value assignment
%y1pos = select i1 true, i64 %val1632, i64 %val1632
store i64 %y1pos, i64* %y1posPtr


; let value assignment
%x0 = select i1 true, float 0x0, float 0x0
store float %x0, float* %x0Ptr

%val1637 = load i64, i64* %channelsPtr
%val1638 = load double, double* %posPtr
%val1639 = call double @llvm.floor.f64(double %val1638)
%val1640 = fptosi double %val1639 to i64
%val1641 = mul i64 %val1637, %val1640

; let value assignment
%x0pos = select i1 true, i64 %val1641, i64 %val1641
store i64 %x0pos, i64* %x0posPtr


; let value assignment
%x1 = select i1 true, float 0x0, float 0x0
store float %x1, float* %x1Ptr

%val1646 = load i64, i64* %channelsPtr
%val1647 = load double, double* %posPtr
%val1648 = load double, double* %ratePtr
%val1649 = fadd double %val1647, %val1648
%val1650 = load double, double* %lgthfPtr
%val1651 = frem double %val1649, %val1650
%val1652 = call double @llvm.floor.f64(double %val1651)
%val1653 = fptosi double %val1652 to i64
%val1654 = mul i64 %val1646, %val1653

; let value assignment
%x1pos = select i1 true, i64 %val1654, i64 %val1654
store i64 %x1pos, i64* %x1posPtr


; let value assignment
%x2 = select i1 true, float 0x0, float 0x0
store float %x2, float* %x2Ptr

%val1659 = load i64, i64* %channelsPtr
%val1660 = load double, double* %posPtr
%val1661 = load double, double* %ratePtr
%val1662 = fadd double %val1660, %val1661
%val1663 = load double, double* %ratePtr
%val1664 = fadd double %val1662, %val1663
%val1665 = load double, double* %lgthfPtr
%val1666 = frem double %val1664, %val1665
%val1667 = call double @llvm.floor.f64(double %val1666)
%val1668 = fptosi double %val1667 to i64
%val1669 = mul i64 %val1659, %val1668

; let value assignment
%x2pos = select i1 true, i64 %val1669, i64 %val1669
store i64 %x2pos, i64* %x2posPtr

; promote local stack var allocations
%tzone1730 = load i8*, i8** %_impzPtr
%zone1731 = bitcast i8* %tzone1730 to %mzone*
%ifptr1705 = alloca double
%ifptr1709 = alloca double
%ifptr1676 = alloca float
%ifptr1677 = alloca i1
%ifptr1679 = alloca i1
%val1673 = load double, double* %posPtr
%val1674 = load double, double* %lgthfPtr
%cmp1675 = fcmp ugt double %val1673, %val1674
br i1 %cmp1675, label %then1672, label %else1672

then1672:
ret float 0x0

else1672:
; do set!
%val1678 = load i1, i1* %oneshotPtr
br i1 %val1678, label %then1677, label %else1677

then1677:
%val1680 = load i64, i64* %x0posPtr
%cmp1681 = icmp slt i64 %val1680, 1
br i1 %cmp1681, label %then1679, label %else1679

then1679:
%val1682 = load i64, i64* %x0posPtr
%cmp1683 = icmp slt i64 %val1682, 1
store i1 %cmp1683, i1* %ifptr1679
br label %ifcont1679

else1679:
%res1684 = call ccc i1 @impc_false()
store i1 %res1684, i1* %ifptr1679
br label %ifcont1679

ifcont1679:
%ifres1685 = load i1, i1* %ifptr1679

store i1 %ifres1685, i1* %ifptr1677
br label %ifcont1677

else1677:
%res1686 = call ccc i1 @impc_false()
store i1 %res1686, i1* %ifptr1677
br label %ifcont1677

ifcont1677:
%ifres1687 = load i1, i1* %ifptr1677

br i1 %ifres1687, label %then1676, label %else1676

then1676:
store float 0x0, float* %ifptr1676
br label %ifcont1676

else1676:
%val1688 = load i64, i64* %y1posPtr
%val1689 = load float*, float** %datPtr
; pointer ref
%val1690 = getelementptr float, float* %val1689, i64 %val1688
%val1691 = load float, float* %val1690
store float %val1691, float* %ifptr1676
br label %ifcont1676

ifcont1676:
%ifres1692 = load float, float* %ifptr1676

store float %ifres1692, float* %y1Ptr
; do set!
%val1693 = load i64, i64* %x0posPtr
%val1694 = load float*, float** %datPtr
; pointer ref
%val1695 = getelementptr float, float* %val1694, i64 %val1693
%val1696 = load float, float* %val1695
store float %val1696, float* %x0Ptr
; do set!
%val1697 = load i64, i64* %x1posPtr
%val1698 = load float*, float** %datPtr
; pointer ref
%val1699 = getelementptr float, float* %val1698, i64 %val1697
%val1700 = load float, float* %val1699
store float %val1700, float* %x1Ptr
; do set!
%val1701 = load i64, i64* %x2posPtr
%val1702 = load float*, float** %datPtr
; pointer ref
%val1703 = getelementptr float, float* %val1702, i64 %val1701
%val1704 = load float, float* %val1703
store float %val1704, float* %x2Ptr
%val1706 = load i64, i64* %chanPtr
%cmp1707 = icmp eq i64 %val1706, 0
br i1 %cmp1707, label %then1705, label %else1705

then1705:
%val1708 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%val1710 = load i1, i1* %oneshotPtr
br i1 %val1710, label %then1709, label %else1709

then1709:
%val1711 = load double, double* %posPtr
%val1712 = load double, double* %ratePtr
%val1713 = fadd double %val1711, %val1712
store double %val1713, double* %ifptr1709
br label %ifcont1709

else1709:
%val1714 = load double, double* %posPtr
%val1715 = load double, double* %ratePtr
%val1716 = fadd double %val1714, %val1715
%val1717 = load double, double* %lgthfPtr
%val1718 = frem double %val1716, %val1717
store double %val1718, double* %ifptr1709
br label %ifcont1709

ifcont1709:
%ifres1719 = load double, double* %ifptr1709

%res1720 = call ccc double @AudioBuffer_set_phase(%AudioBuffer* %val1708, double %ifres1719)
store double %res1720, double* %ifptr1705
br label %ifcont1705

else1705:
br label %ifcont1705

ifcont1705:
%ifres1721 = load double, double* %ifptr1705

%val1722 = load double, double* %posPtr
%val1723 = frem double %val1722, 1.0000000000000000000
%res1724 = call ccc float @dtof(double %val1723)
%val1725 = load float, float* %y1Ptr
%val1726 = load float, float* %x0Ptr
%val1727 = load float, float* %x1Ptr
%val1728 = load float, float* %x2Ptr
%res1729 = call ccc float @hermite_interp_local(float %res1724, float %val1725, float %val1726, float %val1727, float %val1728)
ret float %res1729
}
@gsxtmaudiobuffer84 = hidden constant [124 x i8] c"AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}** @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1753 = load i8*, i8** %_impzPtr
%zone1754 = bitcast i8* %tzone1753 to %mzone*

; let assign value to symbol AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd
%dat_AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone1754, i64 8)
%AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRdPtr = bitcast i8* %dat_AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}***
%tzone1734 = load i8*, i8** %_impzPtr
%zone1735 = bitcast i8* %tzone1734 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1735)
; malloc closure structure
%clsptr1736 = call i8* @llvm_zone_malloc(%mzone* %zone1735, i64 24)
%closure1737 = bitcast i8* %clsptr1736 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}*

; malloc environment structure
%envptr1738 = call i8* @llvm_zone_malloc(%mzone* %zone1735, i64 8)
%environment1739 = bitcast i8* %envptr1738 to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}***}*

; malloc closure address table
%addytable1740 = call %clsvar* @new_address_table()
%var1741 = bitcast [71 x i8]* @gsxtmaudiobuffer82 to i8*
%var1742 = bitcast [59 x i8]* @gsxtmaudiobuffer83 to i8*
%addytable1743 = call %clsvar* @add_address_table(%mzone* %zone1735, i8* %var1741, i32 0, i8* %var1742, i32 3, %clsvar* %addytable1740)
%address-table1744 = bitcast %clsvar* %addytable1743 to i8*

; insert table, function and environment into closure struct
%closure.table1747 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}* %closure1737, i32 0, i32 0
store i8* %address-table1744, i8** %closure.table1747
%closure.env1748 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}* %closure1737, i32 0, i32 1
store i8* %envptr1738, i8** %closure.env1748
%closure.func1749 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}* %closure1737, i32 0, i32 2
store float (i8*, i8*, %AudioBuffer*, float, i64)* @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd__1527, float (i8*, i8*, %AudioBuffer*, float, i64)** %closure.func1749
%closure_size1750 = call i64 @llvm_zone_mark_size(%mzone* %zone1735)
call void @llvm_zone_ptr_set_size(i8* %clsptr1736, i64 %closure_size1750)
%wrapper_ptr1751 = call i8* @llvm_zone_malloc(%mzone* %zone1735, i64 8)
%closure_wrapper1752 = bitcast i8* %wrapper_ptr1751 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}**
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}* %closure1737, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}** %closure_wrapper1752

; let value assignment
%AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd = select i1 true, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}** %closure_wrapper1752, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}** %closure_wrapper1752
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}** %AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}*** %AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRdPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd
%tmp_envptr1746 = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}***}* %environment1739, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}*** %AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRdPtr, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}**** %tmp_envptr1746


%val1755 = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}**, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}*** %AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRdPtr
ret {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}** %val1755
}


@AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}** @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd(%AudioBuffer* %arg_0,float %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, float, i64)*,  float (i8*, i8*, %AudioBuffer*, float, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, float %arg_1, i64 %arg_2)
ret float %result
}


define dllexport ccc float @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_native(%AudioBuffer* %arg_0,float %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, float, i64)*,  float (i8*, i8*, %AudioBuffer*, float, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, float %arg_1, i64 %arg_2)
ret float %result
}


define dllexport ccc i8*  @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1756 = bitcast [124 x i8]* @gsxtmaudiobuffer84 to i8*
call i32 (i8*, ...) @printf(i8* %var1756)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1757 = bitcast [124 x i8]* @gsxtmaudiobuffer84 to i8*
call i32 (i8*, ...) @printf(i8* %var1757)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1758 = bitcast [124 x i8]* @gsxtmaudiobuffer84 to i8*
call i32 (i8*, ...) @printf(i8* %var1758)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, float, i64)*,  float (i8*, i8*, %AudioBuffer*, float, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, float %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*, float, i64}*
%arg_p_0 = getelementptr {%AudioBuffer*, float, i64}, {%AudioBuffer*, float, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
%arg_p_1 = getelementptr {%AudioBuffer*, float, i64}, {%AudioBuffer*, float, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {%AudioBuffer*, float, i64}, {%AudioBuffer*, float, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, float, i64)*,  float (i8*, i8*, %AudioBuffer*, float, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, float %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer85 = hidden constant [82 x i8] c"AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd\00"
@gsxtmaudiobuffer86 = hidden constant [66 x i8] c"{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}**\00"
define dllexport fastcc float @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd__1759(i8* %_impz,i8* %_impenv, %AudioBuffer* %buffer, float %freq, i64 %chan, float %pw) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1760 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}***}*
%AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRdPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRdPtr = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}***, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}**** %AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRdPtr_

; setup arguments
%bufferPtr = alloca %AudioBuffer*
store %AudioBuffer* %buffer, %AudioBuffer** %bufferPtr
%freqPtr = alloca float
store float %freq, float* %freqPtr
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr
%pwPtr = alloca float
store float %pw, float* %pwPtr

; promote local stack var allocations
%tzone2039 = load i8*, i8** %_impzPtr
%zone2040 = bitcast i8* %tzone2039 to %mzone*
%ifptr1808 = alloca i64
%ifptr1814 = alloca i64
%ifptr1823 = alloca i64
%ifptr1783 = alloca i64

; do set!
%val1761 = load float, float* %pwPtr
%val1762 = fmul float %val1761, 0x3fefffffc0000000
store float %val1762, float* %pwPtr
%tzone1765 = load i8*, i8** %_impzPtr
%zone1766 = bitcast i8* %tzone1765 to %mzone*

; let assign value to symbol channels
%channelsPtr = alloca i64
%tzone1769 = load i8*, i8** %_impzPtr
%zone1770 = bitcast i8* %tzone1769 to %mzone*

; let assign value to symbol frames
%framesPtr = alloca i64
%tzone1773 = load i8*, i8** %_impzPtr
%zone1774 = bitcast i8* %tzone1773 to %mzone*

; let assign value to symbol looplgth
%looplgthPtr = alloca i64
%tzone1777 = load i8*, i8** %_impzPtr
%zone1778 = bitcast i8* %tzone1777 to %mzone*

; let assign value to symbol loopstart
%loopstartPtr = alloca i64
%tzone1781 = load i8*, i8** %_impzPtr
%zone1782 = bitcast i8* %tzone1781 to %mzone*

; let assign value to symbol oneshot
%oneshotPtr = alloca i1
%tzone1789 = load i8*, i8** %_impzPtr
%zone1790 = bitcast i8* %tzone1789 to %mzone*

; let assign value to symbol segments
%segmentsPtr = alloca i64
%tzone1793 = load i8*, i8** %_impzPtr
%zone1794 = bitcast i8* %tzone1793 to %mzone*

; let assign value to symbol phase
%phasePtr = alloca double
%tzone1803 = load i8*, i8** %_impzPtr
%zone1804 = bitcast i8* %tzone1803 to %mzone*

; let assign value to symbol rate
%ratePtr = alloca double
%tzone1806 = load i8*, i8** %_impzPtr
%zone1807 = bitcast i8* %tzone1806 to %mzone*

; let assign value to symbol pos
%posPtr = alloca double
%tzone1830 = load i8*, i8** %_impzPtr
%zone1831 = bitcast i8* %tzone1830 to %mzone*

; let assign value to symbol lgth
%lgthPtr = alloca i64
%tzone1834 = load i8*, i8** %_impzPtr
%zone1835 = bitcast i8* %tzone1834 to %mzone*

; let assign value to symbol lgthf
%lgthfPtr = alloca double
%tzone1844 = load i8*, i8** %_impzPtr
%zone1845 = bitcast i8* %tzone1844 to %mzone*

; let assign value to symbol offset
%offsetPtr = alloca i64
%tzone1851 = load i8*, i8** %_impzPtr
%zone1852 = bitcast i8* %tzone1851 to %mzone*

; let assign value to symbol mix
%mixPtr = alloca float
%tzone1857 = load i8*, i8** %_impzPtr
%zone1858 = bitcast i8* %tzone1857 to %mzone*

; let assign value to symbol dat1
%dat1Ptr = alloca float*
%tzone1867 = load i8*, i8** %_impzPtr
%zone1868 = bitcast i8* %tzone1867 to %mzone*

; let assign value to symbol dat2
%dat2Ptr = alloca float*
%tzone1869 = load i8*, i8** %_impzPtr
%zone1870 = bitcast i8* %tzone1869 to %mzone*

; let assign value to symbol dy1
%dy1Ptr = alloca float
%tzone1871 = load i8*, i8** %_impzPtr
%zone1872 = bitcast i8* %tzone1871 to %mzone*

; let assign value to symbol dx0
%dx0Ptr = alloca float
%tzone1873 = load i8*, i8** %_impzPtr
%zone1874 = bitcast i8* %tzone1873 to %mzone*

; let assign value to symbol dx1
%dx1Ptr = alloca float
%tzone1875 = load i8*, i8** %_impzPtr
%zone1876 = bitcast i8* %tzone1875 to %mzone*

; let assign value to symbol dx2
%dx2Ptr = alloca float
%tzone1877 = load i8*, i8** %_impzPtr
%zone1878 = bitcast i8* %tzone1877 to %mzone*

; let assign value to symbol y1
%y1Ptr = alloca float
%tzone1879 = load i8*, i8** %_impzPtr
%zone1880 = bitcast i8* %tzone1879 to %mzone*

; let assign value to symbol x0
%x0Ptr = alloca float
%tzone1881 = load i8*, i8** %_impzPtr
%zone1882 = bitcast i8* %tzone1881 to %mzone*

; let assign value to symbol x1
%x1Ptr = alloca float
%tzone1883 = load i8*, i8** %_impzPtr
%zone1884 = bitcast i8* %tzone1883 to %mzone*

; let assign value to symbol x2
%x2Ptr = alloca float
%tzone1894 = load i8*, i8** %_impzPtr
%zone1895 = bitcast i8* %tzone1894 to %mzone*

; let assign value to symbol y1pos
%y1posPtr = alloca i64
%tzone1901 = load i8*, i8** %_impzPtr
%zone1902 = bitcast i8* %tzone1901 to %mzone*

; let assign value to symbol x0pos
%x0posPtr = alloca i64
%tzone1912 = load i8*, i8** %_impzPtr
%zone1913 = bitcast i8* %tzone1912 to %mzone*

; let assign value to symbol x1pos
%x1posPtr = alloca i64
%tzone1925 = load i8*, i8** %_impzPtr
%zone1926 = bitcast i8* %tzone1925 to %mzone*

; let assign value to symbol x2pos
%x2posPtr = alloca i64
%val1763 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res1764 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val1763)

; let value assignment
%channels = select i1 true, i64 %res1764, i64 %res1764
store i64 %channels, i64* %channelsPtr

%val1767 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res1768 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val1767)

; let value assignment
%frames = select i1 true, i64 %res1768, i64 %res1768
store i64 %frames, i64* %framesPtr

%val1771 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res1772 = call ccc i64 @AudioBuffer_loop_frames(%AudioBuffer* %val1771)

; let value assignment
%looplgth = select i1 true, i64 %res1772, i64 %res1772
store i64 %looplgth, i64* %looplgthPtr

%val1775 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res1776 = call ccc i64 @AudioBuffer_loop_start(%AudioBuffer* %val1775)

; let value assignment
%loopstart = select i1 true, i64 %res1776, i64 %res1776
store i64 %loopstart, i64* %loopstartPtr

%val1779 = load i64, i64* %looplgthPtr
%cmp1780 = icmp eq i64 %val1779, 0

; let value assignment
%oneshot = select i1 true, i1 %cmp1780, i1 %cmp1780
store i1 %oneshot, i1* %oneshotPtr

%val1784 = load i1, i1* %oneshotPtr
br i1 %val1784, label %then1783, label %else1783

then1783:
store i64 0, i64* %ifptr1783
br label %ifcont1783

else1783:
%val1785 = load i64, i64* %framesPtr
%val1786 = load i64, i64* %looplgthPtr
%val1787 = sdiv i64 %val1785, %val1786
store i64 %val1787, i64* %ifptr1783
br label %ifcont1783

ifcont1783:
%ifres1788 = load i64, i64* %ifptr1783


; let value assignment
%segments = select i1 true, i64 %ifres1788, i64 %ifres1788
store i64 %segments, i64* %segmentsPtr

%val1791 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res1792 = call ccc double @AudioBuffer_phase(%AudioBuffer* %val1791)

; let value assignment
%phase = select i1 true, double %res1792, double %res1792
store double %phase, double* %phasePtr

%val1795 = load float, float* %freqPtr
%val1796 = fpext float %val1795 to double
%val1797 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res1798 = call ccc i64 @AudioBuffer_root_pitch(%AudioBuffer* %val1797)
%val1799 = sitofp i64 %res1798 to float
%res1800 = call ccc float @midi2frq_local(float %val1799)
%val1801 = fpext float %res1800 to double
%val1802 = fdiv double %val1796, %val1801

; let value assignment
%rate = select i1 true, double %val1802, double %val1802
store double %rate, double* %ratePtr

%val1805 = load double, double* %phasePtr

; let value assignment
%pos = select i1 true, double %val1805, double %val1805
store double %pos, double* %posPtr

%val1809 = load i1, i1* %oneshotPtr
br i1 %val1809, label %then1808, label %else1808

then1808:
%val1810 = load i64, i64* %framesPtr
%val1811 = sub i64 %val1810, 1
%val1812 = load i64, i64* %loopstartPtr
%val1813 = sub i64 %val1811, %val1812
store i64 %val1813, i64* %ifptr1808
br label %ifcont1808

else1808:
%val1815 = load i64, i64* %looplgthPtr
%val1816 = load i64, i64* %framesPtr
%val1817 = load i64, i64* %loopstartPtr
%val1818 = sub i64 %val1816, %val1817
%cmp1819 = icmp sgt i64 %val1815, %val1818
br i1 %cmp1819, label %then1814, label %else1814

then1814:
%val1820 = load i64, i64* %framesPtr
%val1821 = load i64, i64* %loopstartPtr
%val1822 = sub i64 %val1820, %val1821
store i64 %val1822, i64* %ifptr1814
br label %ifcont1814

else1814:
%val1824 = load i64, i64* %looplgthPtr
%cmp1825 = icmp slt i64 %val1824, 0
br i1 %cmp1825, label %then1823, label %else1823

then1823:
store i64 0, i64* %ifptr1823
br label %ifcont1823

else1823:
%val1826 = load i64, i64* %looplgthPtr
store i64 %val1826, i64* %ifptr1823
br label %ifcont1823

ifcont1823:
%ifres1827 = load i64, i64* %ifptr1823

store i64 %ifres1827, i64* %ifptr1814
br label %ifcont1814

ifcont1814:
%ifres1828 = load i64, i64* %ifptr1814

store i64 %ifres1828, i64* %ifptr1808
br label %ifcont1808

ifcont1808:
%ifres1829 = load i64, i64* %ifptr1808


; let value assignment
%lgth = select i1 true, i64 %ifres1829, i64 %ifres1829
store i64 %lgth, i64* %lgthPtr

%val1832 = load i64, i64* %lgthPtr
%val1833 = sitofp i64 %val1832 to double

; let value assignment
%lgthf = select i1 true, double %val1833, double %val1833
store double %lgthf, double* %lgthfPtr

%val1836 = load float, float* %pwPtr
%val1837 = load i64, i64* %segmentsPtr
%val1838 = sitofp i64 %val1837 to float
%val1839 = fmul float %val1836, %val1838
%val1840 = call float @llvm.floor.f32(float %val1839)
%val1841 = fptosi float %val1840 to i64
%val1842 = load i64, i64* %looplgthPtr
%val1843 = mul i64 %val1841, %val1842

; let value assignment
%offset = select i1 true, i64 %val1843, i64 %val1843
store i64 %offset, i64* %offsetPtr

%val1846 = load float, float* %pwPtr
%val1847 = load i64, i64* %segmentsPtr
%val1848 = sitofp i64 %val1847 to float
%val1849 = fmul float %val1846, %val1848
%val1850 = frem float %val1849, 0x3ff0000000000000

; let value assignment
%mix = select i1 true, float %val1850, float %val1850
store float %mix, float* %mixPtr

%val1853 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%val1854 = load i64, i64* %offsetPtr
%val1855 = load i64, i64* %chanPtr
%res1856 = call ccc float* @AudioBuffer_ptr(%AudioBuffer* %val1853, i64 %val1854, i64 %val1855)

; let value assignment
%dat1 = select i1 true, float* %res1856, float* %res1856
store float* %dat1, float** %dat1Ptr

%val1859 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%val1860 = load i64, i64* %offsetPtr
%val1861 = load i64, i64* %looplgthPtr
%val1862 = add i64 %val1860, %val1861
%val1863 = load i64, i64* %framesPtr
%val1864 = srem i64 %val1862, %val1863
%val1865 = load i64, i64* %chanPtr
%res1866 = call ccc float* @AudioBuffer_ptr(%AudioBuffer* %val1859, i64 %val1864, i64 %val1865)

; let value assignment
%dat2 = select i1 true, float* %res1866, float* %res1866
store float* %dat2, float** %dat2Ptr


; let value assignment
%dy1 = select i1 true, float 0x0, float 0x0
store float %dy1, float* %dy1Ptr


; let value assignment
%dx0 = select i1 true, float 0x0, float 0x0
store float %dx0, float* %dx0Ptr


; let value assignment
%dx1 = select i1 true, float 0x0, float 0x0
store float %dx1, float* %dx1Ptr


; let value assignment
%dx2 = select i1 true, float 0x0, float 0x0
store float %dx2, float* %dx2Ptr


; let value assignment
%y1 = select i1 true, float 0x0, float 0x0
store float %y1, float* %y1Ptr


; let value assignment
%x0 = select i1 true, float 0x0, float 0x0
store float %x0, float* %x0Ptr


; let value assignment
%x1 = select i1 true, float 0x0, float 0x0
store float %x1, float* %x1Ptr


; let value assignment
%x2 = select i1 true, float 0x0, float 0x0
store float %x2, float* %x2Ptr

%val1885 = load i64, i64* %channelsPtr
%val1886 = load double, double* %posPtr
%val1887 = load double, double* %ratePtr
%val1888 = fsub double %val1886, %val1887
%val1889 = load double, double* %lgthfPtr
%val1890 = frem double %val1888, %val1889
%val1891 = call double @llvm.floor.f64(double %val1890)
%val1892 = fptosi double %val1891 to i64
%val1893 = mul i64 %val1885, %val1892

; let value assignment
%y1pos = select i1 true, i64 %val1893, i64 %val1893
store i64 %y1pos, i64* %y1posPtr

%val1896 = load i64, i64* %channelsPtr
%val1897 = load double, double* %posPtr
%val1898 = call double @llvm.floor.f64(double %val1897)
%val1899 = fptosi double %val1898 to i64
%val1900 = mul i64 %val1896, %val1899

; let value assignment
%x0pos = select i1 true, i64 %val1900, i64 %val1900
store i64 %x0pos, i64* %x0posPtr

%val1903 = load i64, i64* %channelsPtr
%val1904 = load double, double* %posPtr
%val1905 = load double, double* %ratePtr
%val1906 = fadd double %val1904, %val1905
%val1907 = load double, double* %lgthfPtr
%val1908 = frem double %val1906, %val1907
%val1909 = call double @llvm.floor.f64(double %val1908)
%val1910 = fptosi double %val1909 to i64
%val1911 = mul i64 %val1903, %val1910

; let value assignment
%x1pos = select i1 true, i64 %val1911, i64 %val1911
store i64 %x1pos, i64* %x1posPtr

%val1914 = load i64, i64* %channelsPtr
%val1915 = load double, double* %posPtr
%val1916 = load double, double* %ratePtr
%val1917 = fadd double %val1915, %val1916
%val1918 = load double, double* %ratePtr
%val1919 = fadd double %val1917, %val1918
%val1920 = load double, double* %lgthfPtr
%val1921 = frem double %val1919, %val1920
%val1922 = call double @llvm.floor.f64(double %val1921)
%val1923 = fptosi double %val1922 to i64
%val1924 = mul i64 %val1914, %val1923

; let value assignment
%x2pos = select i1 true, i64 %val1924, i64 %val1924
store i64 %x2pos, i64* %x2posPtr

; promote local stack var allocations
%tzone2037 = load i8*, i8** %_impzPtr
%zone2038 = bitcast i8* %tzone2037 to %mzone*
%ifptr2012 = alloca double
%ifptr2016 = alloca double
%ifptr1940 = alloca float
%ifptr1941 = alloca i1
%ifptr1943 = alloca i1
%val1928 = load double, double* %posPtr
%val1929 = load double, double* %lgthfPtr
%cmp1930 = fcmp ugt double %val1928, %val1929
br i1 %cmp1930, label %then1927, label %else1927

then1927:
ret float 0x0

else1927:
; do set!
%val1931 = load i64, i64* %y1posPtr
%val1932 = load float*, float** %dat2Ptr
; pointer ref
%val1933 = getelementptr float, float* %val1932, i64 %val1931
%val1934 = load float, float* %val1933
%val1935 = load i64, i64* %y1posPtr
%val1936 = load float*, float** %dat1Ptr
; pointer ref
%val1937 = getelementptr float, float* %val1936, i64 %val1935
%val1938 = load float, float* %val1937
%val1939 = fsub float %val1934, %val1938
store float %val1939, float* %dy1Ptr
; do set!
%val1942 = load i1, i1* %oneshotPtr
br i1 %val1942, label %then1941, label %else1941

then1941:
%val1944 = load i64, i64* %x0posPtr
%cmp1945 = icmp slt i64 %val1944, 1
br i1 %cmp1945, label %then1943, label %else1943

then1943:
%val1946 = load i64, i64* %x0posPtr
%cmp1947 = icmp slt i64 %val1946, 1
store i1 %cmp1947, i1* %ifptr1943
br label %ifcont1943

else1943:
%res1948 = call ccc i1 @impc_false()
store i1 %res1948, i1* %ifptr1943
br label %ifcont1943

ifcont1943:
%ifres1949 = load i1, i1* %ifptr1943

store i1 %ifres1949, i1* %ifptr1941
br label %ifcont1941

else1941:
%res1950 = call ccc i1 @impc_false()
store i1 %res1950, i1* %ifptr1941
br label %ifcont1941

ifcont1941:
%ifres1951 = load i1, i1* %ifptr1941

br i1 %ifres1951, label %then1940, label %else1940

then1940:
store float 0x0, float* %ifptr1940
br label %ifcont1940

else1940:
%val1952 = load i64, i64* %y1posPtr
%val1953 = load float*, float** %dat1Ptr
; pointer ref
%val1954 = getelementptr float, float* %val1953, i64 %val1952
%val1955 = load float, float* %val1954
%val1956 = load float, float* %dy1Ptr
%val1957 = load float, float* %mixPtr
%val1958 = fmul float %val1956, %val1957
%val1959 = fadd float %val1955, %val1958
store float %val1959, float* %ifptr1940
br label %ifcont1940

ifcont1940:
%ifres1960 = load float, float* %ifptr1940

store float %ifres1960, float* %y1Ptr
; do set!
%val1961 = load i64, i64* %x0posPtr
%val1962 = load float*, float** %dat2Ptr
; pointer ref
%val1963 = getelementptr float, float* %val1962, i64 %val1961
%val1964 = load float, float* %val1963
%val1965 = load i64, i64* %x0posPtr
%val1966 = load float*, float** %dat1Ptr
; pointer ref
%val1967 = getelementptr float, float* %val1966, i64 %val1965
%val1968 = load float, float* %val1967
%val1969 = fsub float %val1964, %val1968
store float %val1969, float* %dx0Ptr
; do set!
%val1970 = load i64, i64* %x0posPtr
%val1971 = load float*, float** %dat1Ptr
; pointer ref
%val1972 = getelementptr float, float* %val1971, i64 %val1970
%val1973 = load float, float* %val1972
%val1974 = load float, float* %dx0Ptr
%val1975 = load float, float* %mixPtr
%val1976 = fmul float %val1974, %val1975
%val1977 = fadd float %val1973, %val1976
store float %val1977, float* %x0Ptr
; do set!
%val1978 = load i64, i64* %x1posPtr
%val1979 = load float*, float** %dat2Ptr
; pointer ref
%val1980 = getelementptr float, float* %val1979, i64 %val1978
%val1981 = load float, float* %val1980
%val1982 = load i64, i64* %x1posPtr
%val1983 = load float*, float** %dat1Ptr
; pointer ref
%val1984 = getelementptr float, float* %val1983, i64 %val1982
%val1985 = load float, float* %val1984
%val1986 = fsub float %val1981, %val1985
store float %val1986, float* %dx1Ptr
; do set!
%val1987 = load i64, i64* %x1posPtr
%val1988 = load float*, float** %dat1Ptr
; pointer ref
%val1989 = getelementptr float, float* %val1988, i64 %val1987
%val1990 = load float, float* %val1989
%val1991 = load float, float* %dx1Ptr
%val1992 = load float, float* %mixPtr
%val1993 = fmul float %val1991, %val1992
%val1994 = fadd float %val1990, %val1993
store float %val1994, float* %x1Ptr
; do set!
%val1995 = load i64, i64* %x2posPtr
%val1996 = load float*, float** %dat2Ptr
; pointer ref
%val1997 = getelementptr float, float* %val1996, i64 %val1995
%val1998 = load float, float* %val1997
%val1999 = load i64, i64* %x2posPtr
%val2000 = load float*, float** %dat1Ptr
; pointer ref
%val2001 = getelementptr float, float* %val2000, i64 %val1999
%val2002 = load float, float* %val2001
%val2003 = fsub float %val1998, %val2002
store float %val2003, float* %dx2Ptr
; do set!
%val2004 = load i64, i64* %x2posPtr
%val2005 = load float*, float** %dat1Ptr
; pointer ref
%val2006 = getelementptr float, float* %val2005, i64 %val2004
%val2007 = load float, float* %val2006
%val2008 = load float, float* %dx2Ptr
%val2009 = load float, float* %mixPtr
%val2010 = fmul float %val2008, %val2009
%val2011 = fadd float %val2007, %val2010
store float %val2011, float* %x2Ptr
%val2013 = load i64, i64* %chanPtr
%cmp2014 = icmp eq i64 %val2013, 0
br i1 %cmp2014, label %then2012, label %else2012

then2012:
%val2015 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%val2017 = load i1, i1* %oneshotPtr
br i1 %val2017, label %then2016, label %else2016

then2016:
%val2018 = load double, double* %posPtr
%val2019 = load double, double* %ratePtr
%val2020 = fadd double %val2018, %val2019
store double %val2020, double* %ifptr2016
br label %ifcont2016

else2016:
%val2021 = load double, double* %posPtr
%val2022 = load double, double* %ratePtr
%val2023 = fadd double %val2021, %val2022
%val2024 = load double, double* %lgthfPtr
%val2025 = frem double %val2023, %val2024
store double %val2025, double* %ifptr2016
br label %ifcont2016

ifcont2016:
%ifres2026 = load double, double* %ifptr2016

%res2027 = call ccc double @AudioBuffer_set_phase(%AudioBuffer* %val2015, double %ifres2026)
store double %res2027, double* %ifptr2012
br label %ifcont2012

else2012:
br label %ifcont2012

ifcont2012:
%ifres2028 = load double, double* %ifptr2012

%val2029 = load double, double* %posPtr
%val2030 = frem double %val2029, 1.0000000000000000000
%res2031 = call ccc float @dtof(double %val2030)
%val2032 = load float, float* %y1Ptr
%val2033 = load float, float* %x0Ptr
%val2034 = load float, float* %x1Ptr
%val2035 = load float, float* %x2Ptr
%res2036 = call ccc float @hermite_interp_local(float %res2031, float %val2032, float %val2033, float %val2034, float %val2035)
ret float %res2036
}
@gsxtmaudiobuffer87 = hidden constant [135 x i8] c"AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}** @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2060 = load i8*, i8** %_impzPtr
%zone2061 = bitcast i8* %tzone2060 to %mzone*

; let assign value to symbol AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd
%dat_AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd = call i8* @llvm_zone_malloc(%mzone* %zone2061, i64 8)
%AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRdPtr = bitcast i8* %dat_AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}***
%tzone2041 = load i8*, i8** %_impzPtr
%zone2042 = bitcast i8* %tzone2041 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2042)
; malloc closure structure
%clsptr2043 = call i8* @llvm_zone_malloc(%mzone* %zone2042, i64 24)
%closure2044 = bitcast i8* %clsptr2043 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}*

; malloc environment structure
%envptr2045 = call i8* @llvm_zone_malloc(%mzone* %zone2042, i64 8)
%environment2046 = bitcast i8* %envptr2045 to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}***}*

; malloc closure address table
%addytable2047 = call %clsvar* @new_address_table()
%var2048 = bitcast [82 x i8]* @gsxtmaudiobuffer85 to i8*
%var2049 = bitcast [66 x i8]* @gsxtmaudiobuffer86 to i8*
%addytable2050 = call %clsvar* @add_address_table(%mzone* %zone2042, i8* %var2048, i32 0, i8* %var2049, i32 3, %clsvar* %addytable2047)
%address-table2051 = bitcast %clsvar* %addytable2050 to i8*

; insert table, function and environment into closure struct
%closure.table2054 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}* %closure2044, i32 0, i32 0
store i8* %address-table2051, i8** %closure.table2054
%closure.env2055 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}* %closure2044, i32 0, i32 1
store i8* %envptr2045, i8** %closure.env2055
%closure.func2056 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}* %closure2044, i32 0, i32 2
store float (i8*, i8*, %AudioBuffer*, float, i64, float)* @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd__1759, float (i8*, i8*, %AudioBuffer*, float, i64, float)** %closure.func2056
%closure_size2057 = call i64 @llvm_zone_mark_size(%mzone* %zone2042)
call void @llvm_zone_ptr_set_size(i8* %clsptr2043, i64 %closure_size2057)
%wrapper_ptr2058 = call i8* @llvm_zone_malloc(%mzone* %zone2042, i64 8)
%closure_wrapper2059 = bitcast i8* %wrapper_ptr2058 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}**
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}* %closure2044, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}** %closure_wrapper2059

; let value assignment
%AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd = select i1 true, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}** %closure_wrapper2059, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}** %closure_wrapper2059
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}** %AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}*** %AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRdPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd
%tmp_envptr2053 = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}***}* %environment2046, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}*** %AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRdPtr, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}**** %tmp_envptr2053


%val2062 = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}**, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}*** %AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRdPtr
ret {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}** %val2062
}


@AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}** @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd(%AudioBuffer* %arg_0,float %arg_1,i64 %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, float, i64, float)*,  float (i8*, i8*, %AudioBuffer*, float, i64, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, float %arg_1, i64 %arg_2, float %arg_3)
ret float %result
}


define dllexport ccc float @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_native(%AudioBuffer* %arg_0,float %arg_1,i64 %arg_2,float %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, float, i64, float)*,  float (i8*, i8*, %AudioBuffer*, float, i64, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, float %arg_1, i64 %arg_2, float %arg_3)
ret float %result
}


define dllexport ccc i8*  @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2063 = bitcast [135 x i8]* @gsxtmaudiobuffer87 to i8*
call i32 (i8*, ...) @printf(i8* %var2063)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_real(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2064 = bitcast [135 x i8]* @gsxtmaudiobuffer87 to i8*
call i32 (i8*, ...) @printf(i8* %var2064)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc float  @r32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2065 = bitcast [135 x i8]* @gsxtmaudiobuffer87 to i8*
call i32 (i8*, ...) @printf(i8* %var2065)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2066 = bitcast [135 x i8]* @gsxtmaudiobuffer87 to i8*
call i32 (i8*, ...) @printf(i8* %var2066)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc float  @r32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, float, i64, float)*,  float (i8*, i8*, %AudioBuffer*, float, i64, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, float %arg_1, i64 %arg_2, float %arg_3)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*, float, i64, float}*
%arg_p_0 = getelementptr {%AudioBuffer*, float, i64, float}, {%AudioBuffer*, float, i64, float}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
%arg_p_1 = getelementptr {%AudioBuffer*, float, i64, float}, {%AudioBuffer*, float, i64, float}* %fstruct, i32 0, i32 1
%arg_1 = load float, float* %arg_p_1
%arg_p_2 = getelementptr {%AudioBuffer*, float, i64, float}, {%AudioBuffer*, float, i64, float}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {%AudioBuffer*, float, i64, float}, {%AudioBuffer*, float, i64, float}* %fstruct, i32 0, i32 3
%arg_3 = load float, float* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_pw_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjQsZmxvYXRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, float, i64, float)*,  float (i8*, i8*, %AudioBuffer*, float, i64, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, float %arg_1, i64 %arg_2, float %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer88 = hidden constant [101 x i8] c"AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ\00"
@gsxtmaudiobuffer89 = hidden constant [81 x i8] c"{i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}**\00"
define dllexport fastcc float @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ__2067(i8* %_impz,i8* %_impenv, %AudioBuffer* %buffer, %AudioBuffer* %buffer2, float %freq, i64 %chan, float %mix) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2068 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}***}*
%AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQPtr_ = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQPtr = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}***, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}**** %AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQPtr_

; setup arguments
%bufferPtr = alloca %AudioBuffer*
store %AudioBuffer* %buffer, %AudioBuffer** %bufferPtr
%buffer2Ptr = alloca %AudioBuffer*
store %AudioBuffer* %buffer2, %AudioBuffer** %buffer2Ptr
%freqPtr = alloca float
store float %freq, float* %freqPtr
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr
%mixPtr = alloca float
store float %mix, float* %mixPtr

; promote local stack var allocations
%tzone2354 = load i8*, i8** %_impzPtr
%zone2355 = bitcast i8* %tzone2354 to %mzone*
%ifptr2163 = alloca i64
%ifptr2172 = alloca i64
%ifptr2143 = alloca i64
%ifptr2152 = alloca i64
%ifptr2114 = alloca i64
%ifptr2120 = alloca i64
%ifptr2129 = alloca i64
%ifptr2089 = alloca i64

%tzone2071 = load i8*, i8** %_impzPtr
%zone2072 = bitcast i8* %tzone2071 to %mzone*

; let assign value to symbol channels
%channelsPtr = alloca i64
%tzone2075 = load i8*, i8** %_impzPtr
%zone2076 = bitcast i8* %tzone2075 to %mzone*

; let assign value to symbol frames
%framesPtr = alloca i64
%tzone2079 = load i8*, i8** %_impzPtr
%zone2080 = bitcast i8* %tzone2079 to %mzone*

; let assign value to symbol looplgth
%looplgthPtr = alloca i64
%tzone2083 = load i8*, i8** %_impzPtr
%zone2084 = bitcast i8* %tzone2083 to %mzone*

; let assign value to symbol loopstart
%loopstartPtr = alloca i64
%tzone2087 = load i8*, i8** %_impzPtr
%zone2088 = bitcast i8* %tzone2087 to %mzone*

; let assign value to symbol oneshot
%oneshotPtr = alloca i1
%tzone2095 = load i8*, i8** %_impzPtr
%zone2096 = bitcast i8* %tzone2095 to %mzone*

; let assign value to symbol segments
%segmentsPtr = alloca i64
%tzone2099 = load i8*, i8** %_impzPtr
%zone2100 = bitcast i8* %tzone2099 to %mzone*

; let assign value to symbol phase
%phasePtr = alloca double
%tzone2109 = load i8*, i8** %_impzPtr
%zone2110 = bitcast i8* %tzone2109 to %mzone*

; let assign value to symbol rate
%ratePtr = alloca double
%tzone2112 = load i8*, i8** %_impzPtr
%zone2113 = bitcast i8* %tzone2112 to %mzone*

; let assign value to symbol pos
%posPtr = alloca double
%tzone2136 = load i8*, i8** %_impzPtr
%zone2137 = bitcast i8* %tzone2136 to %mzone*

; let assign value to symbol lgth
%lgthPtr = alloca i64
%tzone2140 = load i8*, i8** %_impzPtr
%zone2141 = bitcast i8* %tzone2140 to %mzone*

; let assign value to symbol lgthf
%lgthfPtr = alloca double
%tzone2160 = load i8*, i8** %_impzPtr
%zone2161 = bitcast i8* %tzone2160 to %mzone*

; let assign value to symbol dat1
%dat1Ptr = alloca float*
%tzone2180 = load i8*, i8** %_impzPtr
%zone2181 = bitcast i8* %tzone2180 to %mzone*

; let assign value to symbol dat2
%dat2Ptr = alloca float*
%tzone2182 = load i8*, i8** %_impzPtr
%zone2183 = bitcast i8* %tzone2182 to %mzone*

; let assign value to symbol dy1
%dy1Ptr = alloca float
%tzone2184 = load i8*, i8** %_impzPtr
%zone2185 = bitcast i8* %tzone2184 to %mzone*

; let assign value to symbol dx0
%dx0Ptr = alloca float
%tzone2186 = load i8*, i8** %_impzPtr
%zone2187 = bitcast i8* %tzone2186 to %mzone*

; let assign value to symbol dx1
%dx1Ptr = alloca float
%tzone2188 = load i8*, i8** %_impzPtr
%zone2189 = bitcast i8* %tzone2188 to %mzone*

; let assign value to symbol dx2
%dx2Ptr = alloca float
%tzone2190 = load i8*, i8** %_impzPtr
%zone2191 = bitcast i8* %tzone2190 to %mzone*

; let assign value to symbol y1
%y1Ptr = alloca float
%tzone2201 = load i8*, i8** %_impzPtr
%zone2202 = bitcast i8* %tzone2201 to %mzone*

; let assign value to symbol y1pos
%y1posPtr = alloca i64
%tzone2203 = load i8*, i8** %_impzPtr
%zone2204 = bitcast i8* %tzone2203 to %mzone*

; let assign value to symbol x0
%x0Ptr = alloca float
%tzone2210 = load i8*, i8** %_impzPtr
%zone2211 = bitcast i8* %tzone2210 to %mzone*

; let assign value to symbol x0pos
%x0posPtr = alloca i64
%tzone2212 = load i8*, i8** %_impzPtr
%zone2213 = bitcast i8* %tzone2212 to %mzone*

; let assign value to symbol x1
%x1Ptr = alloca float
%tzone2223 = load i8*, i8** %_impzPtr
%zone2224 = bitcast i8* %tzone2223 to %mzone*

; let assign value to symbol x1pos
%x1posPtr = alloca i64
%tzone2225 = load i8*, i8** %_impzPtr
%zone2226 = bitcast i8* %tzone2225 to %mzone*

; let assign value to symbol x2
%x2Ptr = alloca float
%tzone2238 = load i8*, i8** %_impzPtr
%zone2239 = bitcast i8* %tzone2238 to %mzone*

; let assign value to symbol x2pos
%x2posPtr = alloca i64
%val2069 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res2070 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val2069)

; let value assignment
%channels = select i1 true, i64 %res2070, i64 %res2070
store i64 %channels, i64* %channelsPtr

%val2073 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res2074 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val2073)

; let value assignment
%frames = select i1 true, i64 %res2074, i64 %res2074
store i64 %frames, i64* %framesPtr

%val2077 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res2078 = call ccc i64 @AudioBuffer_loop_frames(%AudioBuffer* %val2077)

; let value assignment
%looplgth = select i1 true, i64 %res2078, i64 %res2078
store i64 %looplgth, i64* %looplgthPtr

%val2081 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res2082 = call ccc i64 @AudioBuffer_loop_start(%AudioBuffer* %val2081)

; let value assignment
%loopstart = select i1 true, i64 %res2082, i64 %res2082
store i64 %loopstart, i64* %loopstartPtr

%val2085 = load i64, i64* %looplgthPtr
%cmp2086 = icmp eq i64 %val2085, 0

; let value assignment
%oneshot = select i1 true, i1 %cmp2086, i1 %cmp2086
store i1 %oneshot, i1* %oneshotPtr

%val2090 = load i1, i1* %oneshotPtr
br i1 %val2090, label %then2089, label %else2089

then2089:
store i64 0, i64* %ifptr2089
br label %ifcont2089

else2089:
%val2091 = load i64, i64* %framesPtr
%val2092 = load i64, i64* %looplgthPtr
%val2093 = sdiv i64 %val2091, %val2092
store i64 %val2093, i64* %ifptr2089
br label %ifcont2089

ifcont2089:
%ifres2094 = load i64, i64* %ifptr2089


; let value assignment
%segments = select i1 true, i64 %ifres2094, i64 %ifres2094
store i64 %segments, i64* %segmentsPtr

%val2097 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res2098 = call ccc double @AudioBuffer_phase(%AudioBuffer* %val2097)

; let value assignment
%phase = select i1 true, double %res2098, double %res2098
store double %phase, double* %phasePtr

%val2101 = load float, float* %freqPtr
%val2102 = fpext float %val2101 to double
%val2103 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res2104 = call ccc i64 @AudioBuffer_root_pitch(%AudioBuffer* %val2103)
%val2105 = sitofp i64 %res2104 to float
%res2106 = call ccc float @midi2frq_local(float %val2105)
%val2107 = fpext float %res2106 to double
%val2108 = fdiv double %val2102, %val2107

; let value assignment
%rate = select i1 true, double %val2108, double %val2108
store double %rate, double* %ratePtr

%val2111 = load double, double* %phasePtr

; let value assignment
%pos = select i1 true, double %val2111, double %val2111
store double %pos, double* %posPtr

%val2115 = load i1, i1* %oneshotPtr
br i1 %val2115, label %then2114, label %else2114

then2114:
%val2116 = load i64, i64* %framesPtr
%val2117 = sub i64 %val2116, 1
%val2118 = load i64, i64* %loopstartPtr
%val2119 = sub i64 %val2117, %val2118
store i64 %val2119, i64* %ifptr2114
br label %ifcont2114

else2114:
%val2121 = load i64, i64* %looplgthPtr
%val2122 = load i64, i64* %framesPtr
%val2123 = load i64, i64* %loopstartPtr
%val2124 = sub i64 %val2122, %val2123
%cmp2125 = icmp sgt i64 %val2121, %val2124
br i1 %cmp2125, label %then2120, label %else2120

then2120:
%val2126 = load i64, i64* %framesPtr
%val2127 = load i64, i64* %loopstartPtr
%val2128 = sub i64 %val2126, %val2127
store i64 %val2128, i64* %ifptr2120
br label %ifcont2120

else2120:
%val2130 = load i64, i64* %looplgthPtr
%cmp2131 = icmp slt i64 %val2130, 0
br i1 %cmp2131, label %then2129, label %else2129

then2129:
store i64 0, i64* %ifptr2129
br label %ifcont2129

else2129:
%val2132 = load i64, i64* %looplgthPtr
store i64 %val2132, i64* %ifptr2129
br label %ifcont2129

ifcont2129:
%ifres2133 = load i64, i64* %ifptr2129

store i64 %ifres2133, i64* %ifptr2120
br label %ifcont2120

ifcont2120:
%ifres2134 = load i64, i64* %ifptr2120

store i64 %ifres2134, i64* %ifptr2114
br label %ifcont2114

ifcont2114:
%ifres2135 = load i64, i64* %ifptr2114


; let value assignment
%lgth = select i1 true, i64 %ifres2135, i64 %ifres2135
store i64 %lgth, i64* %lgthPtr

%val2138 = load i64, i64* %lgthPtr
%val2139 = sitofp i64 %val2138 to double

; let value assignment
%lgthf = select i1 true, double %val2139, double %val2139
store double %lgthf, double* %lgthfPtr

%val2142 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%val2144 = load i64, i64* %loopstartPtr
%val2145 = load i64, i64* %framesPtr
%val2146 = load i64, i64* %looplgthPtr
%val2147 = sub i64 %val2145, %val2146
%cmp2148 = icmp sgt i64 %val2144, %val2147
br i1 %cmp2148, label %then2143, label %else2143

then2143:
%val2149 = load i64, i64* %framesPtr
%val2150 = load i64, i64* %looplgthPtr
%val2151 = sub i64 %val2149, %val2150
store i64 %val2151, i64* %ifptr2143
br label %ifcont2143

else2143:
%val2153 = load i64, i64* %loopstartPtr
%cmp2154 = icmp slt i64 %val2153, 0
br i1 %cmp2154, label %then2152, label %else2152

then2152:
store i64 0, i64* %ifptr2152
br label %ifcont2152

else2152:
%val2155 = load i64, i64* %loopstartPtr
store i64 %val2155, i64* %ifptr2152
br label %ifcont2152

ifcont2152:
%ifres2156 = load i64, i64* %ifptr2152

store i64 %ifres2156, i64* %ifptr2143
br label %ifcont2143

ifcont2143:
%ifres2157 = load i64, i64* %ifptr2143

%val2158 = load i64, i64* %chanPtr
%res2159 = call ccc float* @AudioBuffer_ptr(%AudioBuffer* %val2142, i64 %ifres2157, i64 %val2158)

; let value assignment
%dat1 = select i1 true, float* %res2159, float* %res2159
store float* %dat1, float** %dat1Ptr

%val2162 = load %AudioBuffer*, %AudioBuffer** %buffer2Ptr
%val2164 = load i64, i64* %loopstartPtr
%val2165 = load i64, i64* %framesPtr
%val2166 = load i64, i64* %looplgthPtr
%val2167 = sub i64 %val2165, %val2166
%cmp2168 = icmp sgt i64 %val2164, %val2167
br i1 %cmp2168, label %then2163, label %else2163

then2163:
%val2169 = load i64, i64* %framesPtr
%val2170 = load i64, i64* %looplgthPtr
%val2171 = sub i64 %val2169, %val2170
store i64 %val2171, i64* %ifptr2163
br label %ifcont2163

else2163:
%val2173 = load i64, i64* %loopstartPtr
%cmp2174 = icmp slt i64 %val2173, 0
br i1 %cmp2174, label %then2172, label %else2172

then2172:
store i64 0, i64* %ifptr2172
br label %ifcont2172

else2172:
%val2175 = load i64, i64* %loopstartPtr
store i64 %val2175, i64* %ifptr2172
br label %ifcont2172

ifcont2172:
%ifres2176 = load i64, i64* %ifptr2172

store i64 %ifres2176, i64* %ifptr2163
br label %ifcont2163

ifcont2163:
%ifres2177 = load i64, i64* %ifptr2163

%val2178 = load i64, i64* %chanPtr
%res2179 = call ccc float* @AudioBuffer_ptr(%AudioBuffer* %val2162, i64 %ifres2177, i64 %val2178)

; let value assignment
%dat2 = select i1 true, float* %res2179, float* %res2179
store float* %dat2, float** %dat2Ptr


; let value assignment
%dy1 = select i1 true, float 0x0, float 0x0
store float %dy1, float* %dy1Ptr


; let value assignment
%dx0 = select i1 true, float 0x0, float 0x0
store float %dx0, float* %dx0Ptr


; let value assignment
%dx1 = select i1 true, float 0x0, float 0x0
store float %dx1, float* %dx1Ptr


; let value assignment
%dx2 = select i1 true, float 0x0, float 0x0
store float %dx2, float* %dx2Ptr


; let value assignment
%y1 = select i1 true, float 0x0, float 0x0
store float %y1, float* %y1Ptr

%val2192 = load i64, i64* %channelsPtr
%val2193 = load double, double* %posPtr
%val2194 = load double, double* %ratePtr
%val2195 = fsub double %val2193, %val2194
%val2196 = load double, double* %lgthfPtr
%val2197 = frem double %val2195, %val2196
%val2198 = call double @llvm.floor.f64(double %val2197)
%val2199 = fptosi double %val2198 to i64
%val2200 = mul i64 %val2192, %val2199

; let value assignment
%y1pos = select i1 true, i64 %val2200, i64 %val2200
store i64 %y1pos, i64* %y1posPtr


; let value assignment
%x0 = select i1 true, float 0x0, float 0x0
store float %x0, float* %x0Ptr

%val2205 = load i64, i64* %channelsPtr
%val2206 = load double, double* %posPtr
%val2207 = call double @llvm.floor.f64(double %val2206)
%val2208 = fptosi double %val2207 to i64
%val2209 = mul i64 %val2205, %val2208

; let value assignment
%x0pos = select i1 true, i64 %val2209, i64 %val2209
store i64 %x0pos, i64* %x0posPtr


; let value assignment
%x1 = select i1 true, float 0x0, float 0x0
store float %x1, float* %x1Ptr

%val2214 = load i64, i64* %channelsPtr
%val2215 = load double, double* %posPtr
%val2216 = load double, double* %ratePtr
%val2217 = fadd double %val2215, %val2216
%val2218 = load double, double* %lgthfPtr
%val2219 = frem double %val2217, %val2218
%val2220 = call double @llvm.floor.f64(double %val2219)
%val2221 = fptosi double %val2220 to i64
%val2222 = mul i64 %val2214, %val2221

; let value assignment
%x1pos = select i1 true, i64 %val2222, i64 %val2222
store i64 %x1pos, i64* %x1posPtr


; let value assignment
%x2 = select i1 true, float 0x0, float 0x0
store float %x2, float* %x2Ptr

%val2227 = load i64, i64* %channelsPtr
%val2228 = load double, double* %posPtr
%val2229 = load double, double* %ratePtr
%val2230 = fadd double %val2228, %val2229
%val2231 = load double, double* %ratePtr
%val2232 = fadd double %val2230, %val2231
%val2233 = load double, double* %lgthfPtr
%val2234 = frem double %val2232, %val2233
%val2235 = call double @llvm.floor.f64(double %val2234)
%val2236 = fptosi double %val2235 to i64
%val2237 = mul i64 %val2227, %val2236

; let value assignment
%x2pos = select i1 true, i64 %val2237, i64 %val2237
store i64 %x2pos, i64* %x2posPtr

; promote local stack var allocations
%tzone2352 = load i8*, i8** %_impzPtr
%zone2353 = bitcast i8* %tzone2352 to %mzone*
%ifptr2327 = alloca double
%ifptr2331 = alloca double
%ifptr2255 = alloca float
%ifptr2256 = alloca i1
%ifptr2258 = alloca i1
; do set!
%val2240 = load float, float* %mixPtr
%val2241 = call float @llvm.fabs.f32(float %val2240)
store float %val2241, float* %mixPtr
%val2243 = load double, double* %posPtr
%val2244 = load double, double* %lgthfPtr
%cmp2245 = fcmp ugt double %val2243, %val2244
br i1 %cmp2245, label %then2242, label %else2242

then2242:
ret float 0x0

else2242:
; do set!
%val2246 = load i64, i64* %y1posPtr
%val2247 = load float*, float** %dat2Ptr
; pointer ref
%val2248 = getelementptr float, float* %val2247, i64 %val2246
%val2249 = load float, float* %val2248
%val2250 = load i64, i64* %y1posPtr
%val2251 = load float*, float** %dat1Ptr
; pointer ref
%val2252 = getelementptr float, float* %val2251, i64 %val2250
%val2253 = load float, float* %val2252
%val2254 = fsub float %val2249, %val2253
store float %val2254, float* %dy1Ptr
; do set!
%val2257 = load i1, i1* %oneshotPtr
br i1 %val2257, label %then2256, label %else2256

then2256:
%val2259 = load i64, i64* %x0posPtr
%cmp2260 = icmp slt i64 %val2259, 1
br i1 %cmp2260, label %then2258, label %else2258

then2258:
%val2261 = load i64, i64* %x0posPtr
%cmp2262 = icmp slt i64 %val2261, 1
store i1 %cmp2262, i1* %ifptr2258
br label %ifcont2258

else2258:
%res2263 = call ccc i1 @impc_false()
store i1 %res2263, i1* %ifptr2258
br label %ifcont2258

ifcont2258:
%ifres2264 = load i1, i1* %ifptr2258

store i1 %ifres2264, i1* %ifptr2256
br label %ifcont2256

else2256:
%res2265 = call ccc i1 @impc_false()
store i1 %res2265, i1* %ifptr2256
br label %ifcont2256

ifcont2256:
%ifres2266 = load i1, i1* %ifptr2256

br i1 %ifres2266, label %then2255, label %else2255

then2255:
store float 0x0, float* %ifptr2255
br label %ifcont2255

else2255:
%val2267 = load i64, i64* %y1posPtr
%val2268 = load float*, float** %dat1Ptr
; pointer ref
%val2269 = getelementptr float, float* %val2268, i64 %val2267
%val2270 = load float, float* %val2269
%val2271 = load float, float* %dy1Ptr
%val2272 = load float, float* %mixPtr
%val2273 = fmul float %val2271, %val2272
%val2274 = fadd float %val2270, %val2273
store float %val2274, float* %ifptr2255
br label %ifcont2255

ifcont2255:
%ifres2275 = load float, float* %ifptr2255

store float %ifres2275, float* %y1Ptr
; do set!
%val2276 = load i64, i64* %x0posPtr
%val2277 = load float*, float** %dat2Ptr
; pointer ref
%val2278 = getelementptr float, float* %val2277, i64 %val2276
%val2279 = load float, float* %val2278
%val2280 = load i64, i64* %x0posPtr
%val2281 = load float*, float** %dat1Ptr
; pointer ref
%val2282 = getelementptr float, float* %val2281, i64 %val2280
%val2283 = load float, float* %val2282
%val2284 = fsub float %val2279, %val2283
store float %val2284, float* %dx0Ptr
; do set!
%val2285 = load i64, i64* %x0posPtr
%val2286 = load float*, float** %dat1Ptr
; pointer ref
%val2287 = getelementptr float, float* %val2286, i64 %val2285
%val2288 = load float, float* %val2287
%val2289 = load float, float* %dx0Ptr
%val2290 = load float, float* %mixPtr
%val2291 = fmul float %val2289, %val2290
%val2292 = fadd float %val2288, %val2291
store float %val2292, float* %x0Ptr
; do set!
%val2293 = load i64, i64* %x1posPtr
%val2294 = load float*, float** %dat2Ptr
; pointer ref
%val2295 = getelementptr float, float* %val2294, i64 %val2293
%val2296 = load float, float* %val2295
%val2297 = load i64, i64* %x1posPtr
%val2298 = load float*, float** %dat1Ptr
; pointer ref
%val2299 = getelementptr float, float* %val2298, i64 %val2297
%val2300 = load float, float* %val2299
%val2301 = fsub float %val2296, %val2300
store float %val2301, float* %dx1Ptr
; do set!
%val2302 = load i64, i64* %x1posPtr
%val2303 = load float*, float** %dat1Ptr
; pointer ref
%val2304 = getelementptr float, float* %val2303, i64 %val2302
%val2305 = load float, float* %val2304
%val2306 = load float, float* %dx1Ptr
%val2307 = load float, float* %mixPtr
%val2308 = fmul float %val2306, %val2307
%val2309 = fadd float %val2305, %val2308
store float %val2309, float* %x1Ptr
; do set!
%val2310 = load i64, i64* %x2posPtr
%val2311 = load float*, float** %dat2Ptr
; pointer ref
%val2312 = getelementptr float, float* %val2311, i64 %val2310
%val2313 = load float, float* %val2312
%val2314 = load i64, i64* %x2posPtr
%val2315 = load float*, float** %dat1Ptr
; pointer ref
%val2316 = getelementptr float, float* %val2315, i64 %val2314
%val2317 = load float, float* %val2316
%val2318 = fsub float %val2313, %val2317
store float %val2318, float* %dx2Ptr
; do set!
%val2319 = load i64, i64* %x2posPtr
%val2320 = load float*, float** %dat1Ptr
; pointer ref
%val2321 = getelementptr float, float* %val2320, i64 %val2319
%val2322 = load float, float* %val2321
%val2323 = load float, float* %dx2Ptr
%val2324 = load float, float* %mixPtr
%val2325 = fmul float %val2323, %val2324
%val2326 = fadd float %val2322, %val2325
store float %val2326, float* %x2Ptr
%val2328 = load i64, i64* %chanPtr
%cmp2329 = icmp eq i64 %val2328, 0
br i1 %cmp2329, label %then2327, label %else2327

then2327:
%val2330 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%val2332 = load i1, i1* %oneshotPtr
br i1 %val2332, label %then2331, label %else2331

then2331:
%val2333 = load double, double* %posPtr
%val2334 = load double, double* %ratePtr
%val2335 = fadd double %val2333, %val2334
store double %val2335, double* %ifptr2331
br label %ifcont2331

else2331:
%val2336 = load double, double* %posPtr
%val2337 = load double, double* %ratePtr
%val2338 = fadd double %val2336, %val2337
%val2339 = load double, double* %lgthfPtr
%val2340 = frem double %val2338, %val2339
store double %val2340, double* %ifptr2331
br label %ifcont2331

ifcont2331:
%ifres2341 = load double, double* %ifptr2331

%res2342 = call ccc double @AudioBuffer_set_phase(%AudioBuffer* %val2330, double %ifres2341)
store double %res2342, double* %ifptr2327
br label %ifcont2327

else2327:
br label %ifcont2327

ifcont2327:
%ifres2343 = load double, double* %ifptr2327

%val2344 = load double, double* %posPtr
%val2345 = frem double %val2344, 1.0000000000000000000
%res2346 = call ccc float @dtof(double %val2345)
%val2347 = load float, float* %y1Ptr
%val2348 = load float, float* %x0Ptr
%val2349 = load float, float* %x1Ptr
%val2350 = load float, float* %x2Ptr
%res2351 = call ccc float @hermite_interp_local(float %res2346, float %val2347, float %val2348, float %val2349, float %val2350)
ret float %res2351
}
@gsxtmaudiobuffer90 = hidden constant [154 x i8] c"AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}** @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2375 = load i8*, i8** %_impzPtr
%zone2376 = bitcast i8* %tzone2375 to %mzone*

; let assign value to symbol AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ
%dat_AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ = call i8* @llvm_zone_malloc(%mzone* %zone2376, i64 8)
%AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQPtr = bitcast i8* %dat_AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}***
%tzone2356 = load i8*, i8** %_impzPtr
%zone2357 = bitcast i8* %tzone2356 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2357)
; malloc closure structure
%clsptr2358 = call i8* @llvm_zone_malloc(%mzone* %zone2357, i64 24)
%closure2359 = bitcast i8* %clsptr2358 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}*

; malloc environment structure
%envptr2360 = call i8* @llvm_zone_malloc(%mzone* %zone2357, i64 8)
%environment2361 = bitcast i8* %envptr2360 to {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}***}*

; malloc closure address table
%addytable2362 = call %clsvar* @new_address_table()
%var2363 = bitcast [101 x i8]* @gsxtmaudiobuffer88 to i8*
%var2364 = bitcast [81 x i8]* @gsxtmaudiobuffer89 to i8*
%addytable2365 = call %clsvar* @add_address_table(%mzone* %zone2357, i8* %var2363, i32 0, i8* %var2364, i32 3, %clsvar* %addytable2362)
%address-table2366 = bitcast %clsvar* %addytable2365 to i8*

; insert table, function and environment into closure struct
%closure.table2369 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}* %closure2359, i32 0, i32 0
store i8* %address-table2366, i8** %closure.table2369
%closure.env2370 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}* %closure2359, i32 0, i32 1
store i8* %envptr2360, i8** %closure.env2370
%closure.func2371 = getelementptr { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}* %closure2359, i32 0, i32 2
store float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)* @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ__2067, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)** %closure.func2371
%closure_size2372 = call i64 @llvm_zone_mark_size(%mzone* %zone2357)
call void @llvm_zone_ptr_set_size(i8* %clsptr2358, i64 %closure_size2372)
%wrapper_ptr2373 = call i8* @llvm_zone_malloc(%mzone* %zone2357, i64 8)
%closure_wrapper2374 = bitcast i8* %wrapper_ptr2373 to { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}**
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}* %closure2359, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}** %closure_wrapper2374

; let value assignment
%AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ = select i1 true, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}** %closure_wrapper2374, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}** %closure_wrapper2374
store { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}** %AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ, { i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}*** %AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ
%tmp_envptr2368 = getelementptr {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}***}, {{i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}***}* %environment2361, i32 0, i32 0
store {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}*** %AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQPtr, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}**** %tmp_envptr2368


%val2377 = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}**, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}*** %AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQPtr
ret {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}** %val2377
}


@AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}** @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc float @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ(%AudioBuffer* %arg_0,%AudioBuffer* %arg_1,float %arg_2,i64 %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*,  float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %AudioBuffer* %arg_1, float %arg_2, i64 %arg_3, float %arg_4)
ret float %result
}


define dllexport ccc float @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_native(%AudioBuffer* %arg_0,%AudioBuffer* %arg_1,float %arg_2,i64 %arg_3,float %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*,  float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %AudioBuffer* %arg_1, float %arg_2, i64 %arg_3, float %arg_4)
ret float %result
}


define dllexport ccc i8*  @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2378 = bitcast [154 x i8]* @gsxtmaudiobuffer90 to i8*
call i32 (i8*, ...) @printf(i8* %var2378)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2379 = bitcast [154 x i8]* @gsxtmaudiobuffer90 to i8*
call i32 (i8*, ...) @printf(i8* %var2379)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %AudioBuffer*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2380 = bitcast [154 x i8]* @gsxtmaudiobuffer90 to i8*
call i32 (i8*, ...) @printf(i8* %var2380)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc float  @r32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2381 = bitcast [154 x i8]* @gsxtmaudiobuffer90 to i8*
call i32 (i8*, ...) @printf(i8* %var2381)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_real(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2382 = bitcast [154 x i8]* @gsxtmaudiobuffer90 to i8*
call i32 (i8*, ...) @printf(i8* %var2382)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc float  @r32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*,  float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %AudioBuffer* %arg_1, float %arg_2, i64 %arg_3, float %arg_4)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*, %AudioBuffer*, float, i64, float}*
%arg_p_0 = getelementptr {%AudioBuffer*, %AudioBuffer*, float, i64, float}, {%AudioBuffer*, %AudioBuffer*, float, i64, float}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
%arg_p_1 = getelementptr {%AudioBuffer*, %AudioBuffer*, float, i64, float}, {%AudioBuffer*, %AudioBuffer*, float, i64, float}* %fstruct, i32 0, i32 1
%arg_1 = load %AudioBuffer*, %AudioBuffer** %arg_p_1
%arg_p_2 = getelementptr {%AudioBuffer*, %AudioBuffer*, float, i64, float}, {%AudioBuffer*, %AudioBuffer*, float, i64, float}* %fstruct, i32 0, i32 2
%arg_2 = load float, float* %arg_p_2
%arg_p_3 = getelementptr {%AudioBuffer*, %AudioBuffer*, float, i64, float}, {%AudioBuffer*, %AudioBuffer*, float, i64, float}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {%AudioBuffer*, %AudioBuffer*, float, i64, float}, {%AudioBuffer*, %AudioBuffer*, float, i64, float}* %fstruct, i32 0, i32 4
%arg_4 = load float, float* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_read_interp_mix_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosZmxvYXQsaTY0LGZsb2F0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}**
%closure = load {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}*, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}, {i8*, i8*, float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*}* %closure, i32 0, i32 1
%ff = load  float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)*,  float (i8*, i8*, %AudioBuffer*, %AudioBuffer*, float, i64, float)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc float %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %AudioBuffer* %arg_1, float %arg_2, i64 %arg_3, float %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


define dllexport ccc i16 @swapi16(i16 %x) nounwind inlinehint {
entry:
%zone2384 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone2384 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%xPtr = alloca i16
store i16 %x, i16* %xPtr


%val2385 = load i16, i16* %xPtr
%val2386 = lshr i16 %val2385, 8
%val2387 = load i16, i16* %xPtr
%val2388 = shl i16 %val2387, 8
%val2389 = or i16 %val2386, %val2388
ret i16 %val2389
}
@gsxtmaudiobuffer91 = hidden constant [61 x i8] c"swapi16 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @swapi16_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2391 = bitcast [61 x i8]* @gsxtmaudiobuffer91 to i8*
call i32 (i8*, ...) @printf(i8* %var2391)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i16  @i16value(i8* %arg_0_val)
%result = call ccc i16 @swapi16(i16 %arg_0)
%res = call ccc i8* @mk_i16(i8* %_sc, i16 %result)
ret i8* %res
}


define dllexport ccc i32 @swapi32(i32 %x) nounwind inlinehint {
entry:
%zone2393 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone2393 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%xPtr = alloca i32
store i32 %x, i32* %xPtr


%val2394 = load i32, i32* %xPtr
%val2395 = lshr i32 %val2394, 24
%val2396 = and i32 %val2395, 255
%val2397 = load i32, i32* %xPtr
%val2398 = shl i32 %val2397, 8
%val2399 = and i32 %val2398, 16711680
%val2400 = or i32 %val2396, %val2399
%val2401 = load i32, i32* %xPtr
%val2402 = lshr i32 %val2401, 8
%val2403 = and i32 %val2402, 65280
%val2404 = load i32, i32* %xPtr
%val2405 = shl i32 %val2404, 24
%val2406 = and i32 %val2405, -16777216
%val2407 = or i32 %val2403, %val2406
%val2408 = or i32 %val2400, %val2407
ret i32 %val2408
}
@gsxtmaudiobuffer92 = hidden constant [61 x i8] c"swapi32 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @swapi32_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2410 = bitcast [61 x i8]* @gsxtmaudiobuffer92 to i8*
call i32 (i8*, ...) @printf(i8* %var2410)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%result = call ccc i32 @swapi32(i32 %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


@gsxtmaudiobuffer93 = hidden constant [45 x i8] c"swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0\00"
@gsxtmaudiobuffer94 = hidden constant [41 x i8] c"{i8*, i8*, void (i8*, i8*, i8*, i64)*}**\00"
define dllexport fastcc void @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0__2411(i8* %_impz,i8* %_impenv, i8* %buf, i64 %nbytes) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2412 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, i64)*}***}*
%swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i64)*}***}* %impenv, i32 0, i32 0
%swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0Ptr = load {i8*, i8*, void (i8*, i8*, i8*, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, i64)*}**** %swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca i8*
store i8* %buf, i8** %bufPtr
%nbytesPtr = alloca i64
store i64 %nbytes, i64* %nbytesPtr


%tzone2413 = load i8*, i8** %_impzPtr
%zone2414 = bitcast i8* %tzone2413 to %mzone*

; let assign value to symbol tmp
%tmpPtr = alloca i8
%tzone2415 = load i8*, i8** %_impzPtr
%zone2416 = bitcast i8* %tzone2415 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64

; let value assignment
%tmp = select i1 true, i8 0, i8 0
store i8 %tmp, i8* %tmpPtr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

; setup loop
%val2420 = load i64, i64* %nbytesPtr
%val2421 = sdiv i64 %val2420, 2
store i64 0, i64* %iPtr
%val2443 = load i64, i64* %iPtr
%num2444 = add i64 %val2421, %val2443
%comp2445 = icmp ult i64 %val2421, 1
br i1 %comp2445, label %after2417, label %loop2417

loop2417:
; do set!
%val2422 = load i64, i64* %iPtr
%val2423 = load i8*, i8** %bufPtr
; pointer ref
%val2424 = getelementptr i8, i8* %val2423, i64 %val2422
%val2425 = load i8, i8* %val2424
store i8 %val2425, i8* %tmpPtr
%val2426 = load i64, i64* %iPtr
%val2427 = load i8*, i8** %bufPtr
%val2428 = load i64, i64* %nbytesPtr
%val2429 = sub i64 %val2428, 1
%val2430 = load i64, i64* %iPtr
%val2431 = sub i64 %val2429, %val2430
%val2432 = load i8*, i8** %bufPtr
; pointer ref
%val2433 = getelementptr i8, i8* %val2432, i64 %val2431
%val2434 = load i8, i8* %val2433
; set pointer
%val2435 = getelementptr i8, i8* %val2427, i64 %val2426
store i8 %val2434, i8* %val2435
%val2436 = load i64, i64* %nbytesPtr
%val2437 = sub i64 %val2436, 1
%val2438 = load i64, i64* %iPtr
%val2439 = sub i64 %val2437, %val2438
%val2440 = load i8*, i8** %bufPtr
%val2441 = load i8, i8* %tmpPtr
; set pointer
%val2442 = getelementptr i8, i8* %val2440, i64 %val2439
store i8 %val2441, i8* %val2442
%loop_cnt2417 = load i64, i64* %iPtr
%next2417 = add i64 %loop_cnt2417, 1
store i64 %next2417, i64* %iPtr
%cmp2417 = icmp ult i64 %next2417, %num2444
br i1 %cmp2417, label %loop2417, label %after2417

after2417:
ret void
}
@gsxtmaudiobuffer95 = hidden constant [98 x i8] c"swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, i64)*}** @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2466 = load i8*, i8** %_impzPtr
%zone2467 = bitcast i8* %tzone2466 to %mzone*

; let assign value to symbol swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0
%dat_swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone2467, i64 8)
%swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0Ptr = bitcast i8* %dat_swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0 to { i8*, i8*, void (i8*, i8*, i8*, i64)*}***
%tzone2447 = load i8*, i8** %_impzPtr
%zone2448 = bitcast i8* %tzone2447 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2448)
; malloc closure structure
%clsptr2449 = call i8* @llvm_zone_malloc(%mzone* %zone2448, i64 24)
%closure2450 = bitcast i8* %clsptr2449 to { i8*, i8*, void (i8*, i8*, i8*, i64)*}*

; malloc environment structure
%envptr2451 = call i8* @llvm_zone_malloc(%mzone* %zone2448, i64 8)
%environment2452 = bitcast i8* %envptr2451 to {{i8*, i8*, void (i8*, i8*, i8*, i64)*}***}*

; malloc closure address table
%addytable2453 = call %clsvar* @new_address_table()
%var2454 = bitcast [45 x i8]* @gsxtmaudiobuffer93 to i8*
%var2455 = bitcast [41 x i8]* @gsxtmaudiobuffer94 to i8*
%addytable2456 = call %clsvar* @add_address_table(%mzone* %zone2448, i8* %var2454, i32 0, i8* %var2455, i32 3, %clsvar* %addytable2453)
%address-table2457 = bitcast %clsvar* %addytable2456 to i8*

; insert table, function and environment into closure struct
%closure.table2460 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, i64)*}* %closure2450, i32 0, i32 0
store i8* %address-table2457, i8** %closure.table2460
%closure.env2461 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, i64)*}* %closure2450, i32 0, i32 1
store i8* %envptr2451, i8** %closure.env2461
%closure.func2462 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, i64)*}* %closure2450, i32 0, i32 2
store void (i8*, i8*, i8*, i64)* @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0__2411, void (i8*, i8*, i8*, i64)** %closure.func2462
%closure_size2463 = call i64 @llvm_zone_mark_size(%mzone* %zone2448)
call void @llvm_zone_ptr_set_size(i8* %clsptr2449, i64 %closure_size2463)
%wrapper_ptr2464 = call i8* @llvm_zone_malloc(%mzone* %zone2448, i64 8)
%closure_wrapper2465 = bitcast i8* %wrapper_ptr2464 to { i8*, i8*, void (i8*, i8*, i8*, i64)*}**
store { i8*, i8*, void (i8*, i8*, i8*, i64)*}* %closure2450, { i8*, i8*, void (i8*, i8*, i8*, i64)*}** %closure_wrapper2465

; let value assignment
%swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, i64)*}** %closure_wrapper2465, { i8*, i8*, void (i8*, i8*, i8*, i64)*}** %closure_wrapper2465
store { i8*, i8*, void (i8*, i8*, i8*, i64)*}** %swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0, { i8*, i8*, void (i8*, i8*, i8*, i64)*}*** %swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0
%tmp_envptr2459 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, i64)*}***}* %environment2452, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, i64)*}*** %swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0Ptr, {i8*, i8*, void (i8*, i8*, i8*, i64)*}**** %tmp_envptr2459


%val2468 = load {i8*, i8*, void (i8*, i8*, i8*, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, i64)*}*** %swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0Ptr
ret {i8*, i8*, void (i8*, i8*, i8*, i64)*}** %val2468
}


@swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, i64)*}** @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0(i8* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i64)*,  void (i8*, i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc void @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_native(i8* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i64)*,  void (i8*, i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i64 %arg_1)
ret void
}


define dllexport ccc i8*  @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2469 = bitcast [98 x i8]* @gsxtmaudiobuffer95 to i8*
call i32 (i8*, ...) @printf(i8* %var2469)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2470 = bitcast [98 x i8]* @gsxtmaudiobuffer95 to i8*
call i32 (i8*, ...) @printf(i8* %var2470)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i64)*,  void (i8*, i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i64}*
%arg_p_0 = getelementptr {i8*, i64}, {i8*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i64}, {i8*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, i64)*,  void (i8*, i8*, i8*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer96 = hidden constant [64 x i8] c"audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd\00"
@gsxtmaudiobuffer97 = hidden constant [49 x i8] c"{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**\00"
define dllexport fastcc void @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd__2471(i8* %_impz,i8* %_impenv, i8* %src, float* %dest, i64 %nsamp) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2472 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}*
%audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr_

; setup arguments
%srcPtr = alloca i8*
store i8* %src, i8** %srcPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr
%nsampPtr = alloca i64
store i64 %nsamp, i64* %nsampPtr


%tzone2474 = load i8*, i8** %_impzPtr
%zone2475 = bitcast i8* %tzone2474 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val2473 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val2473, i64 %val2473
store i64 %i, i64* %iPtr

; setup loop
%val2478 = load i64, i64* %nsampPtr
store i64 0, i64* %iPtr
%val2487 = load i64, i64* %iPtr
%num2488 = add i64 %val2478, %val2487
%comp2489 = icmp ult i64 %val2478, 1
br i1 %comp2489, label %after2476, label %loop2476

loop2476:
%val2479 = load i64, i64* %iPtr
%val2480 = load float*, float** %destPtr
%val2481 = load i64, i64* %iPtr
%val2482 = load i8*, i8** %srcPtr
%val2483 = bitcast i8* %val2482 to float*
; pointer ref
%val2484 = getelementptr float, float* %val2483, i64 %val2481
%val2485 = load float, float* %val2484
; set pointer
%val2486 = getelementptr float, float* %val2480, i64 %val2479
store float %val2485, float* %val2486
%loop_cnt2476 = load i64, i64* %iPtr
%next2476 = add i64 %loop_cnt2476, 1
store i64 %next2476, i64* %iPtr
%cmp2476 = icmp ult i64 %next2476, %num2488
br i1 %cmp2476, label %loop2476, label %after2476

after2476:
ret void
}
@gsxtmaudiobuffer98 = hidden constant [117 x i8] c"audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2510 = load i8*, i8** %_impzPtr
%zone2511 = bitcast i8* %tzone2510 to %mzone*

; let assign value to symbol audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd
%dat_audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone2511, i64 8)
%audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr = bitcast i8* %dat_audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***
%tzone2491 = load i8*, i8** %_impzPtr
%zone2492 = bitcast i8* %tzone2491 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2492)
; malloc closure structure
%clsptr2493 = call i8* @llvm_zone_malloc(%mzone* %zone2492, i64 24)
%closure2494 = bitcast i8* %clsptr2493 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr2495 = call i8* @llvm_zone_malloc(%mzone* %zone2492, i64 8)
%environment2496 = bitcast i8* %envptr2495 to {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable2497 = call %clsvar* @new_address_table()
%var2498 = bitcast [64 x i8]* @gsxtmaudiobuffer96 to i8*
%var2499 = bitcast [49 x i8]* @gsxtmaudiobuffer97 to i8*
%addytable2500 = call %clsvar* @add_address_table(%mzone* %zone2492, i8* %var2498, i32 0, i8* %var2499, i32 3, %clsvar* %addytable2497)
%address-table2501 = bitcast %clsvar* %addytable2500 to i8*

; insert table, function and environment into closure struct
%closure.table2504 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2494, i32 0, i32 0
store i8* %address-table2501, i8** %closure.table2504
%closure.env2505 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2494, i32 0, i32 1
store i8* %envptr2495, i8** %closure.env2505
%closure.func2506 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2494, i32 0, i32 2
store void (i8*, i8*, i8*, float*, i64)* @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd__2471, void (i8*, i8*, i8*, float*, i64)** %closure.func2506
%closure_size2507 = call i64 @llvm_zone_mark_size(%mzone* %zone2492)
call void @llvm_zone_ptr_set_size(i8* %clsptr2493, i64 %closure_size2507)
%wrapper_ptr2508 = call i8* @llvm_zone_malloc(%mzone* %zone2492, i64 8)
%closure_wrapper2509 = bitcast i8* %wrapper_ptr2508 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
store { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2494, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2509

; let value assignment
%audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2509, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2509
store { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr

; add data to environment
; don't need to alloc for env var audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd
%tmp_envptr2503 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2496, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %tmp_envptr2503


%val2512 = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2512
}


@audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd(i8* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_native(i8* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2513 = bitcast [117 x i8]* @gsxtmaudiobuffer98 to i8*
call i32 (i8*, ...) @printf(i8* %var2513)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2514 = bitcast [117 x i8]* @gsxtmaudiobuffer98 to i8*
call i32 (i8*, ...) @printf(i8* %var2514)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2515 = bitcast [117 x i8]* @gsxtmaudiobuffer98 to i8*
call i32 (i8*, ...) @printf(i8* %var2515)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float*, i64}*
%arg_p_0 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer99 = hidden constant [64 x i8] c"audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd\00"
@gsxtmaudiobuffer100 = hidden constant [4 x i8] c"tmp\00"
@gsxtmaudiobuffer101 = hidden constant [5 x i8] c"i32*\00"
@gsxtmaudiobuffer102 = hidden constant [15 x i8] c"_anon_lambda_1\00"
define dllexport fastcc void @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd__2516(i8* %_impz,i8* %_impenv, i8* %src, float* %dest, i64 %nsamp) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2525 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}*
%audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr_
%tmpPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 1
%tmpPtr = load i32**, i32*** %tmpPtr_
%_anon_lambda_1Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_1Ptr = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %_anon_lambda_1Ptr_

; setup arguments
%srcPtr = alloca i8*
store i8* %src, i8** %srcPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr
%nsampPtr = alloca i64
store i64 %nsamp, i64* %nsampPtr


%tzone2527 = load i8*, i8** %_impzPtr
%zone2528 = bitcast i8* %tzone2527 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val2526 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val2526, i64 %val2526
store i64 %i, i64* %iPtr

; setup loop
%val2531 = load i64, i64* %nsampPtr
store i64 0, i64* %iPtr
%val2552 = load i64, i64* %iPtr
%num2553 = add i64 %val2531, %val2552
%comp2554 = icmp ult i64 %val2531, 1
br i1 %comp2554, label %after2529, label %loop2529

loop2529:
%val2532 = load i32*, i32** %tmpPtr
%val2533 = load i64, i64* %iPtr
%val2534 = load i8*, i8** %srcPtr
%val2535 = bitcast i8* %val2534 to i32*
; pointer ref
%val2536 = getelementptr i32, i32* %val2535, i64 %val2533
%val2537 = load i32, i32* %val2536
; set pointer
%val2538 = getelementptr i32, i32* %val2532, i64 0
store i32 %val2537, i32* %val2538
%val2539 = load i32*, i32** %tmpPtr
%val2540 = load i32*, i32** %tmpPtr
; pointer ref
%val2541 = getelementptr i32, i32* %val2540, i64 0
%val2542 = load i32, i32* %val2541
%res2543 = call ccc i32 @swapi32(i32 %val2542)
; set pointer
%val2544 = getelementptr i32, i32* %val2539, i64 0
store i32 %res2543, i32* %val2544
%val2545 = load i64, i64* %iPtr
%val2546 = load float*, float** %destPtr
%val2547 = load i32*, i32** %tmpPtr
%val2548 = bitcast i32* %val2547 to float*
; pointer ref
%val2549 = getelementptr float, float* %val2548, i64 0
%val2550 = load float, float* %val2549
; set pointer
%val2551 = getelementptr float, float* %val2546, i64 %val2545
store float %val2550, float* %val2551
%loop_cnt2529 = load i64, i64* %iPtr
%next2529 = add i64 %loop_cnt2529, 1
store i64 %next2529, i64* %iPtr
%cmp2529 = icmp ult i64 %next2529, %num2553
br i1 %cmp2529, label %loop2529, label %after2529

after2529:
ret void
}
@gsxtmaudiobuffer103 = hidden constant [117 x i8] c"audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2588 = load i8*, i8** %_impzPtr
%zone2589 = bitcast i8* %tzone2588 to %mzone*

; let assign value to symbol audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd
%dat_audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone2589, i64 8)
%audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr = bitcast i8* %dat_audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***
%tzone2523 = load i8*, i8** %_impzPtr
%zone2524 = bitcast i8* %tzone2523 to %mzone*

; let assign value to symbol tmp
%dat_tmp = call i8* @llvm_zone_malloc(%mzone* %zone2524, i64 8)
%tmpPtr = bitcast i8* %dat_tmp to i32**
%val2517 = getelementptr i64, i64* null, i32 1
%zonesize2518 = mul i64 4, 1
%tzone2519 = load i8*, i8** %_impzPtr
%zone2520 = bitcast i8* %tzone2519 to %mzone*
%dat2521 = call i8* @llvm_zone_malloc(%mzone* %zone2520, i64 %zonesize2518)
call i8* @memset(i8* %dat2521, i32 0, i64 %zonesize2518)
%val2522 = bitcast i8* %dat2521 to i32*

; let value assignment
%tmp = select i1 true, i32* %val2522, i32* %val2522
store i32* %tmp, i32** %tmpPtr

%tzone2585 = load i8*, i8** %_impzPtr
%zone2586 = bitcast i8* %tzone2585 to %mzone*

; let assign value to symbol _anon_lambda_1
%dat__anon_lambda_1 = call i8* @llvm_zone_malloc(%mzone* %zone2586, i64 8)
%_anon_lambda_1Ptr = bitcast i8* %dat__anon_lambda_1 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***
%tzone2556 = load i8*, i8** %_impzPtr
%zone2557 = bitcast i8* %tzone2556 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2557)
; malloc closure structure
%clsptr2558 = call i8* @llvm_zone_malloc(%mzone* %zone2557, i64 24)
%closure2559 = bitcast i8* %clsptr2558 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr2560 = call i8* @llvm_zone_malloc(%mzone* %zone2557, i64 24)
%environment2561 = bitcast i8* %envptr2560 to {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable2562 = call %clsvar* @new_address_table()
%var2563 = bitcast [64 x i8]* @gsxtmaudiobuffer99 to i8*
%var2564 = bitcast [49 x i8]* @gsxtmaudiobuffer97 to i8*
%addytable2565 = call %clsvar* @add_address_table(%mzone* %zone2557, i8* %var2563, i32 0, i8* %var2564, i32 3, %clsvar* %addytable2562)
%var2566 = bitcast [4 x i8]* @gsxtmaudiobuffer100 to i8*
%var2567 = bitcast [5 x i8]* @gsxtmaudiobuffer101 to i8*
%addytable2568 = call %clsvar* @add_address_table(%mzone* %zone2557, i8* %var2566, i32 8, i8* %var2567, i32 3, %clsvar* %addytable2565)
%var2569 = bitcast [15 x i8]* @gsxtmaudiobuffer102 to i8*
%var2570 = bitcast [49 x i8]* @gsxtmaudiobuffer97 to i8*
%addytable2571 = call %clsvar* @add_address_table(%mzone* %zone2557, i8* %var2569, i32 16, i8* %var2570, i32 3, %clsvar* %addytable2568)
%address-table2572 = bitcast %clsvar* %addytable2571 to i8*

; insert table, function and environment into closure struct
%closure.table2579 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2559, i32 0, i32 0
store i8* %address-table2572, i8** %closure.table2579
%closure.env2580 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2559, i32 0, i32 1
store i8* %envptr2560, i8** %closure.env2580
%closure.func2581 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2559, i32 0, i32 2
store void (i8*, i8*, i8*, float*, i64)* @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd__2516, void (i8*, i8*, i8*, float*, i64)** %closure.func2581
%closure_size2582 = call i64 @llvm_zone_mark_size(%mzone* %zone2557)
call void @llvm_zone_ptr_set_size(i8* %clsptr2558, i64 %closure_size2582)
%wrapper_ptr2583 = call i8* @llvm_zone_malloc(%mzone* %zone2557, i64 8)
%closure_wrapper2584 = bitcast i8* %wrapper_ptr2583 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
store { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2559, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2584

; let value assignment
%_anon_lambda_1 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2584, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2584
store { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %_anon_lambda_1, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_1Ptr

; add data to environment
; don't need to alloc for env var audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd
%tmp_envptr2574 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2561, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %tmp_envptr2574

; don't need to alloc for env var tmp
%tmp_envptr2576 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2561, i32 0, i32 1
store i32** %tmpPtr, i32*** %tmp_envptr2576

; don't need to alloc for env var _anon_lambda_1
%tmp_envptr2578 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i32**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2561, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_1Ptr, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %tmp_envptr2578


%val2587 = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_1Ptr

; let value assignment
%audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd = select i1 true, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2587, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2587
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr

%val2590 = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2590
}


@audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd(i8* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_native(i8* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2591 = bitcast [117 x i8]* @gsxtmaudiobuffer103 to i8*
call i32 (i8*, ...) @printf(i8* %var2591)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2592 = bitcast [117 x i8]* @gsxtmaudiobuffer103 to i8*
call i32 (i8*, ...) @printf(i8* %var2592)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2593 = bitcast [117 x i8]* @gsxtmaudiobuffer103 to i8*
call i32 (i8*, ...) @printf(i8* %var2593)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float*, i64}*
%arg_p_0 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer104 = hidden constant [67 x i8] c"audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd\00"
@gsxtmaudiobuffer105 = hidden constant [6 x i8] c"range\00"
@gsxtmaudiobuffer106 = hidden constant [7 x i8] c"double\00"
@gsxtmaudiobuffer107 = hidden constant [15 x i8] c"_anon_lambda_2\00"
define dllexport fastcc void @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd__2594(i8* %_impz,i8* %_impenv, i8* %src, float* %dest, i64 %nsamp) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2599 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}*
%audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr_
%rangePtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 1
%rangePtr = load double*, double** %rangePtr_
%_anon_lambda_2Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_2Ptr = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %_anon_lambda_2Ptr_

; setup arguments
%srcPtr = alloca i8*
store i8* %src, i8** %srcPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr
%nsampPtr = alloca i64
store i64 %nsamp, i64* %nsampPtr


%tzone2601 = load i8*, i8** %_impzPtr
%zone2602 = bitcast i8* %tzone2601 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val2600 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val2600, i64 %val2600
store i64 %i, i64* %iPtr

; setup loop
%val2605 = load i64, i64* %nsampPtr
store i64 0, i64* %iPtr
%val2618 = load i64, i64* %iPtr
%num2619 = add i64 %val2605, %val2618
%comp2620 = icmp ult i64 %val2605, 1
br i1 %comp2620, label %after2603, label %loop2603

loop2603:
%val2606 = load i64, i64* %iPtr
%val2607 = load float*, float** %destPtr
%val2608 = load i64, i64* %iPtr
%val2609 = load i8*, i8** %srcPtr
%val2610 = bitcast i8* %val2609 to i16*
; pointer ref
%val2611 = getelementptr i16, i16* %val2610, i64 %val2608
%val2612 = load i16, i16* %val2611
%res2613 = call ccc double @i16tod(i16 %val2612)
%val2614 = load double, double* %rangePtr
%val2615 = fdiv double %res2613, %val2614
%res2616 = call ccc float @dtof(double %val2615)
; set pointer
%val2617 = getelementptr float, float* %val2607, i64 %val2606
store float %res2616, float* %val2617
%loop_cnt2603 = load i64, i64* %iPtr
%next2603 = add i64 %loop_cnt2603, 1
store i64 %next2603, i64* %iPtr
%cmp2603 = icmp ult i64 %next2603, %num2619
br i1 %cmp2603, label %loop2603, label %after2603

after2603:
ret void
}
@gsxtmaudiobuffer108 = hidden constant [120 x i8] c"audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2654 = load i8*, i8** %_impzPtr
%zone2655 = bitcast i8* %tzone2654 to %mzone*

; let assign value to symbol audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd
%dat_audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone2655, i64 8)
%audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr = bitcast i8* %dat_audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***
%tzone2597 = load i8*, i8** %_impzPtr
%zone2598 = bitcast i8* %tzone2597 to %mzone*

; let assign value to symbol range
%dat_range = call i8* @llvm_zone_malloc(%mzone* %zone2598, i64 8)
%rangePtr = bitcast i8* %dat_range to double*
%val2595 = shl i64 1, 16
%res2596 = call ccc double @i64tod(i64 %val2595)

; let value assignment
%range = select i1 true, double %res2596, double %res2596
store double %range, double* %rangePtr

%tzone2651 = load i8*, i8** %_impzPtr
%zone2652 = bitcast i8* %tzone2651 to %mzone*

; let assign value to symbol _anon_lambda_2
%dat__anon_lambda_2 = call i8* @llvm_zone_malloc(%mzone* %zone2652, i64 8)
%_anon_lambda_2Ptr = bitcast i8* %dat__anon_lambda_2 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***
%tzone2622 = load i8*, i8** %_impzPtr
%zone2623 = bitcast i8* %tzone2622 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2623)
; malloc closure structure
%clsptr2624 = call i8* @llvm_zone_malloc(%mzone* %zone2623, i64 24)
%closure2625 = bitcast i8* %clsptr2624 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr2626 = call i8* @llvm_zone_malloc(%mzone* %zone2623, i64 24)
%environment2627 = bitcast i8* %envptr2626 to {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable2628 = call %clsvar* @new_address_table()
%var2629 = bitcast [67 x i8]* @gsxtmaudiobuffer104 to i8*
%var2630 = bitcast [49 x i8]* @gsxtmaudiobuffer97 to i8*
%addytable2631 = call %clsvar* @add_address_table(%mzone* %zone2623, i8* %var2629, i32 0, i8* %var2630, i32 3, %clsvar* %addytable2628)
%var2632 = bitcast [6 x i8]* @gsxtmaudiobuffer105 to i8*
%var2633 = bitcast [7 x i8]* @gsxtmaudiobuffer106 to i8*
%addytable2634 = call %clsvar* @add_address_table(%mzone* %zone2623, i8* %var2632, i32 8, i8* %var2633, i32 3, %clsvar* %addytable2631)
%var2635 = bitcast [15 x i8]* @gsxtmaudiobuffer107 to i8*
%var2636 = bitcast [49 x i8]* @gsxtmaudiobuffer97 to i8*
%addytable2637 = call %clsvar* @add_address_table(%mzone* %zone2623, i8* %var2635, i32 16, i8* %var2636, i32 3, %clsvar* %addytable2634)
%address-table2638 = bitcast %clsvar* %addytable2637 to i8*

; insert table, function and environment into closure struct
%closure.table2645 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2625, i32 0, i32 0
store i8* %address-table2638, i8** %closure.table2645
%closure.env2646 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2625, i32 0, i32 1
store i8* %envptr2626, i8** %closure.env2646
%closure.func2647 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2625, i32 0, i32 2
store void (i8*, i8*, i8*, float*, i64)* @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd__2594, void (i8*, i8*, i8*, float*, i64)** %closure.func2647
%closure_size2648 = call i64 @llvm_zone_mark_size(%mzone* %zone2623)
call void @llvm_zone_ptr_set_size(i8* %clsptr2624, i64 %closure_size2648)
%wrapper_ptr2649 = call i8* @llvm_zone_malloc(%mzone* %zone2623, i64 8)
%closure_wrapper2650 = bitcast i8* %wrapper_ptr2649 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
store { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2625, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2650

; let value assignment
%_anon_lambda_2 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2650, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2650
store { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %_anon_lambda_2, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_2Ptr

; add data to environment
; don't need to alloc for env var audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd
%tmp_envptr2640 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2627, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %tmp_envptr2640

; don't need to alloc for env var range
%tmp_envptr2642 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2627, i32 0, i32 1
store double* %rangePtr, double** %tmp_envptr2642

; don't need to alloc for env var _anon_lambda_2
%tmp_envptr2644 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2627, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_2Ptr, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %tmp_envptr2644


%val2653 = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_2Ptr

; let value assignment
%audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd = select i1 true, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2653, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2653
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr

%val2656 = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2656
}


@audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd(i8* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_native(i8* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2657 = bitcast [120 x i8]* @gsxtmaudiobuffer108 to i8*
call i32 (i8*, ...) @printf(i8* %var2657)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2658 = bitcast [120 x i8]* @gsxtmaudiobuffer108 to i8*
call i32 (i8*, ...) @printf(i8* %var2658)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2659 = bitcast [120 x i8]* @gsxtmaudiobuffer108 to i8*
call i32 (i8*, ...) @printf(i8* %var2659)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float*, i64}*
%arg_p_0 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer109 = hidden constant [67 x i8] c"audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd\00"
@gsxtmaudiobuffer110 = hidden constant [15 x i8] c"_anon_lambda_3\00"
define dllexport fastcc void @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd__2660(i8* %_impz,i8* %_impenv, i8* %src, float* %dest, i64 %nsamp) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2665 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}*
%audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr_
%rangePtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 1
%rangePtr = load double*, double** %rangePtr_
%_anon_lambda_3Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_3Ptr = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %_anon_lambda_3Ptr_

; setup arguments
%srcPtr = alloca i8*
store i8* %src, i8** %srcPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr
%nsampPtr = alloca i64
store i64 %nsamp, i64* %nsampPtr


%tzone2667 = load i8*, i8** %_impzPtr
%zone2668 = bitcast i8* %tzone2667 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val2666 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val2666, i64 %val2666
store i64 %i, i64* %iPtr

; setup loop
%val2671 = load i64, i64* %nsampPtr
store i64 0, i64* %iPtr
%val2685 = load i64, i64* %iPtr
%num2686 = add i64 %val2671, %val2685
%comp2687 = icmp ult i64 %val2671, 1
br i1 %comp2687, label %after2669, label %loop2669

loop2669:
%val2672 = load i64, i64* %iPtr
%val2673 = load float*, float** %destPtr
%val2674 = load i64, i64* %iPtr
%val2675 = load i8*, i8** %srcPtr
%val2676 = bitcast i8* %val2675 to i16*
; pointer ref
%val2677 = getelementptr i16, i16* %val2676, i64 %val2674
%val2678 = load i16, i16* %val2677
%res2679 = call ccc i16 @swapi16(i16 %val2678)
%res2680 = call ccc double @i16tod(i16 %res2679)
%val2681 = load double, double* %rangePtr
%val2682 = fdiv double %res2680, %val2681
%res2683 = call ccc float @dtof(double %val2682)
; set pointer
%val2684 = getelementptr float, float* %val2673, i64 %val2672
store float %res2683, float* %val2684
%loop_cnt2669 = load i64, i64* %iPtr
%next2669 = add i64 %loop_cnt2669, 1
store i64 %next2669, i64* %iPtr
%cmp2669 = icmp ult i64 %next2669, %num2686
br i1 %cmp2669, label %loop2669, label %after2669

after2669:
ret void
}
@gsxtmaudiobuffer111 = hidden constant [120 x i8] c"audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2721 = load i8*, i8** %_impzPtr
%zone2722 = bitcast i8* %tzone2721 to %mzone*

; let assign value to symbol audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd
%dat_audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone2722, i64 8)
%audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr = bitcast i8* %dat_audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***
%tzone2663 = load i8*, i8** %_impzPtr
%zone2664 = bitcast i8* %tzone2663 to %mzone*

; let assign value to symbol range
%dat_range = call i8* @llvm_zone_malloc(%mzone* %zone2664, i64 8)
%rangePtr = bitcast i8* %dat_range to double*
%val2661 = shl i64 1, 16
%res2662 = call ccc double @i64tod(i64 %val2661)

; let value assignment
%range = select i1 true, double %res2662, double %res2662
store double %range, double* %rangePtr

%tzone2718 = load i8*, i8** %_impzPtr
%zone2719 = bitcast i8* %tzone2718 to %mzone*

; let assign value to symbol _anon_lambda_3
%dat__anon_lambda_3 = call i8* @llvm_zone_malloc(%mzone* %zone2719, i64 8)
%_anon_lambda_3Ptr = bitcast i8* %dat__anon_lambda_3 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***
%tzone2689 = load i8*, i8** %_impzPtr
%zone2690 = bitcast i8* %tzone2689 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2690)
; malloc closure structure
%clsptr2691 = call i8* @llvm_zone_malloc(%mzone* %zone2690, i64 24)
%closure2692 = bitcast i8* %clsptr2691 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr2693 = call i8* @llvm_zone_malloc(%mzone* %zone2690, i64 24)
%environment2694 = bitcast i8* %envptr2693 to {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable2695 = call %clsvar* @new_address_table()
%var2696 = bitcast [67 x i8]* @gsxtmaudiobuffer109 to i8*
%var2697 = bitcast [49 x i8]* @gsxtmaudiobuffer97 to i8*
%addytable2698 = call %clsvar* @add_address_table(%mzone* %zone2690, i8* %var2696, i32 0, i8* %var2697, i32 3, %clsvar* %addytable2695)
%var2699 = bitcast [6 x i8]* @gsxtmaudiobuffer105 to i8*
%var2700 = bitcast [7 x i8]* @gsxtmaudiobuffer106 to i8*
%addytable2701 = call %clsvar* @add_address_table(%mzone* %zone2690, i8* %var2699, i32 8, i8* %var2700, i32 3, %clsvar* %addytable2698)
%var2702 = bitcast [15 x i8]* @gsxtmaudiobuffer110 to i8*
%var2703 = bitcast [49 x i8]* @gsxtmaudiobuffer97 to i8*
%addytable2704 = call %clsvar* @add_address_table(%mzone* %zone2690, i8* %var2702, i32 16, i8* %var2703, i32 3, %clsvar* %addytable2701)
%address-table2705 = bitcast %clsvar* %addytable2704 to i8*

; insert table, function and environment into closure struct
%closure.table2712 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2692, i32 0, i32 0
store i8* %address-table2705, i8** %closure.table2712
%closure.env2713 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2692, i32 0, i32 1
store i8* %envptr2693, i8** %closure.env2713
%closure.func2714 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2692, i32 0, i32 2
store void (i8*, i8*, i8*, float*, i64)* @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd__2660, void (i8*, i8*, i8*, float*, i64)** %closure.func2714
%closure_size2715 = call i64 @llvm_zone_mark_size(%mzone* %zone2690)
call void @llvm_zone_ptr_set_size(i8* %clsptr2691, i64 %closure_size2715)
%wrapper_ptr2716 = call i8* @llvm_zone_malloc(%mzone* %zone2690, i64 8)
%closure_wrapper2717 = bitcast i8* %wrapper_ptr2716 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
store { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2692, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2717

; let value assignment
%_anon_lambda_3 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2717, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2717
store { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %_anon_lambda_3, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_3Ptr

; add data to environment
; don't need to alloc for env var audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd
%tmp_envptr2707 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2694, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %tmp_envptr2707

; don't need to alloc for env var range
%tmp_envptr2709 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2694, i32 0, i32 1
store double* %rangePtr, double** %tmp_envptr2709

; don't need to alloc for env var _anon_lambda_3
%tmp_envptr2711 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2694, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_3Ptr, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %tmp_envptr2711


%val2720 = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_3Ptr

; let value assignment
%audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd = select i1 true, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2720, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2720
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr

%val2723 = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2723
}


@audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd(i8* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_native(i8* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2724 = bitcast [120 x i8]* @gsxtmaudiobuffer111 to i8*
call i32 (i8*, ...) @printf(i8* %var2724)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2725 = bitcast [120 x i8]* @gsxtmaudiobuffer111 to i8*
call i32 (i8*, ...) @printf(i8* %var2725)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2726 = bitcast [120 x i8]* @gsxtmaudiobuffer111 to i8*
call i32 (i8*, ...) @printf(i8* %var2726)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float*, i64}*
%arg_p_0 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer112 = hidden constant [67 x i8] c"audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd\00"
@gsxtmaudiobuffer113 = hidden constant [4 x i8] c"i8*\00"
@gsxtmaudiobuffer114 = hidden constant [15 x i8] c"_anon_lambda_4\00"
define dllexport fastcc void @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd__2727(i8* %_impz,i8* %_impenv, i8* %src, float* %dest, i64 %nsamp) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2740 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}*
%audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr_
%tmpPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 1
%tmpPtr = load i8**, i8*** %tmpPtr_
%rangePtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 2
%rangePtr = load double*, double** %rangePtr_
%_anon_lambda_4Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 3
%_anon_lambda_4Ptr = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %_anon_lambda_4Ptr_

; setup arguments
%srcPtr = alloca i8*
store i8* %src, i8** %srcPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr
%nsampPtr = alloca i64
store i64 %nsamp, i64* %nsampPtr


%val2741 = load i8*, i8** %tmpPtr
; set pointer
%val2742 = getelementptr i8, i8* %val2741, i64 3
store i8 0, i8* %val2742
%tzone2744 = load i8*, i8** %_impzPtr
%zone2745 = bitcast i8* %tzone2744 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val2743 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val2743, i64 %val2743
store i64 %i, i64* %iPtr

; setup loop
%val2748 = load i64, i64* %nsampPtr
store i64 0, i64* %iPtr
%val2783 = load i64, i64* %iPtr
%num2784 = add i64 %val2748, %val2783
%comp2785 = icmp ult i64 %val2748, 1
br i1 %comp2785, label %after2746, label %loop2746

loop2746:
%val2749 = load i8*, i8** %tmpPtr
%val2750 = load i64, i64* %iPtr
%val2751 = mul i64 %val2750, 3
%val2752 = load i8*, i8** %srcPtr
; pointer ref
%val2753 = getelementptr i8, i8* %val2752, i64 %val2751
%val2754 = load i8, i8* %val2753
; set pointer
%val2755 = getelementptr i8, i8* %val2749, i64 1
store i8 %val2754, i8* %val2755
%val2756 = load i8*, i8** %tmpPtr
%val2757 = load i64, i64* %iPtr
%val2758 = mul i64 %val2757, 3
%val2759 = add i64 %val2758, 1
%val2760 = load i8*, i8** %srcPtr
; pointer ref
%val2761 = getelementptr i8, i8* %val2760, i64 %val2759
%val2762 = load i8, i8* %val2761
; set pointer
%val2763 = getelementptr i8, i8* %val2756, i64 2
store i8 %val2762, i8* %val2763
%val2764 = load i8*, i8** %tmpPtr
%val2765 = load i64, i64* %iPtr
%val2766 = mul i64 %val2765, 3
%val2767 = add i64 %val2766, 2
%val2768 = load i8*, i8** %srcPtr
; pointer ref
%val2769 = getelementptr i8, i8* %val2768, i64 %val2767
%val2770 = load i8, i8* %val2769
; set pointer
%val2771 = getelementptr i8, i8* %val2764, i64 3
store i8 %val2770, i8* %val2771
%val2772 = load i64, i64* %iPtr
%val2773 = load float*, float** %destPtr
%val2774 = load i8*, i8** %tmpPtr
%val2775 = bitcast i8* %val2774 to i32*
; pointer ref
%val2776 = getelementptr i32, i32* %val2775, i64 0
%val2777 = load i32, i32* %val2776
%res2778 = call ccc double @i32tod(i32 %val2777)
%val2779 = load double, double* %rangePtr
%val2780 = fdiv double %res2778, %val2779
%res2781 = call ccc float @dtof(double %val2780)
; set pointer
%val2782 = getelementptr float, float* %val2773, i64 %val2772
store float %res2781, float* %val2782
%loop_cnt2746 = load i64, i64* %iPtr
%next2746 = add i64 %loop_cnt2746, 1
store i64 %next2746, i64* %iPtr
%cmp2746 = icmp ult i64 %next2746, %num2784
br i1 %cmp2746, label %loop2746, label %after2746

after2746:
ret void
}
@gsxtmaudiobuffer115 = hidden constant [120 x i8] c"audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2824 = load i8*, i8** %_impzPtr
%zone2825 = bitcast i8* %tzone2824 to %mzone*

; let assign value to symbol audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd
%dat_audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone2825, i64 8)
%audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr = bitcast i8* %dat_audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***
%tzone2730 = load i8*, i8** %_impzPtr
%zone2731 = bitcast i8* %tzone2730 to %mzone*

; let assign value to symbol range
%dat_range = call i8* @llvm_zone_malloc(%mzone* %zone2731, i64 8)
%rangePtr = bitcast i8* %dat_range to double*
%tzone2738 = load i8*, i8** %_impzPtr
%zone2739 = bitcast i8* %tzone2738 to %mzone*

; let assign value to symbol tmp
%dat_tmp = call i8* @llvm_zone_malloc(%mzone* %zone2739, i64 8)
%tmpPtr = bitcast i8* %dat_tmp to i8**
%val2728 = shl i64 1, 32
%res2729 = call ccc double @i64tod(i64 %val2728)

; let value assignment
%range = select i1 true, double %res2729, double %res2729
store double %range, double* %rangePtr

%val2732 = getelementptr i64, i64* null, i32 1
%zonesize2733 = mul i64 1, 4
%tzone2734 = load i8*, i8** %_impzPtr
%zone2735 = bitcast i8* %tzone2734 to %mzone*
%dat2736 = call i8* @llvm_zone_malloc(%mzone* %zone2735, i64 %zonesize2733)
call i8* @memset(i8* %dat2736, i32 0, i64 %zonesize2733)
%val2737 = bitcast i8* %dat2736 to i8*

; let value assignment
%tmp = select i1 true, i8* %val2737, i8* %val2737
store i8* %tmp, i8** %tmpPtr

%tzone2821 = load i8*, i8** %_impzPtr
%zone2822 = bitcast i8* %tzone2821 to %mzone*

; let assign value to symbol _anon_lambda_4
%dat__anon_lambda_4 = call i8* @llvm_zone_malloc(%mzone* %zone2822, i64 8)
%_anon_lambda_4Ptr = bitcast i8* %dat__anon_lambda_4 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***
%tzone2787 = load i8*, i8** %_impzPtr
%zone2788 = bitcast i8* %tzone2787 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2788)
; malloc closure structure
%clsptr2789 = call i8* @llvm_zone_malloc(%mzone* %zone2788, i64 24)
%closure2790 = bitcast i8* %clsptr2789 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr2791 = call i8* @llvm_zone_malloc(%mzone* %zone2788, i64 32)
%environment2792 = bitcast i8* %envptr2791 to {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable2793 = call %clsvar* @new_address_table()
%var2794 = bitcast [67 x i8]* @gsxtmaudiobuffer112 to i8*
%var2795 = bitcast [49 x i8]* @gsxtmaudiobuffer97 to i8*
%addytable2796 = call %clsvar* @add_address_table(%mzone* %zone2788, i8* %var2794, i32 0, i8* %var2795, i32 3, %clsvar* %addytable2793)
%var2797 = bitcast [4 x i8]* @gsxtmaudiobuffer100 to i8*
%var2798 = bitcast [4 x i8]* @gsxtmaudiobuffer113 to i8*
%addytable2799 = call %clsvar* @add_address_table(%mzone* %zone2788, i8* %var2797, i32 8, i8* %var2798, i32 3, %clsvar* %addytable2796)
%var2800 = bitcast [6 x i8]* @gsxtmaudiobuffer105 to i8*
%var2801 = bitcast [7 x i8]* @gsxtmaudiobuffer106 to i8*
%addytable2802 = call %clsvar* @add_address_table(%mzone* %zone2788, i8* %var2800, i32 16, i8* %var2801, i32 3, %clsvar* %addytable2799)
%var2803 = bitcast [15 x i8]* @gsxtmaudiobuffer114 to i8*
%var2804 = bitcast [49 x i8]* @gsxtmaudiobuffer97 to i8*
%addytable2805 = call %clsvar* @add_address_table(%mzone* %zone2788, i8* %var2803, i32 24, i8* %var2804, i32 3, %clsvar* %addytable2802)
%address-table2806 = bitcast %clsvar* %addytable2805 to i8*

; insert table, function and environment into closure struct
%closure.table2815 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2790, i32 0, i32 0
store i8* %address-table2806, i8** %closure.table2815
%closure.env2816 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2790, i32 0, i32 1
store i8* %envptr2791, i8** %closure.env2816
%closure.func2817 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2790, i32 0, i32 2
store void (i8*, i8*, i8*, float*, i64)* @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd__2727, void (i8*, i8*, i8*, float*, i64)** %closure.func2817
%closure_size2818 = call i64 @llvm_zone_mark_size(%mzone* %zone2788)
call void @llvm_zone_ptr_set_size(i8* %clsptr2789, i64 %closure_size2818)
%wrapper_ptr2819 = call i8* @llvm_zone_malloc(%mzone* %zone2788, i64 8)
%closure_wrapper2820 = bitcast i8* %wrapper_ptr2819 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
store { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2790, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2820

; let value assignment
%_anon_lambda_4 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2820, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2820
store { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %_anon_lambda_4, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_4Ptr

; add data to environment
; don't need to alloc for env var audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd
%tmp_envptr2808 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2792, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %tmp_envptr2808

; don't need to alloc for env var tmp
%tmp_envptr2810 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2792, i32 0, i32 1
store i8** %tmpPtr, i8*** %tmp_envptr2810

; don't need to alloc for env var range
%tmp_envptr2812 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2792, i32 0, i32 2
store double* %rangePtr, double** %tmp_envptr2812

; don't need to alloc for env var _anon_lambda_4
%tmp_envptr2814 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2792, i32 0, i32 3
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_4Ptr, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %tmp_envptr2814


%val2823 = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_4Ptr

; let value assignment
%audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd = select i1 true, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2823, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2823
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr

%val2826 = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2826
}


@audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd(i8* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_native(i8* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2827 = bitcast [120 x i8]* @gsxtmaudiobuffer115 to i8*
call i32 (i8*, ...) @printf(i8* %var2827)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2828 = bitcast [120 x i8]* @gsxtmaudiobuffer115 to i8*
call i32 (i8*, ...) @printf(i8* %var2828)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2829 = bitcast [120 x i8]* @gsxtmaudiobuffer115 to i8*
call i32 (i8*, ...) @printf(i8* %var2829)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float*, i64}*
%arg_p_0 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer116 = hidden constant [67 x i8] c"audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd\00"
@gsxtmaudiobuffer117 = hidden constant [15 x i8] c"_anon_lambda_5\00"
define dllexport fastcc void @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd__2830(i8* %_impz,i8* %_impenv, i8* %src, float* %dest, i64 %nsamp) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2843 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}*
%audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr_
%tmpPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 1
%tmpPtr = load i8**, i8*** %tmpPtr_
%rangePtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 2
%rangePtr = load double*, double** %rangePtr_
%_anon_lambda_5Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 3
%_anon_lambda_5Ptr = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %_anon_lambda_5Ptr_

; setup arguments
%srcPtr = alloca i8*
store i8* %src, i8** %srcPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr
%nsampPtr = alloca i64
store i64 %nsamp, i64* %nsampPtr


%val2844 = load i8*, i8** %tmpPtr
; set pointer
%val2845 = getelementptr i8, i8* %val2844, i64 0
store i8 0, i8* %val2845
%tzone2847 = load i8*, i8** %_impzPtr
%zone2848 = bitcast i8* %tzone2847 to %mzone*

; let assign value to symbol i
%iPtr = alloca i64
%val2846 = bitcast i64 0 to i64

; let value assignment
%i = select i1 true, i64 %val2846, i64 %val2846
store i64 %i, i64* %iPtr

; setup loop
%val2851 = load i64, i64* %nsampPtr
store i64 0, i64* %iPtr
%val2886 = load i64, i64* %iPtr
%num2887 = add i64 %val2851, %val2886
%comp2888 = icmp ult i64 %val2851, 1
br i1 %comp2888, label %after2849, label %loop2849

loop2849:
%val2852 = load i8*, i8** %tmpPtr
%val2853 = load i64, i64* %iPtr
%val2854 = mul i64 %val2853, 3
%val2855 = load i8*, i8** %srcPtr
; pointer ref
%val2856 = getelementptr i8, i8* %val2855, i64 %val2854
%val2857 = load i8, i8* %val2856
; set pointer
%val2858 = getelementptr i8, i8* %val2852, i64 3
store i8 %val2857, i8* %val2858
%val2859 = load i8*, i8** %tmpPtr
%val2860 = load i64, i64* %iPtr
%val2861 = mul i64 %val2860, 3
%val2862 = add i64 %val2861, 1
%val2863 = load i8*, i8** %srcPtr
; pointer ref
%val2864 = getelementptr i8, i8* %val2863, i64 %val2862
%val2865 = load i8, i8* %val2864
; set pointer
%val2866 = getelementptr i8, i8* %val2859, i64 2
store i8 %val2865, i8* %val2866
%val2867 = load i8*, i8** %tmpPtr
%val2868 = load i64, i64* %iPtr
%val2869 = mul i64 %val2868, 3
%val2870 = add i64 %val2869, 2
%val2871 = load i8*, i8** %srcPtr
; pointer ref
%val2872 = getelementptr i8, i8* %val2871, i64 %val2870
%val2873 = load i8, i8* %val2872
; set pointer
%val2874 = getelementptr i8, i8* %val2867, i64 1
store i8 %val2873, i8* %val2874
%val2875 = load i64, i64* %iPtr
%val2876 = load float*, float** %destPtr
%val2877 = load i8*, i8** %tmpPtr
%val2878 = bitcast i8* %val2877 to i32*
; pointer ref
%val2879 = getelementptr i32, i32* %val2878, i64 0
%val2880 = load i32, i32* %val2879
%res2881 = call ccc double @i32tod(i32 %val2880)
%val2882 = load double, double* %rangePtr
%val2883 = fdiv double %res2881, %val2882
%res2884 = call ccc float @dtof(double %val2883)
; set pointer
%val2885 = getelementptr float, float* %val2876, i64 %val2875
store float %res2884, float* %val2885
%loop_cnt2849 = load i64, i64* %iPtr
%next2849 = add i64 %loop_cnt2849, 1
store i64 %next2849, i64* %iPtr
%cmp2849 = icmp ult i64 %next2849, %num2887
br i1 %cmp2849, label %loop2849, label %after2849

after2849:
ret void
}
@gsxtmaudiobuffer118 = hidden constant [120 x i8] c"audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2927 = load i8*, i8** %_impzPtr
%zone2928 = bitcast i8* %tzone2927 to %mzone*

; let assign value to symbol audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd
%dat_audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone2928, i64 8)
%audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr = bitcast i8* %dat_audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***
%tzone2833 = load i8*, i8** %_impzPtr
%zone2834 = bitcast i8* %tzone2833 to %mzone*

; let assign value to symbol range
%dat_range = call i8* @llvm_zone_malloc(%mzone* %zone2834, i64 8)
%rangePtr = bitcast i8* %dat_range to double*
%tzone2841 = load i8*, i8** %_impzPtr
%zone2842 = bitcast i8* %tzone2841 to %mzone*

; let assign value to symbol tmp
%dat_tmp = call i8* @llvm_zone_malloc(%mzone* %zone2842, i64 8)
%tmpPtr = bitcast i8* %dat_tmp to i8**
%val2831 = shl i64 1, 32
%res2832 = call ccc double @i64tod(i64 %val2831)

; let value assignment
%range = select i1 true, double %res2832, double %res2832
store double %range, double* %rangePtr

%val2835 = getelementptr i64, i64* null, i32 1
%zonesize2836 = mul i64 1, 4
%tzone2837 = load i8*, i8** %_impzPtr
%zone2838 = bitcast i8* %tzone2837 to %mzone*
%dat2839 = call i8* @llvm_zone_malloc(%mzone* %zone2838, i64 %zonesize2836)
call i8* @memset(i8* %dat2839, i32 0, i64 %zonesize2836)
%val2840 = bitcast i8* %dat2839 to i8*

; let value assignment
%tmp = select i1 true, i8* %val2840, i8* %val2840
store i8* %tmp, i8** %tmpPtr

%tzone2924 = load i8*, i8** %_impzPtr
%zone2925 = bitcast i8* %tzone2924 to %mzone*

; let assign value to symbol _anon_lambda_5
%dat__anon_lambda_5 = call i8* @llvm_zone_malloc(%mzone* %zone2925, i64 8)
%_anon_lambda_5Ptr = bitcast i8* %dat__anon_lambda_5 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***
%tzone2890 = load i8*, i8** %_impzPtr
%zone2891 = bitcast i8* %tzone2890 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2891)
; malloc closure structure
%clsptr2892 = call i8* @llvm_zone_malloc(%mzone* %zone2891, i64 24)
%closure2893 = bitcast i8* %clsptr2892 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr2894 = call i8* @llvm_zone_malloc(%mzone* %zone2891, i64 32)
%environment2895 = bitcast i8* %envptr2894 to {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable2896 = call %clsvar* @new_address_table()
%var2897 = bitcast [67 x i8]* @gsxtmaudiobuffer116 to i8*
%var2898 = bitcast [49 x i8]* @gsxtmaudiobuffer97 to i8*
%addytable2899 = call %clsvar* @add_address_table(%mzone* %zone2891, i8* %var2897, i32 0, i8* %var2898, i32 3, %clsvar* %addytable2896)
%var2900 = bitcast [4 x i8]* @gsxtmaudiobuffer100 to i8*
%var2901 = bitcast [4 x i8]* @gsxtmaudiobuffer113 to i8*
%addytable2902 = call %clsvar* @add_address_table(%mzone* %zone2891, i8* %var2900, i32 8, i8* %var2901, i32 3, %clsvar* %addytable2899)
%var2903 = bitcast [6 x i8]* @gsxtmaudiobuffer105 to i8*
%var2904 = bitcast [7 x i8]* @gsxtmaudiobuffer106 to i8*
%addytable2905 = call %clsvar* @add_address_table(%mzone* %zone2891, i8* %var2903, i32 16, i8* %var2904, i32 3, %clsvar* %addytable2902)
%var2906 = bitcast [15 x i8]* @gsxtmaudiobuffer117 to i8*
%var2907 = bitcast [49 x i8]* @gsxtmaudiobuffer97 to i8*
%addytable2908 = call %clsvar* @add_address_table(%mzone* %zone2891, i8* %var2906, i32 24, i8* %var2907, i32 3, %clsvar* %addytable2905)
%address-table2909 = bitcast %clsvar* %addytable2908 to i8*

; insert table, function and environment into closure struct
%closure.table2918 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2893, i32 0, i32 0
store i8* %address-table2909, i8** %closure.table2918
%closure.env2919 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2893, i32 0, i32 1
store i8* %envptr2894, i8** %closure.env2919
%closure.func2920 = getelementptr { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2893, i32 0, i32 2
store void (i8*, i8*, i8*, float*, i64)* @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd__2830, void (i8*, i8*, i8*, float*, i64)** %closure.func2920
%closure_size2921 = call i64 @llvm_zone_mark_size(%mzone* %zone2891)
call void @llvm_zone_ptr_set_size(i8* %clsptr2892, i64 %closure_size2921)
%wrapper_ptr2922 = call i8* @llvm_zone_malloc(%mzone* %zone2891, i64 8)
%closure_wrapper2923 = bitcast i8* %wrapper_ptr2922 to { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
store { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure2893, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2923

; let value assignment
%_anon_lambda_5 = select i1 true, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2923, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_wrapper2923
store { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %_anon_lambda_5, { i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_5Ptr

; add data to environment
; don't need to alloc for env var audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd
%tmp_envptr2911 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2895, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %tmp_envptr2911

; don't need to alloc for env var tmp
%tmp_envptr2913 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2895, i32 0, i32 1
store i8** %tmpPtr, i8*** %tmp_envptr2913

; don't need to alloc for env var range
%tmp_envptr2915 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2895, i32 0, i32 2
store double* %rangePtr, double** %tmp_envptr2915

; don't need to alloc for env var _anon_lambda_5
%tmp_envptr2917 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}, {{i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***, i8**, double*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}***}* %environment2895, i32 0, i32 3
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_5Ptr, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**** %tmp_envptr2917


%val2926 = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %_anon_lambda_5Ptr

; let value assignment
%audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd = select i1 true, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2926, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2926
store {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr

%val2929 = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*** %audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRdPtr
ret {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %val2929
}


@audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd(i8* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc void @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_native(i8* %arg_0,float* %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
ret void
}


define dllexport ccc i8*  @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2930 = bitcast [120 x i8]* @gsxtmaudiobuffer118 to i8*
call i32 (i8*, ...) @printf(i8* %var2930)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2931 = bitcast [120 x i8]* @gsxtmaudiobuffer118 to i8*
call i32 (i8*, ...) @printf(i8* %var2931)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2932 = bitcast [120 x i8]* @gsxtmaudiobuffer118 to i8*
call i32 (i8*, ...) @printf(i8* %var2932)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float*, i64}*
%arg_p_0 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {i8*, float*, i64}, {i8*, float*, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}*, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}, {i8*, i8*, void (i8*, i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*, float*, i64)*,  void (i8*, i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@WAVE_FORMAT_PCM = dllexport global i64 1
@WAVE_FORMAT_IEEE_FLOAT = dllexport global i64 3
@WAVE_FORMAT_ALAW = dllexport global i64 6
@WAVE_FORMAT_MULAW = dllexport global i64 7
@WAVE_FORMAT_EXTENSIBLE = dllexport global i64 -2
@gsxtmaudiobuffer119 = hidden constant [184 x i8] c"audiofile error: the native xtlang wave/aiff file reader currently
only supports 16/24-bit PCM or 32-bit IEEE float audio

For more audio format options, use libs/external/sndfile.xtm\00"
@gsxtmaudiobuffer120 = hidden constant [70 x i8] c"audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd\00"
@gsxtmaudiobuffer121 = hidden constant [61 x i8] c"{i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}**\00"
define dllexport fastcc i1 @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd__2933(i8* %_impz,i8* %_impenv, i8* %src, float* %dest, i64 %nsamp, i64 %bitdepth, i64 %type, i1 %le) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2934 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}***}*
%audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFdPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}***}* %impenv, i32 0, i32 0
%audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFdPtr = load {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}***, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}**** %audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFdPtr_

; setup arguments
%srcPtr = alloca i8*
store i8* %src, i8** %srcPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr
%nsampPtr = alloca i64
store i64 %nsamp, i64* %nsampPtr
%bitdepthPtr = alloca i64
store i64 %bitdepth, i64* %bitdepthPtr
%typePtr = alloca i64
store i64 %type, i64* %typePtr
%lePtr = alloca i1
store i1 %le, i1* %lePtr

; promote local stack var allocations
%tzone3033 = load i8*, i8** %_impzPtr
%zone3034 = bitcast i8* %tzone3033 to %mzone*
%ifptr2990 = alloca i1
%ifptr3008 = alloca i1
%ifptr2991 = alloca i1
%ifptr2998 = alloca i1
%ifptr2951 = alloca i1
%ifptr2969 = alloca i1
%ifptr2952 = alloca i1
%ifptr2959 = alloca i1

%val2936 = load i64, i64* %typePtr
%val2937 = load i64, i64* @WAVE_FORMAT_IEEE_FLOAT
%cmp2938 = icmp eq i64 %val2936, %val2937
br i1 %cmp2938, label %then2935, label %else2935

then2935:
%val2940 = load i1, i1* %lePtr
br i1 %val2940, label %then2939, label %else2939

then2939:
%val2941 = load i8*, i8** %srcPtr
%val2942 = load float*, float** %destPtr
%val2943 = load i64, i64* %nsampPtr
call fastcc void @audiofile_float_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd(i8* %val2941, float* %val2942, i64 %val2943)
br label %ifcont2939

else2939:
%val2945 = load i8*, i8** %srcPtr
%val2946 = load float*, float** %destPtr
%val2947 = load i64, i64* %nsampPtr
call fastcc void @audiofile_float_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd(i8* %val2945, float* %val2946, i64 %val2947)
br label %ifcont2939

ifcont2939:
%res2949 = call ccc i1 @impc_true()
ret i1 %res2949

else2935:
%val2953 = load i64, i64* %typePtr
%val2954 = load i64, i64* @WAVE_FORMAT_PCM
%cmp2955 = icmp eq i64 %val2953, %val2954
br i1 %cmp2955, label %then2952, label %else2952

then2952:
%val2956 = load i64, i64* %typePtr
%val2957 = load i64, i64* @WAVE_FORMAT_PCM
%cmp2958 = icmp eq i64 %val2956, %val2957
store i1 %cmp2958, i1* %ifptr2952
br label %ifcont2952

else2952:
%val2960 = load i64, i64* %typePtr
%val2961 = load i64, i64* @WAVE_FORMAT_EXTENSIBLE
%cmp2962 = icmp eq i64 %val2960, %val2961
br i1 %cmp2962, label %then2959, label %else2959

then2959:
%val2963 = load i64, i64* %typePtr
%val2964 = load i64, i64* @WAVE_FORMAT_EXTENSIBLE
%cmp2965 = icmp eq i64 %val2963, %val2964
store i1 %cmp2965, i1* %ifptr2959
br label %ifcont2959

else2959:
%res2966 = call ccc i1 @impc_false()
store i1 %res2966, i1* %ifptr2959
br label %ifcont2959

ifcont2959:
%ifres2967 = load i1, i1* %ifptr2959

store i1 %ifres2967, i1* %ifptr2952
br label %ifcont2952

ifcont2952:
%ifres2968 = load i1, i1* %ifptr2952

br i1 %ifres2968, label %then2951, label %else2951

then2951:
%val2970 = load i64, i64* %bitdepthPtr
%cmp2971 = icmp eq i64 %val2970, 16
br i1 %cmp2971, label %then2969, label %else2969

then2969:
%val2972 = load i64, i64* %bitdepthPtr
%cmp2973 = icmp eq i64 %val2972, 16
store i1 %cmp2973, i1* %ifptr2969
br label %ifcont2969

else2969:
%res2974 = call ccc i1 @impc_false()
store i1 %res2974, i1* %ifptr2969
br label %ifcont2969

ifcont2969:
%ifres2975 = load i1, i1* %ifptr2969

store i1 %ifres2975, i1* %ifptr2951
br label %ifcont2951

else2951:
%res2976 = call ccc i1 @impc_false()
store i1 %res2976, i1* %ifptr2951
br label %ifcont2951

ifcont2951:
%ifres2977 = load i1, i1* %ifptr2951

br i1 %ifres2977, label %then2950, label %else2950

then2950:
%val2979 = load i1, i1* %lePtr
br i1 %val2979, label %then2978, label %else2978

then2978:
%val2980 = load i8*, i8** %srcPtr
%val2981 = load float*, float** %destPtr
%val2982 = load i64, i64* %nsampPtr
call fastcc void @audiofile_16bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd(i8* %val2980, float* %val2981, i64 %val2982)
br label %ifcont2978

else2978:
%val2984 = load i8*, i8** %srcPtr
%val2985 = load float*, float** %destPtr
%val2986 = load i64, i64* %nsampPtr
call fastcc void @audiofile_16bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd(i8* %val2984, float* %val2985, i64 %val2986)
br label %ifcont2978

ifcont2978:
%res2988 = call ccc i1 @impc_true()
ret i1 %res2988

else2950:
%val2992 = load i64, i64* %typePtr
%val2993 = load i64, i64* @WAVE_FORMAT_PCM
%cmp2994 = icmp eq i64 %val2992, %val2993
br i1 %cmp2994, label %then2991, label %else2991

then2991:
%val2995 = load i64, i64* %typePtr
%val2996 = load i64, i64* @WAVE_FORMAT_PCM
%cmp2997 = icmp eq i64 %val2995, %val2996
store i1 %cmp2997, i1* %ifptr2991
br label %ifcont2991

else2991:
%val2999 = load i64, i64* %typePtr
%val3000 = load i64, i64* @WAVE_FORMAT_EXTENSIBLE
%cmp3001 = icmp eq i64 %val2999, %val3000
br i1 %cmp3001, label %then2998, label %else2998

then2998:
%val3002 = load i64, i64* %typePtr
%val3003 = load i64, i64* @WAVE_FORMAT_EXTENSIBLE
%cmp3004 = icmp eq i64 %val3002, %val3003
store i1 %cmp3004, i1* %ifptr2998
br label %ifcont2998

else2998:
%res3005 = call ccc i1 @impc_false()
store i1 %res3005, i1* %ifptr2998
br label %ifcont2998

ifcont2998:
%ifres3006 = load i1, i1* %ifptr2998

store i1 %ifres3006, i1* %ifptr2991
br label %ifcont2991

ifcont2991:
%ifres3007 = load i1, i1* %ifptr2991

br i1 %ifres3007, label %then2990, label %else2990

then2990:
%val3009 = load i64, i64* %bitdepthPtr
%cmp3010 = icmp eq i64 %val3009, 24
br i1 %cmp3010, label %then3008, label %else3008

then3008:
%val3011 = load i64, i64* %bitdepthPtr
%cmp3012 = icmp eq i64 %val3011, 24
store i1 %cmp3012, i1* %ifptr3008
br label %ifcont3008

else3008:
%res3013 = call ccc i1 @impc_false()
store i1 %res3013, i1* %ifptr3008
br label %ifcont3008

ifcont3008:
%ifres3014 = load i1, i1* %ifptr3008

store i1 %ifres3014, i1* %ifptr2990
br label %ifcont2990

else2990:
%res3015 = call ccc i1 @impc_false()
store i1 %res3015, i1* %ifptr2990
br label %ifcont2990

ifcont2990:
%ifres3016 = load i1, i1* %ifptr2990

br i1 %ifres3016, label %then2989, label %else2989

then2989:
%val3018 = load i1, i1* %lePtr
br i1 %val3018, label %then3017, label %else3017

then3017:
%val3019 = load i8*, i8** %srcPtr
%val3020 = load float*, float** %destPtr
%val3021 = load i64, i64* %nsampPtr
call fastcc void @audiofile_24bitPCM_to_sample_le_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd(i8* %val3019, float* %val3020, i64 %val3021)
br label %ifcont3017

else3017:
%val3023 = load i8*, i8** %srcPtr
%val3024 = load float*, float** %destPtr
%val3025 = load i64, i64* %nsampPtr
call fastcc void @audiofile_24bitPCM_to_sample_be_adhoc_W3ZvaWQsaTgqLGZsb2F0KixpNjRd(i8* %val3023, float* %val3024, i64 %val3025)
br label %ifcont3017

ifcont3017:
%res3027 = call ccc i1 @impc_true()
ret i1 %res3027

else2989:
%var3028 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var3029 = bitcast [184 x i8]* @gsxtmaudiobuffer119 to i8*

%val3030 = call i32 (i8*, ...) @printf(i8* %var3028, i8* %var3029)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%res3032 = call ccc i1 @impc_false()
ret i1 %res3032
}
@gsxtmaudiobuffer122 = hidden constant [123 x i8] c"audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}** @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3054 = load i8*, i8** %_impzPtr
%zone3055 = bitcast i8* %tzone3054 to %mzone*

; let assign value to symbol audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd
%dat_audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd = call i8* @llvm_zone_malloc(%mzone* %zone3055, i64 8)
%audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFdPtr = bitcast i8* %dat_audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd to { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}***
%tzone3035 = load i8*, i8** %_impzPtr
%zone3036 = bitcast i8* %tzone3035 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3036)
; malloc closure structure
%clsptr3037 = call i8* @llvm_zone_malloc(%mzone* %zone3036, i64 24)
%closure3038 = bitcast i8* %clsptr3037 to { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}*

; malloc environment structure
%envptr3039 = call i8* @llvm_zone_malloc(%mzone* %zone3036, i64 8)
%environment3040 = bitcast i8* %envptr3039 to {{i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}***}*

; malloc closure address table
%addytable3041 = call %clsvar* @new_address_table()
%var3042 = bitcast [70 x i8]* @gsxtmaudiobuffer120 to i8*
%var3043 = bitcast [61 x i8]* @gsxtmaudiobuffer121 to i8*
%addytable3044 = call %clsvar* @add_address_table(%mzone* %zone3036, i8* %var3042, i32 0, i8* %var3043, i32 3, %clsvar* %addytable3041)
%address-table3045 = bitcast %clsvar* %addytable3044 to i8*

; insert table, function and environment into closure struct
%closure.table3048 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}, { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}* %closure3038, i32 0, i32 0
store i8* %address-table3045, i8** %closure.table3048
%closure.env3049 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}, { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}* %closure3038, i32 0, i32 1
store i8* %envptr3039, i8** %closure.env3049
%closure.func3050 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}, { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}* %closure3038, i32 0, i32 2
store i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)* @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd__2933, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)** %closure.func3050
%closure_size3051 = call i64 @llvm_zone_mark_size(%mzone* %zone3036)
call void @llvm_zone_ptr_set_size(i8* %clsptr3037, i64 %closure_size3051)
%wrapper_ptr3052 = call i8* @llvm_zone_malloc(%mzone* %zone3036, i64 8)
%closure_wrapper3053 = bitcast i8* %wrapper_ptr3052 to { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}**
store { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}* %closure3038, { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}** %closure_wrapper3053

; let value assignment
%audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd = select i1 true, { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}** %closure_wrapper3053, { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}** %closure_wrapper3053
store { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}** %audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd, { i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}*** %audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFdPtr

; add data to environment
; don't need to alloc for env var audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd
%tmp_envptr3047 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}***}* %environment3040, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}*** %audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFdPtr, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}**** %tmp_envptr3047


%val3056 = load {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}**, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}*** %audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFdPtr
ret {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}** %val3056
}


@audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}** @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd(i8* %arg_0,float* %arg_1,i64 %arg_2,i64 %arg_3,i64 %arg_4,i1 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*,  i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4, i1 %arg_5)
ret i1 %result
}


define dllexport ccc i1 @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_native(i8* %arg_0,float* %arg_1,i64 %arg_2,i64 %arg_3,i64 %arg_4,i1 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*,  i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4, i1 %arg_5)
ret i1 %result
}


define dllexport ccc i8*  @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3057 = bitcast [123 x i8]* @gsxtmaudiobuffer122 to i8*
call i32 (i8*, ...) @printf(i8* %var3057)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3058 = bitcast [123 x i8]* @gsxtmaudiobuffer122 to i8*
call i32 (i8*, ...) @printf(i8* %var3058)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3059 = bitcast [123 x i8]* @gsxtmaudiobuffer122 to i8*
call i32 (i8*, ...) @printf(i8* %var3059)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3060 = bitcast [123 x i8]* @gsxtmaudiobuffer122 to i8*
call i32 (i8*, ...) @printf(i8* %var3060)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var3061 = bitcast [123 x i8]* @gsxtmaudiobuffer122 to i8*
call i32 (i8*, ...) @printf(i8* %var3061)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var3062 = bitcast [123 x i8]* @gsxtmaudiobuffer122 to i8*
call i32 (i8*, ...) @printf(i8* %var3062)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i1  @i1value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*,  i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4, i1 %arg_5)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float*, i64, i64, i64, i1}*
%arg_p_0 = getelementptr {i8*, float*, i64, i64, i64, i1}, {i8*, float*, i64, i64, i64, i1}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float*, i64, i64, i64, i1}, {i8*, float*, i64, i64, i64, i1}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {i8*, float*, i64, i64, i64, i1}, {i8*, float*, i64, i64, i64, i1}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i8*, float*, i64, i64, i64, i1}, {i8*, float*, i64, i64, i64, i1}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {i8*, float*, i64, i64, i64, i1}, {i8*, float*, i64, i64, i64, i1}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
%arg_p_5 = getelementptr {i8*, float*, i64, i64, i64, i1}, {i8*, float*, i64, i64, i64, i1}* %fstruct, i32 0, i32 5
%arg_5 = load i1, i1* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)*,  i1 (i8*, i8*, i8*, float*, i64, i64, i64, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1, i64 %arg_2, i64 %arg_3, i64 %arg_4, i1 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%IffChunkHeader = type {[4 x i8],i32}
@gsxtmaudiobuffer123 = hidden constant [60 x i8] c"IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ\00"
@gsxtmaudiobuffer124 = hidden constant [58 x i8] c"{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**\00"
define dllexport fastcc %IffChunkHeader* @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ__3063(i8* %_impz,i8* %_impenv, [4 x i8] %arg_0, i32 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3064 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}*
%IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr_ = getelementptr {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}, {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}* %impenv, i32 0, i32 0
%IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**** %IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca [4 x i8]
store [4 x i8] %arg_0, [4 x i8]* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr


%tzone3069 = load i8*, i8** %_impzPtr
%zone3070 = bitcast i8* %tzone3069 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %IffChunkHeader*
%tzone3065 = load i8*, i8** %_impzPtr
%zone3066 = bitcast i8* %tzone3065 to %mzone*
%dat3067 = call i8* @llvm_zone_malloc(%mzone* %zone3066, i64 8)
call i8* @memset(i8* %dat3067, i32 0, i64 8)
%val3068 = bitcast i8* %dat3067 to %IffChunkHeader*

; let value assignment
%obj = select i1 true, %IffChunkHeader* %val3068, %IffChunkHeader* %val3068
store %IffChunkHeader* %obj, %IffChunkHeader** %objPtr

%val3071 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
%val3072 = load [4 x i8], [4 x i8]* %arg_0Ptr
; set tuple
%val3073 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3071, i64 0, i32 0
store [4 x i8] %val3072, [4 x i8]* %val3073
%val3074 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
%val3075 = load i32, i32* %arg_1Ptr
; set tuple
%val3076 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3074, i64 0, i32 1
store i32 %val3075, i32* %val3076
%val3077 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
ret %IffChunkHeader* %val3077
}
@gsxtmaudiobuffer125 = hidden constant [113 x i8] c"IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3097 = load i8*, i8** %_impzPtr
%zone3098 = bitcast i8* %tzone3097 to %mzone*

; let assign value to symbol IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ
%dat_IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone3098, i64 8)
%IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr = bitcast i8* %dat_IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ to { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***
%tzone3078 = load i8*, i8** %_impzPtr
%zone3079 = bitcast i8* %tzone3078 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3079)
; malloc closure structure
%clsptr3080 = call i8* @llvm_zone_malloc(%mzone* %zone3079, i64 24)
%closure3081 = bitcast i8* %clsptr3080 to { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*

; malloc environment structure
%envptr3082 = call i8* @llvm_zone_malloc(%mzone* %zone3079, i64 8)
%environment3083 = bitcast i8* %envptr3082 to {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}*

; malloc closure address table
%addytable3084 = call %clsvar* @new_address_table()
%var3085 = bitcast [60 x i8]* @gsxtmaudiobuffer123 to i8*
%var3086 = bitcast [58 x i8]* @gsxtmaudiobuffer124 to i8*
%addytable3087 = call %clsvar* @add_address_table(%mzone* %zone3079, i8* %var3085, i32 0, i8* %var3086, i32 3, %clsvar* %addytable3084)
%address-table3088 = bitcast %clsvar* %addytable3087 to i8*

; insert table, function and environment into closure struct
%closure.table3091 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure3081, i32 0, i32 0
store i8* %address-table3088, i8** %closure.table3091
%closure.env3092 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure3081, i32 0, i32 1
store i8* %envptr3082, i8** %closure.env3092
%closure.func3093 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure3081, i32 0, i32 2
store %IffChunkHeader* (i8*, i8*, [4 x i8], i32)* @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ__3063, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)** %closure.func3093
%closure_size3094 = call i64 @llvm_zone_mark_size(%mzone* %zone3079)
call void @llvm_zone_ptr_set_size(i8* %clsptr3080, i64 %closure_size3094)
%wrapper_ptr3095 = call i8* @llvm_zone_malloc(%mzone* %zone3079, i64 8)
%closure_wrapper3096 = bitcast i8* %wrapper_ptr3095 to { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**
store { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure3081, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_wrapper3096

; let value assignment
%IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ = select i1 true, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_wrapper3096, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_wrapper3096
store { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*** %IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr

; add data to environment
; don't need to alloc for env var IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ
%tmp_envptr3090 = getelementptr {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}, {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}* %environment3083, i32 0, i32 0
store {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*** %IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**** %tmp_envptr3090


%val3099 = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*** %IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr
ret {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %val3099
}


@IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %IffChunkHeader* @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ([4 x i8] %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*,  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, [4 x i8] %arg_0, i32 %arg_1)
ret %IffChunkHeader* %result
}


define dllexport ccc %IffChunkHeader* @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_native([4 x i8] %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*,  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, [4 x i8] %arg_0, i32 %arg_1)
ret %IffChunkHeader* %result
}


define dllexport ccc void @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[4 x i8], i32}*
%arg_p_0 = getelementptr {[4 x i8], i32}, {[4 x i8], i32}* %fstruct, i32 0, i32 0
%arg_0 = load [4 x i8], [4 x i8]* %arg_p_0
%arg_p_1 = getelementptr {[4 x i8], i32}, {[4 x i8], i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*,  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, [4 x i8] %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer126 = hidden constant [62 x i8] c"IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ\00"
define dllexport fastcc %IffChunkHeader* @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ__3101(i8* %_impz,i8* %_impenv, [4 x i8] %arg_0, i32 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3102 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}*
%IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr_ = getelementptr {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}, {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}* %impenv, i32 0, i32 0
%IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**** %IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca [4 x i8]
store [4 x i8] %arg_0, [4 x i8]* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr


%tzone3107 = load i8*, i8** %_impzPtr
%zone3108 = bitcast i8* %tzone3107 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %IffChunkHeader*
%tzone3103 = load i8*, i8** %_impzPtr
%zone3104 = bitcast i8* %tzone3103 to %mzone*
%dat3105 = call i8* @llvm_zone_malloc(%mzone* %zone3104, i64 8)
call i8* @memset(i8* %dat3105, i32 0, i64 8)
%val3106 = bitcast i8* %dat3105 to %IffChunkHeader*

; let value assignment
%obj = select i1 true, %IffChunkHeader* %val3106, %IffChunkHeader* %val3106
store %IffChunkHeader* %obj, %IffChunkHeader** %objPtr

%val3109 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
%val3110 = load [4 x i8], [4 x i8]* %arg_0Ptr
; set tuple
%val3111 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3109, i64 0, i32 0
store [4 x i8] %val3110, [4 x i8]* %val3111
%val3112 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
%val3113 = load i32, i32* %arg_1Ptr
; set tuple
%val3114 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3112, i64 0, i32 1
store i32 %val3113, i32* %val3114
%val3115 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
ret %IffChunkHeader* %val3115
}
@gsxtmaudiobuffer127 = hidden constant [115 x i8] c"IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3135 = load i8*, i8** %_impzPtr
%zone3136 = bitcast i8* %tzone3135 to %mzone*

; let assign value to symbol IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ
%dat_IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone3136, i64 8)
%IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr = bitcast i8* %dat_IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ to { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***
%tzone3116 = load i8*, i8** %_impzPtr
%zone3117 = bitcast i8* %tzone3116 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3117)
; malloc closure structure
%clsptr3118 = call i8* @llvm_zone_malloc(%mzone* %zone3117, i64 24)
%closure3119 = bitcast i8* %clsptr3118 to { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*

; malloc environment structure
%envptr3120 = call i8* @llvm_zone_malloc(%mzone* %zone3117, i64 8)
%environment3121 = bitcast i8* %envptr3120 to {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}*

; malloc closure address table
%addytable3122 = call %clsvar* @new_address_table()
%var3123 = bitcast [62 x i8]* @gsxtmaudiobuffer126 to i8*
%var3124 = bitcast [58 x i8]* @gsxtmaudiobuffer124 to i8*
%addytable3125 = call %clsvar* @add_address_table(%mzone* %zone3117, i8* %var3123, i32 0, i8* %var3124, i32 3, %clsvar* %addytable3122)
%address-table3126 = bitcast %clsvar* %addytable3125 to i8*

; insert table, function and environment into closure struct
%closure.table3129 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure3119, i32 0, i32 0
store i8* %address-table3126, i8** %closure.table3129
%closure.env3130 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure3119, i32 0, i32 1
store i8* %envptr3120, i8** %closure.env3130
%closure.func3131 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure3119, i32 0, i32 2
store %IffChunkHeader* (i8*, i8*, [4 x i8], i32)* @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ__3101, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)** %closure.func3131
%closure_size3132 = call i64 @llvm_zone_mark_size(%mzone* %zone3117)
call void @llvm_zone_ptr_set_size(i8* %clsptr3118, i64 %closure_size3132)
%wrapper_ptr3133 = call i8* @llvm_zone_malloc(%mzone* %zone3117, i64 8)
%closure_wrapper3134 = bitcast i8* %wrapper_ptr3133 to { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**
store { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure3119, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_wrapper3134

; let value assignment
%IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ = select i1 true, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_wrapper3134, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_wrapper3134
store { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*** %IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr

; add data to environment
; don't need to alloc for env var IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ
%tmp_envptr3128 = getelementptr {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}, {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}* %environment3121, i32 0, i32 0
store {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*** %IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**** %tmp_envptr3128


%val3137 = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*** %IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr
ret {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %val3137
}


@IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %IffChunkHeader* @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ([4 x i8] %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*,  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, [4 x i8] %arg_0, i32 %arg_1)
ret %IffChunkHeader* %result
}


define dllexport ccc %IffChunkHeader* @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_native([4 x i8] %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*,  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, [4 x i8] %arg_0, i32 %arg_1)
ret %IffChunkHeader* %result
}


define dllexport ccc void @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[4 x i8], i32}*
%arg_p_0 = getelementptr {[4 x i8], i32}, {[4 x i8], i32}* %fstruct, i32 0, i32 0
%arg_0 = load [4 x i8], [4 x i8]* %arg_p_0
%arg_p_1 = getelementptr {[4 x i8], i32}, {[4 x i8], i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_z_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*,  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, [4 x i8] %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer128 = hidden constant [62 x i8] c"IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ\00"
define dllexport fastcc %IffChunkHeader* @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ__3139(i8* %_impz,i8* %_impenv, [4 x i8] %arg_0, i32 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3140 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}*
%IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr_ = getelementptr {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}, {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}* %impenv, i32 0, i32 0
%IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**** %IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca [4 x i8]
store [4 x i8] %arg_0, [4 x i8]* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr


%tzone3143 = load i8*, i8** %_impzPtr
%zone3144 = bitcast i8* %tzone3143 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %IffChunkHeader*
%dat3141 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat3141, i32 0, i64 8)
%val3142 = bitcast i8* %dat3141 to %IffChunkHeader*

; let value assignment
%obj = select i1 true, %IffChunkHeader* %val3142, %IffChunkHeader* %val3142
store %IffChunkHeader* %obj, %IffChunkHeader** %objPtr

%val3145 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
%val3146 = load [4 x i8], [4 x i8]* %arg_0Ptr
; set tuple
%val3147 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3145, i64 0, i32 0
store [4 x i8] %val3146, [4 x i8]* %val3147
%val3148 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
%val3149 = load i32, i32* %arg_1Ptr
; set tuple
%val3150 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3148, i64 0, i32 1
store i32 %val3149, i32* %val3150
%val3151 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
ret %IffChunkHeader* %val3151
}
@gsxtmaudiobuffer129 = hidden constant [115 x i8] c"IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3171 = load i8*, i8** %_impzPtr
%zone3172 = bitcast i8* %tzone3171 to %mzone*

; let assign value to symbol IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ
%dat_IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone3172, i64 8)
%IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr = bitcast i8* %dat_IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ to { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***
%tzone3152 = load i8*, i8** %_impzPtr
%zone3153 = bitcast i8* %tzone3152 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3153)
; malloc closure structure
%clsptr3154 = call i8* @llvm_zone_malloc(%mzone* %zone3153, i64 24)
%closure3155 = bitcast i8* %clsptr3154 to { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*

; malloc environment structure
%envptr3156 = call i8* @llvm_zone_malloc(%mzone* %zone3153, i64 8)
%environment3157 = bitcast i8* %envptr3156 to {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}*

; malloc closure address table
%addytable3158 = call %clsvar* @new_address_table()
%var3159 = bitcast [62 x i8]* @gsxtmaudiobuffer128 to i8*
%var3160 = bitcast [58 x i8]* @gsxtmaudiobuffer124 to i8*
%addytable3161 = call %clsvar* @add_address_table(%mzone* %zone3153, i8* %var3159, i32 0, i8* %var3160, i32 3, %clsvar* %addytable3158)
%address-table3162 = bitcast %clsvar* %addytable3161 to i8*

; insert table, function and environment into closure struct
%closure.table3165 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure3155, i32 0, i32 0
store i8* %address-table3162, i8** %closure.table3165
%closure.env3166 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure3155, i32 0, i32 1
store i8* %envptr3156, i8** %closure.env3166
%closure.func3167 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure3155, i32 0, i32 2
store %IffChunkHeader* (i8*, i8*, [4 x i8], i32)* @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ__3139, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)** %closure.func3167
%closure_size3168 = call i64 @llvm_zone_mark_size(%mzone* %zone3153)
call void @llvm_zone_ptr_set_size(i8* %clsptr3154, i64 %closure_size3168)
%wrapper_ptr3169 = call i8* @llvm_zone_malloc(%mzone* %zone3153, i64 8)
%closure_wrapper3170 = bitcast i8* %wrapper_ptr3169 to { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**
store { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure3155, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_wrapper3170

; let value assignment
%IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ = select i1 true, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_wrapper3170, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_wrapper3170
store { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ, { i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*** %IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr

; add data to environment
; don't need to alloc for env var IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ
%tmp_envptr3164 = getelementptr {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}, {{i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}***}* %environment3157, i32 0, i32 0
store {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*** %IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**** %tmp_envptr3164


%val3173 = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*** %IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQPtr
ret {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %val3173
}


@IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %IffChunkHeader* @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ([4 x i8] %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*,  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, [4 x i8] %arg_0, i32 %arg_1)
ret %IffChunkHeader* %result
}


define dllexport ccc %IffChunkHeader* @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_native([4 x i8] %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*,  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, [4 x i8] %arg_0, i32 %arg_1)
ret %IffChunkHeader* %result
}


define dllexport ccc void @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[4 x i8], i32}*
%arg_p_0 = getelementptr {[4 x i8], i32}, {[4 x i8], i32}* %fstruct, i32 0, i32 0
%arg_0 = load [4 x i8], [4 x i8]* %arg_p_0
%arg_p_1 = getelementptr {[4 x i8], i32}, {[4 x i8], i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_h_adhoc_W0lmZkNodW5rSGVhZGVyKix8NCxpOHwsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)*,  %IffChunkHeader* (i8*, i8*, [4 x i8], i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, [4 x i8] %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer130 = hidden constant [62 x i8] c"IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd\00"
@gsxtmaudiobuffer131 = hidden constant [57 x i8] c"{i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}**\00"
define dllexport fastcc %IffChunkHeader @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd__3175(i8* %_impz,i8* %_impenv, [4 x i8] %arg_0, i32 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3176 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}***}*
%IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJdPtr_ = getelementptr {{i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}***}, {{i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}***}* %impenv, i32 0, i32 0
%IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJdPtr = load {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}***, {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}**** %IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJdPtr_

; setup arguments
%arg_0Ptr = alloca [4 x i8]
store [4 x i8] %arg_0, [4 x i8]* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr


%tzone3178 = load i8*, i8** %_impzPtr
%zone3179 = bitcast i8* %tzone3178 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %IffChunkHeader*
%dat3177 = alloca %IffChunkHeader, align 16

; let value assignment
%obj = select i1 true, %IffChunkHeader* %dat3177, %IffChunkHeader* %dat3177
store %IffChunkHeader* %obj, %IffChunkHeader** %objPtr

%val3180 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
%val3181 = load [4 x i8], [4 x i8]* %arg_0Ptr
; set tuple
%val3182 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3180, i64 0, i32 0
store [4 x i8] %val3181, [4 x i8]* %val3182
%val3183 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
%val3184 = load i32, i32* %arg_1Ptr
; set tuple
%val3185 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3183, i64 0, i32 1
store i32 %val3184, i32* %val3185
%val3186 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
; pointer ref
%val3187 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3186, i64 0
%val3188 = load %IffChunkHeader, %IffChunkHeader* %val3187
ret %IffChunkHeader %val3188
}
@gsxtmaudiobuffer132 = hidden constant [115 x i8] c"IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}** @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3208 = load i8*, i8** %_impzPtr
%zone3209 = bitcast i8* %tzone3208 to %mzone*

; let assign value to symbol IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd
%dat_IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone3209, i64 8)
%IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJdPtr = bitcast i8* %dat_IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd to { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}***
%tzone3189 = load i8*, i8** %_impzPtr
%zone3190 = bitcast i8* %tzone3189 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3190)
; malloc closure structure
%clsptr3191 = call i8* @llvm_zone_malloc(%mzone* %zone3190, i64 24)
%closure3192 = bitcast i8* %clsptr3191 to { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}*

; malloc environment structure
%envptr3193 = call i8* @llvm_zone_malloc(%mzone* %zone3190, i64 8)
%environment3194 = bitcast i8* %envptr3193 to {{i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}***}*

; malloc closure address table
%addytable3195 = call %clsvar* @new_address_table()
%var3196 = bitcast [62 x i8]* @gsxtmaudiobuffer130 to i8*
%var3197 = bitcast [57 x i8]* @gsxtmaudiobuffer131 to i8*
%addytable3198 = call %clsvar* @add_address_table(%mzone* %zone3190, i8* %var3196, i32 0, i8* %var3197, i32 3, %clsvar* %addytable3195)
%address-table3199 = bitcast %clsvar* %addytable3198 to i8*

; insert table, function and environment into closure struct
%closure.table3202 = getelementptr { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}, { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}* %closure3192, i32 0, i32 0
store i8* %address-table3199, i8** %closure.table3202
%closure.env3203 = getelementptr { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}, { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}* %closure3192, i32 0, i32 1
store i8* %envptr3193, i8** %closure.env3203
%closure.func3204 = getelementptr { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}, { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}* %closure3192, i32 0, i32 2
store %IffChunkHeader (i8*, i8*, [4 x i8], i32)* @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd__3175, %IffChunkHeader (i8*, i8*, [4 x i8], i32)** %closure.func3204
%closure_size3205 = call i64 @llvm_zone_mark_size(%mzone* %zone3190)
call void @llvm_zone_ptr_set_size(i8* %clsptr3191, i64 %closure_size3205)
%wrapper_ptr3206 = call i8* @llvm_zone_malloc(%mzone* %zone3190, i64 8)
%closure_wrapper3207 = bitcast i8* %wrapper_ptr3206 to { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}**
store { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}* %closure3192, { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}** %closure_wrapper3207

; let value assignment
%IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd = select i1 true, { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}** %closure_wrapper3207, { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}** %closure_wrapper3207
store { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}** %IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd, { i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}*** %IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJdPtr

; add data to environment
; don't need to alloc for env var IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd
%tmp_envptr3201 = getelementptr {{i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}***}, {{i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}***}* %environment3194, i32 0, i32 0
store {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}*** %IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJdPtr, {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}**** %tmp_envptr3201


%val3210 = load {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}**, {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}*** %IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJdPtr
ret {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}** %val3210
}


@IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}** @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %IffChunkHeader @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd([4 x i8] %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}**
%closure = load {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}*, {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader (i8*, i8*, [4 x i8], i32)*,  %IffChunkHeader (i8*, i8*, [4 x i8], i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader %ff(i8* %_impz, i8* %ee, [4 x i8] %arg_0, i32 %arg_1)
ret %IffChunkHeader %result
}


define dllexport ccc %IffChunkHeader @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_native([4 x i8] %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}**
%closure = load {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}*, {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader (i8*, i8*, [4 x i8], i32)*,  %IffChunkHeader (i8*, i8*, [4 x i8], i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader %ff(i8* %_impz, i8* %ee, [4 x i8] %arg_0, i32 %arg_1)
ret %IffChunkHeader %result
}


define dllexport ccc void @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {[4 x i8], i32}*
%arg_p_0 = getelementptr {[4 x i8], i32}, {[4 x i8], i32}* %fstruct, i32 0, i32 0
%arg_0 = load [4 x i8], [4 x i8]* %arg_p_0
%arg_p_1 = getelementptr {[4 x i8], i32}, {[4 x i8], i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @IffChunkHeader_val_adhoc_W0lmZkNodW5rSGVhZGVyLHw0LGk4fCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}**
%closure = load {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}*, {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}, {i8*, i8*, %IffChunkHeader (i8*, i8*, [4 x i8], i32)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader (i8*, i8*, [4 x i8], i32)*,  %IffChunkHeader (i8*, i8*, [4 x i8], i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader %ff(i8* %_impz, i8* %ee, [4 x i8] %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer133 = hidden constant [57 x i8] c"hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd\00"
@gsxtmaudiobuffer134 = hidden constant [61 x i8] c"{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}**\00"
define dllexport fastcc %IffChunkHeader* @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd__3212(i8* %_impz,i8* %_impenv, %IffChunkHeader* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3213 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}***}*
%hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipdPtr_ = getelementptr {{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}***}, {{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipdPtr = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}***, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}**** %hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipdPtr_

; setup arguments
%xPtr = alloca %IffChunkHeader*
store %IffChunkHeader* %x, %IffChunkHeader** %xPtr


%tzone3216 = load i8*, i8** %_impzPtr
%zone3217 = bitcast i8* %tzone3216 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %IffChunkHeader*
%dat3214 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat3214, i32 0, i64 8)
%val3215 = bitcast i8* %dat3214 to %IffChunkHeader*

; let value assignment
%obj = select i1 true, %IffChunkHeader* %val3215, %IffChunkHeader* %val3215
store %IffChunkHeader* %obj, %IffChunkHeader** %objPtr

%val3218 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
%val3219 = load %IffChunkHeader*, %IffChunkHeader** %xPtr
; tuple ref
%val3220 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3219, i64 0, i32 0
%val3221 = load [4 x i8], [4 x i8]* %val3220
; set tuple
%val3222 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3218, i64 0, i32 0
store [4 x i8] %val3221, [4 x i8]* %val3222
%val3223 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
%val3224 = load %IffChunkHeader*, %IffChunkHeader** %xPtr
; tuple ref
%val3225 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3224, i64 0, i32 1
%val3226 = load i32, i32* %val3225
; set tuple
%val3227 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3223, i64 0, i32 1
store i32 %val3226, i32* %val3227
%val3228 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
ret %IffChunkHeader* %val3228
}
@gsxtmaudiobuffer135 = hidden constant [110 x i8] c"hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}** @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3248 = load i8*, i8** %_impzPtr
%zone3249 = bitcast i8* %tzone3248 to %mzone*

; let assign value to symbol hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd
%dat_hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd = call i8* @llvm_zone_malloc(%mzone* %zone3249, i64 8)
%hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipdPtr = bitcast i8* %dat_hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd to { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}***
%tzone3229 = load i8*, i8** %_impzPtr
%zone3230 = bitcast i8* %tzone3229 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3230)
; malloc closure structure
%clsptr3231 = call i8* @llvm_zone_malloc(%mzone* %zone3230, i64 24)
%closure3232 = bitcast i8* %clsptr3231 to { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}*

; malloc environment structure
%envptr3233 = call i8* @llvm_zone_malloc(%mzone* %zone3230, i64 8)
%environment3234 = bitcast i8* %envptr3233 to {{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}***}*

; malloc closure address table
%addytable3235 = call %clsvar* @new_address_table()
%var3236 = bitcast [57 x i8]* @gsxtmaudiobuffer133 to i8*
%var3237 = bitcast [61 x i8]* @gsxtmaudiobuffer134 to i8*
%addytable3238 = call %clsvar* @add_address_table(%mzone* %zone3230, i8* %var3236, i32 0, i8* %var3237, i32 3, %clsvar* %addytable3235)
%address-table3239 = bitcast %clsvar* %addytable3238 to i8*

; insert table, function and environment into closure struct
%closure.table3242 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}* %closure3232, i32 0, i32 0
store i8* %address-table3239, i8** %closure.table3242
%closure.env3243 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}* %closure3232, i32 0, i32 1
store i8* %envptr3233, i8** %closure.env3243
%closure.func3244 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}* %closure3232, i32 0, i32 2
store %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)* @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd__3212, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)** %closure.func3244
%closure_size3245 = call i64 @llvm_zone_mark_size(%mzone* %zone3230)
call void @llvm_zone_ptr_set_size(i8* %clsptr3231, i64 %closure_size3245)
%wrapper_ptr3246 = call i8* @llvm_zone_malloc(%mzone* %zone3230, i64 8)
%closure_wrapper3247 = bitcast i8* %wrapper_ptr3246 to { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}**
store { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}* %closure3232, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}** %closure_wrapper3247

; let value assignment
%hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd = select i1 true, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}** %closure_wrapper3247, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}** %closure_wrapper3247
store { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}** %hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}*** %hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipdPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd
%tmp_envptr3241 = getelementptr {{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}***}, {{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}***}* %environment3234, i32 0, i32 0
store {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}*** %hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipdPtr, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}**** %tmp_envptr3241


%val3250 = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}**, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}*** %hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipdPtr
ret {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}** %val3250
}


@hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}** @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %IffChunkHeader* @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd(%IffChunkHeader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*,  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
ret %IffChunkHeader* %result
}


define dllexport ccc %IffChunkHeader* @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_native(%IffChunkHeader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*,  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
ret %IffChunkHeader* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3251 = bitcast [110 x i8]* @gsxtmaudiobuffer135 to i8*
call i32 (i8*, ...) @printf(i8* %var3251)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %IffChunkHeader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*,  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
%tmpres = bitcast %IffChunkHeader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%IffChunkHeader*}*
%arg_p_0 = getelementptr {%IffChunkHeader*}, {%IffChunkHeader*}* %fstruct, i32 0, i32 0
%arg_0 = load %IffChunkHeader*, %IffChunkHeader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)*,  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer136 = hidden constant [43 x i8] c"hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ\00"
@gsxtmaudiobuffer137 = hidden constant [49 x i8] c"{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ__3252(i8* %_impz,i8* %_impenv, %IffChunkHeader* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3253 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***}*
%hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***}, {{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr = load {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**** %hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr_

; setup arguments
%xPtr = alloca %IffChunkHeader*
store %IffChunkHeader* %x, %IffChunkHeader** %xPtr


%val3254 = load %IffChunkHeader*, %IffChunkHeader** %xPtr
%val3255 = bitcast %IffChunkHeader* %val3254 to i8*
call ccc void @free(i8* %val3255)
ret void
}
@gsxtmaudiobuffer138 = hidden constant [96 x i8] c"hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3277 = load i8*, i8** %_impzPtr
%zone3278 = bitcast i8* %tzone3277 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ
%dat_hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3278, i64 8)
%hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ to { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***
%tzone3258 = load i8*, i8** %_impzPtr
%zone3259 = bitcast i8* %tzone3258 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3259)
; malloc closure structure
%clsptr3260 = call i8* @llvm_zone_malloc(%mzone* %zone3259, i64 24)
%closure3261 = bitcast i8* %clsptr3260 to { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*

; malloc environment structure
%envptr3262 = call i8* @llvm_zone_malloc(%mzone* %zone3259, i64 8)
%environment3263 = bitcast i8* %envptr3262 to {{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***}*

; malloc closure address table
%addytable3264 = call %clsvar* @new_address_table()
%var3265 = bitcast [43 x i8]* @gsxtmaudiobuffer136 to i8*
%var3266 = bitcast [49 x i8]* @gsxtmaudiobuffer137 to i8*
%addytable3267 = call %clsvar* @add_address_table(%mzone* %zone3259, i8* %var3265, i32 0, i8* %var3266, i32 3, %clsvar* %addytable3264)
%address-table3268 = bitcast %clsvar* %addytable3267 to i8*

; insert table, function and environment into closure struct
%closure.table3271 = getelementptr { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure3261, i32 0, i32 0
store i8* %address-table3268, i8** %closure.table3271
%closure.env3272 = getelementptr { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure3261, i32 0, i32 1
store i8* %envptr3262, i8** %closure.env3272
%closure.func3273 = getelementptr { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure3261, i32 0, i32 2
store void (i8*, i8*, %IffChunkHeader*)* @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ__3252, void (i8*, i8*, %IffChunkHeader*)** %closure.func3273
%closure_size3274 = call i64 @llvm_zone_mark_size(%mzone* %zone3259)
call void @llvm_zone_ptr_set_size(i8* %clsptr3260, i64 %closure_size3274)
%wrapper_ptr3275 = call i8* @llvm_zone_malloc(%mzone* %zone3259, i64 8)
%closure_wrapper3276 = bitcast i8* %wrapper_ptr3275 to { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**
store { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure3261, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_wrapper3276

; let value assignment
%hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_wrapper3276, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_wrapper3276
store { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*** %hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ
%tmp_envptr3270 = getelementptr {{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***}, {{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***}* %environment3263, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*** %hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**** %tmp_envptr3270


%val3279 = load {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*** %hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr
ret {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %val3279
}


@hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ(%IffChunkHeader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %IffChunkHeader*)*,  void (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_native(%IffChunkHeader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %IffChunkHeader*)*,  void (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3280 = bitcast [96 x i8]* @gsxtmaudiobuffer138 to i8*
call i32 (i8*, ...) @printf(i8* %var3280)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %IffChunkHeader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %IffChunkHeader*)*,  void (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%IffChunkHeader*}*
%arg_p_0 = getelementptr {%IffChunkHeader*}, {%IffChunkHeader*}* %fstruct, i32 0, i32 0
%arg_0 = load %IffChunkHeader*, %IffChunkHeader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %IffChunkHeader*)*,  void (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer139 = hidden constant [76 x i8] c"zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0\00"
@gsxtmaudiobuffer140 = hidden constant [79 x i8] c"{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %IffChunkHeader* @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0__3281(i8* %_impz,i8* %_impenv, %IffChunkHeader* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3282 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0Ptr_ = getelementptr {{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0Ptr = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}***, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0Ptr_

; setup arguments
%xPtr = alloca %IffChunkHeader*
store %IffChunkHeader* %x, %IffChunkHeader** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val3284 = load %mzone*, %mzone** %fromzPtr
%val3285 = load %IffChunkHeader*, %IffChunkHeader** %xPtr
%val3286 = bitcast %IffChunkHeader* %val3285 to i8*
%res3287 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3284, i8* %val3286)
br i1 %res3287, label %then3283, label %else3283

then3283:
%val3288 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val3288)
%zone_ptr3289 = bitcast %mzone* %val3288 to i8*
store i8* %zone_ptr3289, i8** %_impzPtr
%tzone3295 = load i8*, i8** %_impzPtr
%zone3296 = bitcast i8* %tzone3295 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %IffChunkHeader*
%tzone3291 = load i8*, i8** %_impzPtr
%zone3292 = bitcast i8* %tzone3291 to %mzone*
%dat3293 = call i8* @llvm_zone_malloc(%mzone* %zone3292, i64 8)
call i8* @memset(i8* %dat3293, i32 0, i64 8)
%val3294 = bitcast i8* %dat3293 to %IffChunkHeader*

; let value assignment
%obj = select i1 true, %IffChunkHeader* %val3294, %IffChunkHeader* %val3294
store %IffChunkHeader* %obj, %IffChunkHeader** %objPtr

%val3297 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
%val3298 = load %IffChunkHeader*, %IffChunkHeader** %xPtr
; tuple ref
%val3299 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3298, i64 0, i32 0
%val3300 = load [4 x i8], [4 x i8]* %val3299
; set tuple
%val3301 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3297, i64 0, i32 0
store [4 x i8] %val3300, [4 x i8]* %val3301
%val3302 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
%val3303 = load %IffChunkHeader*, %IffChunkHeader** %xPtr
; tuple ref
%val3304 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3303, i64 0, i32 1
%val3305 = load i32, i32* %val3304
; set tuple
%val3306 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3302, i64 0, i32 1
store i32 %val3305, i32* %val3306
%oldzone3307 = call %mzone* @llvm_pop_zone_stack()
%newzone3308 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3309 = bitcast %mzone* %newzone3308 to i8*
store i8* %zone_ptr3309, i8** %_impzPtr
%val3310 = load %IffChunkHeader*, %IffChunkHeader** %objPtr
ret %IffChunkHeader* %val3310

else3283:
%val3311 = load %IffChunkHeader*, %IffChunkHeader** %xPtr
ret %IffChunkHeader* %val3311
}
@gsxtmaudiobuffer141 = hidden constant [129 x i8] c"zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3331 = load i8*, i8** %_impzPtr
%zone3332 = bitcast i8* %tzone3331 to %mzone*

; let assign value to symbol zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0
%dat_zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3332, i64 8)
%zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0Ptr = bitcast i8* %dat_zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0 to { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}***
%tzone3312 = load i8*, i8** %_impzPtr
%zone3313 = bitcast i8* %tzone3312 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3313)
; malloc closure structure
%clsptr3314 = call i8* @llvm_zone_malloc(%mzone* %zone3313, i64 24)
%closure3315 = bitcast i8* %clsptr3314 to { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr3316 = call i8* @llvm_zone_malloc(%mzone* %zone3313, i64 8)
%environment3317 = bitcast i8* %envptr3316 to {{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable3318 = call %clsvar* @new_address_table()
%var3319 = bitcast [76 x i8]* @gsxtmaudiobuffer139 to i8*
%var3320 = bitcast [79 x i8]* @gsxtmaudiobuffer140 to i8*
%addytable3321 = call %clsvar* @add_address_table(%mzone* %zone3313, i8* %var3319, i32 0, i8* %var3320, i32 3, %clsvar* %addytable3318)
%address-table3322 = bitcast %clsvar* %addytable3321 to i8*

; insert table, function and environment into closure struct
%closure.table3325 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}* %closure3315, i32 0, i32 0
store i8* %address-table3322, i8** %closure.table3325
%closure.env3326 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}* %closure3315, i32 0, i32 1
store i8* %envptr3316, i8** %closure.env3326
%closure.func3327 = getelementptr { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}* %closure3315, i32 0, i32 2
store %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)* @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0__3281, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)** %closure.func3327
%closure_size3328 = call i64 @llvm_zone_mark_size(%mzone* %zone3313)
call void @llvm_zone_ptr_set_size(i8* %clsptr3314, i64 %closure_size3328)
%wrapper_ptr3329 = call i8* @llvm_zone_malloc(%mzone* %zone3313, i64 8)
%closure_wrapper3330 = bitcast i8* %wrapper_ptr3329 to { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}**
store { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}* %closure3315, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}** %closure_wrapper3330

; let value assignment
%zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0 = select i1 true, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}** %closure_wrapper3330, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}** %closure_wrapper3330
store { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}** %zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0, { i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0Ptr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0
%tmp_envptr3324 = getelementptr {{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}***}* %environment3317, i32 0, i32 0
store {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0Ptr, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}**** %tmp_envptr3324


%val3333 = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}**, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0Ptr
ret {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}** %val3333
}


@zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %IffChunkHeader* @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0(%IffChunkHeader* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*,  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %IffChunkHeader* %result
}


define dllexport ccc %IffChunkHeader* @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_native(%IffChunkHeader* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*,  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %IffChunkHeader* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3334 = bitcast [129 x i8]* @gsxtmaudiobuffer141 to i8*
call i32 (i8*, ...) @printf(i8* %var3334)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %IffChunkHeader*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3335 = bitcast [129 x i8]* @gsxtmaudiobuffer141 to i8*
call i32 (i8*, ...) @printf(i8* %var3335)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3336 = bitcast [129 x i8]* @gsxtmaudiobuffer141 to i8*
call i32 (i8*, ...) @printf(i8* %var3336)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*,  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %IffChunkHeader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%IffChunkHeader*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%IffChunkHeader*, %mzone*, %mzone*}, {%IffChunkHeader*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %IffChunkHeader*, %IffChunkHeader** %arg_p_0
%arg_p_1 = getelementptr {%IffChunkHeader*, %mzone*, %mzone*}, {%IffChunkHeader*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%IffChunkHeader*, %mzone*, %mzone*}, {%IffChunkHeader*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0lmZkNodW5rSGVhZGVyKixJZmZDaHVua0hlYWRlciosbXpvbmUqLG16b25lKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}*, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}, {i8*, i8*, %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)*,  %IffChunkHeader* (i8*, i8*, %IffChunkHeader*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %IffChunkHeader* %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@IFF_CHUNK_HEADER_SIZE = dllexport global i64 8
@gsxtmaudiobuffer142 = hidden constant [57 x i8] c"iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd\00"
@gsxtmaudiobuffer143 = hidden constant [52 x i8] c"{i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}**\00"
define dllexport fastcc i1 @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd__3337(i8* %_impz,i8* %_impenv, %IffChunkHeader* %hdr, i8* %id) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3338 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}***}*
%iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpdPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}***}* %impenv, i32 0, i32 0
%iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpdPtr = load {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}***, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}**** %iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpdPtr_

; setup arguments
%hdrPtr = alloca %IffChunkHeader*
store %IffChunkHeader* %hdr, %IffChunkHeader** %hdrPtr
%idPtr = alloca i8*
store i8* %id, i8** %idPtr


%val3339 = load %IffChunkHeader*, %IffChunkHeader** %hdrPtr
; tuple ref
%val3340 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3339, i64 0, i32 0
; array ref
%val3341 = getelementptr [4 x i8], [4 x i8]* %val3340, i32 0, i64 0
%val3342 = load i8*, i8** %idPtr
%res3343 = call ccc i32 @strncmp(i8* %val3341, i8* %val3342, i64 4)
%cmp3344 = icmp eq i32 %res3343, 0
ret i1 %cmp3344
}
@gsxtmaudiobuffer144 = hidden constant [110 x i8] c"iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}** @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3364 = load i8*, i8** %_impzPtr
%zone3365 = bitcast i8* %tzone3364 to %mzone*

; let assign value to symbol iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd
%dat_iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone3365, i64 8)
%iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpdPtr = bitcast i8* %dat_iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd to { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}***
%tzone3345 = load i8*, i8** %_impzPtr
%zone3346 = bitcast i8* %tzone3345 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3346)
; malloc closure structure
%clsptr3347 = call i8* @llvm_zone_malloc(%mzone* %zone3346, i64 24)
%closure3348 = bitcast i8* %clsptr3347 to { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}*

; malloc environment structure
%envptr3349 = call i8* @llvm_zone_malloc(%mzone* %zone3346, i64 8)
%environment3350 = bitcast i8* %envptr3349 to {{i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}***}*

; malloc closure address table
%addytable3351 = call %clsvar* @new_address_table()
%var3352 = bitcast [57 x i8]* @gsxtmaudiobuffer142 to i8*
%var3353 = bitcast [52 x i8]* @gsxtmaudiobuffer143 to i8*
%addytable3354 = call %clsvar* @add_address_table(%mzone* %zone3346, i8* %var3352, i32 0, i8* %var3353, i32 3, %clsvar* %addytable3351)
%address-table3355 = bitcast %clsvar* %addytable3354 to i8*

; insert table, function and environment into closure struct
%closure.table3358 = getelementptr { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}, { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}* %closure3348, i32 0, i32 0
store i8* %address-table3355, i8** %closure.table3358
%closure.env3359 = getelementptr { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}, { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}* %closure3348, i32 0, i32 1
store i8* %envptr3349, i8** %closure.env3359
%closure.func3360 = getelementptr { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}, { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}* %closure3348, i32 0, i32 2
store i1 (i8*, i8*, %IffChunkHeader*, i8*)* @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd__3337, i1 (i8*, i8*, %IffChunkHeader*, i8*)** %closure.func3360
%closure_size3361 = call i64 @llvm_zone_mark_size(%mzone* %zone3346)
call void @llvm_zone_ptr_set_size(i8* %clsptr3347, i64 %closure_size3361)
%wrapper_ptr3362 = call i8* @llvm_zone_malloc(%mzone* %zone3346, i64 8)
%closure_wrapper3363 = bitcast i8* %wrapper_ptr3362 to { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}**
store { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}* %closure3348, { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}** %closure_wrapper3363

; let value assignment
%iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd = select i1 true, { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}** %closure_wrapper3363, { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}** %closure_wrapper3363
store { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}** %iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd, { i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}*** %iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpdPtr

; add data to environment
; don't need to alloc for env var iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd
%tmp_envptr3357 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}***}, {{i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}***}* %environment3350, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}*** %iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpdPtr, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}**** %tmp_envptr3357


%val3366 = load {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}**, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}*** %iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpdPtr
ret {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}** %val3366
}


@iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}** @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd(%IffChunkHeader* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %IffChunkHeader*, i8*)*,  i1 (i8*, i8*, %IffChunkHeader*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0, i8* %arg_1)
ret i1 %result
}


define dllexport ccc i1 @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_native(%IffChunkHeader* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %IffChunkHeader*, i8*)*,  i1 (i8*, i8*, %IffChunkHeader*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0, i8* %arg_1)
ret i1 %result
}


define dllexport ccc i8*  @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3367 = bitcast [110 x i8]* @gsxtmaudiobuffer144 to i8*
call i32 (i8*, ...) @printf(i8* %var3367)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %IffChunkHeader*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3368 = bitcast [110 x i8]* @gsxtmaudiobuffer144 to i8*
call i32 (i8*, ...) @printf(i8* %var3368)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %IffChunkHeader*, i8*)*,  i1 (i8*, i8*, %IffChunkHeader*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0, i8* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%IffChunkHeader*, i8*}*
%arg_p_0 = getelementptr {%IffChunkHeader*, i8*}, {%IffChunkHeader*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load %IffChunkHeader*, %IffChunkHeader** %arg_p_0
%arg_p_1 = getelementptr {%IffChunkHeader*, i8*}, {%IffChunkHeader*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, %IffChunkHeader*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %IffChunkHeader*, i8*)*,  i1 (i8*, i8*, %IffChunkHeader*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer145 = hidden constant [53 x i8] c"iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd\00"
@gsxtmaudiobuffer146 = hidden constant [52 x i8] c"{i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}**\00"
define dllexport fastcc i32 @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd__3369(i8* %_impz,i8* %_impenv, %IffChunkHeader* %hdr, i1 %le) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3370 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}***}*
%iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}***}, {{i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}***}* %impenv, i32 0, i32 0
%iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFdPtr = load {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}***, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}**** %iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFdPtr_

; setup arguments
%hdrPtr = alloca %IffChunkHeader*
store %IffChunkHeader* %hdr, %IffChunkHeader** %hdrPtr
%lePtr = alloca i1
store i1 %le, i1* %lePtr


%val3372 = load i1, i1* %lePtr
br i1 %val3372, label %then3371, label %else3371

then3371:
%val3373 = load %IffChunkHeader*, %IffChunkHeader** %hdrPtr
; tuple ref
%val3374 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3373, i64 0, i32 1
%val3375 = load i32, i32* %val3374
ret i32 %val3375

else3371:
%val3376 = load %IffChunkHeader*, %IffChunkHeader** %hdrPtr
; tuple ref
%val3377 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3376, i64 0, i32 1
%val3378 = load i32, i32* %val3377
%res3379 = call ccc i32 @swapi32(i32 %val3378)
ret i32 %res3379
}
@gsxtmaudiobuffer147 = hidden constant [106 x i8] c"iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}** @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3399 = load i8*, i8** %_impzPtr
%zone3400 = bitcast i8* %tzone3399 to %mzone*

; let assign value to symbol iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd
%dat_iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd = call i8* @llvm_zone_malloc(%mzone* %zone3400, i64 8)
%iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFdPtr = bitcast i8* %dat_iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd to { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}***
%tzone3380 = load i8*, i8** %_impzPtr
%zone3381 = bitcast i8* %tzone3380 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3381)
; malloc closure structure
%clsptr3382 = call i8* @llvm_zone_malloc(%mzone* %zone3381, i64 24)
%closure3383 = bitcast i8* %clsptr3382 to { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}*

; malloc environment structure
%envptr3384 = call i8* @llvm_zone_malloc(%mzone* %zone3381, i64 8)
%environment3385 = bitcast i8* %envptr3384 to {{i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}***}*

; malloc closure address table
%addytable3386 = call %clsvar* @new_address_table()
%var3387 = bitcast [53 x i8]* @gsxtmaudiobuffer145 to i8*
%var3388 = bitcast [52 x i8]* @gsxtmaudiobuffer146 to i8*
%addytable3389 = call %clsvar* @add_address_table(%mzone* %zone3381, i8* %var3387, i32 0, i8* %var3388, i32 3, %clsvar* %addytable3386)
%address-table3390 = bitcast %clsvar* %addytable3389 to i8*

; insert table, function and environment into closure struct
%closure.table3393 = getelementptr { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}, { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}* %closure3383, i32 0, i32 0
store i8* %address-table3390, i8** %closure.table3393
%closure.env3394 = getelementptr { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}, { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}* %closure3383, i32 0, i32 1
store i8* %envptr3384, i8** %closure.env3394
%closure.func3395 = getelementptr { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}, { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}* %closure3383, i32 0, i32 2
store i32 (i8*, i8*, %IffChunkHeader*, i1)* @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd__3369, i32 (i8*, i8*, %IffChunkHeader*, i1)** %closure.func3395
%closure_size3396 = call i64 @llvm_zone_mark_size(%mzone* %zone3381)
call void @llvm_zone_ptr_set_size(i8* %clsptr3382, i64 %closure_size3396)
%wrapper_ptr3397 = call i8* @llvm_zone_malloc(%mzone* %zone3381, i64 8)
%closure_wrapper3398 = bitcast i8* %wrapper_ptr3397 to { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}**
store { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}* %closure3383, { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}** %closure_wrapper3398

; let value assignment
%iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}** %closure_wrapper3398, { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}** %closure_wrapper3398
store { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}** %iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd, { i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}*** %iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFdPtr

; add data to environment
; don't need to alloc for env var iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd
%tmp_envptr3392 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}***}, {{i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}***}* %environment3385, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}*** %iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFdPtr, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}**** %tmp_envptr3392


%val3401 = load {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}**, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}*** %iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFdPtr
ret {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}** %val3401
}


@iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}** @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd(%IffChunkHeader* %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}*, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %IffChunkHeader*, i1)*,  i32 (i8*, i8*, %IffChunkHeader*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0, i1 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_native(%IffChunkHeader* %arg_0,i1 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}*, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %IffChunkHeader*, i1)*,  i32 (i8*, i8*, %IffChunkHeader*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0, i1 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3402 = bitcast [106 x i8]* @gsxtmaudiobuffer147 to i8*
call i32 (i8*, ...) @printf(i8* %var3402)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %IffChunkHeader*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3403 = bitcast [106 x i8]* @gsxtmaudiobuffer147 to i8*
call i32 (i8*, ...) @printf(i8* %var3403)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i1  @i1value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}*, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %IffChunkHeader*, i1)*,  i32 (i8*, i8*, %IffChunkHeader*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0, i1 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%IffChunkHeader*, i1}*
%arg_p_0 = getelementptr {%IffChunkHeader*, i1}, {%IffChunkHeader*, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %IffChunkHeader*, %IffChunkHeader** %arg_p_0
%arg_p_1 = getelementptr {%IffChunkHeader*, i1}, {%IffChunkHeader*, i1}* %fstruct, i32 0, i32 1
%arg_1 = load i1, i1* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}*, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}, {i8*, i8*, i32 (i8*, i8*, %IffChunkHeader*, i1)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %IffChunkHeader*, i1)*,  i32 (i8*, i8*, %IffChunkHeader*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0, i1 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer148 = hidden constant [49 x i8] c"iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ\00"
@gsxtmaudiobuffer149 = hidden constant [44 x i8] c"{i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}**\00"
define dllexport fastcc i8* @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ__3404(i8* %_impz,i8* %_impenv, i8* %fileptr, i8* %id, i1 %le) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3405 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}***}*
%iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}***}* %impenv, i32 0, i32 0
%iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQPtr = load {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}***, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}**** %iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQPtr_

; setup arguments
%fileptrPtr = alloca i8*
store i8* %fileptr, i8** %fileptrPtr
%idPtr = alloca i8*
store i8* %id, i8** %idPtr
%lePtr = alloca i1
store i1 %le, i1* %lePtr

; promote local stack var allocations
%tzone3434 = load i8*, i8** %_impzPtr
%zone3435 = bitcast i8* %tzone3434 to %mzone*
%ifptr3424 = alloca i1
%ifptr3407 = alloca i1

; while loop
%val3408 = load i8*, i8** %fileptrPtr
%val3409 = bitcast i8* %val3408 to %IffChunkHeader*
%val3410 = load i8*, i8** %idPtr
%res3411 = call fastcc i1 @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd(%IffChunkHeader* %val3409, i8* %val3410)
br i1 %res3411, label %then3407, label %else3407

then3407:
%res3412 = call ccc i1 @impc_false()
store i1 %res3412, i1* %ifptr3407
br label %ifcont3407

else3407:
%res3413 = call ccc i1 @impc_true()
store i1 %res3413, i1* %ifptr3407
br label %ifcont3407

ifcont3407:
%ifres3414 = load i1, i1* %ifptr3407

br i1 %ifres3414, label %loop3406, label %after3406

loop3406:
; do set!
%val3415 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val3416 = load i8*, i8** %fileptrPtr
%val3417 = bitcast i8* %val3416 to %IffChunkHeader*
%val3418 = load i1, i1* %lePtr
%res3419 = call fastcc i32 @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd(%IffChunkHeader* %val3417, i1 %val3418)
%val3420 = sext i32 %res3419 to i64
%val3421 = add i64 %val3415, %val3420
%val3422 = load i8*, i8** %fileptrPtr
; pointer ref
%val3423 = getelementptr i8, i8* %val3422, i64 %val3421
store i8* %val3423, i8** %fileptrPtr
%val3425 = load i8*, i8** %fileptrPtr
%val3426 = bitcast i8* %val3425 to %IffChunkHeader*
%val3427 = load i8*, i8** %idPtr
%res3428 = call fastcc i1 @iffchunk_check_ID_adhoc_W2kxLElmZkNodW5rSGVhZGVyKixpOCpd(%IffChunkHeader* %val3426, i8* %val3427)
br i1 %res3428, label %then3424, label %else3424

then3424:
%res3429 = call ccc i1 @impc_false()
store i1 %res3429, i1* %ifptr3424
br label %ifcont3424

else3424:
%res3430 = call ccc i1 @impc_true()
store i1 %res3430, i1* %ifptr3424
br label %ifcont3424

ifcont3424:
%ifres3431 = load i1, i1* %ifptr3424

br i1 %ifres3431, label %loop3406, label %after3406

after3406:
%val3433 = load i8*, i8** %fileptrPtr
ret i8* %val3433
}
@gsxtmaudiobuffer150 = hidden constant [102 x i8] c"iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}** @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3455 = load i8*, i8** %_impzPtr
%zone3456 = bitcast i8* %tzone3455 to %mzone*

; let assign value to symbol iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ
%dat_iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ = call i8* @llvm_zone_malloc(%mzone* %zone3456, i64 8)
%iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQPtr = bitcast i8* %dat_iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ to { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}***
%tzone3436 = load i8*, i8** %_impzPtr
%zone3437 = bitcast i8* %tzone3436 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3437)
; malloc closure structure
%clsptr3438 = call i8* @llvm_zone_malloc(%mzone* %zone3437, i64 24)
%closure3439 = bitcast i8* %clsptr3438 to { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}*

; malloc environment structure
%envptr3440 = call i8* @llvm_zone_malloc(%mzone* %zone3437, i64 8)
%environment3441 = bitcast i8* %envptr3440 to {{i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}***}*

; malloc closure address table
%addytable3442 = call %clsvar* @new_address_table()
%var3443 = bitcast [49 x i8]* @gsxtmaudiobuffer148 to i8*
%var3444 = bitcast [44 x i8]* @gsxtmaudiobuffer149 to i8*
%addytable3445 = call %clsvar* @add_address_table(%mzone* %zone3437, i8* %var3443, i32 0, i8* %var3444, i32 3, %clsvar* %addytable3442)
%address-table3446 = bitcast %clsvar* %addytable3445 to i8*

; insert table, function and environment into closure struct
%closure.table3449 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}, { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}* %closure3439, i32 0, i32 0
store i8* %address-table3446, i8** %closure.table3449
%closure.env3450 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}, { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}* %closure3439, i32 0, i32 1
store i8* %envptr3440, i8** %closure.env3450
%closure.func3451 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}, { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}* %closure3439, i32 0, i32 2
store i8* (i8*, i8*, i8*, i8*, i1)* @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ__3404, i8* (i8*, i8*, i8*, i8*, i1)** %closure.func3451
%closure_size3452 = call i64 @llvm_zone_mark_size(%mzone* %zone3437)
call void @llvm_zone_ptr_set_size(i8* %clsptr3438, i64 %closure_size3452)
%wrapper_ptr3453 = call i8* @llvm_zone_malloc(%mzone* %zone3437, i64 8)
%closure_wrapper3454 = bitcast i8* %wrapper_ptr3453 to { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}**
store { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}* %closure3439, { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}** %closure_wrapper3454

; let value assignment
%iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}** %closure_wrapper3454, { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}** %closure_wrapper3454
store { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}** %iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ, { i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}*** %iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQPtr

; add data to environment
; don't need to alloc for env var iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ
%tmp_envptr3448 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}***}* %environment3441, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}*** %iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQPtr, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}**** %tmp_envptr3448


%val3457 = load {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}**, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}*** %iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQPtr
ret {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}** %val3457
}


@iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_var = dllexport global [1 x i8*] [ i8* null ]

@iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}** @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ(i8* %arg_0,i8* %arg_1,i1 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}*, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*, i8*, i1)*,  i8* (i8*, i8*, i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i1 %arg_2)
ret i8* %result
}


define dllexport ccc i8* @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_native(i8* %arg_0,i8* %arg_1,i1 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}*, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*, i8*, i1)*,  i8* (i8*, i8*, i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i1 %arg_2)
ret i8* %result
}


define dllexport ccc i8*  @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3458 = bitcast [102 x i8]* @gsxtmaudiobuffer150 to i8*
call i32 (i8*, ...) @printf(i8* %var3458)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3459 = bitcast [102 x i8]* @gsxtmaudiobuffer150 to i8*
call i32 (i8*, ...) @printf(i8* %var3459)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3460 = bitcast [102 x i8]* @gsxtmaudiobuffer150 to i8*
call i32 (i8*, ...) @printf(i8* %var3460)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i1  @i1value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}*, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*, i8*, i1)*,  i8* (i8*, i8*, i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i1 %arg_2)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*, i1}*
%arg_p_0 = getelementptr {i8*, i8*, i1}, {i8*, i8*, i1}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*, i1}, {i8*, i8*, i1}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i8*, i8*, i1}, {i8*, i8*, i1}* %fstruct, i32 0, i32 2
%arg_2 = load i1, i1* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_find_smart_adhoc_W2k4KixpOCosaTgqLGkxXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}*, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*, i1)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*, i8*, i1)*,  i8* (i8*, i8*, i8*, i8*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i1 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer151 = hidden constant [44 x i8] c"iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ\00"
@gsxtmaudiobuffer152 = hidden constant [40 x i8] c"{i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}**\00"
define dllexport fastcc i8* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ__3461(i8* %_impz,i8* %_impenv, i8* %fileptr, i8* %id) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3462 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}***}*
%iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQPtr = load {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}***, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}**** %iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQPtr_

; setup arguments
%fileptrPtr = alloca i8*
store i8* %fileptr, i8** %fileptrPtr
%idPtr = alloca i8*
store i8* %id, i8** %idPtr


; while loop
%val3464 = load i8*, i8** %fileptrPtr
%val3465 = load i8*, i8** %idPtr
%res3466 = call ccc i32 @strncmp(i8* %val3464, i8* %val3465, i64 4)
%cmp3467 = icmp ne i32 %res3466, 0
br i1 %cmp3467, label %loop3463, label %after3463

loop3463:
; do set!
%val3468 = load i8*, i8** %fileptrPtr
; pointer ref
%val3469 = getelementptr i8, i8* %val3468, i64 1
store i8* %val3469, i8** %fileptrPtr
%val3470 = load i8*, i8** %fileptrPtr
%val3471 = load i8*, i8** %idPtr
%res3472 = call ccc i32 @strncmp(i8* %val3470, i8* %val3471, i64 4)
%cmp3473 = icmp ne i32 %res3472, 0
br i1 %cmp3473, label %loop3463, label %after3463

after3463:
%val3475 = load i8*, i8** %fileptrPtr
ret i8* %val3475
}
@gsxtmaudiobuffer153 = hidden constant [97 x i8] c"iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}** @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3495 = load i8*, i8** %_impzPtr
%zone3496 = bitcast i8* %tzone3495 to %mzone*

; let assign value to symbol iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ
%dat_iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3496, i64 8)
%iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQPtr = bitcast i8* %dat_iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ to { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}***
%tzone3476 = load i8*, i8** %_impzPtr
%zone3477 = bitcast i8* %tzone3476 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3477)
; malloc closure structure
%clsptr3478 = call i8* @llvm_zone_malloc(%mzone* %zone3477, i64 24)
%closure3479 = bitcast i8* %clsptr3478 to { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3480 = call i8* @llvm_zone_malloc(%mzone* %zone3477, i64 8)
%environment3481 = bitcast i8* %envptr3480 to {{i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3482 = call %clsvar* @new_address_table()
%var3483 = bitcast [44 x i8]* @gsxtmaudiobuffer151 to i8*
%var3484 = bitcast [40 x i8]* @gsxtmaudiobuffer152 to i8*
%addytable3485 = call %clsvar* @add_address_table(%mzone* %zone3477, i8* %var3483, i32 0, i8* %var3484, i32 3, %clsvar* %addytable3482)
%address-table3486 = bitcast %clsvar* %addytable3485 to i8*

; insert table, function and environment into closure struct
%closure.table3489 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}* %closure3479, i32 0, i32 0
store i8* %address-table3486, i8** %closure.table3489
%closure.env3490 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}* %closure3479, i32 0, i32 1
store i8* %envptr3480, i8** %closure.env3490
%closure.func3491 = getelementptr { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}, { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}* %closure3479, i32 0, i32 2
store i8* (i8*, i8*, i8*, i8*)* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ__3461, i8* (i8*, i8*, i8*, i8*)** %closure.func3491
%closure_size3492 = call i64 @llvm_zone_mark_size(%mzone* %zone3477)
call void @llvm_zone_ptr_set_size(i8* %clsptr3478, i64 %closure_size3492)
%wrapper_ptr3493 = call i8* @llvm_zone_malloc(%mzone* %zone3477, i64 8)
%closure_wrapper3494 = bitcast i8* %wrapper_ptr3493 to { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}* %closure3479, { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}** %closure_wrapper3494

; let value assignment
%iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}** %closure_wrapper3494, { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}** %closure_wrapper3494
store { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}** %iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ, { i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}*** %iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQPtr

; add data to environment
; don't need to alloc for env var iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ
%tmp_envptr3488 = getelementptr {{i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}***}* %environment3481, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}*** %iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQPtr, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}**** %tmp_envptr3488


%val3497 = load {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}**, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}*** %iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQPtr
ret {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}** %val3497
}


@iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}** @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*, i8*)*,  i8* (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret i8* %result
}


define dllexport ccc i8* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_native(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*, i8*)*,  i8* (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret i8* %result
}


define dllexport ccc i8*  @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3498 = bitcast [97 x i8]* @gsxtmaudiobuffer153 to i8*
call i32 (i8*, ...) @printf(i8* %var3498)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3499 = bitcast [97 x i8]* @gsxtmaudiobuffer153 to i8*
call i32 (i8*, ...) @printf(i8* %var3499)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*, i8*)*,  i8* (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i8* (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, i8*, i8*)*,  i8* (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer154 = hidden constant [21 x i8] c"<IffChunkHeader 0x0>\00"
@gsxtmaudiobuffer155 = hidden constant [48 x i8] c"<IffChunkHeader chunk ID: %.4s  chunk size: %d>\00"
@gsxtmaudiobuffer156 = hidden constant [43 x i8] c"print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ__3500(i8* %_impz,i8* %_impenv, %IffChunkHeader* %hdr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3501 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***}*
%print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***}, {{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr = load {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**** %print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr_

; setup arguments
%hdrPtr = alloca %IffChunkHeader*
store %IffChunkHeader* %hdr, %IffChunkHeader** %hdrPtr

; promote local stack var allocations
%tzone3517 = load i8*, i8** %_impzPtr
%zone3518 = bitcast i8* %tzone3517 to %mzone*
%ifptr3502 = alloca i32

%val3503 = load %IffChunkHeader*, %IffChunkHeader** %hdrPtr
%val3504 = icmp eq %IffChunkHeader* %val3503, null
br i1 %val3504, label %then3502, label %else3502

then3502:
%var3505 = bitcast [21 x i8]* @gsxtmaudiobuffer154 to i8*

%val3506 = call i32 (i8*, ...) @printf(i8* %var3505)
store i32 %val3506, i32* %ifptr3502
br label %ifcont3502

else3502:
%var3507 = bitcast [48 x i8]* @gsxtmaudiobuffer155 to i8*
%val3508 = load %IffChunkHeader*, %IffChunkHeader** %hdrPtr
; tuple ref
%val3509 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3508, i64 0, i32 0
; array ref
%val3510 = getelementptr [4 x i8], [4 x i8]* %val3509, i32 0, i64 0
%val3511 = load %IffChunkHeader*, %IffChunkHeader** %hdrPtr
%res3512 = call ccc i1 @impc_true()
%res3513 = call fastcc i32 @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd(%IffChunkHeader* %val3511, i1 %res3512)

%val3514 = call i32 (i8*, ...) @printf(i8* %var3507, i8* %val3510, i32 %res3513)
store i32 %val3514, i32* %ifptr3502
br label %ifcont3502

ifcont3502:
%ifres3515 = load i32, i32* %ifptr3502

ret void
}
@gsxtmaudiobuffer157 = hidden constant [96 x i8] c"print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3538 = load i8*, i8** %_impzPtr
%zone3539 = bitcast i8* %tzone3538 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ
%dat_print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3539, i64 8)
%print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ to { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***
%tzone3519 = load i8*, i8** %_impzPtr
%zone3520 = bitcast i8* %tzone3519 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3520)
; malloc closure structure
%clsptr3521 = call i8* @llvm_zone_malloc(%mzone* %zone3520, i64 24)
%closure3522 = bitcast i8* %clsptr3521 to { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*

; malloc environment structure
%envptr3523 = call i8* @llvm_zone_malloc(%mzone* %zone3520, i64 8)
%environment3524 = bitcast i8* %envptr3523 to {{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***}*

; malloc closure address table
%addytable3525 = call %clsvar* @new_address_table()
%var3526 = bitcast [43 x i8]* @gsxtmaudiobuffer156 to i8*
%var3527 = bitcast [49 x i8]* @gsxtmaudiobuffer137 to i8*
%addytable3528 = call %clsvar* @add_address_table(%mzone* %zone3520, i8* %var3526, i32 0, i8* %var3527, i32 3, %clsvar* %addytable3525)
%address-table3529 = bitcast %clsvar* %addytable3528 to i8*

; insert table, function and environment into closure struct
%closure.table3532 = getelementptr { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure3522, i32 0, i32 0
store i8* %address-table3529, i8** %closure.table3532
%closure.env3533 = getelementptr { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure3522, i32 0, i32 1
store i8* %envptr3523, i8** %closure.env3533
%closure.func3534 = getelementptr { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure3522, i32 0, i32 2
store void (i8*, i8*, %IffChunkHeader*)* @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ__3500, void (i8*, i8*, %IffChunkHeader*)** %closure.func3534
%closure_size3535 = call i64 @llvm_zone_mark_size(%mzone* %zone3520)
call void @llvm_zone_ptr_set_size(i8* %clsptr3521, i64 %closure_size3535)
%wrapper_ptr3536 = call i8* @llvm_zone_malloc(%mzone* %zone3520, i64 8)
%closure_wrapper3537 = bitcast i8* %wrapper_ptr3536 to { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**
store { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure3522, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_wrapper3537

; let value assignment
%print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_wrapper3537, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_wrapper3537
store { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ, { i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*** %print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ
%tmp_envptr3531 = getelementptr {{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***}, {{i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}***}* %environment3524, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*** %print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**** %tmp_envptr3531


%val3540 = load {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*** %print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQPtr
ret {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %val3540
}


@print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ(%IffChunkHeader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %IffChunkHeader*)*,  void (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_native(%IffChunkHeader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %IffChunkHeader*)*,  void (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3541 = bitcast [96 x i8]* @gsxtmaudiobuffer157 to i8*
call i32 (i8*, ...) @printf(i8* %var3541)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %IffChunkHeader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %IffChunkHeader*)*,  void (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%IffChunkHeader*}*
%arg_p_0 = getelementptr {%IffChunkHeader*}, {%IffChunkHeader*}* %fstruct, i32 0, i32 0
%arg_0 = load %IffChunkHeader*, %IffChunkHeader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, void (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %IffChunkHeader*)*,  void (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer158 = hidden constant [50 x i8] c"toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ\00"
@gsxtmaudiobuffer159 = hidden constant [53 x i8] c"{i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ__3542(i8* %_impz,i8* %_impenv, %IffChunkHeader* %hdr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3543 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}***}*
%toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQPtr = load {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}***, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}**** %toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQPtr_

; setup arguments
%hdrPtr = alloca %IffChunkHeader*
store %IffChunkHeader* %hdr, %IffChunkHeader** %hdrPtr


%tzone3545 = load i8*, i8** %_impzPtr
%zone3546 = bitcast i8* %tzone3545 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%dat3544 = alloca i8, i64 256, align 16

; let value assignment
%str = select i1 true, i8* %dat3544, i8* %dat3544
store i8* %str, i8** %strPtr

; promote local stack var allocations
%tzone3565 = load i8*, i8** %_impzPtr
%zone3566 = bitcast i8* %tzone3565 to %mzone*
%ifptr3547 = alloca i32
%val3548 = load %IffChunkHeader*, %IffChunkHeader** %hdrPtr
%val3549 = icmp eq %IffChunkHeader* %val3548, null
br i1 %val3549, label %then3547, label %else3547

then3547:
%val3550 = load i8*, i8** %strPtr
%var3551 = bitcast [21 x i8]* @gsxtmaudiobuffer154 to i8*

%val3552 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3550, i8* %var3551)
store i32 %val3552, i32* %ifptr3547
br label %ifcont3547

else3547:
%val3553 = load i8*, i8** %strPtr
%var3554 = bitcast [48 x i8]* @gsxtmaudiobuffer155 to i8*
%val3555 = load %IffChunkHeader*, %IffChunkHeader** %hdrPtr
; tuple ref
%val3556 = getelementptr %IffChunkHeader, %IffChunkHeader* %val3555, i64 0, i32 0
; array ref
%val3557 = getelementptr [4 x i8], [4 x i8]* %val3556, i32 0, i64 0
%val3558 = load %IffChunkHeader*, %IffChunkHeader** %hdrPtr
%res3559 = call ccc i1 @impc_true()
%res3560 = call fastcc i32 @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd(%IffChunkHeader* %val3558, i1 %res3559)

%val3561 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3553, i8* %var3554, i8* %val3557, i32 %res3560)
store i32 %val3561, i32* %ifptr3547
br label %ifcont3547

ifcont3547:
%ifres3562 = load i32, i32* %ifptr3547

%val3563 = load i8*, i8** %strPtr
%res3564 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3563)
ret %String* %res3564
}
@gsxtmaudiobuffer160 = hidden constant [103 x i8] c"toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}** @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3586 = load i8*, i8** %_impzPtr
%zone3587 = bitcast i8* %tzone3586 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ
%dat_toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3587, i64 8)
%toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ to { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}***
%tzone3567 = load i8*, i8** %_impzPtr
%zone3568 = bitcast i8* %tzone3567 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3568)
; malloc closure structure
%clsptr3569 = call i8* @llvm_zone_malloc(%mzone* %zone3568, i64 24)
%closure3570 = bitcast i8* %clsptr3569 to { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}*

; malloc environment structure
%envptr3571 = call i8* @llvm_zone_malloc(%mzone* %zone3568, i64 8)
%environment3572 = bitcast i8* %envptr3571 to {{i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}***}*

; malloc closure address table
%addytable3573 = call %clsvar* @new_address_table()
%var3574 = bitcast [50 x i8]* @gsxtmaudiobuffer158 to i8*
%var3575 = bitcast [53 x i8]* @gsxtmaudiobuffer159 to i8*
%addytable3576 = call %clsvar* @add_address_table(%mzone* %zone3568, i8* %var3574, i32 0, i8* %var3575, i32 3, %clsvar* %addytable3573)
%address-table3577 = bitcast %clsvar* %addytable3576 to i8*

; insert table, function and environment into closure struct
%closure.table3580 = getelementptr { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}, { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}* %closure3570, i32 0, i32 0
store i8* %address-table3577, i8** %closure.table3580
%closure.env3581 = getelementptr { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}, { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}* %closure3570, i32 0, i32 1
store i8* %envptr3571, i8** %closure.env3581
%closure.func3582 = getelementptr { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}, { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}* %closure3570, i32 0, i32 2
store %String* (i8*, i8*, %IffChunkHeader*)* @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ__3542, %String* (i8*, i8*, %IffChunkHeader*)** %closure.func3582
%closure_size3583 = call i64 @llvm_zone_mark_size(%mzone* %zone3568)
call void @llvm_zone_ptr_set_size(i8* %clsptr3569, i64 %closure_size3583)
%wrapper_ptr3584 = call i8* @llvm_zone_malloc(%mzone* %zone3568, i64 8)
%closure_wrapper3585 = bitcast i8* %wrapper_ptr3584 to { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}**
store { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}* %closure3570, { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}** %closure_wrapper3585

; let value assignment
%toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ = select i1 true, { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}** %closure_wrapper3585, { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}** %closure_wrapper3585
store { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}** %toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ, { i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}*** %toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ
%tmp_envptr3579 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}***}* %environment3572, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}*** %toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQPtr, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}**** %tmp_envptr3579


%val3588 = load {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}**, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}*** %toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQPtr
ret {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}** %val3588
}


@toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}** @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ(%IffChunkHeader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %IffChunkHeader*)*,  %String* (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_native(%IffChunkHeader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %IffChunkHeader*)*,  %String* (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3589 = bitcast [103 x i8]* @gsxtmaudiobuffer160 to i8*
call i32 (i8*, ...) @printf(i8* %var3589)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %IffChunkHeader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %IffChunkHeader*)*,  %String* (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%IffChunkHeader*}*
%arg_p_0 = getelementptr {%IffChunkHeader*}, {%IffChunkHeader*}* %fstruct, i32 0, i32 0
%arg_0 = load %IffChunkHeader*, %IffChunkHeader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosSWZmQ2h1bmtIZWFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}*, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}, {i8*, i8*, %String* (i8*, i8*, %IffChunkHeader*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %IffChunkHeader*)*,  %String* (i8*, i8*, %IffChunkHeader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %IffChunkHeader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer161 = hidden constant [5 x i8] c"RIFF\00"
@gsxtmaudiobuffer162 = hidden constant [5 x i8] c"WAVE\00"
@gsxtmaudiobuffer163 = hidden constant [32 x i8] c"wave_validate_adhoc_W2kxLGk4Kl0\00"
@gsxtmaudiobuffer164 = hidden constant [34 x i8] c"{i8*, i8*, i1 (i8*, i8*, i8*)*}**\00"
define dllexport fastcc i1 @wave_validate_adhoc_W2kxLGk4Kl0__3590(i8* %_impz,i8* %_impenv, i8* %fileptr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3591 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i8*)*}***}*
%wave_validate_adhoc_W2kxLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%wave_validate_adhoc_W2kxLGk4Kl0Ptr = load {i8*, i8*, i1 (i8*, i8*, i8*)*}***, {i8*, i8*, i1 (i8*, i8*, i8*)*}**** %wave_validate_adhoc_W2kxLGk4Kl0Ptr_

; setup arguments
%fileptrPtr = alloca i8*
store i8* %fileptr, i8** %fileptrPtr


%val3593 = load i8*, i8** %fileptrPtr
%var3594 = bitcast [5 x i8]* @gsxtmaudiobuffer161 to i8*
%res3595 = call ccc i32 @strncmp(i8* %val3593, i8* %var3594, i64 4)
%cmp3596 = icmp eq i32 %res3595, 0
br i1 %cmp3596, label %then3592, label %else3592

then3592:
%val3598 = load i8*, i8** %fileptrPtr
; pointer ref
%val3599 = getelementptr i8, i8* %val3598, i64 8
%var3600 = bitcast [5 x i8]* @gsxtmaudiobuffer162 to i8*
%res3601 = call ccc i32 @strncmp(i8* %val3599, i8* %var3600, i64 4)
%cmp3602 = icmp eq i32 %res3601, 0
br i1 %cmp3602, label %then3597, label %else3597

then3597:
%val3603 = load i8*, i8** %fileptrPtr
; pointer ref
%val3604 = getelementptr i8, i8* %val3603, i64 8
%var3605 = bitcast [5 x i8]* @gsxtmaudiobuffer162 to i8*
%res3606 = call ccc i32 @strncmp(i8* %val3604, i8* %var3605, i64 4)
%cmp3607 = icmp eq i32 %res3606, 0
ret i1 %cmp3607

else3597:
%res3608 = call ccc i1 @impc_false()
ret i1 %res3608

else3592:
%res3609 = call ccc i1 @impc_false()
ret i1 %res3609
}
@gsxtmaudiobuffer165 = hidden constant [85 x i8] c"wave_validate_adhoc_W2kxLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i8*)*}** @wave_validate_adhoc_W2kxLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3629 = load i8*, i8** %_impzPtr
%zone3630 = bitcast i8* %tzone3629 to %mzone*

; let assign value to symbol wave_validate_adhoc_W2kxLGk4Kl0
%dat_wave_validate_adhoc_W2kxLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3630, i64 8)
%wave_validate_adhoc_W2kxLGk4Kl0Ptr = bitcast i8* %dat_wave_validate_adhoc_W2kxLGk4Kl0 to { i8*, i8*, i1 (i8*, i8*, i8*)*}***
%tzone3610 = load i8*, i8** %_impzPtr
%zone3611 = bitcast i8* %tzone3610 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3611)
; malloc closure structure
%clsptr3612 = call i8* @llvm_zone_malloc(%mzone* %zone3611, i64 24)
%closure3613 = bitcast i8* %clsptr3612 to { i8*, i8*, i1 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3614 = call i8* @llvm_zone_malloc(%mzone* %zone3611, i64 8)
%environment3615 = bitcast i8* %envptr3614 to {{i8*, i8*, i1 (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3616 = call %clsvar* @new_address_table()
%var3617 = bitcast [32 x i8]* @gsxtmaudiobuffer163 to i8*
%var3618 = bitcast [34 x i8]* @gsxtmaudiobuffer164 to i8*
%addytable3619 = call %clsvar* @add_address_table(%mzone* %zone3611, i8* %var3617, i32 0, i8* %var3618, i32 3, %clsvar* %addytable3616)
%address-table3620 = bitcast %clsvar* %addytable3619 to i8*

; insert table, function and environment into closure struct
%closure.table3623 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure3613, i32 0, i32 0
store i8* %address-table3620, i8** %closure.table3623
%closure.env3624 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure3613, i32 0, i32 1
store i8* %envptr3614, i8** %closure.env3624
%closure.func3625 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure3613, i32 0, i32 2
store i1 (i8*, i8*, i8*)* @wave_validate_adhoc_W2kxLGk4Kl0__3590, i1 (i8*, i8*, i8*)** %closure.func3625
%closure_size3626 = call i64 @llvm_zone_mark_size(%mzone* %zone3611)
call void @llvm_zone_ptr_set_size(i8* %clsptr3612, i64 %closure_size3626)
%wrapper_ptr3627 = call i8* @llvm_zone_malloc(%mzone* %zone3611, i64 8)
%closure_wrapper3628 = bitcast i8* %wrapper_ptr3627 to { i8*, i8*, i1 (i8*, i8*, i8*)*}**
store { i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure3613, { i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_wrapper3628

; let value assignment
%wave_validate_adhoc_W2kxLGk4Kl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_wrapper3628, { i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_wrapper3628
store { i8*, i8*, i1 (i8*, i8*, i8*)*}** %wave_validate_adhoc_W2kxLGk4Kl0, { i8*, i8*, i1 (i8*, i8*, i8*)*}*** %wave_validate_adhoc_W2kxLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var wave_validate_adhoc_W2kxLGk4Kl0
%tmp_envptr3622 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*)*}***}* %environment3615, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i8*)*}*** %wave_validate_adhoc_W2kxLGk4Kl0Ptr, {i8*, i8*, i1 (i8*, i8*, i8*)*}**** %tmp_envptr3622


%val3631 = load {i8*, i8*, i1 (i8*, i8*, i8*)*}**, {i8*, i8*, i1 (i8*, i8*, i8*)*}*** %wave_validate_adhoc_W2kxLGk4Kl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, i8*)*}** %val3631
}


@wave_validate_adhoc_W2kxLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@wave_validate_adhoc_W2kxLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @wave_validate_adhoc_W2kxLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @wave_validate_adhoc_W2kxLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i8*)*}** @wave_validate_adhoc_W2kxLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @wave_validate_adhoc_W2kxLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @wave_validate_adhoc_W2kxLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wave_validate_adhoc_W2kxLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @wave_validate_adhoc_W2kxLGk4Kl0(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wave_validate_adhoc_W2kxLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*)*,  i1 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i1 %result
}


define dllexport ccc i1 @wave_validate_adhoc_W2kxLGk4Kl0_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wave_validate_adhoc_W2kxLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*)*,  i1 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i1 %result
}


define dllexport ccc i8*  @wave_validate_adhoc_W2kxLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3632 = bitcast [85 x i8]* @gsxtmaudiobuffer165 to i8*
call i32 (i8*, ...) @printf(i8* %var3632)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wave_validate_adhoc_W2kxLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*)*,  i1 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @wave_validate_adhoc_W2kxLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wave_validate_adhoc_W2kxLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*)*,  i1 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer166 = hidden constant [36 x i8] c"wavefile error: could not open file\00"
@gsxtmaudiobuffer167 = hidden constant [79 x i8] c"wavefile error: there was a problem with the chunk IDs...
is the file corrupt?\00"
@gsxtmaudiobuffer168 = hidden constant [5 x i8] c"fmt \00"
@gsxtmaudiobuffer169 = hidden constant [5 x i8] c"data\00"
@gsxtmaudiobuffer170 = hidden constant [55 x i8] c"audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd\00"
@gsxtmaudiobuffer171 = hidden constant [42 x i8] c"{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**\00"
define dllexport fastcc i1 @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd__3633(i8* %_impz,i8* %_impenv, i8* %filepath, float* %dest) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3634 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}*
%audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}* %impenv, i32 0, i32 0
%audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**** %audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr_

; setup arguments
%filepathPtr = alloca i8*
store i8* %filepath, i8** %filepathPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr


%tzone3637 = load i8*, i8** %_impzPtr
%zone3638 = bitcast i8* %tzone3637 to %mzone*

; let assign value to symbol filedata
%filedataPtr = alloca i8*
%val3635 = load i8*, i8** %filepathPtr
%res3636 = call ccc i8* @sys_slurp_file(i8* %val3635)

; let value assignment
%filedata = select i1 true, i8* %res3636, i8* %res3636
store i8* %filedata, i8** %filedataPtr

; promote local stack var allocations
%tzone3750 = load i8*, i8** %_impzPtr
%zone3751 = bitcast i8* %tzone3750 to %mzone*
%ifptr3651 = alloca i1
%val3640 = load i8*, i8** %filedataPtr
%val3641 = icmp eq i8* %val3640, null
br i1 %val3641, label %then3639, label %else3639

then3639:
%var3642 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var3643 = bitcast [36 x i8]* @gsxtmaudiobuffer166 to i8*

%val3644 = call i32 (i8*, ...) @printf(i8* %var3642, i8* %var3643)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val3646 = load i8*, i8** %filedataPtr
%val3647 = bitcast i8* %val3646 to i8*
call ccc void @free(i8* %val3647)
%res3649 = call ccc i1 @impc_false()
ret i1 %res3649

else3639:
%val3652 = load i8*, i8** %filedataPtr
%res3653 = call fastcc i1 @wave_validate_adhoc_W2kxLGk4Kl0(i8* %val3652)
br i1 %res3653, label %then3651, label %else3651

then3651:
%res3654 = call ccc i1 @impc_false()
store i1 %res3654, i1* %ifptr3651
br label %ifcont3651

else3651:
%res3655 = call ccc i1 @impc_true()
store i1 %res3655, i1* %ifptr3651
br label %ifcont3651

ifcont3651:
%ifres3656 = load i1, i1* %ifptr3651

br i1 %ifres3656, label %then3650, label %else3650

then3650:
%var3657 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var3658 = bitcast [79 x i8]* @gsxtmaudiobuffer167 to i8*

%val3659 = call i32 (i8*, ...) @printf(i8* %var3657, i8* %var3658)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val3661 = load i8*, i8** %filedataPtr
%val3662 = bitcast i8* %val3661 to i8*
call ccc void @free(i8* %val3662)
%res3664 = call ccc i1 @impc_false()
ret i1 %res3664

else3650:
%tzone3668 = load i8*, i8** %_impzPtr
%zone3669 = bitcast i8* %tzone3668 to %mzone*

; let assign value to symbol fmt
%fmtPtr = alloca i8*
%tzone3675 = load i8*, i8** %_impzPtr
%zone3676 = bitcast i8* %tzone3675 to %mzone*

; let assign value to symbol chunksize
%chunksizePtr = alloca i64
%tzone3684 = load i8*, i8** %_impzPtr
%zone3685 = bitcast i8* %tzone3684 to %mzone*

; let assign value to symbol type
%typePtr = alloca i64
%tzone3694 = load i8*, i8** %_impzPtr
%zone3695 = bitcast i8* %tzone3694 to %mzone*

; let assign value to symbol nchan
%nchanPtr = alloca i64
%tzone3704 = load i8*, i8** %_impzPtr
%zone3705 = bitcast i8* %tzone3704 to %mzone*

; let assign value to symbol samplerate
%sampleratePtr = alloca i64
%tzone3714 = load i8*, i8** %_impzPtr
%zone3715 = bitcast i8* %tzone3714 to %mzone*

; let assign value to symbol bitdepth
%bitdepthPtr = alloca i64
%tzone3719 = load i8*, i8** %_impzPtr
%zone3720 = bitcast i8* %tzone3719 to %mzone*

; let assign value to symbol data
%dataPtr = alloca i8*
%tzone3731 = load i8*, i8** %_impzPtr
%zone3732 = bitcast i8* %tzone3731 to %mzone*

; let assign value to symbol nframes
%nframesPtr = alloca i64
%tzone3744 = load i8*, i8** %_impzPtr
%zone3745 = bitcast i8* %tzone3744 to %mzone*

; let assign value to symbol res
%resPtr = alloca i1
%val3665 = load i8*, i8** %filedataPtr
%var3666 = bitcast [5 x i8]* @gsxtmaudiobuffer168 to i8*
%res3667 = call fastcc i8* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ(i8* %val3665, i8* %var3666)

; let value assignment
%fmt = select i1 true, i8* %res3667, i8* %res3667
store i8* %fmt, i8** %fmtPtr

%val3670 = load i8*, i8** %fmtPtr
%val3671 = bitcast i8* %val3670 to %IffChunkHeader*
%res3672 = call ccc i1 @impc_true()
%res3673 = call fastcc i32 @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd(%IffChunkHeader* %val3671, i1 %res3672)
%res3674 = call ccc i64 @i32toi64(i32 %res3673)

; let value assignment
%chunksize = select i1 true, i64 %res3674, i64 %res3674
store i64 %chunksize, i64* %chunksizePtr

%val3677 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val3678 = load i8*, i8** %fmtPtr
; pointer ref
%val3679 = getelementptr i8, i8* %val3678, i64 %val3677
%val3680 = bitcast i8* %val3679 to i16*
; pointer ref
%val3681 = getelementptr i16, i16* %val3680, i64 0
%val3682 = load i16, i16* %val3681
%res3683 = call ccc i64 @i16toi64(i16 %val3682)

; let value assignment
%type = select i1 true, i64 %res3683, i64 %res3683
store i64 %type, i64* %typePtr

%val3686 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val3687 = add i64 %val3686, 2
%val3688 = load i8*, i8** %fmtPtr
; pointer ref
%val3689 = getelementptr i8, i8* %val3688, i64 %val3687
%val3690 = bitcast i8* %val3689 to i16*
; pointer ref
%val3691 = getelementptr i16, i16* %val3690, i64 0
%val3692 = load i16, i16* %val3691
%res3693 = call ccc i64 @i16toi64(i16 %val3692)

; let value assignment
%nchan = select i1 true, i64 %res3693, i64 %res3693
store i64 %nchan, i64* %nchanPtr

%val3696 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val3697 = add i64 %val3696, 4
%val3698 = load i8*, i8** %fmtPtr
; pointer ref
%val3699 = getelementptr i8, i8* %val3698, i64 %val3697
%val3700 = bitcast i8* %val3699 to i32*
; pointer ref
%val3701 = getelementptr i32, i32* %val3700, i64 0
%val3702 = load i32, i32* %val3701
%res3703 = call ccc i64 @i32toi64(i32 %val3702)

; let value assignment
%samplerate = select i1 true, i64 %res3703, i64 %res3703
store i64 %samplerate, i64* %sampleratePtr

%val3706 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val3707 = add i64 %val3706, 14
%val3708 = load i8*, i8** %fmtPtr
; pointer ref
%val3709 = getelementptr i8, i8* %val3708, i64 %val3707
%val3710 = bitcast i8* %val3709 to i16*
; pointer ref
%val3711 = getelementptr i16, i16* %val3710, i64 0
%val3712 = load i16, i16* %val3711
%res3713 = call ccc i64 @i16toi64(i16 %val3712)

; let value assignment
%bitdepth = select i1 true, i64 %res3713, i64 %res3713
store i64 %bitdepth, i64* %bitdepthPtr

%val3716 = load i8*, i8** %filedataPtr
%var3717 = bitcast [5 x i8]* @gsxtmaudiobuffer169 to i8*
%res3718 = call fastcc i8* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ(i8* %val3716, i8* %var3717)

; let value assignment
%data = select i1 true, i8* %res3718, i8* %res3718
store i8* %data, i8** %dataPtr

%val3721 = load i8*, i8** %dataPtr
%val3722 = bitcast i8* %val3721 to %IffChunkHeader*
%res3723 = call ccc i1 @impc_true()
%res3724 = call fastcc i32 @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd(%IffChunkHeader* %val3722, i1 %res3723)
%res3725 = call ccc i64 @i32toi64(i32 %res3724)
%val3726 = load i64, i64* %nchanPtr
%val3727 = load i64, i64* %bitdepthPtr
%val3728 = sdiv i64 %val3727, 8
%val3729 = mul i64 %val3726, %val3728
%val3730 = sdiv i64 %res3725, %val3729

; let value assignment
%nframes = select i1 true, i64 %val3730, i64 %val3730
store i64 %nframes, i64* %nframesPtr

%val3733 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val3734 = load i8*, i8** %dataPtr
; pointer ref
%val3735 = getelementptr i8, i8* %val3734, i64 %val3733
%val3736 = load float*, float** %destPtr
%val3737 = load i64, i64* %nchanPtr
%val3738 = load i64, i64* %nframesPtr
%val3739 = mul i64 %val3737, %val3738
%val3740 = load i64, i64* %bitdepthPtr
%val3741 = load i64, i64* %typePtr
%res3742 = call ccc i1 @impc_true()
%res3743 = call fastcc i1 @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd(i8* %val3735, float* %val3736, i64 %val3739, i64 %val3740, i64 %val3741, i1 %res3742)

; let value assignment
%res = select i1 true, i1 %res3743, i1 %res3743
store i1 %res, i1* %resPtr

%val3746 = load i8*, i8** %filedataPtr
%val3747 = bitcast i8* %val3746 to i8*
call ccc void @free(i8* %val3747)
%val3749 = load i1, i1* %resPtr
ret i1 %val3749
}
@gsxtmaudiobuffer172 = hidden constant [108 x i8] c"audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3771 = load i8*, i8** %_impzPtr
%zone3772 = bitcast i8* %tzone3771 to %mzone*

; let assign value to symbol audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd
%dat_audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone3772, i64 8)
%audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr = bitcast i8* %dat_audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd to { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***
%tzone3752 = load i8*, i8** %_impzPtr
%zone3753 = bitcast i8* %tzone3752 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3753)
; malloc closure structure
%clsptr3754 = call i8* @llvm_zone_malloc(%mzone* %zone3753, i64 24)
%closure3755 = bitcast i8* %clsptr3754 to { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*

; malloc environment structure
%envptr3756 = call i8* @llvm_zone_malloc(%mzone* %zone3753, i64 8)
%environment3757 = bitcast i8* %envptr3756 to {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}*

; malloc closure address table
%addytable3758 = call %clsvar* @new_address_table()
%var3759 = bitcast [55 x i8]* @gsxtmaudiobuffer170 to i8*
%var3760 = bitcast [42 x i8]* @gsxtmaudiobuffer171 to i8*
%addytable3761 = call %clsvar* @add_address_table(%mzone* %zone3753, i8* %var3759, i32 0, i8* %var3760, i32 3, %clsvar* %addytable3758)
%address-table3762 = bitcast %clsvar* %addytable3761 to i8*

; insert table, function and environment into closure struct
%closure.table3765 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure3755, i32 0, i32 0
store i8* %address-table3762, i8** %closure.table3765
%closure.env3766 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure3755, i32 0, i32 1
store i8* %envptr3756, i8** %closure.env3766
%closure.func3767 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure3755, i32 0, i32 2
store i1 (i8*, i8*, i8*, float*)* @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd__3633, i1 (i8*, i8*, i8*, float*)** %closure.func3767
%closure_size3768 = call i64 @llvm_zone_mark_size(%mzone* %zone3753)
call void @llvm_zone_ptr_set_size(i8* %clsptr3754, i64 %closure_size3768)
%wrapper_ptr3769 = call i8* @llvm_zone_malloc(%mzone* %zone3753, i64 8)
%closure_wrapper3770 = bitcast i8* %wrapper_ptr3769 to { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
store { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure3755, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_wrapper3770

; let value assignment
%audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd = select i1 true, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_wrapper3770, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_wrapper3770
store { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*** %audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd
%tmp_envptr3764 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}* %environment3757, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*** %audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**** %tmp_envptr3764


%val3773 = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*** %audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr
ret {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %val3773
}


@audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd(i8* %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*)*,  i1 (i8*, i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1)
ret i1 %result
}


define dllexport ccc i1 @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_native(i8* %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*)*,  i1 (i8*, i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1)
ret i1 %result
}


define dllexport ccc i8*  @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3774 = bitcast [108 x i8]* @gsxtmaudiobuffer172 to i8*
call i32 (i8*, ...) @printf(i8* %var3774)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3775 = bitcast [108 x i8]* @gsxtmaudiobuffer172 to i8*
call i32 (i8*, ...) @printf(i8* %var3775)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*)*,  i1 (i8*, i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float*}*
%arg_p_0 = getelementptr {i8*, float*}, {i8*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float*}, {i8*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*)*,  i1 (i8*, i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer173 = hidden constant [53 x i8] c"AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd\00"
@gsxtmaudiobuffer174 = hidden constant [45 x i8] c"{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd__3776(i8* %_impz,i8* %_impenv, i8* %filepath) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3777 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}*
%AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**** %AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr_

; setup arguments
%filepathPtr = alloca i8*
store i8* %filepath, i8** %filepathPtr


%tzone3780 = load i8*, i8** %_impzPtr
%zone3781 = bitcast i8* %tzone3780 to %mzone*

; let assign value to symbol filedata
%filedataPtr = alloca i8*
%val3778 = load i8*, i8** %filepathPtr
%res3779 = call ccc i8* @sys_slurp_file(i8* %val3778)

; let value assignment
%filedata = select i1 true, i8* %res3779, i8* %res3779
store i8* %filedata, i8** %filedataPtr

; promote local stack var allocations
%tzone3909 = load i8*, i8** %_impzPtr
%zone3910 = bitcast i8* %tzone3909 to %mzone*
%ifptr3794 = alloca i1
%val3783 = load i8*, i8** %filedataPtr
%val3784 = icmp eq i8* %val3783, null
br i1 %val3784, label %then3782, label %else3782

then3782:
%var3785 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var3786 = bitcast [36 x i8]* @gsxtmaudiobuffer166 to i8*

%val3787 = call i32 (i8*, ...) @printf(i8* %var3785, i8* %var3786)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val3789 = load i8*, i8** %filedataPtr
%val3790 = bitcast i8* %val3789 to i8*
call ccc void @free(i8* %val3790)
%null3792 = bitcast i8* null to %AudioBuffer*
ret %AudioBuffer* %null3792

else3782:
%val3795 = load i8*, i8** %filedataPtr
%res3796 = call fastcc i1 @wave_validate_adhoc_W2kxLGk4Kl0(i8* %val3795)
br i1 %res3796, label %then3794, label %else3794

then3794:
%res3797 = call ccc i1 @impc_false()
store i1 %res3797, i1* %ifptr3794
br label %ifcont3794

else3794:
%res3798 = call ccc i1 @impc_true()
store i1 %res3798, i1* %ifptr3794
br label %ifcont3794

ifcont3794:
%ifres3799 = load i1, i1* %ifptr3794

br i1 %ifres3799, label %then3793, label %else3793

then3793:
%var3800 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var3801 = bitcast [79 x i8]* @gsxtmaudiobuffer167 to i8*

%val3802 = call i32 (i8*, ...) @printf(i8* %var3800, i8* %var3801)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val3804 = load i8*, i8** %filedataPtr
%val3805 = bitcast i8* %val3804 to i8*
call ccc void @free(i8* %val3805)
%null3807 = bitcast i8* null to %AudioBuffer*
ret %AudioBuffer* %null3807

else3793:
%tzone3811 = load i8*, i8** %_impzPtr
%zone3812 = bitcast i8* %tzone3811 to %mzone*

; let assign value to symbol fmt
%fmtPtr = alloca i8*
%tzone3818 = load i8*, i8** %_impzPtr
%zone3819 = bitcast i8* %tzone3818 to %mzone*

; let assign value to symbol chunksize
%chunksizePtr = alloca i64
%tzone3827 = load i8*, i8** %_impzPtr
%zone3828 = bitcast i8* %tzone3827 to %mzone*

; let assign value to symbol type
%typePtr = alloca i64
%tzone3837 = load i8*, i8** %_impzPtr
%zone3838 = bitcast i8* %tzone3837 to %mzone*

; let assign value to symbol nchan
%nchanPtr = alloca i64
%tzone3847 = load i8*, i8** %_impzPtr
%zone3848 = bitcast i8* %tzone3847 to %mzone*

; let assign value to symbol samplerate
%sampleratePtr = alloca double
%tzone3857 = load i8*, i8** %_impzPtr
%zone3858 = bitcast i8* %tzone3857 to %mzone*

; let assign value to symbol bitdepth
%bitdepthPtr = alloca i64
%tzone3862 = load i8*, i8** %_impzPtr
%zone3863 = bitcast i8* %tzone3862 to %mzone*

; let assign value to symbol data
%dataPtr = alloca i8*
%tzone3874 = load i8*, i8** %_impzPtr
%zone3875 = bitcast i8* %tzone3874 to %mzone*

; let assign value to symbol nframes
%nframesPtr = alloca i64
%tzone3880 = load i8*, i8** %_impzPtr
%zone3881 = bitcast i8* %tzone3880 to %mzone*

; let assign value to symbol ab
%abPtr = alloca %AudioBuffer*
%tzone3886 = load i8*, i8** %_impzPtr
%zone3887 = bitcast i8* %tzone3886 to %mzone*

; let assign value to symbol abres
%abresPtr = alloca %String*
%tzone3900 = load i8*, i8** %_impzPtr
%zone3901 = bitcast i8* %tzone3900 to %mzone*

; let assign value to symbol res
%resPtr = alloca i1
%val3808 = load i8*, i8** %filedataPtr
%var3809 = bitcast [5 x i8]* @gsxtmaudiobuffer168 to i8*
%res3810 = call fastcc i8* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ(i8* %val3808, i8* %var3809)

; let value assignment
%fmt = select i1 true, i8* %res3810, i8* %res3810
store i8* %fmt, i8** %fmtPtr

%val3813 = load i8*, i8** %fmtPtr
%val3814 = bitcast i8* %val3813 to %IffChunkHeader*
%res3815 = call ccc i1 @impc_true()
%res3816 = call fastcc i32 @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd(%IffChunkHeader* %val3814, i1 %res3815)
%res3817 = call ccc i64 @i32toi64(i32 %res3816)

; let value assignment
%chunksize = select i1 true, i64 %res3817, i64 %res3817
store i64 %chunksize, i64* %chunksizePtr

%val3820 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val3821 = load i8*, i8** %fmtPtr
; pointer ref
%val3822 = getelementptr i8, i8* %val3821, i64 %val3820
%val3823 = bitcast i8* %val3822 to i16*
; pointer ref
%val3824 = getelementptr i16, i16* %val3823, i64 0
%val3825 = load i16, i16* %val3824
%res3826 = call ccc i64 @i16toi64(i16 %val3825)

; let value assignment
%type = select i1 true, i64 %res3826, i64 %res3826
store i64 %type, i64* %typePtr

%val3829 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val3830 = add i64 %val3829, 2
%val3831 = load i8*, i8** %fmtPtr
; pointer ref
%val3832 = getelementptr i8, i8* %val3831, i64 %val3830
%val3833 = bitcast i8* %val3832 to i16*
; pointer ref
%val3834 = getelementptr i16, i16* %val3833, i64 0
%val3835 = load i16, i16* %val3834
%res3836 = call ccc i64 @i16toi64(i16 %val3835)

; let value assignment
%nchan = select i1 true, i64 %res3836, i64 %res3836
store i64 %nchan, i64* %nchanPtr

%val3839 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val3840 = add i64 %val3839, 4
%val3841 = load i8*, i8** %fmtPtr
; pointer ref
%val3842 = getelementptr i8, i8* %val3841, i64 %val3840
%val3843 = bitcast i8* %val3842 to i32*
; pointer ref
%val3844 = getelementptr i32, i32* %val3843, i64 0
%val3845 = load i32, i32* %val3844
%res3846 = call ccc double @i32tod(i32 %val3845)

; let value assignment
%samplerate = select i1 true, double %res3846, double %res3846
store double %samplerate, double* %sampleratePtr

%val3849 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val3850 = add i64 %val3849, 14
%val3851 = load i8*, i8** %fmtPtr
; pointer ref
%val3852 = getelementptr i8, i8* %val3851, i64 %val3850
%val3853 = bitcast i8* %val3852 to i16*
; pointer ref
%val3854 = getelementptr i16, i16* %val3853, i64 0
%val3855 = load i16, i16* %val3854
%res3856 = call ccc i64 @i16toi64(i16 %val3855)

; let value assignment
%bitdepth = select i1 true, i64 %res3856, i64 %res3856
store i64 %bitdepth, i64* %bitdepthPtr

%val3859 = load i8*, i8** %filedataPtr
%var3860 = bitcast [5 x i8]* @gsxtmaudiobuffer169 to i8*
%res3861 = call fastcc i8* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ(i8* %val3859, i8* %var3860)

; let value assignment
%data = select i1 true, i8* %res3861, i8* %res3861
store i8* %data, i8** %dataPtr

%val3864 = load i8*, i8** %dataPtr
%val3865 = bitcast i8* %val3864 to %IffChunkHeader*
%res3866 = call ccc i1 @impc_true()
%res3867 = call fastcc i32 @iffchunk_size_adhoc_W2kzMixJZmZDaHVua0hlYWRlciosaTFd(%IffChunkHeader* %val3865, i1 %res3866)
%res3868 = call ccc i64 @i32toi64(i32 %res3867)
%val3869 = load i64, i64* %nchanPtr
%val3870 = load i64, i64* %bitdepthPtr
%val3871 = sdiv i64 %val3870, 8
%val3872 = mul i64 %val3869, %val3871
%val3873 = sdiv i64 %res3868, %val3872

; let value assignment
%nframes = select i1 true, i64 %val3873, i64 %val3873
store i64 %nframes, i64* %nframesPtr

%val3876 = load i64, i64* %nframesPtr
%val3877 = load i64, i64* %nchanPtr
%val3878 = load double, double* %sampleratePtr
%res3879 = call fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0(i64 %val3876, i64 %val3877, double %val3878)

; let value assignment
%ab = select i1 true, %AudioBuffer* %res3879, %AudioBuffer* %res3879
store %AudioBuffer* %ab, %AudioBuffer** %abPtr

%val3882 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val3883 = load i8*, i8** %filepathPtr
%res3884 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3883)
%res3885 = call ccc %String* @AudioBuffer_set_filepath(%AudioBuffer* %val3882, %String* %res3884)

; let value assignment
%abres = select i1 true, %String* %res3885, %String* %res3885
store %String* %abres, %String** %abresPtr

%val3888 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val3889 = load i8*, i8** %dataPtr
; pointer ref
%val3890 = getelementptr i8, i8* %val3889, i64 %val3888
%val3891 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res3892 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val3891)
%val3893 = load i64, i64* %nchanPtr
%val3894 = load i64, i64* %nframesPtr
%val3895 = mul i64 %val3893, %val3894
%val3896 = load i64, i64* %bitdepthPtr
%val3897 = load i64, i64* %typePtr
%res3898 = call ccc i1 @impc_true()
%res3899 = call fastcc i1 @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd(i8* %val3890, float* %res3892, i64 %val3895, i64 %val3896, i64 %val3897, i1 %res3898)

; let value assignment
%res = select i1 true, i1 %res3899, i1 %res3899
store i1 %res, i1* %resPtr

%val3902 = load i8*, i8** %filedataPtr
%val3903 = bitcast i8* %val3902 to i8*
call ccc void @free(i8* %val3903)
%val3906 = load i1, i1* %resPtr
br i1 %val3906, label %then3905, label %else3905

then3905:
%val3907 = load %AudioBuffer*, %AudioBuffer** %abPtr
ret %AudioBuffer* %val3907

else3905:
%null3908 = bitcast i8* null to %AudioBuffer*
ret %AudioBuffer* %null3908
}
@gsxtmaudiobuffer175 = hidden constant [106 x i8] c"AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3930 = load i8*, i8** %_impzPtr
%zone3931 = bitcast i8* %tzone3930 to %mzone*

; let assign value to symbol AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd
%dat_AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone3931, i64 8)
%AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr = bitcast i8* %dat_AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd to { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***
%tzone3911 = load i8*, i8** %_impzPtr
%zone3912 = bitcast i8* %tzone3911 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3912)
; malloc closure structure
%clsptr3913 = call i8* @llvm_zone_malloc(%mzone* %zone3912, i64 24)
%closure3914 = bitcast i8* %clsptr3913 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3915 = call i8* @llvm_zone_malloc(%mzone* %zone3912, i64 8)
%environment3916 = bitcast i8* %envptr3915 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3917 = call %clsvar* @new_address_table()
%var3918 = bitcast [53 x i8]* @gsxtmaudiobuffer173 to i8*
%var3919 = bitcast [45 x i8]* @gsxtmaudiobuffer174 to i8*
%addytable3920 = call %clsvar* @add_address_table(%mzone* %zone3912, i8* %var3918, i32 0, i8* %var3919, i32 3, %clsvar* %addytable3917)
%address-table3921 = bitcast %clsvar* %addytable3920 to i8*

; insert table, function and environment into closure struct
%closure.table3924 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure3914, i32 0, i32 0
store i8* %address-table3921, i8** %closure.table3924
%closure.env3925 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure3914, i32 0, i32 1
store i8* %envptr3915, i8** %closure.env3925
%closure.func3926 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure3914, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, i8*)* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd__3776, %AudioBuffer* (i8*, i8*, i8*)** %closure.func3926
%closure_size3927 = call i64 @llvm_zone_mark_size(%mzone* %zone3912)
call void @llvm_zone_ptr_set_size(i8* %clsptr3913, i64 %closure_size3927)
%wrapper_ptr3928 = call i8* @llvm_zone_malloc(%mzone* %zone3912, i64 8)
%closure_wrapper3929 = bitcast i8* %wrapper_ptr3928 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure3914, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_wrapper3929

; let value assignment
%AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_wrapper3929, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_wrapper3929
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*** %AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd
%tmp_envptr3923 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}* %environment3916, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*** %AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**** %tmp_envptr3923


%val3932 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*** %AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %val3932
}


@AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i8*)*,  %AudioBuffer* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i8*)*,  %AudioBuffer* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3933 = bitcast [106 x i8]* @gsxtmaudiobuffer175 to i8*
call i32 (i8*, ...) @printf(i8* %var3933)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i8*)*,  %AudioBuffer* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i8*)*,  %AudioBuffer* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer176 = hidden constant [5 x i8] c"FORM\00"
@gsxtmaudiobuffer177 = hidden constant [5 x i8] c"AIFF\00"
@gsxtmaudiobuffer178 = hidden constant [32 x i8] c"aiff_validate_adhoc_W2kxLGk4Kl0\00"
define dllexport fastcc i1 @aiff_validate_adhoc_W2kxLGk4Kl0__3934(i8* %_impz,i8* %_impenv, i8* %fileptr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3935 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i8*)*}***}*
%aiff_validate_adhoc_W2kxLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%aiff_validate_adhoc_W2kxLGk4Kl0Ptr = load {i8*, i8*, i1 (i8*, i8*, i8*)*}***, {i8*, i8*, i1 (i8*, i8*, i8*)*}**** %aiff_validate_adhoc_W2kxLGk4Kl0Ptr_

; setup arguments
%fileptrPtr = alloca i8*
store i8* %fileptr, i8** %fileptrPtr


%val3937 = load i8*, i8** %fileptrPtr
%var3938 = bitcast [5 x i8]* @gsxtmaudiobuffer176 to i8*
%res3939 = call ccc i32 @strncmp(i8* %val3937, i8* %var3938, i64 4)
%cmp3940 = icmp eq i32 %res3939, 0
br i1 %cmp3940, label %then3936, label %else3936

then3936:
%val3942 = load i8*, i8** %fileptrPtr
; pointer ref
%val3943 = getelementptr i8, i8* %val3942, i64 8
%var3944 = bitcast [5 x i8]* @gsxtmaudiobuffer177 to i8*
%res3945 = call ccc i32 @strncmp(i8* %val3943, i8* %var3944, i64 4)
%cmp3946 = icmp eq i32 %res3945, 0
br i1 %cmp3946, label %then3941, label %else3941

then3941:
%val3947 = load i8*, i8** %fileptrPtr
; pointer ref
%val3948 = getelementptr i8, i8* %val3947, i64 8
%var3949 = bitcast [5 x i8]* @gsxtmaudiobuffer177 to i8*
%res3950 = call ccc i32 @strncmp(i8* %val3948, i8* %var3949, i64 4)
%cmp3951 = icmp eq i32 %res3950, 0
ret i1 %cmp3951

else3941:
%res3952 = call ccc i1 @impc_false()
ret i1 %res3952

else3936:
%res3953 = call ccc i1 @impc_false()
ret i1 %res3953
}
@gsxtmaudiobuffer179 = hidden constant [85 x i8] c"aiff_validate_adhoc_W2kxLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i8*)*}** @aiff_validate_adhoc_W2kxLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3973 = load i8*, i8** %_impzPtr
%zone3974 = bitcast i8* %tzone3973 to %mzone*

; let assign value to symbol aiff_validate_adhoc_W2kxLGk4Kl0
%dat_aiff_validate_adhoc_W2kxLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3974, i64 8)
%aiff_validate_adhoc_W2kxLGk4Kl0Ptr = bitcast i8* %dat_aiff_validate_adhoc_W2kxLGk4Kl0 to { i8*, i8*, i1 (i8*, i8*, i8*)*}***
%tzone3954 = load i8*, i8** %_impzPtr
%zone3955 = bitcast i8* %tzone3954 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3955)
; malloc closure structure
%clsptr3956 = call i8* @llvm_zone_malloc(%mzone* %zone3955, i64 24)
%closure3957 = bitcast i8* %clsptr3956 to { i8*, i8*, i1 (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3958 = call i8* @llvm_zone_malloc(%mzone* %zone3955, i64 8)
%environment3959 = bitcast i8* %envptr3958 to {{i8*, i8*, i1 (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3960 = call %clsvar* @new_address_table()
%var3961 = bitcast [32 x i8]* @gsxtmaudiobuffer178 to i8*
%var3962 = bitcast [34 x i8]* @gsxtmaudiobuffer164 to i8*
%addytable3963 = call %clsvar* @add_address_table(%mzone* %zone3955, i8* %var3961, i32 0, i8* %var3962, i32 3, %clsvar* %addytable3960)
%address-table3964 = bitcast %clsvar* %addytable3963 to i8*

; insert table, function and environment into closure struct
%closure.table3967 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure3957, i32 0, i32 0
store i8* %address-table3964, i8** %closure.table3967
%closure.env3968 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure3957, i32 0, i32 1
store i8* %envptr3958, i8** %closure.env3968
%closure.func3969 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*)*}, { i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure3957, i32 0, i32 2
store i1 (i8*, i8*, i8*)* @aiff_validate_adhoc_W2kxLGk4Kl0__3934, i1 (i8*, i8*, i8*)** %closure.func3969
%closure_size3970 = call i64 @llvm_zone_mark_size(%mzone* %zone3955)
call void @llvm_zone_ptr_set_size(i8* %clsptr3956, i64 %closure_size3970)
%wrapper_ptr3971 = call i8* @llvm_zone_malloc(%mzone* %zone3955, i64 8)
%closure_wrapper3972 = bitcast i8* %wrapper_ptr3971 to { i8*, i8*, i1 (i8*, i8*, i8*)*}**
store { i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure3957, { i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_wrapper3972

; let value assignment
%aiff_validate_adhoc_W2kxLGk4Kl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_wrapper3972, { i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_wrapper3972
store { i8*, i8*, i1 (i8*, i8*, i8*)*}** %aiff_validate_adhoc_W2kxLGk4Kl0, { i8*, i8*, i1 (i8*, i8*, i8*)*}*** %aiff_validate_adhoc_W2kxLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var aiff_validate_adhoc_W2kxLGk4Kl0
%tmp_envptr3966 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*)*}***}* %environment3959, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i8*)*}*** %aiff_validate_adhoc_W2kxLGk4Kl0Ptr, {i8*, i8*, i1 (i8*, i8*, i8*)*}**** %tmp_envptr3966


%val3975 = load {i8*, i8*, i1 (i8*, i8*, i8*)*}**, {i8*, i8*, i1 (i8*, i8*, i8*)*}*** %aiff_validate_adhoc_W2kxLGk4Kl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, i8*)*}** %val3975
}


@aiff_validate_adhoc_W2kxLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@aiff_validate_adhoc_W2kxLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @aiff_validate_adhoc_W2kxLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @aiff_validate_adhoc_W2kxLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i8*)*}** @aiff_validate_adhoc_W2kxLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @aiff_validate_adhoc_W2kxLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @aiff_validate_adhoc_W2kxLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @aiff_validate_adhoc_W2kxLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @aiff_validate_adhoc_W2kxLGk4Kl0(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @aiff_validate_adhoc_W2kxLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*)*,  i1 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i1 %result
}


define dllexport ccc i1 @aiff_validate_adhoc_W2kxLGk4Kl0_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @aiff_validate_adhoc_W2kxLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*)*,  i1 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret i1 %result
}


define dllexport ccc i8*  @aiff_validate_adhoc_W2kxLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3976 = bitcast [85 x i8]* @gsxtmaudiobuffer179 to i8*
call i32 (i8*, ...) @printf(i8* %var3976)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @aiff_validate_adhoc_W2kxLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*)*,  i1 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @aiff_validate_adhoc_W2kxLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @aiff_validate_adhoc_W2kxLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*)*}, {i8*, i8*, i1 (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*)*,  i1 (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer180 = hidden constant [37 x i8] c"aiff file error: could not open file\00"
@gsxtmaudiobuffer181 = hidden constant [5 x i8] c"COMM\00"
@gsxtmaudiobuffer182 = hidden constant [5 x i8] c"SSND\00"
@gsxtmaudiobuffer183 = hidden constant [55 x i8] c"audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd\00"
define dllexport fastcc i1 @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd__3977(i8* %_impz,i8* %_impenv, i8* %filepath, float* %dest) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3978 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}*
%audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}* %impenv, i32 0, i32 0
%audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**** %audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr_

; setup arguments
%filepathPtr = alloca i8*
store i8* %filepath, i8** %filepathPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr


%tzone3981 = load i8*, i8** %_impzPtr
%zone3982 = bitcast i8* %tzone3981 to %mzone*

; let assign value to symbol filedata
%filedataPtr = alloca i8*
%val3979 = load i8*, i8** %filepathPtr
%res3980 = call ccc i8* @sys_slurp_file(i8* %val3979)

; let value assignment
%filedata = select i1 true, i8* %res3980, i8* %res3980
store i8* %filedata, i8** %filedataPtr

%val3984 = load i8*, i8** %filedataPtr
%val3985 = icmp eq i8* %val3984, null
br i1 %val3985, label %then3983, label %else3983

then3983:
%var3986 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var3987 = bitcast [37 x i8]* @gsxtmaudiobuffer180 to i8*

%val3988 = call i32 (i8*, ...) @printf(i8* %var3986, i8* %var3987)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%res3990 = call ccc i1 @impc_false()
ret i1 %res3990

else3983:
%tzone3994 = load i8*, i8** %_impzPtr
%zone3995 = bitcast i8* %tzone3994 to %mzone*

; let assign value to symbol common
%commonPtr = alloca i8*
%tzone3999 = load i8*, i8** %_impzPtr
%zone4000 = bitcast i8* %tzone3999 to %mzone*

; let assign value to symbol sounddata
%sounddataPtr = alloca i8*
%val3991 = load i8*, i8** %filedataPtr
%var3992 = bitcast [5 x i8]* @gsxtmaudiobuffer181 to i8*
%res3993 = call fastcc i8* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ(i8* %val3991, i8* %var3992)

; let value assignment
%common = select i1 true, i8* %res3993, i8* %res3993
store i8* %common, i8** %commonPtr

%val3996 = load i8*, i8** %filedataPtr
%var3997 = bitcast [5 x i8]* @gsxtmaudiobuffer182 to i8*
%res3998 = call fastcc i8* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ(i8* %val3996, i8* %var3997)

; let value assignment
%sounddata = select i1 true, i8* %res3998, i8* %res3998
store i8* %sounddata, i8** %sounddataPtr

%tzone4009 = load i8*, i8** %_impzPtr
%zone4010 = bitcast i8* %tzone4009 to %mzone*

; let assign value to symbol nchan
%nchanPtr = alloca i64
%tzone4020 = load i8*, i8** %_impzPtr
%zone4021 = bitcast i8* %tzone4020 to %mzone*

; let assign value to symbol nframes
%nframesPtr = alloca i64
%tzone4031 = load i8*, i8** %_impzPtr
%zone4032 = bitcast i8* %tzone4031 to %mzone*

; let assign value to symbol bitdepth
%bitdepthPtr = alloca i64
%tzone4045 = load i8*, i8** %_impzPtr
%zone4046 = bitcast i8* %tzone4045 to %mzone*

; let assign value to symbol res
%resPtr = alloca i1
%val4001 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val4002 = load i8*, i8** %commonPtr
; pointer ref
%val4003 = getelementptr i8, i8* %val4002, i64 %val4001
%val4004 = bitcast i8* %val4003 to i16*
; pointer ref
%val4005 = getelementptr i16, i16* %val4004, i64 0
%val4006 = load i16, i16* %val4005
%res4007 = call ccc i16 @swapi16(i16 %val4006)
%res4008 = call ccc i64 @i16toi64(i16 %res4007)

; let value assignment
%nchan = select i1 true, i64 %res4008, i64 %res4008
store i64 %nchan, i64* %nchanPtr

%val4011 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val4012 = add i64 %val4011, 2
%val4013 = load i8*, i8** %commonPtr
; pointer ref
%val4014 = getelementptr i8, i8* %val4013, i64 %val4012
%val4015 = bitcast i8* %val4014 to i32*
; pointer ref
%val4016 = getelementptr i32, i32* %val4015, i64 0
%val4017 = load i32, i32* %val4016
%res4018 = call ccc i32 @swapi32(i32 %val4017)
%res4019 = call ccc i64 @i32toi64(i32 %res4018)

; let value assignment
%nframes = select i1 true, i64 %res4019, i64 %res4019
store i64 %nframes, i64* %nframesPtr

%val4022 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val4023 = add i64 %val4022, 6
%val4024 = load i8*, i8** %commonPtr
; pointer ref
%val4025 = getelementptr i8, i8* %val4024, i64 %val4023
%val4026 = bitcast i8* %val4025 to i16*
; pointer ref
%val4027 = getelementptr i16, i16* %val4026, i64 0
%val4028 = load i16, i16* %val4027
%res4029 = call ccc i16 @swapi16(i16 %val4028)
%res4030 = call ccc i64 @i16toi64(i16 %res4029)

; let value assignment
%bitdepth = select i1 true, i64 %res4030, i64 %res4030
store i64 %bitdepth, i64* %bitdepthPtr

%val4033 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val4034 = add i64 %val4033, 8
%val4035 = load i8*, i8** %sounddataPtr
; pointer ref
%val4036 = getelementptr i8, i8* %val4035, i64 %val4034
%val4037 = load float*, float** %destPtr
%val4038 = load i64, i64* %nchanPtr
%val4039 = load i64, i64* %nframesPtr
%val4040 = mul i64 %val4038, %val4039
%val4041 = load i64, i64* %bitdepthPtr
%val4042 = load i64, i64* @WAVE_FORMAT_PCM
%res4043 = call ccc i1 @impc_false()
%res4044 = call fastcc i1 @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd(i8* %val4036, float* %val4037, i64 %val4040, i64 %val4041, i64 %val4042, i1 %res4043)

; let value assignment
%res = select i1 true, i1 %res4044, i1 %res4044
store i1 %res, i1* %resPtr

%val4047 = load i8*, i8** %filedataPtr
%val4048 = bitcast i8* %val4047 to i8*
call ccc void @free(i8* %val4048)
%val4050 = load i1, i1* %resPtr
ret i1 %val4050
}
@gsxtmaudiobuffer184 = hidden constant [108 x i8] c"audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4070 = load i8*, i8** %_impzPtr
%zone4071 = bitcast i8* %tzone4070 to %mzone*

; let assign value to symbol audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd
%dat_audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone4071, i64 8)
%audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr = bitcast i8* %dat_audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd to { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***
%tzone4051 = load i8*, i8** %_impzPtr
%zone4052 = bitcast i8* %tzone4051 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4052)
; malloc closure structure
%clsptr4053 = call i8* @llvm_zone_malloc(%mzone* %zone4052, i64 24)
%closure4054 = bitcast i8* %clsptr4053 to { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*

; malloc environment structure
%envptr4055 = call i8* @llvm_zone_malloc(%mzone* %zone4052, i64 8)
%environment4056 = bitcast i8* %envptr4055 to {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}*

; malloc closure address table
%addytable4057 = call %clsvar* @new_address_table()
%var4058 = bitcast [55 x i8]* @gsxtmaudiobuffer183 to i8*
%var4059 = bitcast [42 x i8]* @gsxtmaudiobuffer171 to i8*
%addytable4060 = call %clsvar* @add_address_table(%mzone* %zone4052, i8* %var4058, i32 0, i8* %var4059, i32 3, %clsvar* %addytable4057)
%address-table4061 = bitcast %clsvar* %addytable4060 to i8*

; insert table, function and environment into closure struct
%closure.table4064 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure4054, i32 0, i32 0
store i8* %address-table4061, i8** %closure.table4064
%closure.env4065 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure4054, i32 0, i32 1
store i8* %envptr4055, i8** %closure.env4065
%closure.func4066 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure4054, i32 0, i32 2
store i1 (i8*, i8*, i8*, float*)* @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd__3977, i1 (i8*, i8*, i8*, float*)** %closure.func4066
%closure_size4067 = call i64 @llvm_zone_mark_size(%mzone* %zone4052)
call void @llvm_zone_ptr_set_size(i8* %clsptr4053, i64 %closure_size4067)
%wrapper_ptr4068 = call i8* @llvm_zone_malloc(%mzone* %zone4052, i64 8)
%closure_wrapper4069 = bitcast i8* %wrapper_ptr4068 to { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
store { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure4054, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_wrapper4069

; let value assignment
%audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd = select i1 true, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_wrapper4069, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_wrapper4069
store { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*** %audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd
%tmp_envptr4063 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}* %environment4056, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*** %audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**** %tmp_envptr4063


%val4072 = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*** %audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr
ret {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %val4072
}


@audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd(i8* %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*)*,  i1 (i8*, i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1)
ret i1 %result
}


define dllexport ccc i1 @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_native(i8* %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*)*,  i1 (i8*, i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1)
ret i1 %result
}


define dllexport ccc i8*  @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4073 = bitcast [108 x i8]* @gsxtmaudiobuffer184 to i8*
call i32 (i8*, ...) @printf(i8* %var4073)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4074 = bitcast [108 x i8]* @gsxtmaudiobuffer184 to i8*
call i32 (i8*, ...) @printf(i8* %var4074)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*)*,  i1 (i8*, i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float*}*
%arg_p_0 = getelementptr {i8*, float*}, {i8*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float*}, {i8*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*)*,  i1 (i8*, i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer185 = hidden constant [53 x i8] c"AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd__4075(i8* %_impz,i8* %_impenv, i8* %filepath) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4076 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}*
%AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**** %AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr_

; setup arguments
%filepathPtr = alloca i8*
store i8* %filepath, i8** %filepathPtr


%tzone4079 = load i8*, i8** %_impzPtr
%zone4080 = bitcast i8* %tzone4079 to %mzone*

; let assign value to symbol filedata
%filedataPtr = alloca i8*
%val4077 = load i8*, i8** %filepathPtr
%res4078 = call ccc i8* @sys_slurp_file(i8* %val4077)

; let value assignment
%filedata = select i1 true, i8* %res4078, i8* %res4078
store i8* %filedata, i8** %filedataPtr

%val4082 = load i8*, i8** %filedataPtr
%val4083 = icmp eq i8* %val4082, null
br i1 %val4083, label %then4081, label %else4081

then4081:
%var4084 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var4085 = bitcast [37 x i8]* @gsxtmaudiobuffer180 to i8*

%val4086 = call i32 (i8*, ...) @printf(i8* %var4084, i8* %var4085)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%null4088 = bitcast i8* null to %AudioBuffer*
ret %AudioBuffer* %null4088

else4081:
%tzone4092 = load i8*, i8** %_impzPtr
%zone4093 = bitcast i8* %tzone4092 to %mzone*

; let assign value to symbol common
%commonPtr = alloca i8*
%tzone4097 = load i8*, i8** %_impzPtr
%zone4098 = bitcast i8* %tzone4097 to %mzone*

; let assign value to symbol sounddata
%sounddataPtr = alloca i8*
%val4089 = load i8*, i8** %filedataPtr
%var4090 = bitcast [5 x i8]* @gsxtmaudiobuffer181 to i8*
%res4091 = call fastcc i8* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ(i8* %val4089, i8* %var4090)

; let value assignment
%common = select i1 true, i8* %res4091, i8* %res4091
store i8* %common, i8** %commonPtr

%val4094 = load i8*, i8** %filedataPtr
%var4095 = bitcast [5 x i8]* @gsxtmaudiobuffer182 to i8*
%res4096 = call fastcc i8* @iffchunk_find_dumb_adhoc_W2k4KixpOCosaTgqXQ(i8* %val4094, i8* %var4095)

; let value assignment
%sounddata = select i1 true, i8* %res4096, i8* %res4096
store i8* %sounddata, i8** %sounddataPtr

%tzone4107 = load i8*, i8** %_impzPtr
%zone4108 = bitcast i8* %tzone4107 to %mzone*

; let assign value to symbol nchan
%nchanPtr = alloca i64
%tzone4118 = load i8*, i8** %_impzPtr
%zone4119 = bitcast i8* %tzone4118 to %mzone*

; let assign value to symbol nframes
%nframesPtr = alloca i64
%tzone4129 = load i8*, i8** %_impzPtr
%zone4130 = bitcast i8* %tzone4129 to %mzone*

; let assign value to symbol bitdepth
%bitdepthPtr = alloca i64
%tzone4141 = load i8*, i8** %_impzPtr
%zone4142 = bitcast i8* %tzone4141 to %mzone*

; let assign value to symbol samplerate
%sampleratePtr = alloca double
%tzone4147 = load i8*, i8** %_impzPtr
%zone4148 = bitcast i8* %tzone4147 to %mzone*

; let assign value to symbol ab
%abPtr = alloca %AudioBuffer*
%tzone4153 = load i8*, i8** %_impzPtr
%zone4154 = bitcast i8* %tzone4153 to %mzone*

; let assign value to symbol abres
%abresPtr = alloca %String*
%tzone4168 = load i8*, i8** %_impzPtr
%zone4169 = bitcast i8* %tzone4168 to %mzone*

; let assign value to symbol res
%resPtr = alloca i1
%val4099 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val4100 = load i8*, i8** %commonPtr
; pointer ref
%val4101 = getelementptr i8, i8* %val4100, i64 %val4099
%val4102 = bitcast i8* %val4101 to i16*
; pointer ref
%val4103 = getelementptr i16, i16* %val4102, i64 0
%val4104 = load i16, i16* %val4103
%res4105 = call ccc i16 @swapi16(i16 %val4104)
%res4106 = call ccc i64 @i16toi64(i16 %res4105)

; let value assignment
%nchan = select i1 true, i64 %res4106, i64 %res4106
store i64 %nchan, i64* %nchanPtr

%val4109 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val4110 = add i64 %val4109, 2
%val4111 = load i8*, i8** %commonPtr
; pointer ref
%val4112 = getelementptr i8, i8* %val4111, i64 %val4110
%val4113 = bitcast i8* %val4112 to i32*
; pointer ref
%val4114 = getelementptr i32, i32* %val4113, i64 0
%val4115 = load i32, i32* %val4114
%res4116 = call ccc i32 @swapi32(i32 %val4115)
%res4117 = call ccc i64 @i32toi64(i32 %res4116)

; let value assignment
%nframes = select i1 true, i64 %res4117, i64 %res4117
store i64 %nframes, i64* %nframesPtr

%val4120 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val4121 = add i64 %val4120, 6
%val4122 = load i8*, i8** %commonPtr
; pointer ref
%val4123 = getelementptr i8, i8* %val4122, i64 %val4121
%val4124 = bitcast i8* %val4123 to i16*
; pointer ref
%val4125 = getelementptr i16, i16* %val4124, i64 0
%val4126 = load i16, i16* %val4125
%res4127 = call ccc i16 @swapi16(i16 %val4126)
%res4128 = call ccc i64 @i16toi64(i16 %res4127)

; let value assignment
%bitdepth = select i1 true, i64 %res4128, i64 %res4128
store i64 %bitdepth, i64* %bitdepthPtr

%val4131 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val4132 = add i64 %val4131, 8
%val4133 = load i8*, i8** %commonPtr
; pointer ref
%val4134 = getelementptr i8, i8* %val4133, i64 %val4132
call fastcc void @swap_bytes_inplace_adhoc_W3ZvaWQsaTgqLGk2NF0(i8* %val4134, i64 10)
%val4136 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val4137 = add i64 %val4136, 8
%val4138 = load i8*, i8** %commonPtr
; pointer ref
%val4139 = getelementptr i8, i8* %val4138, i64 %val4137
%res4140 = call ccc double @fp80ptrtod(i8* %val4139)

; let value assignment
%samplerate = select i1 true, double %res4140, double %res4140
store double %samplerate, double* %sampleratePtr

%val4143 = load i64, i64* %nframesPtr
%val4144 = load i64, i64* %nchanPtr
%val4145 = load double, double* %sampleratePtr
%res4146 = call fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0(i64 %val4143, i64 %val4144, double %val4145)

; let value assignment
%ab = select i1 true, %AudioBuffer* %res4146, %AudioBuffer* %res4146
store %AudioBuffer* %ab, %AudioBuffer** %abPtr

%val4149 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4150 = load i8*, i8** %filepathPtr
%res4151 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4150)
%res4152 = call ccc %String* @AudioBuffer_set_filepath(%AudioBuffer* %val4149, %String* %res4151)

; let value assignment
%abres = select i1 true, %String* %res4152, %String* %res4152
store %String* %abres, %String** %abresPtr

%val4155 = load i64, i64* @IFF_CHUNK_HEADER_SIZE
%val4156 = add i64 %val4155, 8
%val4157 = load i8*, i8** %sounddataPtr
; pointer ref
%val4158 = getelementptr i8, i8* %val4157, i64 %val4156
%val4159 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res4160 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val4159)
%val4161 = load i64, i64* %nchanPtr
%val4162 = load i64, i64* %nframesPtr
%val4163 = mul i64 %val4161, %val4162
%val4164 = load i64, i64* %bitdepthPtr
%val4165 = load i64, i64* @WAVE_FORMAT_PCM
%res4166 = call ccc i1 @impc_false()
%res4167 = call fastcc i1 @audiofile_copy_samples_adhoc_W2kxLGk4KixmbG9hdCosaTY0LGk2NCxpNjQsaTFd(i8* %val4158, float* %res4160, i64 %val4163, i64 %val4164, i64 %val4165, i1 %res4166)

; let value assignment
%res = select i1 true, i1 %res4167, i1 %res4167
store i1 %res, i1* %resPtr

%val4170 = load i8*, i8** %filedataPtr
%val4171 = bitcast i8* %val4170 to i8*
call ccc void @free(i8* %val4171)
%val4174 = load i1, i1* %resPtr
br i1 %val4174, label %then4173, label %else4173

then4173:
%val4175 = load %AudioBuffer*, %AudioBuffer** %abPtr
ret %AudioBuffer* %val4175

else4173:
%null4176 = bitcast i8* null to %AudioBuffer*
ret %AudioBuffer* %null4176
}
@gsxtmaudiobuffer186 = hidden constant [106 x i8] c"AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4196 = load i8*, i8** %_impzPtr
%zone4197 = bitcast i8* %tzone4196 to %mzone*

; let assign value to symbol AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd
%dat_AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone4197, i64 8)
%AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr = bitcast i8* %dat_AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd to { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***
%tzone4177 = load i8*, i8** %_impzPtr
%zone4178 = bitcast i8* %tzone4177 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4178)
; malloc closure structure
%clsptr4179 = call i8* @llvm_zone_malloc(%mzone* %zone4178, i64 24)
%closure4180 = bitcast i8* %clsptr4179 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr4181 = call i8* @llvm_zone_malloc(%mzone* %zone4178, i64 8)
%environment4182 = bitcast i8* %envptr4181 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable4183 = call %clsvar* @new_address_table()
%var4184 = bitcast [53 x i8]* @gsxtmaudiobuffer185 to i8*
%var4185 = bitcast [45 x i8]* @gsxtmaudiobuffer174 to i8*
%addytable4186 = call %clsvar* @add_address_table(%mzone* %zone4178, i8* %var4184, i32 0, i8* %var4185, i32 3, %clsvar* %addytable4183)
%address-table4187 = bitcast %clsvar* %addytable4186 to i8*

; insert table, function and environment into closure struct
%closure.table4190 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure4180, i32 0, i32 0
store i8* %address-table4187, i8** %closure.table4190
%closure.env4191 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure4180, i32 0, i32 1
store i8* %envptr4181, i8** %closure.env4191
%closure.func4192 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure4180, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, i8*)* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd__4075, %AudioBuffer* (i8*, i8*, i8*)** %closure.func4192
%closure_size4193 = call i64 @llvm_zone_mark_size(%mzone* %zone4178)
call void @llvm_zone_ptr_set_size(i8* %clsptr4179, i64 %closure_size4193)
%wrapper_ptr4194 = call i8* @llvm_zone_malloc(%mzone* %zone4178, i64 8)
%closure_wrapper4195 = bitcast i8* %wrapper_ptr4194 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure4180, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_wrapper4195

; let value assignment
%AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_wrapper4195, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_wrapper4195
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*** %AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd
%tmp_envptr4189 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}* %environment4182, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*** %AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**** %tmp_envptr4189


%val4198 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*** %AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %val4198
}


@AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i8*)*,  %AudioBuffer* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i8*)*,  %AudioBuffer* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4199 = bitcast [106 x i8]* @gsxtmaudiobuffer186 to i8*
call i32 (i8*, ...) @printf(i8* %var4199)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i8*)*,  %AudioBuffer* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i8*)*,  %AudioBuffer* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer187 = hidden constant [9 x i8] c"\.wave?$\00"
@gsxtmaudiobuffer188 = hidden constant [9 x i8] c"\.aiff?$\00"
@gsxtmaudiobuffer189 = hidden constant [79 x i8] c"native xtlang audiofile reader only works for uncompressed aiff and wave files\00"
@gsxtmaudiobuffer190 = hidden constant [50 x i8] c"audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd\00"
define dllexport fastcc i1 @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd__4200(i8* %_impz,i8* %_impenv, i8* %filepath, float* %dest) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4201 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}*
%audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}* %impenv, i32 0, i32 0
%audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**** %audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr_

; setup arguments
%filepathPtr = alloca i8*
store i8* %filepath, i8** %filepathPtr
%destPtr = alloca float*
store float* %dest, float** %destPtr


%var4203 = bitcast [9 x i8]* @gsxtmaudiobuffer187 to i8*
%val4204 = load i8*, i8** %filepathPtr
%res4205 = call ccc i1 @rmatch(i8* %var4203, i8* %val4204)
br i1 %res4205, label %then4202, label %else4202

then4202:
%val4206 = load i8*, i8** %filepathPtr
%val4207 = load float*, float** %destPtr
%res4208 = call fastcc i1 @audiofile_wave_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd(i8* %val4206, float* %val4207)
ret i1 %res4208

else4202:
%var4210 = bitcast [9 x i8]* @gsxtmaudiobuffer188 to i8*
%val4211 = load i8*, i8** %filepathPtr
%res4212 = call ccc i1 @rmatch(i8* %var4210, i8* %val4211)
br i1 %res4212, label %then4209, label %else4209

then4209:
%val4213 = load i8*, i8** %filepathPtr
%val4214 = load float*, float** %destPtr
%res4215 = call fastcc i1 @audiofile_aiff_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd(i8* %val4213, float* %val4214)
ret i1 %res4215

else4209:
%var4216 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var4217 = bitcast [79 x i8]* @gsxtmaudiobuffer189 to i8*

%val4218 = call i32 (i8*, ...) @printf(i8* %var4216, i8* %var4217)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%res4220 = call ccc i1 @impc_false()
ret i1 %res4220
}
@gsxtmaudiobuffer191 = hidden constant [103 x i8] c"audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4240 = load i8*, i8** %_impzPtr
%zone4241 = bitcast i8* %tzone4240 to %mzone*

; let assign value to symbol audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd
%dat_audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd = call i8* @llvm_zone_malloc(%mzone* %zone4241, i64 8)
%audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr = bitcast i8* %dat_audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd to { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***
%tzone4221 = load i8*, i8** %_impzPtr
%zone4222 = bitcast i8* %tzone4221 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4222)
; malloc closure structure
%clsptr4223 = call i8* @llvm_zone_malloc(%mzone* %zone4222, i64 24)
%closure4224 = bitcast i8* %clsptr4223 to { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*

; malloc environment structure
%envptr4225 = call i8* @llvm_zone_malloc(%mzone* %zone4222, i64 8)
%environment4226 = bitcast i8* %envptr4225 to {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}*

; malloc closure address table
%addytable4227 = call %clsvar* @new_address_table()
%var4228 = bitcast [50 x i8]* @gsxtmaudiobuffer190 to i8*
%var4229 = bitcast [42 x i8]* @gsxtmaudiobuffer171 to i8*
%addytable4230 = call %clsvar* @add_address_table(%mzone* %zone4222, i8* %var4228, i32 0, i8* %var4229, i32 3, %clsvar* %addytable4227)
%address-table4231 = bitcast %clsvar* %addytable4230 to i8*

; insert table, function and environment into closure struct
%closure.table4234 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure4224, i32 0, i32 0
store i8* %address-table4231, i8** %closure.table4234
%closure.env4235 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure4224, i32 0, i32 1
store i8* %envptr4225, i8** %closure.env4235
%closure.func4236 = getelementptr { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure4224, i32 0, i32 2
store i1 (i8*, i8*, i8*, float*)* @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd__4200, i1 (i8*, i8*, i8*, float*)** %closure.func4236
%closure_size4237 = call i64 @llvm_zone_mark_size(%mzone* %zone4222)
call void @llvm_zone_ptr_set_size(i8* %clsptr4223, i64 %closure_size4237)
%wrapper_ptr4238 = call i8* @llvm_zone_malloc(%mzone* %zone4222, i64 8)
%closure_wrapper4239 = bitcast i8* %wrapper_ptr4238 to { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
store { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure4224, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_wrapper4239

; let value assignment
%audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd = select i1 true, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_wrapper4239, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_wrapper4239
store { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd, { i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*** %audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr

; add data to environment
; don't need to alloc for env var audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd
%tmp_envptr4233 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}, {{i8*, i8*, i1 (i8*, i8*, i8*, float*)*}***}* %environment4226, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*** %audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**** %tmp_envptr4233


%val4242 = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*** %audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpdPtr
ret {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %val4242
}


@audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var = dllexport global [1 x i8*] [ i8* null ]

@audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd(i8* %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*)*,  i1 (i8*, i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1)
ret i1 %result
}


define dllexport ccc i1 @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_native(i8* %arg_0,float* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*)*,  i1 (i8*, i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1)
ret i1 %result
}


define dllexport ccc i8*  @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4243 = bitcast [103 x i8]* @gsxtmaudiobuffer191 to i8*
call i32 (i8*, ...) @printf(i8* %var4243)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4244 = bitcast [103 x i8]* @gsxtmaudiobuffer191 to i8*
call i32 (i8*, ...) @printf(i8* %var4244)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*)*,  i1 (i8*, i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, float*}*
%arg_p_0 = getelementptr {i8*, float*}, {i8*, float*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, float*}, {i8*, float*}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @audiofile_read_samples_adhoc_W2kxLGk4KixmbG9hdCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}*, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}, {i8*, i8*, i1 (i8*, i8*, i8*, float*)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i8*, float*)*,  i1 (i8*, i8*, i8*, float*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i8* %arg_0, float* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer192 = hidden constant [43 x i8] c"AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd__4245(i8* %_impz,i8* %_impenv, i8* %filepath) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4246 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}*
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr_

; setup arguments
%filepathPtr = alloca i8*
store i8* %filepath, i8** %filepathPtr


%var4248 = bitcast [9 x i8]* @gsxtmaudiobuffer187 to i8*
%val4249 = load i8*, i8** %filepathPtr
%res4250 = call ccc i1 @rmatch(i8* %var4248, i8* %val4249)
br i1 %res4250, label %then4247, label %else4247

then4247:
%val4251 = load i8*, i8** %filepathPtr
%res4252 = call fastcc %AudioBuffer* @AudioBuffer_from_wave_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd(i8* %val4251)
ret %AudioBuffer* %res4252

else4247:
%var4254 = bitcast [9 x i8]* @gsxtmaudiobuffer188 to i8*
%val4255 = load i8*, i8** %filepathPtr
%res4256 = call ccc i1 @rmatch(i8* %var4254, i8* %val4255)
br i1 %res4256, label %then4253, label %else4253

then4253:
%val4257 = load i8*, i8** %filepathPtr
%res4258 = call fastcc %AudioBuffer* @AudioBuffer_from_aiff_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd(i8* %val4257)
ret %AudioBuffer* %res4258

else4253:
%var4259 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var4260 = bitcast [79 x i8]* @gsxtmaudiobuffer189 to i8*

%val4261 = call i32 (i8*, ...) @printf(i8* %var4259, i8* %var4260)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%null4263 = bitcast i8* null to %AudioBuffer*
ret %AudioBuffer* %null4263
}
@gsxtmaudiobuffer193 = hidden constant [96 x i8] c"AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4283 = load i8*, i8** %_impzPtr
%zone4284 = bitcast i8* %tzone4283 to %mzone*

; let assign value to symbol AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd
%dat_AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone4284, i64 8)
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr = bitcast i8* %dat_AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd to { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***
%tzone4264 = load i8*, i8** %_impzPtr
%zone4265 = bitcast i8* %tzone4264 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4265)
; malloc closure structure
%clsptr4266 = call i8* @llvm_zone_malloc(%mzone* %zone4265, i64 24)
%closure4267 = bitcast i8* %clsptr4266 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr4268 = call i8* @llvm_zone_malloc(%mzone* %zone4265, i64 8)
%environment4269 = bitcast i8* %envptr4268 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable4270 = call %clsvar* @new_address_table()
%var4271 = bitcast [43 x i8]* @gsxtmaudiobuffer192 to i8*
%var4272 = bitcast [45 x i8]* @gsxtmaudiobuffer174 to i8*
%addytable4273 = call %clsvar* @add_address_table(%mzone* %zone4265, i8* %var4271, i32 0, i8* %var4272, i32 3, %clsvar* %addytable4270)
%address-table4274 = bitcast %clsvar* %addytable4273 to i8*

; insert table, function and environment into closure struct
%closure.table4277 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure4267, i32 0, i32 0
store i8* %address-table4274, i8** %closure.table4277
%closure.env4278 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure4267, i32 0, i32 1
store i8* %envptr4268, i8** %closure.env4278
%closure.func4279 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure4267, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, i8*)* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd__4245, %AudioBuffer* (i8*, i8*, i8*)** %closure.func4279
%closure_size4280 = call i64 @llvm_zone_mark_size(%mzone* %zone4265)
call void @llvm_zone_ptr_set_size(i8* %clsptr4266, i64 %closure_size4280)
%wrapper_ptr4281 = call i8* @llvm_zone_malloc(%mzone* %zone4265, i64 8)
%closure_wrapper4282 = bitcast i8* %wrapper_ptr4281 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure4267, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_wrapper4282

; let value assignment
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_wrapper4282, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_wrapper4282
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd, { i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd
%tmp_envptr4276 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}***}* %environment4269, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**** %tmp_envptr4276


%val4285 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpdPtr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %val4285
}


@AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i8*)*,  %AudioBuffer* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i8*)*,  %AudioBuffer* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4286 = bitcast [96 x i8]* @gsxtmaudiobuffer193 to i8*
call i32 (i8*, ...) @printf(i8* %var4286)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i8*)*,  %AudioBuffer* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i8*)*,  %AudioBuffer* (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer194 = hidden constant [65 x i8] c"AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0__4287(i8* %_impz,i8* %_impenv, i64 %frames, i64 %chans, double %samplerate) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4288 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***}*
%AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**** %AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr_

; setup arguments
%framesPtr = alloca i64
store i64 %frames, i64* %framesPtr
%chansPtr = alloca i64
store i64 %chans, i64* %chansPtr
%sampleratePtr = alloca double
store double %samplerate, double* %sampleratePtr


%tzone4298 = load i8*, i8** %_impzPtr
%zone4299 = bitcast i8* %tzone4298 to %mzone*

; let assign value to symbol dat
%datPtr = alloca float*
%val4289 = load i64, i64* %framesPtr
%val4290 = load i64, i64* %chansPtr
%val4291 = mul i64 %val4289, %val4290
%val4292 = getelementptr i64, i64* null, i32 1
%zonesize4293 = mul i64 4, %val4291
%tzone4294 = load i8*, i8** %_impzPtr
%zone4295 = bitcast i8* %tzone4294 to %mzone*
%dat4296 = call i8* @llvm_zone_malloc(%mzone* %zone4295, i64 %zonesize4293)
call i8* @memset(i8* %dat4296, i32 0, i64 %zonesize4293)
%val4297 = bitcast i8* %dat4296 to float*

; let value assignment
%dat = select i1 true, float* %val4297, float* %val4297
store float* %dat, float** %datPtr

%var4300 = bitcast [1 x i8]* @gsxtmaudiobuffer21 to i8*
%res4301 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var4300)
%val4302 = load i64, i64* %framesPtr
%val4303 = load i64, i64* %chansPtr
%val4304 = load float*, float** %datPtr
%val4305 = load double, double* %sampleratePtr
%res4306 = call fastcc %AudioBuffer* @AudioBuffer_h_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ(%String* %res4301, i64 0, i64 %val4302, i64 %val4303, float* %val4304, double %val4305, i64 0, i64 0, i64 60, double 0.00000000000000000000)
ret %AudioBuffer* %res4306
}
@gsxtmaudiobuffer195 = hidden constant [118 x i8] c"AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4326 = load i8*, i8** %_impzPtr
%zone4327 = bitcast i8* %tzone4326 to %mzone*

; let assign value to symbol AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0
%dat_AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0 = call i8* @llvm_zone_malloc(%mzone* %zone4327, i64 8)
%AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr = bitcast i8* %dat_AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***
%tzone4307 = load i8*, i8** %_impzPtr
%zone4308 = bitcast i8* %tzone4307 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4308)
; malloc closure structure
%clsptr4309 = call i8* @llvm_zone_malloc(%mzone* %zone4308, i64 24)
%closure4310 = bitcast i8* %clsptr4309 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*

; malloc environment structure
%envptr4311 = call i8* @llvm_zone_malloc(%mzone* %zone4308, i64 8)
%environment4312 = bitcast i8* %envptr4311 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***}*

; malloc closure address table
%addytable4313 = call %clsvar* @new_address_table()
%var4314 = bitcast [65 x i8]* @gsxtmaudiobuffer194 to i8*
%var4315 = bitcast [58 x i8]* @gsxtmaudiobuffer26 to i8*
%addytable4316 = call %clsvar* @add_address_table(%mzone* %zone4308, i8* %var4314, i32 0, i8* %var4315, i32 3, %clsvar* %addytable4313)
%address-table4317 = bitcast %clsvar* %addytable4316 to i8*

; insert table, function and environment into closure struct
%closure.table4320 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure4310, i32 0, i32 0
store i8* %address-table4317, i8** %closure.table4320
%closure.env4321 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure4310, i32 0, i32 1
store i8* %envptr4311, i8** %closure.env4321
%closure.func4322 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure4310, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, i64, i64, double)* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0__4287, %AudioBuffer* (i8*, i8*, i64, i64, double)** %closure.func4322
%closure_size4323 = call i64 @llvm_zone_mark_size(%mzone* %zone4308)
call void @llvm_zone_ptr_set_size(i8* %clsptr4309, i64 %closure_size4323)
%wrapper_ptr4324 = call i8* @llvm_zone_malloc(%mzone* %zone4308, i64 8)
%closure_wrapper4325 = bitcast i8* %wrapper_ptr4324 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure4310, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_wrapper4325

; let value assignment
%AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0 = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_wrapper4325, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_wrapper4325
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*** %AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr

; add data to environment
; don't need to alloc for env var AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0
%tmp_envptr4319 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}***}* %environment4312, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*** %AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**** %tmp_envptr4319


%val4328 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*** %AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0Ptr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %val4328
}


@AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0(i64 %arg_0,i64 %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_native(i64 %arg_0,i64 %arg_1,double %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4329 = bitcast [118 x i8]* @gsxtmaudiobuffer195 to i8*
call i32 (i8*, ...) @printf(i8* %var4329)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4330 = bitcast [118 x i8]* @gsxtmaudiobuffer195 to i8*
call i32 (i8*, ...) @printf(i8* %var4330)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4331 = bitcast [118 x i8]* @gsxtmaudiobuffer195 to i8*
call i32 (i8*, ...) @printf(i8* %var4331)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64, double}*
%arg_p_0 = getelementptr {i64, i64, double}, {i64, i64, double}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64, double}, {i64, i64, double}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i64, i64, double}, {i64, i64, double}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double)*,  %AudioBuffer* (i8*, i8*, i64, i64, double)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer196 = hidden constant [94 x i8] c"AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0\00"
@gsxtmaudiobuffer197 = hidden constant [91 x i8] c"{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}**\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0__4332(i8* %_impz,i8* %_impenv, i64 %frames, i64 %chans, double %samplerate, double %phase, i64 %root, i64 %loopstart, i64 %loopframes, %String* %b64) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4333 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}***}*
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0Ptr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0Ptr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}**** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0Ptr_

; setup arguments
%framesPtr = alloca i64
store i64 %frames, i64* %framesPtr
%chansPtr = alloca i64
store i64 %chans, i64* %chansPtr
%sampleratePtr = alloca double
store double %samplerate, double* %sampleratePtr
%phasePtr = alloca double
store double %phase, double* %phasePtr
%rootPtr = alloca i64
store i64 %root, i64* %rootPtr
%loopstartPtr = alloca i64
store i64 %loopstart, i64* %loopstartPtr
%loopframesPtr = alloca i64
store i64 %loopframes, i64* %loopframesPtr
%b64Ptr = alloca %String*
store %String* %b64, %String** %b64Ptr


%tzone4338 = load i8*, i8** %_impzPtr
%zone4339 = bitcast i8* %tzone4338 to %mzone*

; let assign value to symbol ab
%abPtr = alloca %AudioBuffer*
%val4334 = load i64, i64* %framesPtr
%val4335 = load i64, i64* %chansPtr
%val4336 = load double, double* %sampleratePtr
%res4337 = call fastcc %AudioBuffer* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0(i64 %val4334, i64 %val4335, double %val4336)

; let value assignment
%ab = select i1 true, %AudioBuffer* %res4337, %AudioBuffer* %res4337
store %AudioBuffer* %ab, %AudioBuffer** %abPtr

%val4340 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4341 = load double, double* %phasePtr
%res4342 = call ccc double @AudioBuffer_set_phase(%AudioBuffer* %val4340, double %val4341)
%val4343 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4344 = load i64, i64* %rootPtr
%res4345 = call ccc i64 @AudioBuffer_set_root_pitch(%AudioBuffer* %val4343, i64 %val4344)
%val4346 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4347 = load i64, i64* %loopstartPtr
%res4348 = call ccc i64 @AudioBuffer_set_loop_start(%AudioBuffer* %val4346, i64 %val4347)
%val4349 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4350 = load i64, i64* %loopframesPtr
%res4351 = call ccc i64 @AudioBuffer_set_loop_frames(%AudioBuffer* %val4349, i64 %val4350)
%val4352 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4353 = load %String*, %String** %b64Ptr
call fastcc void @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd(%AudioBuffer* %val4352, %String* %val4353)
%val4355 = load %AudioBuffer*, %AudioBuffer** %abPtr
ret %AudioBuffer* %val4355
}
@gsxtmaudiobuffer198 = hidden constant [147 x i8] c"AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}** @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4375 = load i8*, i8** %_impzPtr
%zone4376 = bitcast i8* %tzone4375 to %mzone*

; let assign value to symbol AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0
%dat_AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4376, i64 8)
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0Ptr = bitcast i8* %dat_AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}***
%tzone4356 = load i8*, i8** %_impzPtr
%zone4357 = bitcast i8* %tzone4356 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4357)
; malloc closure structure
%clsptr4358 = call i8* @llvm_zone_malloc(%mzone* %zone4357, i64 24)
%closure4359 = bitcast i8* %clsptr4358 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}*

; malloc environment structure
%envptr4360 = call i8* @llvm_zone_malloc(%mzone* %zone4357, i64 8)
%environment4361 = bitcast i8* %envptr4360 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}***}*

; malloc closure address table
%addytable4362 = call %clsvar* @new_address_table()
%var4363 = bitcast [94 x i8]* @gsxtmaudiobuffer196 to i8*
%var4364 = bitcast [91 x i8]* @gsxtmaudiobuffer197 to i8*
%addytable4365 = call %clsvar* @add_address_table(%mzone* %zone4357, i8* %var4363, i32 0, i8* %var4364, i32 3, %clsvar* %addytable4362)
%address-table4366 = bitcast %clsvar* %addytable4365 to i8*

; insert table, function and environment into closure struct
%closure.table4369 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}* %closure4359, i32 0, i32 0
store i8* %address-table4366, i8** %closure.table4369
%closure.env4370 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}* %closure4359, i32 0, i32 1
store i8* %envptr4360, i8** %closure.env4370
%closure.func4371 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}* %closure4359, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0__4332, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)** %closure.func4371
%closure_size4372 = call i64 @llvm_zone_mark_size(%mzone* %zone4357)
call void @llvm_zone_ptr_set_size(i8* %clsptr4358, i64 %closure_size4372)
%wrapper_ptr4373 = call i8* @llvm_zone_malloc(%mzone* %zone4357, i64 8)
%closure_wrapper4374 = bitcast i8* %wrapper_ptr4373 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}* %closure4359, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}** %closure_wrapper4374

; let value assignment
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0 = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}** %closure_wrapper4374, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}** %closure_wrapper4374
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0Ptr

; add data to environment
; don't need to alloc for env var AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0
%tmp_envptr4368 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}***}* %environment4361, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0Ptr, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}**** %tmp_envptr4368


%val4377 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0Ptr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}** %val4377
}


@AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}** @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0(i64 %arg_0,i64 %arg_1,double %arg_2,double %arg_3,i64 %arg_4,i64 %arg_5,i64 %arg_6,%String* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*,  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2, double %arg_3, i64 %arg_4, i64 %arg_5, i64 %arg_6, %String* %arg_7)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_native(i64 %arg_0,i64 %arg_1,double %arg_2,double %arg_3,i64 %arg_4,i64 %arg_5,i64 %arg_6,%String* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*,  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2, double %arg_3, i64 %arg_4, i64 %arg_5, i64 %arg_6, %String* %arg_7)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4378 = bitcast [147 x i8]* @gsxtmaudiobuffer198 to i8*
call i32 (i8*, ...) @printf(i8* %var4378)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4379 = bitcast [147 x i8]* @gsxtmaudiobuffer198 to i8*
call i32 (i8*, ...) @printf(i8* %var4379)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4380 = bitcast [147 x i8]* @gsxtmaudiobuffer198 to i8*
call i32 (i8*, ...) @printf(i8* %var4380)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4381 = bitcast [147 x i8]* @gsxtmaudiobuffer198 to i8*
call i32 (i8*, ...) @printf(i8* %var4381)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc double @r64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4382 = bitcast [147 x i8]* @gsxtmaudiobuffer198 to i8*
call i32 (i8*, ...) @printf(i8* %var4382)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var4383 = bitcast [147 x i8]* @gsxtmaudiobuffer198 to i8*
call i32 (i8*, ...) @printf(i8* %var4383)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i64  @i64value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_integer(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var4384 = bitcast [147 x i8]* @gsxtmaudiobuffer198 to i8*
call i32 (i8*, ...) @printf(i8* %var4384)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc i64  @i64value(i8* %arg_6_val)
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var4385 = bitcast [147 x i8]* @gsxtmaudiobuffer198 to i8*
call i32 (i8*, ...) @printf(i8* %var4385)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%ttv_7 = call ccc i8* @cptr_value(i8* %arg_7_val)
%arg_7 = bitcast i8* %ttv_7 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*,  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2, double %arg_3, i64 %arg_4, i64 %arg_5, i64 %arg_6, %String* %arg_7)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64, double, double, i64, i64, i64, %String*}*
%arg_p_0 = getelementptr {i64, i64, double, double, i64, i64, i64, %String*}, {i64, i64, double, double, i64, i64, i64, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64, double, double, i64, i64, i64, %String*}, {i64, i64, double, double, i64, i64, i64, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i64, i64, double, double, i64, i64, i64, %String*}, {i64, i64, double, double, i64, i64, i64, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
%arg_p_3 = getelementptr {i64, i64, double, double, i64, i64, i64, %String*}, {i64, i64, double, double, i64, i64, i64, %String*}* %fstruct, i32 0, i32 3
%arg_3 = load double, double* %arg_p_3
%arg_p_4 = getelementptr {i64, i64, double, double, i64, i64, i64, %String*}, {i64, i64, double, double, i64, i64, i64, %String*}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
%arg_p_5 = getelementptr {i64, i64, double, double, i64, i64, i64, %String*}, {i64, i64, double, double, i64, i64, i64, %String*}* %fstruct, i32 0, i32 5
%arg_5 = load i64, i64* %arg_p_5
%arg_p_6 = getelementptr {i64, i64, double, double, i64, i64, i64, %String*}, {i64, i64, double, double, i64, i64, i64, %String*}* %fstruct, i32 0, i32 6
%arg_6 = load i64, i64* %arg_p_6
%arg_p_7 = getelementptr {i64, i64, double, double, i64, i64, i64, %String*}, {i64, i64, double, double, i64, i64, i64, %String*}* %fstruct, i32 0, i32 7
%arg_7 = load %String*, %String** %arg_p_7
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsU3RyaW5nKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)*,  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2, double %arg_3, i64 %arg_4, i64 %arg_5, i64 %arg_6, %String* %arg_7)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer199 = hidden constant [97 x i8] c"AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ\00"
@gsxtmaudiobuffer200 = hidden constant [86 x i8] c"{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}**\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ__4386(i8* %_impz,i8* %_impenv, i64 %frames, i64 %chans, double %samplerate, double %phase, i64 %root, i64 %loopstart, i64 %loopframes, i8* %b64) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4387 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}***}*
%AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQPtr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQPtr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}**** %AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQPtr_

; setup arguments
%framesPtr = alloca i64
store i64 %frames, i64* %framesPtr
%chansPtr = alloca i64
store i64 %chans, i64* %chansPtr
%sampleratePtr = alloca double
store double %samplerate, double* %sampleratePtr
%phasePtr = alloca double
store double %phase, double* %phasePtr
%rootPtr = alloca i64
store i64 %root, i64* %rootPtr
%loopstartPtr = alloca i64
store i64 %loopstart, i64* %loopstartPtr
%loopframesPtr = alloca i64
store i64 %loopframes, i64* %loopframesPtr
%b64Ptr = alloca i8*
store i8* %b64, i8** %b64Ptr


%tzone4392 = load i8*, i8** %_impzPtr
%zone4393 = bitcast i8* %tzone4392 to %mzone*

; let assign value to symbol ab
%abPtr = alloca %AudioBuffer*
%val4388 = load i64, i64* %framesPtr
%val4389 = load i64, i64* %chansPtr
%val4390 = load double, double* %sampleratePtr
%res4391 = call fastcc %AudioBuffer* @AudioBuffer_malloc_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0(i64 %val4388, i64 %val4389, double %val4390)

; let value assignment
%ab = select i1 true, %AudioBuffer* %res4391, %AudioBuffer* %res4391
store %AudioBuffer* %ab, %AudioBuffer** %abPtr

%val4394 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4395 = load double, double* %phasePtr
%res4396 = call ccc double @AudioBuffer_set_phase(%AudioBuffer* %val4394, double %val4395)
%val4397 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4398 = load i64, i64* %rootPtr
%res4399 = call ccc i64 @AudioBuffer_set_root_pitch(%AudioBuffer* %val4397, i64 %val4398)
%val4400 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4401 = load i64, i64* %loopstartPtr
%res4402 = call ccc i64 @AudioBuffer_set_loop_start(%AudioBuffer* %val4400, i64 %val4401)
%val4403 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4404 = load i64, i64* %loopframesPtr
%res4405 = call ccc i64 @AudioBuffer_set_loop_frames(%AudioBuffer* %val4403, i64 %val4404)
%val4406 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4407 = load i8*, i8** %b64Ptr
%res4408 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val4407)
call fastcc void @AudioBuffer_set_data_b64_adhoc_W3ZvaWQsQXVkaW9CdWZmZXIqLFN0cmluZypd(%AudioBuffer* %val4406, %String* %res4408)
%val4410 = load %AudioBuffer*, %AudioBuffer** %abPtr
ret %AudioBuffer* %val4410
}
@gsxtmaudiobuffer201 = hidden constant [150 x i8] c"AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}** @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4430 = load i8*, i8** %_impzPtr
%zone4431 = bitcast i8* %tzone4430 to %mzone*

; let assign value to symbol AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ
%dat_AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone4431, i64 8)
%AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQPtr = bitcast i8* %dat_AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}***
%tzone4411 = load i8*, i8** %_impzPtr
%zone4412 = bitcast i8* %tzone4411 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4412)
; malloc closure structure
%clsptr4413 = call i8* @llvm_zone_malloc(%mzone* %zone4412, i64 24)
%closure4414 = bitcast i8* %clsptr4413 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}*

; malloc environment structure
%envptr4415 = call i8* @llvm_zone_malloc(%mzone* %zone4412, i64 8)
%environment4416 = bitcast i8* %envptr4415 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}***}*

; malloc closure address table
%addytable4417 = call %clsvar* @new_address_table()
%var4418 = bitcast [97 x i8]* @gsxtmaudiobuffer199 to i8*
%var4419 = bitcast [86 x i8]* @gsxtmaudiobuffer200 to i8*
%addytable4420 = call %clsvar* @add_address_table(%mzone* %zone4412, i8* %var4418, i32 0, i8* %var4419, i32 3, %clsvar* %addytable4417)
%address-table4421 = bitcast %clsvar* %addytable4420 to i8*

; insert table, function and environment into closure struct
%closure.table4424 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}* %closure4414, i32 0, i32 0
store i8* %address-table4421, i8** %closure.table4424
%closure.env4425 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}* %closure4414, i32 0, i32 1
store i8* %envptr4415, i8** %closure.env4425
%closure.func4426 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}* %closure4414, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)* @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ__4386, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)** %closure.func4426
%closure_size4427 = call i64 @llvm_zone_mark_size(%mzone* %zone4412)
call void @llvm_zone_ptr_set_size(i8* %clsptr4413, i64 %closure_size4427)
%wrapper_ptr4428 = call i8* @llvm_zone_malloc(%mzone* %zone4412, i64 8)
%closure_wrapper4429 = bitcast i8* %wrapper_ptr4428 to { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}* %closure4414, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}** %closure_wrapper4429

; let value assignment
%AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}** %closure_wrapper4429, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}** %closure_wrapper4429
store { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}** %AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ, { i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}*** %AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ
%tmp_envptr4423 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}***}* %environment4416, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}*** %AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQPtr, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}**** %tmp_envptr4423


%val4432 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}*** %AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQPtr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}** %val4432
}


@AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}** @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ(i64 %arg_0,i64 %arg_1,double %arg_2,double %arg_3,i64 %arg_4,i64 %arg_5,i64 %arg_6,i8* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*,  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2, double %arg_3, i64 %arg_4, i64 %arg_5, i64 %arg_6, i8* %arg_7)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_native(i64 %arg_0,i64 %arg_1,double %arg_2,double %arg_3,i64 %arg_4,i64 %arg_5,i64 %arg_6,i8* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*,  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2, double %arg_3, i64 %arg_4, i64 %arg_5, i64 %arg_6, i8* %arg_7)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4433 = bitcast [150 x i8]* @gsxtmaudiobuffer201 to i8*
call i32 (i8*, ...) @printf(i8* %var4433)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i64  @i64value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4434 = bitcast [150 x i8]* @gsxtmaudiobuffer201 to i8*
call i32 (i8*, ...) @printf(i8* %var4434)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_real(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4435 = bitcast [150 x i8]* @gsxtmaudiobuffer201 to i8*
call i32 (i8*, ...) @printf(i8* %var4435)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc double @r64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_real(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4436 = bitcast [150 x i8]* @gsxtmaudiobuffer201 to i8*
call i32 (i8*, ...) @printf(i8* %var4436)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc double @r64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4437 = bitcast [150 x i8]* @gsxtmaudiobuffer201 to i8*
call i32 (i8*, ...) @printf(i8* %var4437)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var4438 = bitcast [150 x i8]* @gsxtmaudiobuffer201 to i8*
call i32 (i8*, ...) @printf(i8* %var4438)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i64  @i64value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_integer(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var4439 = bitcast [150 x i8]* @gsxtmaudiobuffer201 to i8*
call i32 (i8*, ...) @printf(i8* %var4439)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc i64  @i64value(i8* %arg_6_val)
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr_or_str(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var4440 = bitcast [150 x i8]* @gsxtmaudiobuffer201 to i8*
call i32 (i8*, ...) @printf(i8* %var4440)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc i8*  @cptr_value(i8* %arg_7_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*,  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2, double %arg_3, i64 %arg_4, i64 %arg_5, i64 %arg_6, i8* %arg_7)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i64, i64, double, double, i64, i64, i64, i8*}*
%arg_p_0 = getelementptr {i64, i64, double, double, i64, i64, i64, i8*}, {i64, i64, double, double, i64, i64, i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i64, i64* %arg_p_0
%arg_p_1 = getelementptr {i64, i64, double, double, i64, i64, i64, i8*}, {i64, i64, double, double, i64, i64, i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i64, i64, double, double, i64, i64, i64, i8*}, {i64, i64, double, double, i64, i64, i64, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load double, double* %arg_p_2
%arg_p_3 = getelementptr {i64, i64, double, double, i64, i64, i64, i8*}, {i64, i64, double, double, i64, i64, i64, i8*}* %fstruct, i32 0, i32 3
%arg_3 = load double, double* %arg_p_3
%arg_p_4 = getelementptr {i64, i64, double, double, i64, i64, i64, i8*}, {i64, i64, double, double, i64, i64, i64, i8*}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
%arg_p_5 = getelementptr {i64, i64, double, double, i64, i64, i64, i8*}, {i64, i64, double, double, i64, i64, i64, i8*}* %fstruct, i32 0, i32 5
%arg_5 = load i64, i64* %arg_p_5
%arg_p_6 = getelementptr {i64, i64, double, double, i64, i64, i64, i8*}, {i64, i64, double, double, i64, i64, i64, i8*}* %fstruct, i32 0, i32 6
%arg_6 = load i64, i64* %arg_p_6
%arg_p_7 = getelementptr {i64, i64, double, double, i64, i64, i64, i8*}, {i64, i64, double, double, i64, i64, i64, i8*}* %fstruct, i32 0, i32 7
%arg_7 = load i8*, i8** %arg_p_7
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_cstring_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZSxkb3VibGUsaTY0LGk2NCxpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)*,  %AudioBuffer* (i8*, i8*, i64, i64, double, double, i64, i64, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, i64 %arg_0, i64 %arg_1, double %arg_2, double %arg_3, i64 %arg_4, i64 %arg_5, i64 %arg_6, i8* %arg_7)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer202 = hidden constant [55 x i8] c"AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd__4441(i8* %_impz,i8* %_impenv, %AudioBuffer* %in) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4442 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}*
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr_

; setup arguments
%inPtr = alloca %AudioBuffer*
store %AudioBuffer* %in, %AudioBuffer** %inPtr


%tzone4448 = load i8*, i8** %_impzPtr
%zone4449 = bitcast i8* %tzone4448 to %mzone*

; let assign value to symbol size_s_2
%size_s_2Ptr = alloca i64
%tzone4457 = load i8*, i8** %_impzPtr
%zone4458 = bitcast i8* %tzone4457 to %mzone*

; let assign value to symbol dat
%datPtr = alloca float*
%tzone4461 = load i8*, i8** %_impzPtr
%zone4462 = bitcast i8* %tzone4461 to %mzone*

; let assign value to symbol olddat
%olddatPtr = alloca float*
%val4443 = load %AudioBuffer*, %AudioBuffer** %inPtr
%res4444 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val4443)
%val4445 = load %AudioBuffer*, %AudioBuffer** %inPtr
%res4446 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val4445)
%val4447 = mul i64 %res4444, %res4446

; let value assignment
%size_s_2 = select i1 true, i64 %val4447, i64 %val4447
store i64 %size_s_2, i64* %size_s_2Ptr

%val4450 = load i64, i64* %size_s_2Ptr
%val4451 = getelementptr i64, i64* null, i32 1
%zonesize4452 = mul i64 4, %val4450
%tzone4453 = load i8*, i8** %_impzPtr
%zone4454 = bitcast i8* %tzone4453 to %mzone*
%dat4455 = call i8* @llvm_zone_malloc(%mzone* %zone4454, i64 %zonesize4452)
call i8* @memset(i8* %dat4455, i32 0, i64 %zonesize4452)
%val4456 = bitcast i8* %dat4455 to float*

; let value assignment
%dat = select i1 true, float* %val4456, float* %val4456
store float* %dat, float** %datPtr

%val4459 = load %AudioBuffer*, %AudioBuffer** %inPtr
%res4460 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val4459)

; let value assignment
%olddat = select i1 true, float* %res4460, float* %res4460
store float* %olddat, float** %olddatPtr

%val4463 = load float*, float** %datPtr
%val4464 = bitcast float* %val4463 to i8*
%val4465 = load float*, float** %olddatPtr
%val4466 = bitcast float* %val4465 to i8*
%val4467 = load i64, i64* %size_s_2Ptr
%val4468 = mul i64 %val4467, 4
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val4464, i8* %val4466, i64 %val4468, i32 1, i1 0)
%val4470 = load %AudioBuffer*, %AudioBuffer** %inPtr
%res4471 = call ccc %String* @AudioBuffer_filepath(%AudioBuffer* %val4470)
%val4472 = load %AudioBuffer*, %AudioBuffer** %inPtr
%res4473 = call ccc i64 @AudioBuffer_playhead(%AudioBuffer* %val4472)
%val4474 = load %AudioBuffer*, %AudioBuffer** %inPtr
%res4475 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val4474)
%val4476 = load %AudioBuffer*, %AudioBuffer** %inPtr
%res4477 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val4476)
%val4478 = load float*, float** %datPtr
%val4479 = load %AudioBuffer*, %AudioBuffer** %inPtr
%res4480 = call ccc double @AudioBuffer_samplerate(%AudioBuffer* %val4479)
%val4481 = load %AudioBuffer*, %AudioBuffer** %inPtr
%res4482 = call ccc i64 @AudioBuffer_loop_start(%AudioBuffer* %val4481)
%val4483 = load %AudioBuffer*, %AudioBuffer** %inPtr
%res4484 = call ccc i64 @AudioBuffer_loop_frames(%AudioBuffer* %val4483)
%val4485 = load %AudioBuffer*, %AudioBuffer** %inPtr
%res4486 = call ccc i64 @AudioBuffer_root_pitch(%AudioBuffer* %val4485)
%val4487 = load %AudioBuffer*, %AudioBuffer** %inPtr
%res4488 = call ccc double @AudioBuffer_phase(%AudioBuffer* %val4487)
%res4489 = call fastcc %AudioBuffer* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ(%String* %res4471, i64 %res4473, i64 %res4475, i64 %res4477, float* %val4478, double %res4480, i64 %res4482, i64 %res4484, i64 %res4486, double %res4488)
ret %AudioBuffer* %res4489
}
@gsxtmaudiobuffer203 = hidden constant [108 x i8] c"AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4509 = load i8*, i8** %_impzPtr
%zone4510 = bitcast i8* %tzone4509 to %mzone*

; let assign value to symbol AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd
%dat_AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd = call i8* @llvm_zone_malloc(%mzone* %zone4510, i64 8)
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr = bitcast i8* %dat_AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***
%tzone4490 = load i8*, i8** %_impzPtr
%zone4491 = bitcast i8* %tzone4490 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4491)
; malloc closure structure
%clsptr4492 = call i8* @llvm_zone_malloc(%mzone* %zone4491, i64 24)
%closure4493 = bitcast i8* %clsptr4492 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*

; malloc environment structure
%envptr4494 = call i8* @llvm_zone_malloc(%mzone* %zone4491, i64 8)
%environment4495 = bitcast i8* %envptr4494 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}*

; malloc closure address table
%addytable4496 = call %clsvar* @new_address_table()
%var4497 = bitcast [55 x i8]* @gsxtmaudiobuffer202 to i8*
%var4498 = bitcast [55 x i8]* @gsxtmaudiobuffer13 to i8*
%addytable4499 = call %clsvar* @add_address_table(%mzone* %zone4491, i8* %var4497, i32 0, i8* %var4498, i32 3, %clsvar* %addytable4496)
%address-table4500 = bitcast %clsvar* %addytable4499 to i8*

; insert table, function and environment into closure struct
%closure.table4503 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure4493, i32 0, i32 0
store i8* %address-table4500, i8** %closure.table4503
%closure.env4504 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure4493, i32 0, i32 1
store i8* %envptr4494, i8** %closure.env4504
%closure.func4505 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure4493, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, %AudioBuffer*)* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd__4441, %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %closure.func4505
%closure_size4506 = call i64 @llvm_zone_mark_size(%mzone* %zone4491)
call void @llvm_zone_ptr_set_size(i8* %clsptr4492, i64 %closure_size4506)
%wrapper_ptr4507 = call i8* @llvm_zone_malloc(%mzone* %zone4491, i64 8)
%closure_wrapper4508 = bitcast i8* %wrapper_ptr4507 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure4493, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper4508

; let value assignment
%AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper4508, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper4508
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd
%tmp_envptr4502 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}* %environment4495, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**** %tmp_envptr4502


%val4511 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*** %AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %val4511
}


@AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_native(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4512 = bitcast [108 x i8]* @gsxtmaudiobuffer203 to i8*
call i32 (i8*, ...) @printf(i8* %var4512)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*}*
%arg_p_0 = getelementptr {%AudioBuffer*}, {%AudioBuffer*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer204 = hidden constant [67 x i8] c"AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd__4513(i8* %_impz,i8* %_impenv, %AudioBuffer* %ab) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4514 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}*
%AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**** %AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr_

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr


%var4515 = bitcast [1 x i8]* @gsxtmaudiobuffer21 to i8*
%res4516 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %var4515)
%val4517 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res4518 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val4517)
%val4519 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res4520 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val4519)
%val4521 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res4522 = call ccc float* @AudioBuffer_data(%AudioBuffer* %val4521)
%val4523 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res4524 = call ccc double @AudioBuffer_samplerate(%AudioBuffer* %val4523)
%val4525 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res4526 = call ccc i64 @AudioBuffer_loop_start(%AudioBuffer* %val4525)
%val4527 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res4528 = call ccc i64 @AudioBuffer_loop_frames(%AudioBuffer* %val4527)
%val4529 = load %AudioBuffer*, %AudioBuffer** %abPtr
%res4530 = call ccc i64 @AudioBuffer_root_pitch(%AudioBuffer* %val4529)
%res4531 = call fastcc %AudioBuffer* @AudioBuffer_z_adhoc_W0F1ZGlvQnVmZmVyKixTdHJpbmcqLGk2NCxpNjQsaTY0LGZsb2F0Kixkb3VibGUsaTY0LGk2NCxpNjQsZG91YmxlXQ(%String* %res4516, i64 0, i64 %res4518, i64 %res4520, float* %res4522, double %res4524, i64 %res4526, i64 %res4528, i64 %res4530, double 0.00000000000000000000)
ret %AudioBuffer* %res4531
}
@gsxtmaudiobuffer205 = hidden constant [120 x i8] c"AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4551 = load i8*, i8** %_impzPtr
%zone4552 = bitcast i8* %tzone4551 to %mzone*

; let assign value to symbol AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd
%dat_AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd = call i8* @llvm_zone_malloc(%mzone* %zone4552, i64 8)
%AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr = bitcast i8* %dat_AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***
%tzone4532 = load i8*, i8** %_impzPtr
%zone4533 = bitcast i8* %tzone4532 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4533)
; malloc closure structure
%clsptr4534 = call i8* @llvm_zone_malloc(%mzone* %zone4533, i64 24)
%closure4535 = bitcast i8* %clsptr4534 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*

; malloc environment structure
%envptr4536 = call i8* @llvm_zone_malloc(%mzone* %zone4533, i64 8)
%environment4537 = bitcast i8* %envptr4536 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}*

; malloc closure address table
%addytable4538 = call %clsvar* @new_address_table()
%var4539 = bitcast [67 x i8]* @gsxtmaudiobuffer204 to i8*
%var4540 = bitcast [55 x i8]* @gsxtmaudiobuffer13 to i8*
%addytable4541 = call %clsvar* @add_address_table(%mzone* %zone4533, i8* %var4539, i32 0, i8* %var4540, i32 3, %clsvar* %addytable4538)
%address-table4542 = bitcast %clsvar* %addytable4541 to i8*

; insert table, function and environment into closure struct
%closure.table4545 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure4535, i32 0, i32 0
store i8* %address-table4542, i8** %closure.table4545
%closure.env4546 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure4535, i32 0, i32 1
store i8* %envptr4536, i8** %closure.env4546
%closure.func4547 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure4535, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, %AudioBuffer*)* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd__4513, %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %closure.func4547
%closure_size4548 = call i64 @llvm_zone_mark_size(%mzone* %zone4533)
call void @llvm_zone_ptr_set_size(i8* %clsptr4534, i64 %closure_size4548)
%wrapper_ptr4549 = call i8* @llvm_zone_malloc(%mzone* %zone4533, i64 8)
%closure_wrapper4550 = bitcast i8* %wrapper_ptr4549 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure4535, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper4550

; let value assignment
%AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper4550, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper4550
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*** %AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd
%tmp_envptr4544 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}***}* %environment4537, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*** %AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**** %tmp_envptr4544


%val4553 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*** %AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipdPtr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %val4553
}


@AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_native(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4554 = bitcast [120 x i8]* @gsxtmaudiobuffer205 to i8*
call i32 (i8*, ...) @printf(i8* %var4554)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*}*
%arg_p_0 = getelementptr {%AudioBuffer*}, {%AudioBuffer*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer206 = hidden constant [59 x i8] c"wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0\00"
@gsxtmaudiobuffer207 = hidden constant [87 x i8] c"{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**\00"
@gsxtmaudiobuffer208 = hidden constant [7 x i8] c"buffer\00"
@gsxtmaudiobuffer209 = hidden constant [14 x i8] c"%AudioBuffer*\00"
@gsxtmaudiobuffer210 = hidden constant [3 x i8] c"wt\00"
@gsxtmaudiobuffer211 = hidden constant [15 x i8] c"_anon_lambda_6\00"
@gsxtmaudiobuffer212 = hidden constant [46 x i8] c"{i8*, i8*, float (i8*, i8*, float, float)*}**\00"
define dllexport fastcc float @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0__4556(i8* %_impz,i8* %_impenv, float %amp, float %freq) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4562 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}*
%wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0Ptr_ = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 0
%wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0Ptr = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**** %wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0Ptr_
%bufferPtr_ = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 1
%bufferPtr = load %AudioBuffer**, %AudioBuffer*** %bufferPtr_
%wtPtr_ = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 2
%wtPtr = load %AudioBuffer**, %AudioBuffer*** %wtPtr_
%_anon_lambda_6Ptr_ = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}* %impenv, i32 0, i32 3
%_anon_lambda_6Ptr = load {i8*, i8*, float (i8*, i8*, float, float)*}***, {i8*, i8*, float (i8*, i8*, float, float)*}**** %_anon_lambda_6Ptr_

; setup arguments
%ampPtr = alloca float
store float %amp, float* %ampPtr
%freqPtr = alloca float
store float %freq, float* %freqPtr


%val4563 = load float, float* %ampPtr
%val4564 = load %AudioBuffer*, %AudioBuffer** %wtPtr
%val4565 = load float, float* %freqPtr
%res4566 = call fastcc float @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd(%AudioBuffer* %val4564, float %val4565, i64 0)
%val4567 = fmul float %val4563, %res4566
ret float %val4567
}
define dllexport fastcc {i8*, i8*, float (i8*, i8*, float, float)*}** @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0__4555(i8* %_impz,i8* %_impenv, %AudioBuffer* %buffer) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4557 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***}*
%wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0Ptr_ = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***}* %impenv, i32 0, i32 0
%wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0Ptr = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**** %wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0Ptr_

; setup arguments
%dat_buffer = call i8* @llvm_zone_malloc(%mzone* %zone4557, i64 8)
%bufferPtr = bitcast i8* %dat_buffer to %AudioBuffer**
store %AudioBuffer* %buffer, %AudioBuffer** %bufferPtr


%tzone4560 = load i8*, i8** %_impzPtr
%zone4561 = bitcast i8* %tzone4560 to %mzone*

; let assign value to symbol wt
%dat_wt = call i8* @llvm_zone_malloc(%mzone* %zone4561, i64 8)
%wtPtr = bitcast i8* %dat_wt to %AudioBuffer**
%val4558 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res4559 = call fastcc %AudioBuffer* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd(%AudioBuffer* %val4558)

; let value assignment
%wt = select i1 true, %AudioBuffer* %res4559, %AudioBuffer* %res4559
store %AudioBuffer* %wt, %AudioBuffer** %wtPtr

%tzone4602 = load i8*, i8** %_impzPtr
%zone4603 = bitcast i8* %tzone4602 to %mzone*

; let assign value to symbol _anon_lambda_6
%dat__anon_lambda_6 = call i8* @llvm_zone_malloc(%mzone* %zone4603, i64 8)
%_anon_lambda_6Ptr = bitcast i8* %dat__anon_lambda_6 to { i8*, i8*, float (i8*, i8*, float, float)*}***
%tzone4568 = load i8*, i8** %_impzPtr
%zone4569 = bitcast i8* %tzone4568 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4569)
; malloc closure structure
%clsptr4570 = call i8* @llvm_zone_malloc(%mzone* %zone4569, i64 24)
%closure4571 = bitcast i8* %clsptr4570 to { i8*, i8*, float (i8*, i8*, float, float)*}*

; malloc environment structure
%envptr4572 = call i8* @llvm_zone_malloc(%mzone* %zone4569, i64 32)
%environment4573 = bitcast i8* %envptr4572 to {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}*

; malloc closure address table
%addytable4574 = call %clsvar* @new_address_table()
%var4575 = bitcast [59 x i8]* @gsxtmaudiobuffer206 to i8*
%var4576 = bitcast [87 x i8]* @gsxtmaudiobuffer207 to i8*
%addytable4577 = call %clsvar* @add_address_table(%mzone* %zone4569, i8* %var4575, i32 0, i8* %var4576, i32 3, %clsvar* %addytable4574)
%var4578 = bitcast [7 x i8]* @gsxtmaudiobuffer208 to i8*
%var4579 = bitcast [14 x i8]* @gsxtmaudiobuffer209 to i8*
%addytable4580 = call %clsvar* @add_address_table(%mzone* %zone4569, i8* %var4578, i32 8, i8* %var4579, i32 3, %clsvar* %addytable4577)
%var4581 = bitcast [3 x i8]* @gsxtmaudiobuffer210 to i8*
%var4582 = bitcast [14 x i8]* @gsxtmaudiobuffer209 to i8*
%addytable4583 = call %clsvar* @add_address_table(%mzone* %zone4569, i8* %var4581, i32 16, i8* %var4582, i32 3, %clsvar* %addytable4580)
%var4584 = bitcast [15 x i8]* @gsxtmaudiobuffer211 to i8*
%var4585 = bitcast [46 x i8]* @gsxtmaudiobuffer212 to i8*
%addytable4586 = call %clsvar* @add_address_table(%mzone* %zone4569, i8* %var4584, i32 24, i8* %var4585, i32 3, %clsvar* %addytable4583)
%address-table4587 = bitcast %clsvar* %addytable4586 to i8*

; insert table, function and environment into closure struct
%closure.table4596 = getelementptr { i8*, i8*, float (i8*, i8*, float, float)*}, { i8*, i8*, float (i8*, i8*, float, float)*}* %closure4571, i32 0, i32 0
store i8* %address-table4587, i8** %closure.table4596
%closure.env4597 = getelementptr { i8*, i8*, float (i8*, i8*, float, float)*}, { i8*, i8*, float (i8*, i8*, float, float)*}* %closure4571, i32 0, i32 1
store i8* %envptr4572, i8** %closure.env4597
%closure.func4598 = getelementptr { i8*, i8*, float (i8*, i8*, float, float)*}, { i8*, i8*, float (i8*, i8*, float, float)*}* %closure4571, i32 0, i32 2
store float (i8*, i8*, float, float)* @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0__4556, float (i8*, i8*, float, float)** %closure.func4598
%closure_size4599 = call i64 @llvm_zone_mark_size(%mzone* %zone4569)
call void @llvm_zone_ptr_set_size(i8* %clsptr4570, i64 %closure_size4599)
%wrapper_ptr4600 = call i8* @llvm_zone_malloc(%mzone* %zone4569, i64 8)
%closure_wrapper4601 = bitcast i8* %wrapper_ptr4600 to { i8*, i8*, float (i8*, i8*, float, float)*}**
store { i8*, i8*, float (i8*, i8*, float, float)*}* %closure4571, { i8*, i8*, float (i8*, i8*, float, float)*}** %closure_wrapper4601

; let value assignment
%_anon_lambda_6 = select i1 true, { i8*, i8*, float (i8*, i8*, float, float)*}** %closure_wrapper4601, { i8*, i8*, float (i8*, i8*, float, float)*}** %closure_wrapper4601
store { i8*, i8*, float (i8*, i8*, float, float)*}** %_anon_lambda_6, { i8*, i8*, float (i8*, i8*, float, float)*}*** %_anon_lambda_6Ptr

; add data to environment
; don't need to alloc for env var wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0
%tmp_envptr4589 = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}* %environment4573, i32 0, i32 0
store {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*** %wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0Ptr, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**** %tmp_envptr4589

; don't need to alloc for env var buffer
%tmp_envptr4591 = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}* %environment4573, i32 0, i32 1
store %AudioBuffer** %bufferPtr, %AudioBuffer*** %tmp_envptr4591

; don't need to alloc for env var wt
%tmp_envptr4593 = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}* %environment4573, i32 0, i32 2
store %AudioBuffer** %wtPtr, %AudioBuffer*** %tmp_envptr4593

; don't need to alloc for env var _anon_lambda_6
%tmp_envptr4595 = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, float, float)*}***}* %environment4573, i32 0, i32 3
store {i8*, i8*, float (i8*, i8*, float, float)*}*** %_anon_lambda_6Ptr, {i8*, i8*, float (i8*, i8*, float, float)*}**** %tmp_envptr4595


%val4604 = load {i8*, i8*, float (i8*, i8*, float, float)*}**, {i8*, i8*, float (i8*, i8*, float, float)*}*** %_anon_lambda_6Ptr
ret {i8*, i8*, float (i8*, i8*, float, float)*}** %val4604
}
@gsxtmaudiobuffer213 = hidden constant [112 x i8] c"wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4624 = load i8*, i8** %_impzPtr
%zone4625 = bitcast i8* %tzone4624 to %mzone*

; let assign value to symbol wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0
%dat_wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4625, i64 8)
%wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0Ptr = bitcast i8* %dat_wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0 to { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***
%tzone4605 = load i8*, i8** %_impzPtr
%zone4606 = bitcast i8* %tzone4605 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4606)
; malloc closure structure
%clsptr4607 = call i8* @llvm_zone_malloc(%mzone* %zone4606, i64 24)
%closure4608 = bitcast i8* %clsptr4607 to { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*

; malloc environment structure
%envptr4609 = call i8* @llvm_zone_malloc(%mzone* %zone4606, i64 8)
%environment4610 = bitcast i8* %envptr4609 to {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***}*

; malloc closure address table
%addytable4611 = call %clsvar* @new_address_table()
%var4612 = bitcast [59 x i8]* @gsxtmaudiobuffer206 to i8*
%var4613 = bitcast [87 x i8]* @gsxtmaudiobuffer207 to i8*
%addytable4614 = call %clsvar* @add_address_table(%mzone* %zone4606, i8* %var4612, i32 0, i8* %var4613, i32 3, %clsvar* %addytable4611)
%address-table4615 = bitcast %clsvar* %addytable4614 to i8*

; insert table, function and environment into closure struct
%closure.table4618 = getelementptr { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure4608, i32 0, i32 0
store i8* %address-table4615, i8** %closure.table4618
%closure.env4619 = getelementptr { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure4608, i32 0, i32 1
store i8* %envptr4609, i8** %closure.env4619
%closure.func4620 = getelementptr { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure4608, i32 0, i32 2
store {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)* @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0__4555, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)** %closure.func4620
%closure_size4621 = call i64 @llvm_zone_mark_size(%mzone* %zone4606)
call void @llvm_zone_ptr_set_size(i8* %clsptr4607, i64 %closure_size4621)
%wrapper_ptr4622 = call i8* @llvm_zone_malloc(%mzone* %zone4606, i64 8)
%closure_wrapper4623 = bitcast i8* %wrapper_ptr4622 to { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**
store { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure4608, { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper4623

; let value assignment
%wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0 = select i1 true, { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper4623, { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper4623
store { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0, { i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*** %wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0Ptr

; add data to environment
; don't need to alloc for env var wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0
%tmp_envptr4617 = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***}* %environment4610, i32 0, i32 0
store {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*** %wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0Ptr, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**** %tmp_envptr4617


%val4626 = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*** %wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0Ptr
ret {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %val4626
}


@wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_var = dllexport global [1 x i8*] [ i8* null ]

@wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc {i8*, i8*, float (i8*, i8*, float, float)*}** @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*,  {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc {i8*, i8*, float (i8*, i8*, float, float)*}** %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret {i8*, i8*, float (i8*, i8*, float, float)*}** %result
}


define dllexport ccc {i8*, i8*, float (i8*, i8*, float, float)*}** @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_native(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*,  {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc {i8*, i8*, float (i8*, i8*, float, float)*}** %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret {i8*, i8*, float (i8*, i8*, float, float)*}** %result
}


define dllexport ccc i8*  @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4627 = bitcast [112 x i8]* @gsxtmaudiobuffer213 to i8*
call i32 (i8*, ...) @printf(i8* %var4627)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*,  {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc {i8*, i8*, float (i8*, i8*, float, float)*}** %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%tmpres = bitcast {i8*, i8*, float (i8*, i8*, float, float)*}** %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*}*
%arg_p_0 = getelementptr {%AudioBuffer*}, {%AudioBuffer*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wt_c_adhoc_W1tmbG9hdCxmbG9hdCxmbG9hdF0qLEF1ZGlvQnVmZmVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)*,  {i8*, i8*, float (i8*, i8*, float, float)*}** (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc {i8*, i8*, float (i8*, i8*, float, float)*}** %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmaudiobuffer214 = hidden constant [67 x i8] c"wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd\00"
@gsxtmaudiobuffer215 = hidden constant [92 x i8] c"{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**\00"
@gsxtmaudiobuffer216 = hidden constant [15 x i8] c"_anon_lambda_7\00"
@gsxtmaudiobuffer217 = hidden constant [51 x i8] c"{i8*, i8*, float (i8*, i8*, i64, float, float)*}**\00"
define dllexport fastcc float @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd__4629(i8* %_impz,i8* %_impenv, i64 %chan, float %amp, float %freq) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4635 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}*
%wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipdPtr_ = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}* %impenv, i32 0, i32 0
%wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipdPtr = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**** %wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipdPtr_
%bufferPtr_ = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}* %impenv, i32 0, i32 1
%bufferPtr = load %AudioBuffer**, %AudioBuffer*** %bufferPtr_
%wtPtr_ = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}* %impenv, i32 0, i32 2
%wtPtr = load %AudioBuffer**, %AudioBuffer*** %wtPtr_
%_anon_lambda_7Ptr_ = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}* %impenv, i32 0, i32 3
%_anon_lambda_7Ptr = load {i8*, i8*, float (i8*, i8*, i64, float, float)*}***, {i8*, i8*, float (i8*, i8*, i64, float, float)*}**** %_anon_lambda_7Ptr_

; setup arguments
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr
%ampPtr = alloca float
store float %amp, float* %ampPtr
%freqPtr = alloca float
store float %freq, float* %freqPtr


%val4636 = load float, float* %ampPtr
%val4637 = load %AudioBuffer*, %AudioBuffer** %wtPtr
%val4638 = load float, float* %freqPtr
%val4639 = load i64, i64* %chanPtr
%res4640 = call fastcc float @AudioBuffer_read_interp_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixmbG9hdCxpNjRd(%AudioBuffer* %val4637, float %val4638, i64 %val4639)
%val4641 = fmul float %val4636, %res4640
ret float %val4641
}
define dllexport fastcc {i8*, i8*, float (i8*, i8*, i64, float, float)*}** @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd__4628(i8* %_impz,i8* %_impenv, %AudioBuffer* %buffer) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4630 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***}*
%wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipdPtr_ = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***}* %impenv, i32 0, i32 0
%wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipdPtr = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**** %wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipdPtr_

; setup arguments
%dat_buffer = call i8* @llvm_zone_malloc(%mzone* %zone4630, i64 8)
%bufferPtr = bitcast i8* %dat_buffer to %AudioBuffer**
store %AudioBuffer* %buffer, %AudioBuffer** %bufferPtr


%tzone4633 = load i8*, i8** %_impzPtr
%zone4634 = bitcast i8* %tzone4633 to %mzone*

; let assign value to symbol wt
%dat_wt = call i8* @llvm_zone_malloc(%mzone* %zone4634, i64 8)
%wtPtr = bitcast i8* %dat_wt to %AudioBuffer**
%val4631 = load %AudioBuffer*, %AudioBuffer** %bufferPtr
%res4632 = call fastcc %AudioBuffer* @AudioBuffer_shared_data_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlcipd(%AudioBuffer* %val4631)

; let value assignment
%wt = select i1 true, %AudioBuffer* %res4632, %AudioBuffer* %res4632
store %AudioBuffer* %wt, %AudioBuffer** %wtPtr

%tzone4676 = load i8*, i8** %_impzPtr
%zone4677 = bitcast i8* %tzone4676 to %mzone*

; let assign value to symbol _anon_lambda_7
%dat__anon_lambda_7 = call i8* @llvm_zone_malloc(%mzone* %zone4677, i64 8)
%_anon_lambda_7Ptr = bitcast i8* %dat__anon_lambda_7 to { i8*, i8*, float (i8*, i8*, i64, float, float)*}***
%tzone4642 = load i8*, i8** %_impzPtr
%zone4643 = bitcast i8* %tzone4642 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4643)
; malloc closure structure
%clsptr4644 = call i8* @llvm_zone_malloc(%mzone* %zone4643, i64 24)
%closure4645 = bitcast i8* %clsptr4644 to { i8*, i8*, float (i8*, i8*, i64, float, float)*}*

; malloc environment structure
%envptr4646 = call i8* @llvm_zone_malloc(%mzone* %zone4643, i64 32)
%environment4647 = bitcast i8* %envptr4646 to {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}*

; malloc closure address table
%addytable4648 = call %clsvar* @new_address_table()
%var4649 = bitcast [67 x i8]* @gsxtmaudiobuffer214 to i8*
%var4650 = bitcast [92 x i8]* @gsxtmaudiobuffer215 to i8*
%addytable4651 = call %clsvar* @add_address_table(%mzone* %zone4643, i8* %var4649, i32 0, i8* %var4650, i32 3, %clsvar* %addytable4648)
%var4652 = bitcast [7 x i8]* @gsxtmaudiobuffer208 to i8*
%var4653 = bitcast [14 x i8]* @gsxtmaudiobuffer209 to i8*
%addytable4654 = call %clsvar* @add_address_table(%mzone* %zone4643, i8* %var4652, i32 8, i8* %var4653, i32 3, %clsvar* %addytable4651)
%var4655 = bitcast [3 x i8]* @gsxtmaudiobuffer210 to i8*
%var4656 = bitcast [14 x i8]* @gsxtmaudiobuffer209 to i8*
%addytable4657 = call %clsvar* @add_address_table(%mzone* %zone4643, i8* %var4655, i32 16, i8* %var4656, i32 3, %clsvar* %addytable4654)
%var4658 = bitcast [15 x i8]* @gsxtmaudiobuffer216 to i8*
%var4659 = bitcast [51 x i8]* @gsxtmaudiobuffer217 to i8*
%addytable4660 = call %clsvar* @add_address_table(%mzone* %zone4643, i8* %var4658, i32 24, i8* %var4659, i32 3, %clsvar* %addytable4657)
%address-table4661 = bitcast %clsvar* %addytable4660 to i8*

; insert table, function and environment into closure struct
%closure.table4670 = getelementptr { i8*, i8*, float (i8*, i8*, i64, float, float)*}, { i8*, i8*, float (i8*, i8*, i64, float, float)*}* %closure4645, i32 0, i32 0
store i8* %address-table4661, i8** %closure.table4670
%closure.env4671 = getelementptr { i8*, i8*, float (i8*, i8*, i64, float, float)*}, { i8*, i8*, float (i8*, i8*, i64, float, float)*}* %closure4645, i32 0, i32 1
store i8* %envptr4646, i8** %closure.env4671
%closure.func4672 = getelementptr { i8*, i8*, float (i8*, i8*, i64, float, float)*}, { i8*, i8*, float (i8*, i8*, i64, float, float)*}* %closure4645, i32 0, i32 2
store float (i8*, i8*, i64, float, float)* @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd__4629, float (i8*, i8*, i64, float, float)** %closure.func4672
%closure_size4673 = call i64 @llvm_zone_mark_size(%mzone* %zone4643)
call void @llvm_zone_ptr_set_size(i8* %clsptr4644, i64 %closure_size4673)
%wrapper_ptr4674 = call i8* @llvm_zone_malloc(%mzone* %zone4643, i64 8)
%closure_wrapper4675 = bitcast i8* %wrapper_ptr4674 to { i8*, i8*, float (i8*, i8*, i64, float, float)*}**
store { i8*, i8*, float (i8*, i8*, i64, float, float)*}* %closure4645, { i8*, i8*, float (i8*, i8*, i64, float, float)*}** %closure_wrapper4675

; let value assignment
%_anon_lambda_7 = select i1 true, { i8*, i8*, float (i8*, i8*, i64, float, float)*}** %closure_wrapper4675, { i8*, i8*, float (i8*, i8*, i64, float, float)*}** %closure_wrapper4675
store { i8*, i8*, float (i8*, i8*, i64, float, float)*}** %_anon_lambda_7, { i8*, i8*, float (i8*, i8*, i64, float, float)*}*** %_anon_lambda_7Ptr

; add data to environment
; don't need to alloc for env var wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd
%tmp_envptr4663 = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}* %environment4647, i32 0, i32 0
store {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*** %wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipdPtr, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**** %tmp_envptr4663

; don't need to alloc for env var buffer
%tmp_envptr4665 = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}* %environment4647, i32 0, i32 1
store %AudioBuffer** %bufferPtr, %AudioBuffer*** %tmp_envptr4665

; don't need to alloc for env var wt
%tmp_envptr4667 = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}* %environment4647, i32 0, i32 2
store %AudioBuffer** %wtPtr, %AudioBuffer*** %tmp_envptr4667

; don't need to alloc for env var _anon_lambda_7
%tmp_envptr4669 = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***, %AudioBuffer**, %AudioBuffer**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}***}* %environment4647, i32 0, i32 3
store {i8*, i8*, float (i8*, i8*, i64, float, float)*}*** %_anon_lambda_7Ptr, {i8*, i8*, float (i8*, i8*, i64, float, float)*}**** %tmp_envptr4669


%val4678 = load {i8*, i8*, float (i8*, i8*, i64, float, float)*}**, {i8*, i8*, float (i8*, i8*, i64, float, float)*}*** %_anon_lambda_7Ptr
ret {i8*, i8*, float (i8*, i8*, i64, float, float)*}** %val4678
}
@gsxtmaudiobuffer218 = hidden constant [120 x i8] c"wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4698 = load i8*, i8** %_impzPtr
%zone4699 = bitcast i8* %tzone4698 to %mzone*

; let assign value to symbol wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd
%dat_wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd = call i8* @llvm_zone_malloc(%mzone* %zone4699, i64 8)
%wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipdPtr = bitcast i8* %dat_wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd to { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***
%tzone4679 = load i8*, i8** %_impzPtr
%zone4680 = bitcast i8* %tzone4679 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4680)
; malloc closure structure
%clsptr4681 = call i8* @llvm_zone_malloc(%mzone* %zone4680, i64 24)
%closure4682 = bitcast i8* %clsptr4681 to { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*

; malloc environment structure
%envptr4683 = call i8* @llvm_zone_malloc(%mzone* %zone4680, i64 8)
%environment4684 = bitcast i8* %envptr4683 to {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***}*

; malloc closure address table
%addytable4685 = call %clsvar* @new_address_table()
%var4686 = bitcast [67 x i8]* @gsxtmaudiobuffer214 to i8*
%var4687 = bitcast [92 x i8]* @gsxtmaudiobuffer215 to i8*
%addytable4688 = call %clsvar* @add_address_table(%mzone* %zone4680, i8* %var4686, i32 0, i8* %var4687, i32 3, %clsvar* %addytable4685)
%address-table4689 = bitcast %clsvar* %addytable4688 to i8*

; insert table, function and environment into closure struct
%closure.table4692 = getelementptr { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure4682, i32 0, i32 0
store i8* %address-table4689, i8** %closure.table4692
%closure.env4693 = getelementptr { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure4682, i32 0, i32 1
store i8* %envptr4683, i8** %closure.env4693
%closure.func4694 = getelementptr { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure4682, i32 0, i32 2
store {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)* @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd__4628, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)** %closure.func4694
%closure_size4695 = call i64 @llvm_zone_mark_size(%mzone* %zone4680)
call void @llvm_zone_ptr_set_size(i8* %clsptr4681, i64 %closure_size4695)
%wrapper_ptr4696 = call i8* @llvm_zone_malloc(%mzone* %zone4680, i64 8)
%closure_wrapper4697 = bitcast i8* %wrapper_ptr4696 to { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**
store { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure4682, { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper4697

; let value assignment
%wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd = select i1 true, { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper4697, { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_wrapper4697
store { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd, { i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*** %wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipdPtr

; add data to environment
; don't need to alloc for env var wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd
%tmp_envptr4691 = getelementptr {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***}, {{i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}***}* %environment4684, i32 0, i32 0
store {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*** %wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipdPtr, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**** %tmp_envptr4691


%val4700 = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*** %wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipdPtr
ret {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %val4700
}


@wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_var = dllexport global [1 x i8*] [ i8* null ]

@wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc {i8*, i8*, float (i8*, i8*, i64, float, float)*}** @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*,  {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc {i8*, i8*, float (i8*, i8*, i64, float, float)*}** %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret {i8*, i8*, float (i8*, i8*, i64, float, float)*}** %result
}


define dllexport ccc {i8*, i8*, float (i8*, i8*, i64, float, float)*}** @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_native(%AudioBuffer* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*,  {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc {i8*, i8*, float (i8*, i8*, i64, float, float)*}** %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
ret {i8*, i8*, float (i8*, i8*, i64, float, float)*}** %result
}


define dllexport ccc i8*  @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4701 = bitcast [120 x i8]* @gsxtmaudiobuffer218 to i8*
call i32 (i8*, ...) @printf(i8* %var4701)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*,  {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc {i8*, i8*, float (i8*, i8*, i64, float, float)*}** %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%tmpres = bitcast {i8*, i8*, float (i8*, i8*, i64, float, float)*}** %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*}*
%arg_p_0 = getelementptr {%AudioBuffer*}, {%AudioBuffer*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @wt_mc_c_adhoc_W1tmbG9hdCxpNjQsZmxvYXQsZmxvYXRdKixBdWRpb0J1ZmZlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}*, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}, {i8*, i8*, {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)*,  {i8*, i8*, float (i8*, i8*, i64, float, float)*}** (i8*, i8*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc {i8*, i8*, float (i8*, i8*, i64, float, float)*}** %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


define dllexport ccc float @playbuf(%AudioBuffer* %ab, i64 %chan) nounwind inlinehint {
entry:
%zone4703 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone4703 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr


%val4704 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4705 = load i64, i64* %chanPtr
%res4706 = call fastcc float @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd(%AudioBuffer* %val4704, i64 %val4705)
ret float %res4706
}
@gsxtmaudiobuffer219 = hidden constant [61 x i8] c"playbuf Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @playbuf_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4708 = bitcast [61 x i8]* @gsxtmaudiobuffer219 to i8*
call i32 (i8*, ...) @printf(i8* %var4708)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4709 = bitcast [61 x i8]* @gsxtmaudiobuffer219 to i8*
call i32 (i8*, ...) @printf(i8* %var4709)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%result = call ccc float @playbuf(%AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


define dllexport ccc float @loopbuf(%AudioBuffer* %ab, i64 %chan) nounwind inlinehint {
entry:
%zone4711 = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %zone4711 to i8*
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr

; setup arguments
%abPtr = alloca %AudioBuffer*
store %AudioBuffer* %ab, %AudioBuffer** %abPtr
%chanPtr = alloca i64
store i64 %chan, i64* %chanPtr


%val4712 = load %AudioBuffer*, %AudioBuffer** %abPtr
%val4713 = load i64, i64* %chanPtr
%res4714 = call fastcc float @AudioBuffer_read_looped_adhoc_W2Zsb2F0LEF1ZGlvQnVmZmVyKixpNjRd(%AudioBuffer* %val4712, i64 %val4713)
ret float %res4714
}
@gsxtmaudiobuffer220 = hidden constant [61 x i8] c"loopbuf Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc i8*  @loopbuf_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4716 = bitcast [61 x i8]* @gsxtmaudiobuffer220 to i8*
call i32 (i8*, ...) @printf(i8* %var4716)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4717 = bitcast [61 x i8]* @gsxtmaudiobuffer220 to i8*
call i32 (i8*, ...) @printf(i8* %var4717)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%result = call ccc float @loopbuf(%AudioBuffer* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_float(i8* %_sc, float %result)
ret i8* %res
}


@gsxtmaudiobuffer221 = hidden constant [47 x i8] c"Error: cannot concat incompatible audiobuffers\00"
@gsxtmaudiobuffer222 = hidden constant [80 x i8] c"AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ\00"
@gsxtmaudiobuffer223 = hidden constant [70 x i8] c"{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}**\00"
define dllexport fastcc %AudioBuffer* @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ__4718(i8* %_impz,i8* %_impenv, %AudioBuffer* %ab1, %AudioBuffer* %ab2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4719 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}***}*
%AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQPtr_ = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}***}* %impenv, i32 0, i32 0
%AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQPtr = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}***, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}**** %AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQPtr_

; setup arguments
%ab1Ptr = alloca %AudioBuffer*
store %AudioBuffer* %ab1, %AudioBuffer** %ab1Ptr
%ab2Ptr = alloca %AudioBuffer*
store %AudioBuffer* %ab2, %AudioBuffer** %ab2Ptr

; promote local stack var allocations
%tzone4798 = load i8*, i8** %_impzPtr
%zone4799 = bitcast i8* %tzone4798 to %mzone*
%ifptr4721 = alloca i1
%ifptr4732 = alloca i1

%val4722 = load %AudioBuffer*, %AudioBuffer** %ab1Ptr
%res4723 = call ccc double @AudioBuffer_samplerate(%AudioBuffer* %val4722)
%val4724 = load %AudioBuffer*, %AudioBuffer** %ab2Ptr
%res4725 = call ccc double @AudioBuffer_samplerate(%AudioBuffer* %val4724)
%cmp4726 = fcmp une double %res4723, %res4725
br i1 %cmp4726, label %then4721, label %else4721

then4721:
%val4727 = load %AudioBuffer*, %AudioBuffer** %ab1Ptr
%res4728 = call ccc double @AudioBuffer_samplerate(%AudioBuffer* %val4727)
%val4729 = load %AudioBuffer*, %AudioBuffer** %ab2Ptr
%res4730 = call ccc double @AudioBuffer_samplerate(%AudioBuffer* %val4729)
%cmp4731 = fcmp une double %res4728, %res4730
store i1 %cmp4731, i1* %ifptr4721
br label %ifcont4721

else4721:
%val4733 = load %AudioBuffer*, %AudioBuffer** %ab1Ptr
%res4734 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val4733)
%val4735 = load %AudioBuffer*, %AudioBuffer** %ab2Ptr
%res4736 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val4735)
%cmp4737 = icmp ne i64 %res4734, %res4736
br i1 %cmp4737, label %then4732, label %else4732

then4732:
%val4738 = load %AudioBuffer*, %AudioBuffer** %ab1Ptr
%res4739 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val4738)
%val4740 = load %AudioBuffer*, %AudioBuffer** %ab2Ptr
%res4741 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val4740)
%cmp4742 = icmp ne i64 %res4739, %res4741
store i1 %cmp4742, i1* %ifptr4732
br label %ifcont4732

else4732:
%res4743 = call ccc i1 @impc_false()
store i1 %res4743, i1* %ifptr4732
br label %ifcont4732

ifcont4732:
%ifres4744 = load i1, i1* %ifptr4732

store i1 %ifres4744, i1* %ifptr4721
br label %ifcont4721

ifcont4721:
%ifres4745 = load i1, i1* %ifptr4721

br i1 %ifres4745, label %then4720, label %else4720

then4720:
%var4746 = bitcast [3 x i8]* @gsxtmaudiobuffer50 to i8*
%var4747 = bitcast [47 x i8]* @gsxtmaudiobuffer221 to i8*

%val4748 = call i32 (i8*, ...) @printf(i8* %var4746, i8* %var4747)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%null4750 = bitcast i8* null to %AudioBuffer*
ret %AudioBuffer* %null4750

else4720:
%tzone4761 = load i8*, i8** %_impzPtr
%zone4762 = bitcast i8* %tzone4761 to %mzone*

; let assign value to symbol new
%newPtr = alloca %AudioBuffer*
%tzone4765 = load i8*, i8** %_impzPtr
%zone4766 = bitcast i8* %tzone4765 to %mzone*

; let assign value to symbol dat1
%dat1Ptr = alloca float*
%tzone4771 = load i8*, i8** %_impzPtr
%zone4772 = bitcast i8* %tzone4771 to %mzone*

; let assign value to symbol dat2
%dat2Ptr = alloca float*
%val4751 = load %AudioBuffer*, %AudioBuffer** %ab1Ptr
%res4752 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val4751)
%val4753 = load %AudioBuffer*, %AudioBuffer** %ab2Ptr
%res4754 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val4753)
%val4755 = add i64 %res4752, %res4754
%val4756 = load %AudioBuffer*, %AudioBuffer** %ab1Ptr
%res4757 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val4756)
%val4758 = load %AudioBuffer*, %AudioBuffer** %ab1Ptr
%res4759 = call ccc double @AudioBuffer_samplerate(%AudioBuffer* %val4758)
%res4760 = call fastcc %AudioBuffer* @AudioBuffer_adhoc_W0F1ZGlvQnVmZmVyKixpNjQsaTY0LGRvdWJsZV0(i64 %val4755, i64 %res4757, double %res4759)

; let value assignment
%new = select i1 true, %AudioBuffer* %res4760, %AudioBuffer* %res4760
store %AudioBuffer* %new, %AudioBuffer** %newPtr

%val4763 = load %AudioBuffer*, %AudioBuffer** %newPtr
%res4764 = call ccc float* @AudioBuffer_ptr(%AudioBuffer* %val4763, i64 0, i64 0)

; let value assignment
%dat1 = select i1 true, float* %res4764, float* %res4764
store float* %dat1, float** %dat1Ptr

%val4767 = load %AudioBuffer*, %AudioBuffer** %newPtr
%val4768 = load %AudioBuffer*, %AudioBuffer** %ab1Ptr
%res4769 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val4768)
%res4770 = call ccc float* @AudioBuffer_ptr(%AudioBuffer* %val4767, i64 %res4769, i64 0)

; let value assignment
%dat2 = select i1 true, float* %res4770, float* %res4770
store float* %dat2, float** %dat2Ptr

%val4773 = load float*, float** %dat1Ptr
%val4774 = bitcast float* %val4773 to i8*
%val4775 = load %AudioBuffer*, %AudioBuffer** %ab1Ptr
%res4776 = call ccc float* @AudioBuffer_ptr(%AudioBuffer* %val4775, i64 0, i64 0)
%val4777 = bitcast float* %res4776 to i8*
%val4778 = load %AudioBuffer*, %AudioBuffer** %ab1Ptr
%res4779 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val4778)
%val4780 = load %AudioBuffer*, %AudioBuffer** %ab1Ptr
%res4781 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val4780)
%val4782 = mul i64 %res4779, %res4781
%val4783 = mul i64 %val4782, 4
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val4774, i8* %val4777, i64 %val4783, i32 1, i1 0)
%val4785 = load float*, float** %dat2Ptr
%val4786 = bitcast float* %val4785 to i8*
%val4787 = load %AudioBuffer*, %AudioBuffer** %ab2Ptr
%res4788 = call ccc float* @AudioBuffer_ptr(%AudioBuffer* %val4787, i64 0, i64 0)
%val4789 = bitcast float* %res4788 to i8*
%val4790 = load %AudioBuffer*, %AudioBuffer** %ab2Ptr
%res4791 = call ccc i64 @AudioBuffer_frames(%AudioBuffer* %val4790)
%val4792 = load %AudioBuffer*, %AudioBuffer** %ab2Ptr
%res4793 = call ccc i64 @AudioBuffer_channels(%AudioBuffer* %val4792)
%val4794 = mul i64 %res4791, %res4793
%val4795 = mul i64 %val4794, 4
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val4786, i8* %val4789, i64 %val4795, i32 1, i1 0)
%val4797 = load %AudioBuffer*, %AudioBuffer** %newPtr
ret %AudioBuffer* %val4797
}
@gsxtmaudiobuffer224 = hidden constant [133 x i8] c"AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}** @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4819 = load i8*, i8** %_impzPtr
%zone4820 = bitcast i8* %tzone4819 to %mzone*

; let assign value to symbol AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ
%dat_AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone4820, i64 8)
%AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQPtr = bitcast i8* %dat_AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}***
%tzone4800 = load i8*, i8** %_impzPtr
%zone4801 = bitcast i8* %tzone4800 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4801)
; malloc closure structure
%clsptr4802 = call i8* @llvm_zone_malloc(%mzone* %zone4801, i64 24)
%closure4803 = bitcast i8* %clsptr4802 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}*

; malloc environment structure
%envptr4804 = call i8* @llvm_zone_malloc(%mzone* %zone4801, i64 8)
%environment4805 = bitcast i8* %envptr4804 to {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}***}*

; malloc closure address table
%addytable4806 = call %clsvar* @new_address_table()
%var4807 = bitcast [80 x i8]* @gsxtmaudiobuffer222 to i8*
%var4808 = bitcast [70 x i8]* @gsxtmaudiobuffer223 to i8*
%addytable4809 = call %clsvar* @add_address_table(%mzone* %zone4801, i8* %var4807, i32 0, i8* %var4808, i32 3, %clsvar* %addytable4806)
%address-table4810 = bitcast %clsvar* %addytable4809 to i8*

; insert table, function and environment into closure struct
%closure.table4813 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}* %closure4803, i32 0, i32 0
store i8* %address-table4810, i8** %closure.table4813
%closure.env4814 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}* %closure4803, i32 0, i32 1
store i8* %envptr4804, i8** %closure.env4814
%closure.func4815 = getelementptr { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}* %closure4803, i32 0, i32 2
store %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)* @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ__4718, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)** %closure.func4815
%closure_size4816 = call i64 @llvm_zone_mark_size(%mzone* %zone4801)
call void @llvm_zone_ptr_set_size(i8* %clsptr4802, i64 %closure_size4816)
%wrapper_ptr4817 = call i8* @llvm_zone_malloc(%mzone* %zone4801, i64 8)
%closure_wrapper4818 = bitcast i8* %wrapper_ptr4817 to { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}**
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}* %closure4803, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}** %closure_wrapper4818

; let value assignment
%AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ = select i1 true, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}** %closure_wrapper4818, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}** %closure_wrapper4818
store { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}** %AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ, { i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}*** %AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQPtr

; add data to environment
; don't need to alloc for env var AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ
%tmp_envptr4812 = getelementptr {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}***}, {{i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}***}* %environment4805, i32 0, i32 0
store {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}*** %AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQPtr, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}**** %tmp_envptr4812


%val4821 = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}**, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}*** %AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQPtr
ret {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}** %val4821
}


@AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}** @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %AudioBuffer* @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ(%AudioBuffer* %arg_0,%AudioBuffer* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %AudioBuffer* %arg_1)
ret %AudioBuffer* %result
}


define dllexport ccc %AudioBuffer* @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_native(%AudioBuffer* %arg_0,%AudioBuffer* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %AudioBuffer* %arg_1)
ret %AudioBuffer* %result
}


define dllexport ccc i8*  @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4822 = bitcast [133 x i8]* @gsxtmaudiobuffer224 to i8*
call i32 (i8*, ...) @printf(i8* %var4822)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %AudioBuffer*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4823 = bitcast [133 x i8]* @gsxtmaudiobuffer224 to i8*
call i32 (i8*, ...) @printf(i8* %var4823)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %AudioBuffer*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %AudioBuffer* %arg_1)
%tmpres = bitcast %AudioBuffer* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%AudioBuffer*, %AudioBuffer*}*
%arg_p_0 = getelementptr {%AudioBuffer*, %AudioBuffer*}, {%AudioBuffer*, %AudioBuffer*}* %fstruct, i32 0, i32 0
%arg_0 = load %AudioBuffer*, %AudioBuffer** %arg_p_0
%arg_p_1 = getelementptr {%AudioBuffer*, %AudioBuffer*}, {%AudioBuffer*, %AudioBuffer*}* %fstruct, i32 0, i32 1
%arg_1 = load %AudioBuffer*, %AudioBuffer** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @AudioBuffer_concat_adhoc_W0F1ZGlvQnVmZmVyKixBdWRpb0J1ZmZlciosQXVkaW9CdWZmZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}**
%closure = load {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}*, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}, {i8*, i8*, %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*}* %closure, i32 0, i32 1
%ff = load  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)*,  %AudioBuffer* (i8*, i8*, %AudioBuffer*, %AudioBuffer*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %AudioBuffer* %ff(i8* %_impz, i8* %ee, %AudioBuffer* %arg_0, %AudioBuffer* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


