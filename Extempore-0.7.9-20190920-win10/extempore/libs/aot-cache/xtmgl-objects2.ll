@gsxtmgl-objects20 = hidden constant [18 x i8] c"%s: Invalid Enum
\00"
@gsxtmgl-objects21 = hidden constant [19 x i8] c"%s: Invalid Value
\00"
@gsxtmgl-objects22 = hidden constant [23 x i8] c"%s: Invalid Operation
\00"
@gsxtmgl-objects23 = hidden constant [19 x i8] c"%s: Out Of Memory
\00"
@gsxtmgl-objects24 = hidden constant [35 x i8] c"%s: Invalid Framebuffer Operation
\00"
@gsxtmgl-objects25 = hidden constant [4 x i8] c"%s
\00"
@gsxtmgl-objects26 = hidden constant [36 x i8] c"gl_print_error_adhoc_W3ZvaWQsaTgqXQ\00"
@gsxtmgl-objects27 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i8*)*}**\00"
define dllexport fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ__1(i8* %_impz,i8* %_impenv, i8* %msg) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*
%gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr = load {i8*, i8*, void (i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*)*}**** %gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr_

; setup arguments
%msgPtr = alloca i8*
store i8* %msg, i8** %msgPtr


%tzone4 = load i8*, i8** %_impzPtr
%zone5 = bitcast i8* %tzone4 to %mzone*

; let assign value to symbol err
%errPtr = alloca i32
%res3 = call fastcc i32 @glGetError_adhoc_W2kzMl0()

; let value assignment
%err = select i1 true, i32 %res3, i32 %res3
store i32 %err, i32* %errPtr

; promote local stack var allocations
%tzone56 = load i8*, i8** %_impzPtr
%zone57 = bitcast i8* %tzone56 to %mzone*
%ifptr6 = alloca i32
%ifptr13 = alloca i32
%ifptr20 = alloca i32
%ifptr27 = alloca i32
%ifptr34 = alloca i32
%ifptr41 = alloca i32
%val7 = load i32, i32* %errPtr
%val8 = load i32, i32* @GL_INVALID_ENUM
%cmp9 = icmp eq i32 %val7, %val8
br i1 %cmp9, label %then6, label %else6

then6:
%var10 = bitcast [18 x i8]* @gsxtmgl-objects20 to i8*
%val11 = load i8*, i8** %msgPtr

%val12 = call i32 (i8*, ...) @printf(i8* %var10, i8* %val11)
store i32 %val12, i32* %ifptr6
br label %ifcont6

else6:
%val14 = load i32, i32* %errPtr
%val15 = load i32, i32* @GL_INVALID_VALUE
%cmp16 = icmp eq i32 %val14, %val15
br i1 %cmp16, label %then13, label %else13

then13:
%var17 = bitcast [19 x i8]* @gsxtmgl-objects21 to i8*
%val18 = load i8*, i8** %msgPtr

%val19 = call i32 (i8*, ...) @printf(i8* %var17, i8* %val18)
store i32 %val19, i32* %ifptr13
br label %ifcont13

else13:
%val21 = load i32, i32* %errPtr
%val22 = load i32, i32* @GL_INVALID_OPERATION
%cmp23 = icmp eq i32 %val21, %val22
br i1 %cmp23, label %then20, label %else20

then20:
%var24 = bitcast [23 x i8]* @gsxtmgl-objects22 to i8*
%val25 = load i8*, i8** %msgPtr

%val26 = call i32 (i8*, ...) @printf(i8* %var24, i8* %val25)
store i32 %val26, i32* %ifptr20
br label %ifcont20

else20:
%val28 = load i32, i32* %errPtr
%val29 = load i32, i32* @GL_OUT_OF_MEMORY
%cmp30 = icmp eq i32 %val28, %val29
br i1 %cmp30, label %then27, label %else27

then27:
%var31 = bitcast [19 x i8]* @gsxtmgl-objects23 to i8*
%val32 = load i8*, i8** %msgPtr

%val33 = call i32 (i8*, ...) @printf(i8* %var31, i8* %val32)
store i32 %val33, i32* %ifptr27
br label %ifcont27

else27:
%val35 = load i32, i32* %errPtr
%val36 = load i32, i32* @GL_INVALID_FRAMEBUFFER_OPERATION
%cmp37 = icmp eq i32 %val35, %val36
br i1 %cmp37, label %then34, label %else34

then34:
%var38 = bitcast [35 x i8]* @gsxtmgl-objects24 to i8*
%val39 = load i8*, i8** %msgPtr

%val40 = call i32 (i8*, ...) @printf(i8* %var38, i8* %val39)
store i32 %val40, i32* %ifptr34
br label %ifcont34

else34:
%val42 = load i32, i32* %errPtr
%val43 = load i32, i32* @GL_NO_ERROR
%cmp44 = icmp eq i32 %val42, %val43
br i1 %cmp44, label %then41, label %else41

then41:
%val45 = trunc i64 1 to i32
store i32 %val45, i32* %ifptr41
br label %ifcont41

else41:
%var46 = bitcast [4 x i8]* @gsxtmgl-objects25 to i8*
%val47 = load i8*, i8** %msgPtr

%val48 = call i32 (i8*, ...) @printf(i8* %var46, i8* %val47)
store i32 %val48, i32* %ifptr41
br label %ifcont41

ifcont41:
%ifres49 = load i32, i32* %ifptr41

store i32 %ifres49, i32* %ifptr34
br label %ifcont34

ifcont34:
%ifres50 = load i32, i32* %ifptr34

store i32 %ifres50, i32* %ifptr27
br label %ifcont27

ifcont27:
%ifres51 = load i32, i32* %ifptr27

store i32 %ifres51, i32* %ifptr20
br label %ifcont20

ifcont20:
%ifres52 = load i32, i32* %ifptr20

store i32 %ifres52, i32* %ifptr13
br label %ifcont13

ifcont13:
%ifres53 = load i32, i32* %ifptr13

store i32 %ifres53, i32* %ifptr6
br label %ifcont6

ifcont6:
%ifres54 = load i32, i32* %ifptr6

ret void
}
@gsxtmgl-objects28 = hidden constant [89 x i8] c"gl_print_error_adhoc_W3ZvaWQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone77 = load i8*, i8** %_impzPtr
%zone78 = bitcast i8* %tzone77 to %mzone*

; let assign value to symbol gl_print_error_adhoc_W3ZvaWQsaTgqXQ
%dat_gl_print_error_adhoc_W3ZvaWQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone78, i64 8)
%gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr = bitcast i8* %dat_gl_print_error_adhoc_W3ZvaWQsaTgqXQ to { i8*, i8*, void (i8*, i8*, i8*)*}***
%tzone58 = load i8*, i8** %_impzPtr
%zone59 = bitcast i8* %tzone58 to %mzone*
call void @llvm_zone_mark(%mzone* %zone59)
; malloc closure structure
%clsptr60 = call i8* @llvm_zone_malloc(%mzone* %zone59, i64 24)
%closure61 = bitcast i8* %clsptr60 to { i8*, i8*, void (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr62 = call i8* @llvm_zone_malloc(%mzone* %zone59, i64 8)
%environment63 = bitcast i8* %envptr62 to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable64 = call %clsvar* @new_address_table()
%var65 = bitcast [36 x i8]* @gsxtmgl-objects26 to i8*
%var66 = bitcast [36 x i8]* @gsxtmgl-objects27 to i8*
%addytable67 = call %clsvar* @add_address_table(%mzone* %zone59, i8* %var65, i32 0, i8* %var66, i32 3, %clsvar* %addytable64)
%address-table68 = bitcast %clsvar* %addytable67 to i8*

; insert table, function and environment into closure struct
%closure.table71 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure61, i32 0, i32 0
store i8* %address-table68, i8** %closure.table71
%closure.env72 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure61, i32 0, i32 1
store i8* %envptr62, i8** %closure.env72
%closure.func73 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure61, i32 0, i32 2
store void (i8*, i8*, i8*)* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ__1, void (i8*, i8*, i8*)** %closure.func73
%closure_size74 = call i64 @llvm_zone_mark_size(%mzone* %zone59)
call void @llvm_zone_ptr_set_size(i8* %clsptr60, i64 %closure_size74)
%wrapper_ptr75 = call i8* @llvm_zone_malloc(%mzone* %zone59, i64 8)
%closure_wrapper76 = bitcast i8* %wrapper_ptr75 to { i8*, i8*, void (i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*)*}* %closure61, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper76

; let value assignment
%gl_print_error_adhoc_W3ZvaWQsaTgqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper76, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper76
store { i8*, i8*, void (i8*, i8*, i8*)*}** %gl_print_error_adhoc_W3ZvaWQsaTgqXQ, { i8*, i8*, void (i8*, i8*, i8*)*}*** %gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var gl_print_error_adhoc_W3ZvaWQsaTgqXQ
%tmp_envptr70 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %environment63, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*)*}*** %gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr, {i8*, i8*, void (i8*, i8*, i8*)*}**** %tmp_envptr70


%val79 = load {i8*, i8*, void (i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*)*}*** %gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr
ret {i8*, i8*, void (i8*, i8*, i8*)*}** %val79
}


@gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc i8*  @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var80 = bitcast [89 x i8]* @gsxtmgl-objects28 to i8*
call i32 (i8*, ...) @printf(i8* %var80)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects29 = hidden constant [13 x i8] c"OpenGL Error\00"
@gsxtmgl-objects210 = hidden constant [30 x i8] c"gl_print_error_adhoc_W3ZvaWRd\00"
@gsxtmgl-objects211 = hidden constant [31 x i8] c"{i8*, i8*, void (i8*, i8*)*}**\00"
define dllexport fastcc void @gl_print_error_adhoc_W3ZvaWRd__81(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone82 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%gl_print_error_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%gl_print_error_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %gl_print_error_adhoc_W3ZvaWRdPtr_

; setup arguments


%var83 = bitcast [13 x i8]* @gsxtmgl-objects29 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var83)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @gl_print_error_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone104 = load i8*, i8** %_impzPtr
%zone105 = bitcast i8* %tzone104 to %mzone*

; let assign value to symbol gl_print_error_adhoc_W3ZvaWRd
%dat_gl_print_error_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone105, i64 8)
%gl_print_error_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_gl_print_error_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone85 = load i8*, i8** %_impzPtr
%zone86 = bitcast i8* %tzone85 to %mzone*
call void @llvm_zone_mark(%mzone* %zone86)
; malloc closure structure
%clsptr87 = call i8* @llvm_zone_malloc(%mzone* %zone86, i64 24)
%closure88 = bitcast i8* %clsptr87 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr89 = call i8* @llvm_zone_malloc(%mzone* %zone86, i64 8)
%environment90 = bitcast i8* %envptr89 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable91 = call %clsvar* @new_address_table()
%var92 = bitcast [30 x i8]* @gsxtmgl-objects210 to i8*
%var93 = bitcast [31 x i8]* @gsxtmgl-objects211 to i8*
%addytable94 = call %clsvar* @add_address_table(%mzone* %zone86, i8* %var92, i32 0, i8* %var93, i32 3, %clsvar* %addytable91)
%address-table95 = bitcast %clsvar* %addytable94 to i8*

; insert table, function and environment into closure struct
%closure.table98 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure88, i32 0, i32 0
store i8* %address-table95, i8** %closure.table98
%closure.env99 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure88, i32 0, i32 1
store i8* %envptr89, i8** %closure.env99
%closure.func100 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure88, i32 0, i32 2
store void (i8*, i8*)* @gl_print_error_adhoc_W3ZvaWRd__81, void (i8*, i8*)** %closure.func100
%closure_size101 = call i64 @llvm_zone_mark_size(%mzone* %zone86)
call void @llvm_zone_ptr_set_size(i8* %clsptr87, i64 %closure_size101)
%wrapper_ptr102 = call i8* @llvm_zone_malloc(%mzone* %zone86, i64 8)
%closure_wrapper103 = bitcast i8* %wrapper_ptr102 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure88, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper103

; let value assignment
%gl_print_error_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper103, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper103
store { i8*, i8*, void (i8*, i8*)*}** %gl_print_error_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %gl_print_error_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var gl_print_error_adhoc_W3ZvaWRd
%tmp_envptr97 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment90, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %gl_print_error_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr97


%val106 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %gl_print_error_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val106
}


@gl_print_error_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@gl_print_error_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @gl_print_error_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @gl_print_error_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @gl_print_error_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @gl_print_error_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @gl_print_error_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @gl_print_error_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @gl_print_error_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects212 = hidden constant [3 x i8] c"%s\00"
@gsxtmgl-objects213 = hidden constant [51 x i8] c"--------------------------------------------------\00"
@gsxtmgl-objects214 = hidden constant [29 x i8] c"Extempore OpenGL driver info\00"
@gsxtmgl-objects215 = hidden constant [15 x i8] c"  Vendor:  %s
\00"
@gsxtmgl-objects216 = hidden constant [15 x i8] c"Renderer:  %s
\00"
@gsxtmgl-objects217 = hidden constant [15 x i8] c" Version:  %s
\00"
@gsxtmgl-objects218 = hidden constant [36 x i8] c"gl_print_driver_info_adhoc_W3ZvaWRd\00"
define dllexport fastcc void @gl_print_driver_info_adhoc_W3ZvaWRd__107(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone108 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%gl_print_driver_info_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%gl_print_driver_info_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %gl_print_driver_info_adhoc_W3ZvaWRdPtr_

; setup arguments


%var109 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var110 = bitcast [51 x i8]* @gsxtmgl-objects213 to i8*

%val111 = call i32 (i8*, ...) @printf(i8* %var109, i8* %var110)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%var113 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var114 = bitcast [29 x i8]* @gsxtmgl-objects214 to i8*

%val115 = call i32 (i8*, ...) @printf(i8* %var113, i8* %var114)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%var117 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var118 = bitcast [51 x i8]* @gsxtmgl-objects213 to i8*

%val119 = call i32 (i8*, ...) @printf(i8* %var117, i8* %var118)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%var121 = bitcast [15 x i8]* @gsxtmgl-objects215 to i8*
%val122 = load i32, i32* @GL_VENDOR
%res123 = call fastcc i8* @glGetString_adhoc_W2k4KixpMzJd(i32 %val122)

%val124 = call i32 (i8*, ...) @printf(i8* %var121, i8* %res123)
%var125 = bitcast [15 x i8]* @gsxtmgl-objects216 to i8*
%val126 = load i32, i32* @GL_RENDERER
%res127 = call fastcc i8* @glGetString_adhoc_W2k4KixpMzJd(i32 %val126)

%val128 = call i32 (i8*, ...) @printf(i8* %var125, i8* %res127)
%var129 = bitcast [15 x i8]* @gsxtmgl-objects217 to i8*
%val130 = load i32, i32* @GL_VERSION
%res131 = call fastcc i8* @glGetString_adhoc_W2k4KixpMzJd(i32 %val130)

%val132 = call i32 (i8*, ...) @printf(i8* %var129, i8* %res131)
%var133 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var134 = bitcast [51 x i8]* @gsxtmgl-objects213 to i8*

%val135 = call i32 (i8*, ...) @printf(i8* %var133, i8* %var134)
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @gl_print_driver_info_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone157 = load i8*, i8** %_impzPtr
%zone158 = bitcast i8* %tzone157 to %mzone*

; let assign value to symbol gl_print_driver_info_adhoc_W3ZvaWRd
%dat_gl_print_driver_info_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone158, i64 8)
%gl_print_driver_info_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_gl_print_driver_info_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone138 = load i8*, i8** %_impzPtr
%zone139 = bitcast i8* %tzone138 to %mzone*
call void @llvm_zone_mark(%mzone* %zone139)
; malloc closure structure
%clsptr140 = call i8* @llvm_zone_malloc(%mzone* %zone139, i64 24)
%closure141 = bitcast i8* %clsptr140 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr142 = call i8* @llvm_zone_malloc(%mzone* %zone139, i64 8)
%environment143 = bitcast i8* %envptr142 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable144 = call %clsvar* @new_address_table()
%var145 = bitcast [36 x i8]* @gsxtmgl-objects218 to i8*
%var146 = bitcast [31 x i8]* @gsxtmgl-objects211 to i8*
%addytable147 = call %clsvar* @add_address_table(%mzone* %zone139, i8* %var145, i32 0, i8* %var146, i32 3, %clsvar* %addytable144)
%address-table148 = bitcast %clsvar* %addytable147 to i8*

; insert table, function and environment into closure struct
%closure.table151 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure141, i32 0, i32 0
store i8* %address-table148, i8** %closure.table151
%closure.env152 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure141, i32 0, i32 1
store i8* %envptr142, i8** %closure.env152
%closure.func153 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure141, i32 0, i32 2
store void (i8*, i8*)* @gl_print_driver_info_adhoc_W3ZvaWRd__107, void (i8*, i8*)** %closure.func153
%closure_size154 = call i64 @llvm_zone_mark_size(%mzone* %zone139)
call void @llvm_zone_ptr_set_size(i8* %clsptr140, i64 %closure_size154)
%wrapper_ptr155 = call i8* @llvm_zone_malloc(%mzone* %zone139, i64 8)
%closure_wrapper156 = bitcast i8* %wrapper_ptr155 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure141, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper156

; let value assignment
%gl_print_driver_info_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper156, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper156
store { i8*, i8*, void (i8*, i8*)*}** %gl_print_driver_info_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %gl_print_driver_info_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var gl_print_driver_info_adhoc_W3ZvaWRd
%tmp_envptr150 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment143, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %gl_print_driver_info_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr150


%val159 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %gl_print_driver_info_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val159
}


@gl_print_driver_info_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@gl_print_driver_info_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @gl_print_driver_info_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @gl_print_driver_info_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @gl_print_driver_info_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @gl_print_driver_info_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @gl_print_driver_info_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @gl_print_driver_info_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @gl_print_driver_info_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%VBO = type {i32,i32,i64,i8*,i64,i64}
@gsxtmgl-objects219 = hidden constant [51 x i8] c"VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd\00"
@gsxtmgl-objects220 = hidden constant [62 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**\00"
define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd__160(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone161 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}*
%VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**** %VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i64
store i64 %arg_2, i64* %arg_2Ptr
%arg_3Ptr = alloca i8*
store i8* %arg_3, i8** %arg_3Ptr
%arg_4Ptr = alloca i64
store i64 %arg_4, i64* %arg_4Ptr
%arg_5Ptr = alloca i64
store i64 %arg_5, i64* %arg_5Ptr


%tzone166 = load i8*, i8** %_impzPtr
%zone167 = bitcast i8* %tzone166 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VBO*
%tzone162 = load i8*, i8** %_impzPtr
%zone163 = bitcast i8* %tzone162 to %mzone*
%dat164 = call i8* @llvm_zone_malloc(%mzone* %zone163, i64 40)
call i8* @memset(i8* %dat164, i32 0, i64 40)
%val165 = bitcast i8* %dat164 to %VBO*

; let value assignment
%obj = select i1 true, %VBO* %val165, %VBO* %val165
store %VBO* %obj, %VBO** %objPtr

%val168 = load %VBO*, %VBO** %objPtr
%val169 = load i32, i32* %arg_0Ptr
; set tuple
%val170 = getelementptr %VBO, %VBO* %val168, i64 0, i32 0
store i32 %val169, i32* %val170
%val171 = load %VBO*, %VBO** %objPtr
%val172 = load i32, i32* %arg_1Ptr
; set tuple
%val173 = getelementptr %VBO, %VBO* %val171, i64 0, i32 1
store i32 %val172, i32* %val173
%val174 = load %VBO*, %VBO** %objPtr
%val175 = load i64, i64* %arg_2Ptr
; set tuple
%val176 = getelementptr %VBO, %VBO* %val174, i64 0, i32 2
store i64 %val175, i64* %val176
%val177 = load %VBO*, %VBO** %objPtr
%val178 = load i8*, i8** %arg_3Ptr
; set tuple
%val179 = getelementptr %VBO, %VBO* %val177, i64 0, i32 3
store i8* %val178, i8** %val179
%val180 = load %VBO*, %VBO** %objPtr
%val181 = load i64, i64* %arg_4Ptr
; set tuple
%val182 = getelementptr %VBO, %VBO* %val180, i64 0, i32 4
store i64 %val181, i64* %val182
%val183 = load %VBO*, %VBO** %objPtr
%val184 = load i64, i64* %arg_5Ptr
; set tuple
%val185 = getelementptr %VBO, %VBO* %val183, i64 0, i32 5
store i64 %val184, i64* %val185
%val186 = load %VBO*, %VBO** %objPtr
ret %VBO* %val186
}
@gsxtmgl-objects221 = hidden constant [104 x i8] c"VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone206 = load i8*, i8** %_impzPtr
%zone207 = bitcast i8* %tzone206 to %mzone*

; let assign value to symbol VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd
%dat_VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone207, i64 8)
%VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr = bitcast i8* %dat_VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***
%tzone187 = load i8*, i8** %_impzPtr
%zone188 = bitcast i8* %tzone187 to %mzone*
call void @llvm_zone_mark(%mzone* %zone188)
; malloc closure structure
%clsptr189 = call i8* @llvm_zone_malloc(%mzone* %zone188, i64 24)
%closure190 = bitcast i8* %clsptr189 to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*

; malloc environment structure
%envptr191 = call i8* @llvm_zone_malloc(%mzone* %zone188, i64 8)
%environment192 = bitcast i8* %envptr191 to {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable193 = call %clsvar* @new_address_table()
%var194 = bitcast [51 x i8]* @gsxtmgl-objects219 to i8*
%var195 = bitcast [62 x i8]* @gsxtmgl-objects220 to i8*
%addytable196 = call %clsvar* @add_address_table(%mzone* %zone188, i8* %var194, i32 0, i8* %var195, i32 3, %clsvar* %addytable193)
%address-table197 = bitcast %clsvar* %addytable196 to i8*

; insert table, function and environment into closure struct
%closure.table200 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure190, i32 0, i32 0
store i8* %address-table197, i8** %closure.table200
%closure.env201 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure190, i32 0, i32 1
store i8* %envptr191, i8** %closure.env201
%closure.func202 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure190, i32 0, i32 2
store %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd__160, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %closure.func202
%closure_size203 = call i64 @llvm_zone_mark_size(%mzone* %zone188)
call void @llvm_zone_ptr_set_size(i8* %clsptr189, i64 %closure_size203)
%wrapper_ptr204 = call i8* @llvm_zone_malloc(%mzone* %zone188, i64 8)
%closure_wrapper205 = bitcast i8* %wrapper_ptr204 to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure190, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_wrapper205

; let value assignment
%VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_wrapper205, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_wrapper205
store { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr

; add data to environment
; don't need to alloc for env var VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd
%tmp_envptr199 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}* %environment192, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**** %tmp_envptr199


%val208 = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr
ret {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %val208
}


@VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3,i64 %arg_4,i64 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_native(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3,i64 %arg_4,i64 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var209 = bitcast [104 x i8]* @gsxtmgl-objects221 to i8*
call i32 (i8*, ...) @printf(i8* %var209)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var210 = bitcast [104 x i8]* @gsxtmgl-objects221 to i8*
call i32 (i8*, ...) @printf(i8* %var210)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var211 = bitcast [104 x i8]* @gsxtmgl-objects221 to i8*
call i32 (i8*, ...) @printf(i8* %var211)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr_or_str(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var212 = bitcast [104 x i8]* @gsxtmgl-objects221 to i8*
call i32 (i8*, ...) @printf(i8* %var212)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i8*  @cptr_value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var213 = bitcast [104 x i8]* @gsxtmgl-objects221 to i8*
call i32 (i8*, ...) @printf(i8* %var213)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var214 = bitcast [104 x i8]* @gsxtmgl-objects221 to i8*
call i32 (i8*, ...) @printf(i8* %var214)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i64  @i64value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i64, i8*, i64, i64}*
%arg_p_0 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i8*, i8** %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
%arg_p_5 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 5
%arg_5 = load i64, i64* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects222 = hidden constant [53 x i8] c"VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd\00"
define dllexport fastcc %VBO* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd__215(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone216 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}*
%VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**** %VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i64
store i64 %arg_2, i64* %arg_2Ptr
%arg_3Ptr = alloca i8*
store i8* %arg_3, i8** %arg_3Ptr
%arg_4Ptr = alloca i64
store i64 %arg_4, i64* %arg_4Ptr
%arg_5Ptr = alloca i64
store i64 %arg_5, i64* %arg_5Ptr


%tzone221 = load i8*, i8** %_impzPtr
%zone222 = bitcast i8* %tzone221 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VBO*
%tzone217 = load i8*, i8** %_impzPtr
%zone218 = bitcast i8* %tzone217 to %mzone*
%dat219 = call i8* @llvm_zone_malloc(%mzone* %zone218, i64 40)
call i8* @memset(i8* %dat219, i32 0, i64 40)
%val220 = bitcast i8* %dat219 to %VBO*

; let value assignment
%obj = select i1 true, %VBO* %val220, %VBO* %val220
store %VBO* %obj, %VBO** %objPtr

%val223 = load %VBO*, %VBO** %objPtr
%val224 = load i32, i32* %arg_0Ptr
; set tuple
%val225 = getelementptr %VBO, %VBO* %val223, i64 0, i32 0
store i32 %val224, i32* %val225
%val226 = load %VBO*, %VBO** %objPtr
%val227 = load i32, i32* %arg_1Ptr
; set tuple
%val228 = getelementptr %VBO, %VBO* %val226, i64 0, i32 1
store i32 %val227, i32* %val228
%val229 = load %VBO*, %VBO** %objPtr
%val230 = load i64, i64* %arg_2Ptr
; set tuple
%val231 = getelementptr %VBO, %VBO* %val229, i64 0, i32 2
store i64 %val230, i64* %val231
%val232 = load %VBO*, %VBO** %objPtr
%val233 = load i8*, i8** %arg_3Ptr
; set tuple
%val234 = getelementptr %VBO, %VBO* %val232, i64 0, i32 3
store i8* %val233, i8** %val234
%val235 = load %VBO*, %VBO** %objPtr
%val236 = load i64, i64* %arg_4Ptr
; set tuple
%val237 = getelementptr %VBO, %VBO* %val235, i64 0, i32 4
store i64 %val236, i64* %val237
%val238 = load %VBO*, %VBO** %objPtr
%val239 = load i64, i64* %arg_5Ptr
; set tuple
%val240 = getelementptr %VBO, %VBO* %val238, i64 0, i32 5
store i64 %val239, i64* %val240
%val241 = load %VBO*, %VBO** %objPtr
ret %VBO* %val241
}
@gsxtmgl-objects223 = hidden constant [106 x i8] c"VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone261 = load i8*, i8** %_impzPtr
%zone262 = bitcast i8* %tzone261 to %mzone*

; let assign value to symbol VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd
%dat_VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone262, i64 8)
%VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr = bitcast i8* %dat_VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***
%tzone242 = load i8*, i8** %_impzPtr
%zone243 = bitcast i8* %tzone242 to %mzone*
call void @llvm_zone_mark(%mzone* %zone243)
; malloc closure structure
%clsptr244 = call i8* @llvm_zone_malloc(%mzone* %zone243, i64 24)
%closure245 = bitcast i8* %clsptr244 to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*

; malloc environment structure
%envptr246 = call i8* @llvm_zone_malloc(%mzone* %zone243, i64 8)
%environment247 = bitcast i8* %envptr246 to {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable248 = call %clsvar* @new_address_table()
%var249 = bitcast [53 x i8]* @gsxtmgl-objects222 to i8*
%var250 = bitcast [62 x i8]* @gsxtmgl-objects220 to i8*
%addytable251 = call %clsvar* @add_address_table(%mzone* %zone243, i8* %var249, i32 0, i8* %var250, i32 3, %clsvar* %addytable248)
%address-table252 = bitcast %clsvar* %addytable251 to i8*

; insert table, function and environment into closure struct
%closure.table255 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure245, i32 0, i32 0
store i8* %address-table252, i8** %closure.table255
%closure.env256 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure245, i32 0, i32 1
store i8* %envptr246, i8** %closure.env256
%closure.func257 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure245, i32 0, i32 2
store %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd__215, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %closure.func257
%closure_size258 = call i64 @llvm_zone_mark_size(%mzone* %zone243)
call void @llvm_zone_ptr_set_size(i8* %clsptr244, i64 %closure_size258)
%wrapper_ptr259 = call i8* @llvm_zone_malloc(%mzone* %zone243, i64 8)
%closure_wrapper260 = bitcast i8* %wrapper_ptr259 to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure245, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_wrapper260

; let value assignment
%VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_wrapper260, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_wrapper260
store { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*** %VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr

; add data to environment
; don't need to alloc for env var VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd
%tmp_envptr254 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}* %environment247, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*** %VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**** %tmp_envptr254


%val263 = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*** %VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr
ret {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %val263
}


@VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3,i64 %arg_4,i64 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_native(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3,i64 %arg_4,i64 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var264 = bitcast [106 x i8]* @gsxtmgl-objects223 to i8*
call i32 (i8*, ...) @printf(i8* %var264)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var265 = bitcast [106 x i8]* @gsxtmgl-objects223 to i8*
call i32 (i8*, ...) @printf(i8* %var265)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var266 = bitcast [106 x i8]* @gsxtmgl-objects223 to i8*
call i32 (i8*, ...) @printf(i8* %var266)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr_or_str(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var267 = bitcast [106 x i8]* @gsxtmgl-objects223 to i8*
call i32 (i8*, ...) @printf(i8* %var267)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i8*  @cptr_value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var268 = bitcast [106 x i8]* @gsxtmgl-objects223 to i8*
call i32 (i8*, ...) @printf(i8* %var268)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var269 = bitcast [106 x i8]* @gsxtmgl-objects223 to i8*
call i32 (i8*, ...) @printf(i8* %var269)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i64  @i64value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i64, i8*, i64, i64}*
%arg_p_0 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i8*, i8** %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
%arg_p_5 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 5
%arg_5 = load i64, i64* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects224 = hidden constant [53 x i8] c"VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd\00"
define dllexport fastcc %VBO* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd__270(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone271 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}*
%VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**** %VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i64
store i64 %arg_2, i64* %arg_2Ptr
%arg_3Ptr = alloca i8*
store i8* %arg_3, i8** %arg_3Ptr
%arg_4Ptr = alloca i64
store i64 %arg_4, i64* %arg_4Ptr
%arg_5Ptr = alloca i64
store i64 %arg_5, i64* %arg_5Ptr


%tzone274 = load i8*, i8** %_impzPtr
%zone275 = bitcast i8* %tzone274 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VBO*
%dat272 = call i8* @malloc(i64 40)
call i8* @memset(i8* %dat272, i32 0, i64 40)
%val273 = bitcast i8* %dat272 to %VBO*

; let value assignment
%obj = select i1 true, %VBO* %val273, %VBO* %val273
store %VBO* %obj, %VBO** %objPtr

%val276 = load %VBO*, %VBO** %objPtr
%val277 = load i32, i32* %arg_0Ptr
; set tuple
%val278 = getelementptr %VBO, %VBO* %val276, i64 0, i32 0
store i32 %val277, i32* %val278
%val279 = load %VBO*, %VBO** %objPtr
%val280 = load i32, i32* %arg_1Ptr
; set tuple
%val281 = getelementptr %VBO, %VBO* %val279, i64 0, i32 1
store i32 %val280, i32* %val281
%val282 = load %VBO*, %VBO** %objPtr
%val283 = load i64, i64* %arg_2Ptr
; set tuple
%val284 = getelementptr %VBO, %VBO* %val282, i64 0, i32 2
store i64 %val283, i64* %val284
%val285 = load %VBO*, %VBO** %objPtr
%val286 = load i8*, i8** %arg_3Ptr
; set tuple
%val287 = getelementptr %VBO, %VBO* %val285, i64 0, i32 3
store i8* %val286, i8** %val287
%val288 = load %VBO*, %VBO** %objPtr
%val289 = load i64, i64* %arg_4Ptr
; set tuple
%val290 = getelementptr %VBO, %VBO* %val288, i64 0, i32 4
store i64 %val289, i64* %val290
%val291 = load %VBO*, %VBO** %objPtr
%val292 = load i64, i64* %arg_5Ptr
; set tuple
%val293 = getelementptr %VBO, %VBO* %val291, i64 0, i32 5
store i64 %val292, i64* %val293
%val294 = load %VBO*, %VBO** %objPtr
ret %VBO* %val294
}
@gsxtmgl-objects225 = hidden constant [106 x i8] c"VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone314 = load i8*, i8** %_impzPtr
%zone315 = bitcast i8* %tzone314 to %mzone*

; let assign value to symbol VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd
%dat_VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone315, i64 8)
%VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr = bitcast i8* %dat_VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***
%tzone295 = load i8*, i8** %_impzPtr
%zone296 = bitcast i8* %tzone295 to %mzone*
call void @llvm_zone_mark(%mzone* %zone296)
; malloc closure structure
%clsptr297 = call i8* @llvm_zone_malloc(%mzone* %zone296, i64 24)
%closure298 = bitcast i8* %clsptr297 to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*

; malloc environment structure
%envptr299 = call i8* @llvm_zone_malloc(%mzone* %zone296, i64 8)
%environment300 = bitcast i8* %envptr299 to {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable301 = call %clsvar* @new_address_table()
%var302 = bitcast [53 x i8]* @gsxtmgl-objects224 to i8*
%var303 = bitcast [62 x i8]* @gsxtmgl-objects220 to i8*
%addytable304 = call %clsvar* @add_address_table(%mzone* %zone296, i8* %var302, i32 0, i8* %var303, i32 3, %clsvar* %addytable301)
%address-table305 = bitcast %clsvar* %addytable304 to i8*

; insert table, function and environment into closure struct
%closure.table308 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure298, i32 0, i32 0
store i8* %address-table305, i8** %closure.table308
%closure.env309 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure298, i32 0, i32 1
store i8* %envptr299, i8** %closure.env309
%closure.func310 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure298, i32 0, i32 2
store %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd__270, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %closure.func310
%closure_size311 = call i64 @llvm_zone_mark_size(%mzone* %zone296)
call void @llvm_zone_ptr_set_size(i8* %clsptr297, i64 %closure_size311)
%wrapper_ptr312 = call i8* @llvm_zone_malloc(%mzone* %zone296, i64 8)
%closure_wrapper313 = bitcast i8* %wrapper_ptr312 to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure298, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_wrapper313

; let value assignment
%VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_wrapper313, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_wrapper313
store { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*** %VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr

; add data to environment
; don't need to alloc for env var VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd
%tmp_envptr307 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}* %environment300, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*** %VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**** %tmp_envptr307


%val316 = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*** %VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRdPtr
ret {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %val316
}


@VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3,i64 %arg_4,i64 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_native(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3,i64 %arg_4,i64 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var317 = bitcast [106 x i8]* @gsxtmgl-objects225 to i8*
call i32 (i8*, ...) @printf(i8* %var317)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var318 = bitcast [106 x i8]* @gsxtmgl-objects225 to i8*
call i32 (i8*, ...) @printf(i8* %var318)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var319 = bitcast [106 x i8]* @gsxtmgl-objects225 to i8*
call i32 (i8*, ...) @printf(i8* %var319)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr_or_str(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var320 = bitcast [106 x i8]* @gsxtmgl-objects225 to i8*
call i32 (i8*, ...) @printf(i8* %var320)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i8*  @cptr_value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var321 = bitcast [106 x i8]* @gsxtmgl-objects225 to i8*
call i32 (i8*, ...) @printf(i8* %var321)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var322 = bitcast [106 x i8]* @gsxtmgl-objects225 to i8*
call i32 (i8*, ...) @printf(i8* %var322)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i64  @i64value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i64, i8*, i64, i64}*
%arg_p_0 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i8*, i8** %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
%arg_p_5 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 5
%arg_5 = load i64, i64* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects226 = hidden constant [54 x i8] c"VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0\00"
@gsxtmgl-objects227 = hidden constant [61 x i8] c"{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**\00"
define dllexport fastcc %VBO @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0__323(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone324 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}*
%VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0Ptr_ = getelementptr {{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}, {{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}* %impenv, i32 0, i32 0
%VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0Ptr = load {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**** %VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i64
store i64 %arg_2, i64* %arg_2Ptr
%arg_3Ptr = alloca i8*
store i8* %arg_3, i8** %arg_3Ptr
%arg_4Ptr = alloca i64
store i64 %arg_4, i64* %arg_4Ptr
%arg_5Ptr = alloca i64
store i64 %arg_5, i64* %arg_5Ptr


%tzone326 = load i8*, i8** %_impzPtr
%zone327 = bitcast i8* %tzone326 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VBO*
%dat325 = alloca %VBO, align 16

; let value assignment
%obj = select i1 true, %VBO* %dat325, %VBO* %dat325
store %VBO* %obj, %VBO** %objPtr

%val328 = load %VBO*, %VBO** %objPtr
%val329 = load i32, i32* %arg_0Ptr
; set tuple
%val330 = getelementptr %VBO, %VBO* %val328, i64 0, i32 0
store i32 %val329, i32* %val330
%val331 = load %VBO*, %VBO** %objPtr
%val332 = load i32, i32* %arg_1Ptr
; set tuple
%val333 = getelementptr %VBO, %VBO* %val331, i64 0, i32 1
store i32 %val332, i32* %val333
%val334 = load %VBO*, %VBO** %objPtr
%val335 = load i64, i64* %arg_2Ptr
; set tuple
%val336 = getelementptr %VBO, %VBO* %val334, i64 0, i32 2
store i64 %val335, i64* %val336
%val337 = load %VBO*, %VBO** %objPtr
%val338 = load i8*, i8** %arg_3Ptr
; set tuple
%val339 = getelementptr %VBO, %VBO* %val337, i64 0, i32 3
store i8* %val338, i8** %val339
%val340 = load %VBO*, %VBO** %objPtr
%val341 = load i64, i64* %arg_4Ptr
; set tuple
%val342 = getelementptr %VBO, %VBO* %val340, i64 0, i32 4
store i64 %val341, i64* %val342
%val343 = load %VBO*, %VBO** %objPtr
%val344 = load i64, i64* %arg_5Ptr
; set tuple
%val345 = getelementptr %VBO, %VBO* %val343, i64 0, i32 5
store i64 %val344, i64* %val345
%val346 = load %VBO*, %VBO** %objPtr
; pointer ref
%val347 = getelementptr %VBO, %VBO* %val346, i64 0
%val348 = load %VBO, %VBO* %val347
ret %VBO %val348
}
@gsxtmgl-objects228 = hidden constant [107 x i8] c"VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone368 = load i8*, i8** %_impzPtr
%zone369 = bitcast i8* %tzone368 to %mzone*

; let assign value to symbol VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0
%dat_VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone369, i64 8)
%VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0Ptr = bitcast i8* %dat_VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0 to { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***
%tzone349 = load i8*, i8** %_impzPtr
%zone350 = bitcast i8* %tzone349 to %mzone*
call void @llvm_zone_mark(%mzone* %zone350)
; malloc closure structure
%clsptr351 = call i8* @llvm_zone_malloc(%mzone* %zone350, i64 24)
%closure352 = bitcast i8* %clsptr351 to { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*

; malloc environment structure
%envptr353 = call i8* @llvm_zone_malloc(%mzone* %zone350, i64 8)
%environment354 = bitcast i8* %envptr353 to {{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}*

; malloc closure address table
%addytable355 = call %clsvar* @new_address_table()
%var356 = bitcast [54 x i8]* @gsxtmgl-objects226 to i8*
%var357 = bitcast [61 x i8]* @gsxtmgl-objects227 to i8*
%addytable358 = call %clsvar* @add_address_table(%mzone* %zone350, i8* %var356, i32 0, i8* %var357, i32 3, %clsvar* %addytable355)
%address-table359 = bitcast %clsvar* %addytable358 to i8*

; insert table, function and environment into closure struct
%closure.table362 = getelementptr { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure352, i32 0, i32 0
store i8* %address-table359, i8** %closure.table362
%closure.env363 = getelementptr { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure352, i32 0, i32 1
store i8* %envptr353, i8** %closure.env363
%closure.func364 = getelementptr { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure352, i32 0, i32 2
store %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0__323, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %closure.func364
%closure_size365 = call i64 @llvm_zone_mark_size(%mzone* %zone350)
call void @llvm_zone_ptr_set_size(i8* %clsptr351, i64 %closure_size365)
%wrapper_ptr366 = call i8* @llvm_zone_malloc(%mzone* %zone350, i64 8)
%closure_wrapper367 = bitcast i8* %wrapper_ptr366 to { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
store { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure352, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_wrapper367

; let value assignment
%VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0 = select i1 true, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_wrapper367, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_wrapper367
store { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*** %VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0Ptr

; add data to environment
; don't need to alloc for env var VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0
%tmp_envptr361 = getelementptr {{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}, {{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}***}* %environment354, i32 0, i32 0
store {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*** %VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0Ptr, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**** %tmp_envptr361


%val370 = load {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*** %VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0Ptr
ret {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %val370
}


@VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3,i64 %arg_4,i64 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
ret %VBO %result
}


define dllexport ccc %VBO @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_native(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3,i64 %arg_4,i64 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
ret %VBO %result
}


define dllexport ccc void @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i64, i8*, i64, i64}*
%arg_p_0 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i8*, i8** %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
%arg_p_5 = getelementptr {i32, i32, i64, i8*, i64, i64}, {i32, i32, i64, i8*, i64, i64}* %fstruct, i32 0, i32 5
%arg_5 = load i64, i64* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCosaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}*, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)*,  %VBO (i8*, i8*, i32, i32, i64, i8*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3, i64 %arg_4, i64 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects229 = hidden constant [28 x i8] c"hcopy_adhoc_W1ZCTyosVkJPKl0\00"
@gsxtmgl-objects230 = hidden constant [39 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**\00"
define dllexport fastcc %VBO* @hcopy_adhoc_W1ZCTyosVkJPKl0__377(i8* %_impz,i8* %_impenv, %VBO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone378 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***}*
%hcopy_adhoc_W1ZCTyosVkJPKl0Ptr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1ZCTyosVkJPKl0Ptr = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**** %hcopy_adhoc_W1ZCTyosVkJPKl0Ptr_

; setup arguments
%xPtr = alloca %VBO*
store %VBO* %x, %VBO** %xPtr


%tzone381 = load i8*, i8** %_impzPtr
%zone382 = bitcast i8* %tzone381 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VBO*
%dat379 = call i8* @malloc(i64 40)
call i8* @memset(i8* %dat379, i32 0, i64 40)
%val380 = bitcast i8* %dat379 to %VBO*

; let value assignment
%obj = select i1 true, %VBO* %val380, %VBO* %val380
store %VBO* %obj, %VBO** %objPtr

%val383 = load %VBO*, %VBO** %objPtr
%val384 = load %VBO*, %VBO** %xPtr
; tuple ref
%val385 = getelementptr %VBO, %VBO* %val384, i64 0, i32 0
%val386 = load i32, i32* %val385
; set tuple
%val387 = getelementptr %VBO, %VBO* %val383, i64 0, i32 0
store i32 %val386, i32* %val387
%val388 = load %VBO*, %VBO** %objPtr
%val389 = load %VBO*, %VBO** %xPtr
; tuple ref
%val390 = getelementptr %VBO, %VBO* %val389, i64 0, i32 1
%val391 = load i32, i32* %val390
; set tuple
%val392 = getelementptr %VBO, %VBO* %val388, i64 0, i32 1
store i32 %val391, i32* %val392
%val393 = load %VBO*, %VBO** %objPtr
%val394 = load %VBO*, %VBO** %xPtr
; tuple ref
%val395 = getelementptr %VBO, %VBO* %val394, i64 0, i32 2
%val396 = load i64, i64* %val395
; set tuple
%val397 = getelementptr %VBO, %VBO* %val393, i64 0, i32 2
store i64 %val396, i64* %val397
%val398 = load %VBO*, %VBO** %objPtr
%val399 = load %VBO*, %VBO** %xPtr
; tuple ref
%val400 = getelementptr %VBO, %VBO* %val399, i64 0, i32 3
%val401 = load i8*, i8** %val400
; set tuple
%val402 = getelementptr %VBO, %VBO* %val398, i64 0, i32 3
store i8* %val401, i8** %val402
%val403 = load %VBO*, %VBO** %objPtr
%val404 = load %VBO*, %VBO** %xPtr
; tuple ref
%val405 = getelementptr %VBO, %VBO* %val404, i64 0, i32 4
%val406 = load i64, i64* %val405
; set tuple
%val407 = getelementptr %VBO, %VBO* %val403, i64 0, i32 4
store i64 %val406, i64* %val407
%val408 = load %VBO*, %VBO** %objPtr
%val409 = load %VBO*, %VBO** %xPtr
; tuple ref
%val410 = getelementptr %VBO, %VBO* %val409, i64 0, i32 5
%val411 = load i64, i64* %val410
; set tuple
%val412 = getelementptr %VBO, %VBO* %val408, i64 0, i32 5
store i64 %val411, i64* %val412
%val413 = load %VBO*, %VBO** %objPtr
ret %VBO* %val413
}
@gsxtmgl-objects231 = hidden constant [81 x i8] c"hcopy_adhoc_W1ZCTyosVkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** @hcopy_adhoc_W1ZCTyosVkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone433 = load i8*, i8** %_impzPtr
%zone434 = bitcast i8* %tzone433 to %mzone*

; let assign value to symbol hcopy_adhoc_W1ZCTyosVkJPKl0
%dat_hcopy_adhoc_W1ZCTyosVkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone434, i64 8)
%hcopy_adhoc_W1ZCTyosVkJPKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1ZCTyosVkJPKl0 to { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***
%tzone414 = load i8*, i8** %_impzPtr
%zone415 = bitcast i8* %tzone414 to %mzone*
call void @llvm_zone_mark(%mzone* %zone415)
; malloc closure structure
%clsptr416 = call i8* @llvm_zone_malloc(%mzone* %zone415, i64 24)
%closure417 = bitcast i8* %clsptr416 to { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr418 = call i8* @llvm_zone_malloc(%mzone* %zone415, i64 8)
%environment419 = bitcast i8* %envptr418 to {{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable420 = call %clsvar* @new_address_table()
%var421 = bitcast [28 x i8]* @gsxtmgl-objects229 to i8*
%var422 = bitcast [39 x i8]* @gsxtmgl-objects230 to i8*
%addytable423 = call %clsvar* @add_address_table(%mzone* %zone415, i8* %var421, i32 0, i8* %var422, i32 3, %clsvar* %addytable420)
%address-table424 = bitcast %clsvar* %addytable423 to i8*

; insert table, function and environment into closure struct
%closure.table427 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure417, i32 0, i32 0
store i8* %address-table424, i8** %closure.table427
%closure.env428 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure417, i32 0, i32 1
store i8* %envptr418, i8** %closure.env428
%closure.func429 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure417, i32 0, i32 2
store %VBO* (i8*, i8*, %VBO*)* @hcopy_adhoc_W1ZCTyosVkJPKl0__377, %VBO* (i8*, i8*, %VBO*)** %closure.func429
%closure_size430 = call i64 @llvm_zone_mark_size(%mzone* %zone415)
call void @llvm_zone_ptr_set_size(i8* %clsptr416, i64 %closure_size430)
%wrapper_ptr431 = call i8* @llvm_zone_malloc(%mzone* %zone415, i64 8)
%closure_wrapper432 = bitcast i8* %wrapper_ptr431 to { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**
store { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure417, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_wrapper432

; let value assignment
%hcopy_adhoc_W1ZCTyosVkJPKl0 = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_wrapper432, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_wrapper432
store { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %hcopy_adhoc_W1ZCTyosVkJPKl0, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*** %hcopy_adhoc_W1ZCTyosVkJPKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1ZCTyosVkJPKl0
%tmp_envptr426 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***}* %environment419, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*** %hcopy_adhoc_W1ZCTyosVkJPKl0Ptr, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**** %tmp_envptr426


%val435 = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*** %hcopy_adhoc_W1ZCTyosVkJPKl0Ptr
ret {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %val435
}


@hcopy_adhoc_W1ZCTyosVkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1ZCTyosVkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1ZCTyosVkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** @hcopy_adhoc_W1ZCTyosVkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1ZCTyosVkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @hcopy_adhoc_W1ZCTyosVkJPKl0(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*)*,  %VBO* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret %VBO* %result
}


define dllexport ccc %VBO* @hcopy_adhoc_W1ZCTyosVkJPKl0_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*)*,  %VBO* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret %VBO* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1ZCTyosVkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var436 = bitcast [81 x i8]* @gsxtmgl-objects231 to i8*
call i32 (i8*, ...) @printf(i8* %var436)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*)*,  %VBO* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1ZCTyosVkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*)*,  %VBO* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects232 = hidden constant [28 x i8] c"hfree_adhoc_W3ZvaWQsVkJPKl0\00"
@gsxtmgl-objects233 = hidden constant [38 x i8] c"{i8*, i8*, void (i8*, i8*, %VBO*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsVkJPKl0__437(i8* %_impz,i8* %_impenv, %VBO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone438 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*
%hfree_adhoc_W3ZvaWQsVkJPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsVkJPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %VBO*)*}***, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %hfree_adhoc_W3ZvaWQsVkJPKl0Ptr_

; setup arguments
%xPtr = alloca %VBO*
store %VBO* %x, %VBO** %xPtr


%val439 = load %VBO*, %VBO** %xPtr
%val440 = bitcast %VBO* %val439 to i8*
call ccc void @free(i8* %val440)
ret void
}
@gsxtmgl-objects234 = hidden constant [81 x i8] c"hfree_adhoc_W3ZvaWQsVkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @hfree_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone462 = load i8*, i8** %_impzPtr
%zone463 = bitcast i8* %tzone462 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsVkJPKl0
%dat_hfree_adhoc_W3ZvaWQsVkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone463, i64 8)
%hfree_adhoc_W3ZvaWQsVkJPKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsVkJPKl0 to { i8*, i8*, void (i8*, i8*, %VBO*)*}***
%tzone443 = load i8*, i8** %_impzPtr
%zone444 = bitcast i8* %tzone443 to %mzone*
call void @llvm_zone_mark(%mzone* %zone444)
; malloc closure structure
%clsptr445 = call i8* @llvm_zone_malloc(%mzone* %zone444, i64 24)
%closure446 = bitcast i8* %clsptr445 to { i8*, i8*, void (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr447 = call i8* @llvm_zone_malloc(%mzone* %zone444, i64 8)
%environment448 = bitcast i8* %envptr447 to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable449 = call %clsvar* @new_address_table()
%var450 = bitcast [28 x i8]* @gsxtmgl-objects232 to i8*
%var451 = bitcast [38 x i8]* @gsxtmgl-objects233 to i8*
%addytable452 = call %clsvar* @add_address_table(%mzone* %zone444, i8* %var450, i32 0, i8* %var451, i32 3, %clsvar* %addytable449)
%address-table453 = bitcast %clsvar* %addytable452 to i8*

; insert table, function and environment into closure struct
%closure.table456 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure446, i32 0, i32 0
store i8* %address-table453, i8** %closure.table456
%closure.env457 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure446, i32 0, i32 1
store i8* %envptr447, i8** %closure.env457
%closure.func458 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure446, i32 0, i32 2
store void (i8*, i8*, %VBO*)* @hfree_adhoc_W3ZvaWQsVkJPKl0__437, void (i8*, i8*, %VBO*)** %closure.func458
%closure_size459 = call i64 @llvm_zone_mark_size(%mzone* %zone444)
call void @llvm_zone_ptr_set_size(i8* %clsptr445, i64 %closure_size459)
%wrapper_ptr460 = call i8* @llvm_zone_malloc(%mzone* %zone444, i64 8)
%closure_wrapper461 = bitcast i8* %wrapper_ptr460 to { i8*, i8*, void (i8*, i8*, %VBO*)*}**
store { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure446, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper461

; let value assignment
%hfree_adhoc_W3ZvaWQsVkJPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper461, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper461
store { i8*, i8*, void (i8*, i8*, %VBO*)*}** %hfree_adhoc_W3ZvaWQsVkJPKl0, { i8*, i8*, void (i8*, i8*, %VBO*)*}*** %hfree_adhoc_W3ZvaWQsVkJPKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsVkJPKl0
%tmp_envptr455 = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %environment448, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %hfree_adhoc_W3ZvaWQsVkJPKl0Ptr, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %tmp_envptr455


%val464 = load {i8*, i8*, void (i8*, i8*, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %hfree_adhoc_W3ZvaWQsVkJPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VBO*)*}** %val464
}


@hfree_adhoc_W3ZvaWQsVkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsVkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsVkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @hfree_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsVkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsVkJPKl0(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsVkJPKl0_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsVkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var465 = bitcast [81 x i8]* @gsxtmgl-objects234 to i8*
call i32 (i8*, ...) @printf(i8* %var465)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsVkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects235 = hidden constant [47 x i8] c"zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmgl-objects236 = hidden constant [57 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %VBO* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ__466(i8* %_impz,i8* %_impenv, %VBO* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone467 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %VBO*
store %VBO* %x, %VBO** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val469 = load %mzone*, %mzone** %fromzPtr
%val470 = load %VBO*, %VBO** %xPtr
%val471 = bitcast %VBO* %val470 to i8*
%res472 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val469, i8* %val471)
br i1 %res472, label %then468, label %else468

then468:
%val473 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val473)
%zone_ptr474 = bitcast %mzone* %val473 to i8*
store i8* %zone_ptr474, i8** %_impzPtr
%tzone480 = load i8*, i8** %_impzPtr
%zone481 = bitcast i8* %tzone480 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VBO*
%tzone476 = load i8*, i8** %_impzPtr
%zone477 = bitcast i8* %tzone476 to %mzone*
%dat478 = call i8* @llvm_zone_malloc(%mzone* %zone477, i64 40)
call i8* @memset(i8* %dat478, i32 0, i64 40)
%val479 = bitcast i8* %dat478 to %VBO*

; let value assignment
%obj = select i1 true, %VBO* %val479, %VBO* %val479
store %VBO* %obj, %VBO** %objPtr

; promote local stack var allocations
%tzone540 = load i8*, i8** %_impzPtr
%zone541 = bitcast i8* %tzone540 to %mzone*
%ifptr497 = alloca i8*
%val482 = load %VBO*, %VBO** %objPtr
%val483 = load %VBO*, %VBO** %xPtr
; tuple ref
%val484 = getelementptr %VBO, %VBO* %val483, i64 0, i32 0
%val485 = load i32, i32* %val484
; set tuple
%val486 = getelementptr %VBO, %VBO* %val482, i64 0, i32 0
store i32 %val485, i32* %val486
%val487 = load %VBO*, %VBO** %objPtr
%val488 = load %VBO*, %VBO** %xPtr
; tuple ref
%val489 = getelementptr %VBO, %VBO* %val488, i64 0, i32 1
%val490 = load i32, i32* %val489
; set tuple
%val491 = getelementptr %VBO, %VBO* %val487, i64 0, i32 1
store i32 %val490, i32* %val491
%val492 = load %VBO*, %VBO** %objPtr
%val493 = load %VBO*, %VBO** %xPtr
; tuple ref
%val494 = getelementptr %VBO, %VBO* %val493, i64 0, i32 2
%val495 = load i64, i64* %val494
; set tuple
%val496 = getelementptr %VBO, %VBO* %val492, i64 0, i32 2
store i64 %val495, i64* %val496
%val498 = load %mzone*, %mzone** %fromzPtr
%val499 = load %VBO*, %VBO** %xPtr
; tuple ref
%val500 = getelementptr %VBO, %VBO* %val499, i64 0, i32 3
%val501 = load i8*, i8** %val500
%val502 = bitcast i8* %val501 to i8*
%res503 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val498, i8* %val502)
br i1 %res503, label %then497, label %else497

then497:
%tzone508 = load i8*, i8** %_impzPtr
%zone509 = bitcast i8* %tzone508 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i8*
%tzone504 = load i8*, i8** %_impzPtr
%zone505 = bitcast i8* %tzone504 to %mzone*
%dat506 = call i8* @llvm_zone_malloc(%mzone* %zone505, i64 1)
call i8* @memset(i8* %dat506, i32 0, i64 1)
%val507 = bitcast i8* %dat506 to i8*

; let value assignment
%newptr = select i1 true, i8* %val507, i8* %val507
store i8* %newptr, i8** %newptrPtr

%val510 = load i8*, i8** %newptrPtr
%val511 = bitcast i8* %val510 to i8*
%val512 = load %VBO*, %VBO** %xPtr
; tuple ref
%val513 = getelementptr %VBO, %VBO* %val512, i64 0, i32 3
%val514 = load i8*, i8** %val513
%val515 = bitcast i8* %val514 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val511, i8* %val515, i64 1, i32 1, i1 0)
%val517 = load %VBO*, %VBO** %objPtr
%val518 = load i8*, i8** %newptrPtr
; set tuple
%val519 = getelementptr %VBO, %VBO* %val517, i64 0, i32 3
store i8* %val518, i8** %val519
store i8* %val518, i8** %ifptr497
br label %ifcont497

else497:
%val520 = load %VBO*, %VBO** %objPtr
%val521 = load %VBO*, %VBO** %xPtr
; tuple ref
%val522 = getelementptr %VBO, %VBO* %val521, i64 0, i32 3
%val523 = load i8*, i8** %val522
; set tuple
%val524 = getelementptr %VBO, %VBO* %val520, i64 0, i32 3
store i8* %val523, i8** %val524
store i8* %val523, i8** %ifptr497
br label %ifcont497

ifcont497:
%ifres525 = load i8*, i8** %ifptr497

%val526 = load %VBO*, %VBO** %objPtr
%val527 = load %VBO*, %VBO** %xPtr
; tuple ref
%val528 = getelementptr %VBO, %VBO* %val527, i64 0, i32 4
%val529 = load i64, i64* %val528
; set tuple
%val530 = getelementptr %VBO, %VBO* %val526, i64 0, i32 4
store i64 %val529, i64* %val530
%val531 = load %VBO*, %VBO** %objPtr
%val532 = load %VBO*, %VBO** %xPtr
; tuple ref
%val533 = getelementptr %VBO, %VBO* %val532, i64 0, i32 5
%val534 = load i64, i64* %val533
; set tuple
%val535 = getelementptr %VBO, %VBO* %val531, i64 0, i32 5
store i64 %val534, i64* %val535
%oldzone536 = call %mzone* @llvm_pop_zone_stack()
%newzone537 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr538 = bitcast %mzone* %newzone537 to i8*
store i8* %zone_ptr538, i8** %_impzPtr
%val539 = load %VBO*, %VBO** %objPtr
ret %VBO* %val539

else468:
%val542 = load %VBO*, %VBO** %xPtr
ret %VBO* %val542
}
@gsxtmgl-objects237 = hidden constant [100 x i8] c"zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone562 = load i8*, i8** %_impzPtr
%zone563 = bitcast i8* %tzone562 to %mzone*

; let assign value to symbol zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone563, i64 8)
%zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***
%tzone543 = load i8*, i8** %_impzPtr
%zone544 = bitcast i8* %tzone543 to %mzone*
call void @llvm_zone_mark(%mzone* %zone544)
; malloc closure structure
%clsptr545 = call i8* @llvm_zone_malloc(%mzone* %zone544, i64 24)
%closure546 = bitcast i8* %clsptr545 to { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr547 = call i8* @llvm_zone_malloc(%mzone* %zone544, i64 8)
%environment548 = bitcast i8* %envptr547 to {{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable549 = call %clsvar* @new_address_table()
%var550 = bitcast [47 x i8]* @gsxtmgl-objects235 to i8*
%var551 = bitcast [57 x i8]* @gsxtmgl-objects236 to i8*
%addytable552 = call %clsvar* @add_address_table(%mzone* %zone544, i8* %var550, i32 0, i8* %var551, i32 3, %clsvar* %addytable549)
%address-table553 = bitcast %clsvar* %addytable552 to i8*

; insert table, function and environment into closure struct
%closure.table556 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure546, i32 0, i32 0
store i8* %address-table553, i8** %closure.table556
%closure.env557 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure546, i32 0, i32 1
store i8* %envptr547, i8** %closure.env557
%closure.func558 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure546, i32 0, i32 2
store %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ__466, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)** %closure.func558
%closure_size559 = call i64 @llvm_zone_mark_size(%mzone* %zone544)
call void @llvm_zone_ptr_set_size(i8* %clsptr545, i64 %closure_size559)
%wrapper_ptr560 = call i8* @llvm_zone_malloc(%mzone* %zone544, i64 8)
%closure_wrapper561 = bitcast i8* %wrapper_ptr560 to { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**
store { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure546, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_wrapper561

; let value assignment
%zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_wrapper561, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_wrapper561
store { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ
%tmp_envptr555 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***}* %environment548, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**** %tmp_envptr555


%val564 = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %val564
}


@zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ(%VBO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*,  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %VBO* %result
}


define dllexport ccc %VBO* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_native(%VBO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*,  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %VBO* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var565 = bitcast [100 x i8]* @gsxtmgl-objects237 to i8*
call i32 (i8*, ...) @printf(i8* %var565)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var566 = bitcast [100 x i8]* @gsxtmgl-objects237 to i8*
call i32 (i8*, ...) @printf(i8* %var566)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var567 = bitcast [100 x i8]* @gsxtmgl-objects237 to i8*
call i32 (i8*, ...) @printf(i8* %var567)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*,  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%VBO*, %mzone*, %mzone*}, {%VBO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
%arg_p_1 = getelementptr {%VBO*, %mzone*, %mzone*}, {%VBO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%VBO*, %mzone*, %mzone*}, {%VBO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*,  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects238 = hidden constant [24 x i8] c"id_adhoc_W2kzMixWQk8qXQ\00"
@gsxtmgl-objects239 = hidden constant [37 x i8] c"{i8*, i8*, i32 (i8*, i8*, %VBO*)*}**\00"
define dllexport fastcc i32 @id_adhoc_W2kzMixWQk8qXQ__568(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone569 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}*
%id_adhoc_W2kzMixWQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%id_adhoc_W2kzMixWQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**** %id_adhoc_W2kzMixWQk8qXQPtr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%val571 = load %VBO*, %VBO** %vboPtr
%val572 = icmp eq %VBO* %val571, null
br i1 %val572, label %then570, label %else570

then570:
ret i32 -1

else570:
%val573 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val574 = getelementptr %VBO, %VBO* %val573, i64 0, i32 0
%val575 = load i32, i32* %val574
ret i32 %val575
}
@gsxtmgl-objects240 = hidden constant [77 x i8] c"id_adhoc_W2kzMixWQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** @id_adhoc_W2kzMixWQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone595 = load i8*, i8** %_impzPtr
%zone596 = bitcast i8* %tzone595 to %mzone*

; let assign value to symbol id_adhoc_W2kzMixWQk8qXQ
%dat_id_adhoc_W2kzMixWQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone596, i64 8)
%id_adhoc_W2kzMixWQk8qXQPtr = bitcast i8* %dat_id_adhoc_W2kzMixWQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %VBO*)*}***
%tzone576 = load i8*, i8** %_impzPtr
%zone577 = bitcast i8* %tzone576 to %mzone*
call void @llvm_zone_mark(%mzone* %zone577)
; malloc closure structure
%clsptr578 = call i8* @llvm_zone_malloc(%mzone* %zone577, i64 24)
%closure579 = bitcast i8* %clsptr578 to { i8*, i8*, i32 (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr580 = call i8* @llvm_zone_malloc(%mzone* %zone577, i64 8)
%environment581 = bitcast i8* %envptr580 to {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable582 = call %clsvar* @new_address_table()
%var583 = bitcast [24 x i8]* @gsxtmgl-objects238 to i8*
%var584 = bitcast [37 x i8]* @gsxtmgl-objects239 to i8*
%addytable585 = call %clsvar* @add_address_table(%mzone* %zone577, i8* %var583, i32 0, i8* %var584, i32 3, %clsvar* %addytable582)
%address-table586 = bitcast %clsvar* %addytable585 to i8*

; insert table, function and environment into closure struct
%closure.table589 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VBO*)*}, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure579, i32 0, i32 0
store i8* %address-table586, i8** %closure.table589
%closure.env590 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VBO*)*}, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure579, i32 0, i32 1
store i8* %envptr580, i8** %closure.env590
%closure.func591 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VBO*)*}, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure579, i32 0, i32 2
store i32 (i8*, i8*, %VBO*)* @id_adhoc_W2kzMixWQk8qXQ__568, i32 (i8*, i8*, %VBO*)** %closure.func591
%closure_size592 = call i64 @llvm_zone_mark_size(%mzone* %zone577)
call void @llvm_zone_ptr_set_size(i8* %clsptr578, i64 %closure_size592)
%wrapper_ptr593 = call i8* @llvm_zone_malloc(%mzone* %zone577, i64 8)
%closure_wrapper594 = bitcast i8* %wrapper_ptr593 to { i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure579, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_wrapper594

; let value assignment
%id_adhoc_W2kzMixWQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_wrapper594, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_wrapper594
store { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %id_adhoc_W2kzMixWQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}*** %id_adhoc_W2kzMixWQk8qXQPtr

; add data to environment
; don't need to alloc for env var id_adhoc_W2kzMixWQk8qXQ
%tmp_envptr588 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}* %environment581, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*** %id_adhoc_W2kzMixWQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**** %tmp_envptr588


%val597 = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*** %id_adhoc_W2kzMixWQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %val597
}


@id_adhoc_W2kzMixWQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@id_adhoc_W2kzMixWQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @id_adhoc_W2kzMixWQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixWQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** @id_adhoc_W2kzMixWQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @id_adhoc_W2kzMixWQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @id_adhoc_W2kzMixWQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @id_adhoc_W2kzMixWQk8qXQ(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @id_adhoc_W2kzMixWQk8qXQ_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @id_adhoc_W2kzMixWQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var598 = bitcast [77 x i8]* @gsxtmgl-objects240 to i8*
call i32 (i8*, ...) @printf(i8* %var598)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @id_adhoc_W2kzMixWQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects241 = hidden constant [26 x i8] c"type_adhoc_W2kzMixWQk8qXQ\00"
define dllexport fastcc i32 @type_adhoc_W2kzMixWQk8qXQ__599(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone600 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}*
%type_adhoc_W2kzMixWQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%type_adhoc_W2kzMixWQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**** %type_adhoc_W2kzMixWQk8qXQPtr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%val602 = load %VBO*, %VBO** %vboPtr
%val603 = icmp eq %VBO* %val602, null
br i1 %val603, label %then601, label %else601

then601:
ret i32 -1

else601:
%val604 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val605 = getelementptr %VBO, %VBO* %val604, i64 0, i32 1
%val606 = load i32, i32* %val605
ret i32 %val606
}
@gsxtmgl-objects242 = hidden constant [79 x i8] c"type_adhoc_W2kzMixWQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** @type_adhoc_W2kzMixWQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone626 = load i8*, i8** %_impzPtr
%zone627 = bitcast i8* %tzone626 to %mzone*

; let assign value to symbol type_adhoc_W2kzMixWQk8qXQ
%dat_type_adhoc_W2kzMixWQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone627, i64 8)
%type_adhoc_W2kzMixWQk8qXQPtr = bitcast i8* %dat_type_adhoc_W2kzMixWQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %VBO*)*}***
%tzone607 = load i8*, i8** %_impzPtr
%zone608 = bitcast i8* %tzone607 to %mzone*
call void @llvm_zone_mark(%mzone* %zone608)
; malloc closure structure
%clsptr609 = call i8* @llvm_zone_malloc(%mzone* %zone608, i64 24)
%closure610 = bitcast i8* %clsptr609 to { i8*, i8*, i32 (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr611 = call i8* @llvm_zone_malloc(%mzone* %zone608, i64 8)
%environment612 = bitcast i8* %envptr611 to {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable613 = call %clsvar* @new_address_table()
%var614 = bitcast [26 x i8]* @gsxtmgl-objects241 to i8*
%var615 = bitcast [37 x i8]* @gsxtmgl-objects239 to i8*
%addytable616 = call %clsvar* @add_address_table(%mzone* %zone608, i8* %var614, i32 0, i8* %var615, i32 3, %clsvar* %addytable613)
%address-table617 = bitcast %clsvar* %addytable616 to i8*

; insert table, function and environment into closure struct
%closure.table620 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VBO*)*}, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure610, i32 0, i32 0
store i8* %address-table617, i8** %closure.table620
%closure.env621 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VBO*)*}, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure610, i32 0, i32 1
store i8* %envptr611, i8** %closure.env621
%closure.func622 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VBO*)*}, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure610, i32 0, i32 2
store i32 (i8*, i8*, %VBO*)* @type_adhoc_W2kzMixWQk8qXQ__599, i32 (i8*, i8*, %VBO*)** %closure.func622
%closure_size623 = call i64 @llvm_zone_mark_size(%mzone* %zone608)
call void @llvm_zone_ptr_set_size(i8* %clsptr609, i64 %closure_size623)
%wrapper_ptr624 = call i8* @llvm_zone_malloc(%mzone* %zone608, i64 8)
%closure_wrapper625 = bitcast i8* %wrapper_ptr624 to { i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure610, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_wrapper625

; let value assignment
%type_adhoc_W2kzMixWQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_wrapper625, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_wrapper625
store { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %type_adhoc_W2kzMixWQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}*** %type_adhoc_W2kzMixWQk8qXQPtr

; add data to environment
; don't need to alloc for env var type_adhoc_W2kzMixWQk8qXQ
%tmp_envptr619 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}* %environment612, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*** %type_adhoc_W2kzMixWQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**** %tmp_envptr619


%val628 = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*** %type_adhoc_W2kzMixWQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %val628
}


@type_adhoc_W2kzMixWQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@type_adhoc_W2kzMixWQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @type_adhoc_W2kzMixWQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixWQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** @type_adhoc_W2kzMixWQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @type_adhoc_W2kzMixWQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @type_adhoc_W2kzMixWQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @type_adhoc_W2kzMixWQk8qXQ(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @type_adhoc_W2kzMixWQk8qXQ_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @type_adhoc_W2kzMixWQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var629 = bitcast [79 x i8]* @gsxtmgl-objects242 to i8*
call i32 (i8*, ...) @printf(i8* %var629)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @type_adhoc_W2kzMixWQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects243 = hidden constant [26 x i8] c"size_adhoc_W2k2NCxWQk8qXQ\00"
@gsxtmgl-objects244 = hidden constant [37 x i8] c"{i8*, i8*, i64 (i8*, i8*, %VBO*)*}**\00"
define dllexport fastcc i64 @size_adhoc_W2k2NCxWQk8qXQ__630(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone631 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}*
%size_adhoc_W2k2NCxWQk8qXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%size_adhoc_W2k2NCxWQk8qXQPtr = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}***, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**** %size_adhoc_W2k2NCxWQk8qXQPtr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%val633 = load %VBO*, %VBO** %vboPtr
%val634 = icmp eq %VBO* %val633, null
br i1 %val634, label %then632, label %else632

then632:
ret i64 0

else632:
%val635 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val636 = getelementptr %VBO, %VBO* %val635, i64 0, i32 2
%val637 = load i64, i64* %val636
ret i64 %val637
}
@gsxtmgl-objects245 = hidden constant [79 x i8] c"size_adhoc_W2k2NCxWQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** @size_adhoc_W2k2NCxWQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone657 = load i8*, i8** %_impzPtr
%zone658 = bitcast i8* %tzone657 to %mzone*

; let assign value to symbol size_adhoc_W2k2NCxWQk8qXQ
%dat_size_adhoc_W2k2NCxWQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone658, i64 8)
%size_adhoc_W2k2NCxWQk8qXQPtr = bitcast i8* %dat_size_adhoc_W2k2NCxWQk8qXQ to { i8*, i8*, i64 (i8*, i8*, %VBO*)*}***
%tzone638 = load i8*, i8** %_impzPtr
%zone639 = bitcast i8* %tzone638 to %mzone*
call void @llvm_zone_mark(%mzone* %zone639)
; malloc closure structure
%clsptr640 = call i8* @llvm_zone_malloc(%mzone* %zone639, i64 24)
%closure641 = bitcast i8* %clsptr640 to { i8*, i8*, i64 (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr642 = call i8* @llvm_zone_malloc(%mzone* %zone639, i64 8)
%environment643 = bitcast i8* %envptr642 to {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable644 = call %clsvar* @new_address_table()
%var645 = bitcast [26 x i8]* @gsxtmgl-objects243 to i8*
%var646 = bitcast [37 x i8]* @gsxtmgl-objects244 to i8*
%addytable647 = call %clsvar* @add_address_table(%mzone* %zone639, i8* %var645, i32 0, i8* %var646, i32 3, %clsvar* %addytable644)
%address-table648 = bitcast %clsvar* %addytable647 to i8*

; insert table, function and environment into closure struct
%closure.table651 = getelementptr { i8*, i8*, i64 (i8*, i8*, %VBO*)*}, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure641, i32 0, i32 0
store i8* %address-table648, i8** %closure.table651
%closure.env652 = getelementptr { i8*, i8*, i64 (i8*, i8*, %VBO*)*}, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure641, i32 0, i32 1
store i8* %envptr642, i8** %closure.env652
%closure.func653 = getelementptr { i8*, i8*, i64 (i8*, i8*, %VBO*)*}, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure641, i32 0, i32 2
store i64 (i8*, i8*, %VBO*)* @size_adhoc_W2k2NCxWQk8qXQ__630, i64 (i8*, i8*, %VBO*)** %closure.func653
%closure_size654 = call i64 @llvm_zone_mark_size(%mzone* %zone639)
call void @llvm_zone_ptr_set_size(i8* %clsptr640, i64 %closure_size654)
%wrapper_ptr655 = call i8* @llvm_zone_malloc(%mzone* %zone639, i64 8)
%closure_wrapper656 = bitcast i8* %wrapper_ptr655 to { i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
store { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure641, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_wrapper656

; let value assignment
%size_adhoc_W2k2NCxWQk8qXQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_wrapper656, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_wrapper656
store { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %size_adhoc_W2k2NCxWQk8qXQ, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}*** %size_adhoc_W2k2NCxWQk8qXQPtr

; add data to environment
; don't need to alloc for env var size_adhoc_W2k2NCxWQk8qXQ
%tmp_envptr650 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}* %environment643, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*** %size_adhoc_W2k2NCxWQk8qXQPtr, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**** %tmp_envptr650


%val659 = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*** %size_adhoc_W2k2NCxWQk8qXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %val659
}


@size_adhoc_W2k2NCxWQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@size_adhoc_W2k2NCxWQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @size_adhoc_W2k2NCxWQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxWQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** @size_adhoc_W2k2NCxWQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @size_adhoc_W2k2NCxWQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @size_adhoc_W2k2NCxWQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @size_adhoc_W2k2NCxWQk8qXQ(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @size_adhoc_W2k2NCxWQk8qXQ_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @size_adhoc_W2k2NCxWQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var660 = bitcast [79 x i8]* @gsxtmgl-objects245 to i8*
call i32 (i8*, ...) @printf(i8* %var660)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @size_adhoc_W2k2NCxWQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @size_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects246 = hidden constant [26 x i8] c"data_adhoc_W2k4KixWQk8qXQ\00"
@gsxtmgl-objects247 = hidden constant [37 x i8] c"{i8*, i8*, i8* (i8*, i8*, %VBO*)*}**\00"
define dllexport fastcc i8* @data_adhoc_W2k4KixWQk8qXQ__661(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone662 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, %VBO*)*}***}*
%data_adhoc_W2k4KixWQk8qXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%data_adhoc_W2k4KixWQk8qXQPtr = load {i8*, i8*, i8* (i8*, i8*, %VBO*)*}***, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**** %data_adhoc_W2k4KixWQk8qXQPtr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%val664 = load %VBO*, %VBO** %vboPtr
%val665 = icmp eq %VBO* %val664, null
br i1 %val665, label %then663, label %else663

then663:
%null666 = bitcast i8* null to i8*
ret i8* %null666

else663:
%val667 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val668 = getelementptr %VBO, %VBO* %val667, i64 0, i32 3
%val669 = load i8*, i8** %val668
ret i8* %val669
}
@gsxtmgl-objects248 = hidden constant [79 x i8] c"data_adhoc_W2k4KixWQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** @data_adhoc_W2k4KixWQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone689 = load i8*, i8** %_impzPtr
%zone690 = bitcast i8* %tzone689 to %mzone*

; let assign value to symbol data_adhoc_W2k4KixWQk8qXQ
%dat_data_adhoc_W2k4KixWQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone690, i64 8)
%data_adhoc_W2k4KixWQk8qXQPtr = bitcast i8* %dat_data_adhoc_W2k4KixWQk8qXQ to { i8*, i8*, i8* (i8*, i8*, %VBO*)*}***
%tzone670 = load i8*, i8** %_impzPtr
%zone671 = bitcast i8* %tzone670 to %mzone*
call void @llvm_zone_mark(%mzone* %zone671)
; malloc closure structure
%clsptr672 = call i8* @llvm_zone_malloc(%mzone* %zone671, i64 24)
%closure673 = bitcast i8* %clsptr672 to { i8*, i8*, i8* (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr674 = call i8* @llvm_zone_malloc(%mzone* %zone671, i64 8)
%environment675 = bitcast i8* %envptr674 to {{i8*, i8*, i8* (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable676 = call %clsvar* @new_address_table()
%var677 = bitcast [26 x i8]* @gsxtmgl-objects246 to i8*
%var678 = bitcast [37 x i8]* @gsxtmgl-objects247 to i8*
%addytable679 = call %clsvar* @add_address_table(%mzone* %zone671, i8* %var677, i32 0, i8* %var678, i32 3, %clsvar* %addytable676)
%address-table680 = bitcast %clsvar* %addytable679 to i8*

; insert table, function and environment into closure struct
%closure.table683 = getelementptr { i8*, i8*, i8* (i8*, i8*, %VBO*)*}, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure673, i32 0, i32 0
store i8* %address-table680, i8** %closure.table683
%closure.env684 = getelementptr { i8*, i8*, i8* (i8*, i8*, %VBO*)*}, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure673, i32 0, i32 1
store i8* %envptr674, i8** %closure.env684
%closure.func685 = getelementptr { i8*, i8*, i8* (i8*, i8*, %VBO*)*}, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure673, i32 0, i32 2
store i8* (i8*, i8*, %VBO*)* @data_adhoc_W2k4KixWQk8qXQ__661, i8* (i8*, i8*, %VBO*)** %closure.func685
%closure_size686 = call i64 @llvm_zone_mark_size(%mzone* %zone671)
call void @llvm_zone_ptr_set_size(i8* %clsptr672, i64 %closure_size686)
%wrapper_ptr687 = call i8* @llvm_zone_malloc(%mzone* %zone671, i64 8)
%closure_wrapper688 = bitcast i8* %wrapper_ptr687 to { i8*, i8*, i8* (i8*, i8*, %VBO*)*}**
store { i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure673, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_wrapper688

; let value assignment
%data_adhoc_W2k4KixWQk8qXQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_wrapper688, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_wrapper688
store { i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %data_adhoc_W2k4KixWQk8qXQ, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}*** %data_adhoc_W2k4KixWQk8qXQPtr

; add data to environment
; don't need to alloc for env var data_adhoc_W2k4KixWQk8qXQ
%tmp_envptr682 = getelementptr {{i8*, i8*, i8* (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %VBO*)*}***}* %environment675, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, %VBO*)*}*** %data_adhoc_W2k4KixWQk8qXQPtr, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**** %tmp_envptr682


%val691 = load {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}*** %data_adhoc_W2k4KixWQk8qXQPtr
ret {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %val691
}


@data_adhoc_W2k4KixWQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@data_adhoc_W2k4KixWQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @data_adhoc_W2k4KixWQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @data_adhoc_W2k4KixWQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** @data_adhoc_W2k4KixWQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @data_adhoc_W2k4KixWQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @data_adhoc_W2k4KixWQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @data_adhoc_W2k4KixWQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @data_adhoc_W2k4KixWQk8qXQ(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @data_adhoc_W2k4KixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %VBO*)*}*, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %VBO*)*,  i8* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i8* %result
}


define dllexport ccc i8* @data_adhoc_W2k4KixWQk8qXQ_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @data_adhoc_W2k4KixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %VBO*)*}*, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %VBO*)*,  i8* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @data_adhoc_W2k4KixWQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var692 = bitcast [79 x i8]* @gsxtmgl-objects248 to i8*
call i32 (i8*, ...) @printf(i8* %var692)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @data_adhoc_W2k4KixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %VBO*)*}*, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %VBO*)*,  i8* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @data_adhoc_W2k4KixWQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @data_adhoc_W2k4KixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %VBO*)*}*, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %VBO*)*,  i8* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects249 = hidden constant [30 x i8] c"elements_adhoc_W2k2NCxWQk8qXQ\00"
define dllexport fastcc i64 @elements_adhoc_W2k2NCxWQk8qXQ__693(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone694 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}*
%elements_adhoc_W2k2NCxWQk8qXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%elements_adhoc_W2k2NCxWQk8qXQPtr = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}***, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**** %elements_adhoc_W2k2NCxWQk8qXQPtr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%val696 = load %VBO*, %VBO** %vboPtr
%val697 = icmp eq %VBO* %val696, null
br i1 %val697, label %then695, label %else695

then695:
ret i64 0

else695:
%val698 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val699 = getelementptr %VBO, %VBO* %val698, i64 0, i32 4
%val700 = load i64, i64* %val699
ret i64 %val700
}
@gsxtmgl-objects250 = hidden constant [83 x i8] c"elements_adhoc_W2k2NCxWQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** @elements_adhoc_W2k2NCxWQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone720 = load i8*, i8** %_impzPtr
%zone721 = bitcast i8* %tzone720 to %mzone*

; let assign value to symbol elements_adhoc_W2k2NCxWQk8qXQ
%dat_elements_adhoc_W2k2NCxWQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone721, i64 8)
%elements_adhoc_W2k2NCxWQk8qXQPtr = bitcast i8* %dat_elements_adhoc_W2k2NCxWQk8qXQ to { i8*, i8*, i64 (i8*, i8*, %VBO*)*}***
%tzone701 = load i8*, i8** %_impzPtr
%zone702 = bitcast i8* %tzone701 to %mzone*
call void @llvm_zone_mark(%mzone* %zone702)
; malloc closure structure
%clsptr703 = call i8* @llvm_zone_malloc(%mzone* %zone702, i64 24)
%closure704 = bitcast i8* %clsptr703 to { i8*, i8*, i64 (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr705 = call i8* @llvm_zone_malloc(%mzone* %zone702, i64 8)
%environment706 = bitcast i8* %envptr705 to {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable707 = call %clsvar* @new_address_table()
%var708 = bitcast [30 x i8]* @gsxtmgl-objects249 to i8*
%var709 = bitcast [37 x i8]* @gsxtmgl-objects244 to i8*
%addytable710 = call %clsvar* @add_address_table(%mzone* %zone702, i8* %var708, i32 0, i8* %var709, i32 3, %clsvar* %addytable707)
%address-table711 = bitcast %clsvar* %addytable710 to i8*

; insert table, function and environment into closure struct
%closure.table714 = getelementptr { i8*, i8*, i64 (i8*, i8*, %VBO*)*}, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure704, i32 0, i32 0
store i8* %address-table711, i8** %closure.table714
%closure.env715 = getelementptr { i8*, i8*, i64 (i8*, i8*, %VBO*)*}, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure704, i32 0, i32 1
store i8* %envptr705, i8** %closure.env715
%closure.func716 = getelementptr { i8*, i8*, i64 (i8*, i8*, %VBO*)*}, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure704, i32 0, i32 2
store i64 (i8*, i8*, %VBO*)* @elements_adhoc_W2k2NCxWQk8qXQ__693, i64 (i8*, i8*, %VBO*)** %closure.func716
%closure_size717 = call i64 @llvm_zone_mark_size(%mzone* %zone702)
call void @llvm_zone_ptr_set_size(i8* %clsptr703, i64 %closure_size717)
%wrapper_ptr718 = call i8* @llvm_zone_malloc(%mzone* %zone702, i64 8)
%closure_wrapper719 = bitcast i8* %wrapper_ptr718 to { i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
store { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure704, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_wrapper719

; let value assignment
%elements_adhoc_W2k2NCxWQk8qXQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_wrapper719, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_wrapper719
store { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %elements_adhoc_W2k2NCxWQk8qXQ, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}*** %elements_adhoc_W2k2NCxWQk8qXQPtr

; add data to environment
; don't need to alloc for env var elements_adhoc_W2k2NCxWQk8qXQ
%tmp_envptr713 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}* %environment706, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*** %elements_adhoc_W2k2NCxWQk8qXQPtr, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**** %tmp_envptr713


%val722 = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*** %elements_adhoc_W2k2NCxWQk8qXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %val722
}


@elements_adhoc_W2k2NCxWQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@elements_adhoc_W2k2NCxWQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @elements_adhoc_W2k2NCxWQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @elements_adhoc_W2k2NCxWQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** @elements_adhoc_W2k2NCxWQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @elements_adhoc_W2k2NCxWQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @elements_adhoc_W2k2NCxWQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @elements_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @elements_adhoc_W2k2NCxWQk8qXQ(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @elements_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @elements_adhoc_W2k2NCxWQk8qXQ_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @elements_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @elements_adhoc_W2k2NCxWQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var723 = bitcast [83 x i8]* @gsxtmgl-objects250 to i8*
call i32 (i8*, ...) @printf(i8* %var723)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @elements_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @elements_adhoc_W2k2NCxWQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @elements_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects251 = hidden constant [28 x i8] c"stride_adhoc_W2k2NCxWQk8qXQ\00"
define dllexport fastcc i64 @stride_adhoc_W2k2NCxWQk8qXQ__724(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone725 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}*
%stride_adhoc_W2k2NCxWQk8qXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%stride_adhoc_W2k2NCxWQk8qXQPtr = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}***, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**** %stride_adhoc_W2k2NCxWQk8qXQPtr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%val727 = load %VBO*, %VBO** %vboPtr
%val728 = icmp eq %VBO* %val727, null
br i1 %val728, label %then726, label %else726

then726:
ret i64 0

else726:
%val729 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val730 = getelementptr %VBO, %VBO* %val729, i64 0, i32 5
%val731 = load i64, i64* %val730
ret i64 %val731
}
@gsxtmgl-objects252 = hidden constant [81 x i8] c"stride_adhoc_W2k2NCxWQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** @stride_adhoc_W2k2NCxWQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone751 = load i8*, i8** %_impzPtr
%zone752 = bitcast i8* %tzone751 to %mzone*

; let assign value to symbol stride_adhoc_W2k2NCxWQk8qXQ
%dat_stride_adhoc_W2k2NCxWQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone752, i64 8)
%stride_adhoc_W2k2NCxWQk8qXQPtr = bitcast i8* %dat_stride_adhoc_W2k2NCxWQk8qXQ to { i8*, i8*, i64 (i8*, i8*, %VBO*)*}***
%tzone732 = load i8*, i8** %_impzPtr
%zone733 = bitcast i8* %tzone732 to %mzone*
call void @llvm_zone_mark(%mzone* %zone733)
; malloc closure structure
%clsptr734 = call i8* @llvm_zone_malloc(%mzone* %zone733, i64 24)
%closure735 = bitcast i8* %clsptr734 to { i8*, i8*, i64 (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr736 = call i8* @llvm_zone_malloc(%mzone* %zone733, i64 8)
%environment737 = bitcast i8* %envptr736 to {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable738 = call %clsvar* @new_address_table()
%var739 = bitcast [28 x i8]* @gsxtmgl-objects251 to i8*
%var740 = bitcast [37 x i8]* @gsxtmgl-objects244 to i8*
%addytable741 = call %clsvar* @add_address_table(%mzone* %zone733, i8* %var739, i32 0, i8* %var740, i32 3, %clsvar* %addytable738)
%address-table742 = bitcast %clsvar* %addytable741 to i8*

; insert table, function and environment into closure struct
%closure.table745 = getelementptr { i8*, i8*, i64 (i8*, i8*, %VBO*)*}, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure735, i32 0, i32 0
store i8* %address-table742, i8** %closure.table745
%closure.env746 = getelementptr { i8*, i8*, i64 (i8*, i8*, %VBO*)*}, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure735, i32 0, i32 1
store i8* %envptr736, i8** %closure.env746
%closure.func747 = getelementptr { i8*, i8*, i64 (i8*, i8*, %VBO*)*}, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure735, i32 0, i32 2
store i64 (i8*, i8*, %VBO*)* @stride_adhoc_W2k2NCxWQk8qXQ__724, i64 (i8*, i8*, %VBO*)** %closure.func747
%closure_size748 = call i64 @llvm_zone_mark_size(%mzone* %zone733)
call void @llvm_zone_ptr_set_size(i8* %clsptr734, i64 %closure_size748)
%wrapper_ptr749 = call i8* @llvm_zone_malloc(%mzone* %zone733, i64 8)
%closure_wrapper750 = bitcast i8* %wrapper_ptr749 to { i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
store { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure735, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_wrapper750

; let value assignment
%stride_adhoc_W2k2NCxWQk8qXQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_wrapper750, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_wrapper750
store { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %stride_adhoc_W2k2NCxWQk8qXQ, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}*** %stride_adhoc_W2k2NCxWQk8qXQPtr

; add data to environment
; don't need to alloc for env var stride_adhoc_W2k2NCxWQk8qXQ
%tmp_envptr744 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}* %environment737, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*** %stride_adhoc_W2k2NCxWQk8qXQPtr, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**** %tmp_envptr744


%val753 = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*** %stride_adhoc_W2k2NCxWQk8qXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %val753
}


@stride_adhoc_W2k2NCxWQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@stride_adhoc_W2k2NCxWQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @stride_adhoc_W2k2NCxWQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @stride_adhoc_W2k2NCxWQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** @stride_adhoc_W2k2NCxWQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @stride_adhoc_W2k2NCxWQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @stride_adhoc_W2k2NCxWQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @stride_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @stride_adhoc_W2k2NCxWQk8qXQ(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @stride_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @stride_adhoc_W2k2NCxWQk8qXQ_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @stride_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @stride_adhoc_W2k2NCxWQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var754 = bitcast [81 x i8]* @gsxtmgl-objects252 to i8*
call i32 (i8*, ...) @printf(i8* %var754)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @stride_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @stride_adhoc_W2k2NCxWQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @stride_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects253 = hidden constant [11 x i8] c"<VBO: 0x0>\00"
@gsxtmgl-objects254 = hidden constant [63 x i8] c"<VBO: id=%d type=%s nbytes=%d data=%p elements=%ld stride=%ld>\00"
@gsxtmgl-objects255 = hidden constant [5 x i8] c"byte\00"
@gsxtmgl-objects256 = hidden constant [6 x i8] c"short\00"
@gsxtmgl-objects257 = hidden constant [4 x i8] c"int\00"
@gsxtmgl-objects258 = hidden constant [6 x i8] c"float\00"
@gsxtmgl-objects259 = hidden constant [8 x i8] c"unknown\00"
@gsxtmgl-objects260 = hidden constant [28 x i8] c"print_adhoc_W3ZvaWQsVkJPKl0\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsVkJPKl0__755(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone756 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*
%print_adhoc_W3ZvaWQsVkJPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsVkJPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %VBO*)*}***, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %print_adhoc_W3ZvaWQsVkJPKl0Ptr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr

; promote local stack var allocations
%tzone812 = load i8*, i8** %_impzPtr
%zone813 = bitcast i8* %tzone812 to %mzone*
%ifptr757 = alloca i32

%val758 = load %VBO*, %VBO** %vboPtr
%val759 = icmp eq %VBO* %val758, null
br i1 %val759, label %then757, label %else757

then757:
%var760 = bitcast [11 x i8]* @gsxtmgl-objects253 to i8*

%val761 = call i32 (i8*, ...) @printf(i8* %var760)
store i32 %val761, i32* %ifptr757
br label %ifcont757

else757:
%var762 = bitcast [63 x i8]* @gsxtmgl-objects254 to i8*
%val763 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val764 = getelementptr %VBO, %VBO* %val763, i64 0, i32 0
%val765 = load i32, i32* %val764
%tzone768 = load i8*, i8** %_impzPtr
%zone769 = bitcast i8* %tzone768 to %mzone*

; let assign value to symbol t
%tPtr = alloca i32
%val766 = load %VBO*, %VBO** %vboPtr
%res767 = call fastcc i32 @type_adhoc_W2kzMixWQk8qXQ(%VBO* %val766)

; let value assignment
%t = select i1 true, i32 %res767, i32 %res767
store i32 %t, i32* %tPtr

; promote local stack var allocations
%tzone795 = load i8*, i8** %_impzPtr
%zone796 = bitcast i8* %tzone795 to %mzone*
%ifptr770 = alloca i8*
%ifptr775 = alloca i8*
%ifptr780 = alloca i8*
%ifptr785 = alloca i8*
%val771 = load i32, i32* %tPtr
%val772 = load i32, i32* @GL_BYTE
%cmp773 = icmp eq i32 %val771, %val772
br i1 %cmp773, label %then770, label %else770

then770:
%var774 = bitcast [5 x i8]* @gsxtmgl-objects255 to i8*
store i8* %var774, i8** %ifptr770
br label %ifcont770

else770:
%val776 = load i32, i32* %tPtr
%val777 = load i32, i32* @GL_SHORT
%cmp778 = icmp eq i32 %val776, %val777
br i1 %cmp778, label %then775, label %else775

then775:
%var779 = bitcast [6 x i8]* @gsxtmgl-objects256 to i8*
store i8* %var779, i8** %ifptr775
br label %ifcont775

else775:
%val781 = load i32, i32* %tPtr
%val782 = load i32, i32* @GL_INT
%cmp783 = icmp eq i32 %val781, %val782
br i1 %cmp783, label %then780, label %else780

then780:
%var784 = bitcast [4 x i8]* @gsxtmgl-objects257 to i8*
store i8* %var784, i8** %ifptr780
br label %ifcont780

else780:
%val786 = load i32, i32* %tPtr
%val787 = load i32, i32* @GL_FLOAT
%cmp788 = icmp eq i32 %val786, %val787
br i1 %cmp788, label %then785, label %else785

then785:
%var789 = bitcast [6 x i8]* @gsxtmgl-objects258 to i8*
store i8* %var789, i8** %ifptr785
br label %ifcont785

else785:
%var790 = bitcast [8 x i8]* @gsxtmgl-objects259 to i8*
store i8* %var790, i8** %ifptr785
br label %ifcont785

ifcont785:
%ifres791 = load i8*, i8** %ifptr785

store i8* %ifres791, i8** %ifptr780
br label %ifcont780

ifcont780:
%ifres792 = load i8*, i8** %ifptr780

store i8* %ifres792, i8** %ifptr775
br label %ifcont775

ifcont775:
%ifres793 = load i8*, i8** %ifptr775

store i8* %ifres793, i8** %ifptr770
br label %ifcont770

ifcont770:
%ifres794 = load i8*, i8** %ifptr770

%val797 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val798 = getelementptr %VBO, %VBO* %val797, i64 0, i32 2
%val799 = load i64, i64* %val798
%val800 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val801 = getelementptr %VBO, %VBO* %val800, i64 0, i32 3
%val802 = load i8*, i8** %val801
%val803 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val804 = getelementptr %VBO, %VBO* %val803, i64 0, i32 4
%val805 = load i64, i64* %val804
%val806 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val807 = getelementptr %VBO, %VBO* %val806, i64 0, i32 5
%val808 = load i64, i64* %val807

%val809 = call i32 (i8*, ...) @printf(i8* %var762, i32 %val765, i8* %ifres794, i64 %val799, i8* %val802, i64 %val805, i64 %val808)
store i32 %val809, i32* %ifptr757
br label %ifcont757

ifcont757:
%ifres810 = load i32, i32* %ifptr757

ret void
}
@gsxtmgl-objects261 = hidden constant [81 x i8] c"print_adhoc_W3ZvaWQsVkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @print_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone833 = load i8*, i8** %_impzPtr
%zone834 = bitcast i8* %tzone833 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsVkJPKl0
%dat_print_adhoc_W3ZvaWQsVkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone834, i64 8)
%print_adhoc_W3ZvaWQsVkJPKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsVkJPKl0 to { i8*, i8*, void (i8*, i8*, %VBO*)*}***
%tzone814 = load i8*, i8** %_impzPtr
%zone815 = bitcast i8* %tzone814 to %mzone*
call void @llvm_zone_mark(%mzone* %zone815)
; malloc closure structure
%clsptr816 = call i8* @llvm_zone_malloc(%mzone* %zone815, i64 24)
%closure817 = bitcast i8* %clsptr816 to { i8*, i8*, void (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr818 = call i8* @llvm_zone_malloc(%mzone* %zone815, i64 8)
%environment819 = bitcast i8* %envptr818 to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable820 = call %clsvar* @new_address_table()
%var821 = bitcast [28 x i8]* @gsxtmgl-objects260 to i8*
%var822 = bitcast [38 x i8]* @gsxtmgl-objects233 to i8*
%addytable823 = call %clsvar* @add_address_table(%mzone* %zone815, i8* %var821, i32 0, i8* %var822, i32 3, %clsvar* %addytable820)
%address-table824 = bitcast %clsvar* %addytable823 to i8*

; insert table, function and environment into closure struct
%closure.table827 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure817, i32 0, i32 0
store i8* %address-table824, i8** %closure.table827
%closure.env828 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure817, i32 0, i32 1
store i8* %envptr818, i8** %closure.env828
%closure.func829 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure817, i32 0, i32 2
store void (i8*, i8*, %VBO*)* @print_adhoc_W3ZvaWQsVkJPKl0__755, void (i8*, i8*, %VBO*)** %closure.func829
%closure_size830 = call i64 @llvm_zone_mark_size(%mzone* %zone815)
call void @llvm_zone_ptr_set_size(i8* %clsptr816, i64 %closure_size830)
%wrapper_ptr831 = call i8* @llvm_zone_malloc(%mzone* %zone815, i64 8)
%closure_wrapper832 = bitcast i8* %wrapper_ptr831 to { i8*, i8*, void (i8*, i8*, %VBO*)*}**
store { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure817, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper832

; let value assignment
%print_adhoc_W3ZvaWQsVkJPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper832, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper832
store { i8*, i8*, void (i8*, i8*, %VBO*)*}** %print_adhoc_W3ZvaWQsVkJPKl0, { i8*, i8*, void (i8*, i8*, %VBO*)*}*** %print_adhoc_W3ZvaWQsVkJPKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsVkJPKl0
%tmp_envptr826 = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %environment819, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %print_adhoc_W3ZvaWQsVkJPKl0Ptr, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %tmp_envptr826


%val835 = load {i8*, i8*, void (i8*, i8*, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %print_adhoc_W3ZvaWQsVkJPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VBO*)*}** %val835
}


@print_adhoc_W3ZvaWQsVkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsVkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsVkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @print_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsVkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsVkJPKl0(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsVkJPKl0_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsVkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var836 = bitcast [81 x i8]* @gsxtmgl-objects261 to i8*
call i32 (i8*, ...) @printf(i8* %var836)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsVkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects262 = hidden constant [35 x i8] c"toString_adhoc_W1N0cmluZyosVkJPKl0\00"
@gsxtmgl-objects263 = hidden constant [42 x i8] c"{i8*, i8*, %String* (i8*, i8*, %VBO*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosVkJPKl0__837(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone838 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %VBO*)*}***}*
%toString_adhoc_W1N0cmluZyosVkJPKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosVkJPKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %VBO*)*}***, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**** %toString_adhoc_W1N0cmluZyosVkJPKl0Ptr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%tzone840 = load i8*, i8** %_impzPtr
%zone841 = bitcast i8* %tzone840 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat839 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat839, i8* %dat839
store i8* %s, i8** %sPtr

; promote local stack var allocations
%tzone900 = load i8*, i8** %_impzPtr
%zone901 = bitcast i8* %tzone900 to %mzone*
%ifptr842 = alloca i32
%val843 = load %VBO*, %VBO** %vboPtr
%val844 = icmp eq %VBO* %val843, null
br i1 %val844, label %then842, label %else842

then842:
%val845 = load i8*, i8** %sPtr
%var846 = bitcast [11 x i8]* @gsxtmgl-objects253 to i8*

%val847 = call i32 (i8*,i8*, ...) @sprintf(i8* %val845, i8* %var846)
store i32 %val847, i32* %ifptr842
br label %ifcont842

else842:
%val848 = load i8*, i8** %sPtr
%var849 = bitcast [63 x i8]* @gsxtmgl-objects254 to i8*
%val850 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val851 = getelementptr %VBO, %VBO* %val850, i64 0, i32 0
%val852 = load i32, i32* %val851
%tzone855 = load i8*, i8** %_impzPtr
%zone856 = bitcast i8* %tzone855 to %mzone*

; let assign value to symbol t
%tPtr = alloca i32
%val853 = load %VBO*, %VBO** %vboPtr
%res854 = call fastcc i32 @type_adhoc_W2kzMixWQk8qXQ(%VBO* %val853)

; let value assignment
%t = select i1 true, i32 %res854, i32 %res854
store i32 %t, i32* %tPtr

; promote local stack var allocations
%tzone882 = load i8*, i8** %_impzPtr
%zone883 = bitcast i8* %tzone882 to %mzone*
%ifptr857 = alloca i8*
%ifptr862 = alloca i8*
%ifptr867 = alloca i8*
%ifptr872 = alloca i8*
%val858 = load i32, i32* %tPtr
%val859 = load i32, i32* @GL_BYTE
%cmp860 = icmp eq i32 %val858, %val859
br i1 %cmp860, label %then857, label %else857

then857:
%var861 = bitcast [5 x i8]* @gsxtmgl-objects255 to i8*
store i8* %var861, i8** %ifptr857
br label %ifcont857

else857:
%val863 = load i32, i32* %tPtr
%val864 = load i32, i32* @GL_SHORT
%cmp865 = icmp eq i32 %val863, %val864
br i1 %cmp865, label %then862, label %else862

then862:
%var866 = bitcast [6 x i8]* @gsxtmgl-objects256 to i8*
store i8* %var866, i8** %ifptr862
br label %ifcont862

else862:
%val868 = load i32, i32* %tPtr
%val869 = load i32, i32* @GL_INT
%cmp870 = icmp eq i32 %val868, %val869
br i1 %cmp870, label %then867, label %else867

then867:
%var871 = bitcast [4 x i8]* @gsxtmgl-objects257 to i8*
store i8* %var871, i8** %ifptr867
br label %ifcont867

else867:
%val873 = load i32, i32* %tPtr
%val874 = load i32, i32* @GL_FLOAT
%cmp875 = icmp eq i32 %val873, %val874
br i1 %cmp875, label %then872, label %else872

then872:
%var876 = bitcast [6 x i8]* @gsxtmgl-objects258 to i8*
store i8* %var876, i8** %ifptr872
br label %ifcont872

else872:
%var877 = bitcast [8 x i8]* @gsxtmgl-objects259 to i8*
store i8* %var877, i8** %ifptr872
br label %ifcont872

ifcont872:
%ifres878 = load i8*, i8** %ifptr872

store i8* %ifres878, i8** %ifptr867
br label %ifcont867

ifcont867:
%ifres879 = load i8*, i8** %ifptr867

store i8* %ifres879, i8** %ifptr862
br label %ifcont862

ifcont862:
%ifres880 = load i8*, i8** %ifptr862

store i8* %ifres880, i8** %ifptr857
br label %ifcont857

ifcont857:
%ifres881 = load i8*, i8** %ifptr857

%val884 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val885 = getelementptr %VBO, %VBO* %val884, i64 0, i32 2
%val886 = load i64, i64* %val885
%val887 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val888 = getelementptr %VBO, %VBO* %val887, i64 0, i32 3
%val889 = load i8*, i8** %val888
%val890 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val891 = getelementptr %VBO, %VBO* %val890, i64 0, i32 4
%val892 = load i64, i64* %val891
%val893 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val894 = getelementptr %VBO, %VBO* %val893, i64 0, i32 5
%val895 = load i64, i64* %val894

%val896 = call i32 (i8*,i8*, ...) @sprintf(i8* %val848, i8* %var849, i32 %val852, i8* %ifres881, i64 %val886, i8* %val889, i64 %val892, i64 %val895)
store i32 %val896, i32* %ifptr842
br label %ifcont842

ifcont842:
%ifres897 = load i32, i32* %ifptr842

%val898 = load i8*, i8** %sPtr
%res899 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val898)
ret %String* %res899
}
@gsxtmgl-objects264 = hidden constant [88 x i8] c"toString_adhoc_W1N0cmluZyosVkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** @toString_adhoc_W1N0cmluZyosVkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone921 = load i8*, i8** %_impzPtr
%zone922 = bitcast i8* %tzone921 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosVkJPKl0
%dat_toString_adhoc_W1N0cmluZyosVkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone922, i64 8)
%toString_adhoc_W1N0cmluZyosVkJPKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosVkJPKl0 to { i8*, i8*, %String* (i8*, i8*, %VBO*)*}***
%tzone902 = load i8*, i8** %_impzPtr
%zone903 = bitcast i8* %tzone902 to %mzone*
call void @llvm_zone_mark(%mzone* %zone903)
; malloc closure structure
%clsptr904 = call i8* @llvm_zone_malloc(%mzone* %zone903, i64 24)
%closure905 = bitcast i8* %clsptr904 to { i8*, i8*, %String* (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr906 = call i8* @llvm_zone_malloc(%mzone* %zone903, i64 8)
%environment907 = bitcast i8* %envptr906 to {{i8*, i8*, %String* (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable908 = call %clsvar* @new_address_table()
%var909 = bitcast [35 x i8]* @gsxtmgl-objects262 to i8*
%var910 = bitcast [42 x i8]* @gsxtmgl-objects263 to i8*
%addytable911 = call %clsvar* @add_address_table(%mzone* %zone903, i8* %var909, i32 0, i8* %var910, i32 3, %clsvar* %addytable908)
%address-table912 = bitcast %clsvar* %addytable911 to i8*

; insert table, function and environment into closure struct
%closure.table915 = getelementptr { i8*, i8*, %String* (i8*, i8*, %VBO*)*}, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure905, i32 0, i32 0
store i8* %address-table912, i8** %closure.table915
%closure.env916 = getelementptr { i8*, i8*, %String* (i8*, i8*, %VBO*)*}, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure905, i32 0, i32 1
store i8* %envptr906, i8** %closure.env916
%closure.func917 = getelementptr { i8*, i8*, %String* (i8*, i8*, %VBO*)*}, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure905, i32 0, i32 2
store %String* (i8*, i8*, %VBO*)* @toString_adhoc_W1N0cmluZyosVkJPKl0__837, %String* (i8*, i8*, %VBO*)** %closure.func917
%closure_size918 = call i64 @llvm_zone_mark_size(%mzone* %zone903)
call void @llvm_zone_ptr_set_size(i8* %clsptr904, i64 %closure_size918)
%wrapper_ptr919 = call i8* @llvm_zone_malloc(%mzone* %zone903, i64 8)
%closure_wrapper920 = bitcast i8* %wrapper_ptr919 to { i8*, i8*, %String* (i8*, i8*, %VBO*)*}**
store { i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure905, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_wrapper920

; let value assignment
%toString_adhoc_W1N0cmluZyosVkJPKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_wrapper920, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_wrapper920
store { i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %toString_adhoc_W1N0cmluZyosVkJPKl0, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}*** %toString_adhoc_W1N0cmluZyosVkJPKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosVkJPKl0
%tmp_envptr914 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %VBO*)*}***}* %environment907, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %VBO*)*}*** %toString_adhoc_W1N0cmluZyosVkJPKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**** %tmp_envptr914


%val923 = load {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}*** %toString_adhoc_W1N0cmluZyosVkJPKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %val923
}


@toString_adhoc_W1N0cmluZyosVkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosVkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosVkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** @toString_adhoc_W1N0cmluZyosVkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosVkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosVkJPKl0(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VBO*)*,  %String* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosVkJPKl0_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VBO*)*,  %String* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosVkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var924 = bitcast [88 x i8]* @gsxtmgl-objects264 to i8*
call i32 (i8*, ...) @printf(i8* %var924)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VBO*)*,  %String* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosVkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VBO*)*,  %String* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects265 = hidden constant [19 x i8] c"Error creating VBO\00"
@gsxtmgl-objects266 = hidden constant [23 x i8] c"Error setting VBO data\00"
@gsxtmgl-objects267 = hidden constant [19 x i8] c"Error deleting VBO\00"
@gsxtmgl-objects268 = hidden constant [50 x i8] c"VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0\00"
@gsxtmgl-objects269 = hidden constant [60 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}**\00"
@gsxtmgl-objects270 = hidden constant [11 x i8] c"stride_s_2\00"
@gsxtmgl-objects271 = hidden constant [4 x i8] c"i64\00"
@gsxtmgl-objects272 = hidden constant [13 x i8] c"elements_s_1\00"
@gsxtmgl-objects273 = hidden constant [6 x i8] c"usage\00"
@gsxtmgl-objects274 = hidden constant [4 x i8] c"i32\00"
@gsxtmgl-objects275 = hidden constant [7 x i8] c"buflen\00"
@gsxtmgl-objects276 = hidden constant [4 x i8] c"buf\00"
@gsxtmgl-objects277 = hidden constant [7 x i8] c"float*\00"
@gsxtmgl-objects278 = hidden constant [4 x i8] c"vbo\00"
@gsxtmgl-objects279 = hidden constant [6 x i8] c"%VBO*\00"
@gsxtmgl-objects280 = hidden constant [2 x i8] c"f\00"
@gsxtmgl-objects281 = hidden constant [5 x i8] c"hook\00"
@gsxtmgl-objects282 = hidden constant [15 x i8] c"{i64,i8*,i8*}*\00"
@gsxtmgl-objects283 = hidden constant [6 x i8] c"hooks\00"
@gsxtmgl-objects284 = hidden constant [5 x i8] c"zone\00"
@gsxtmgl-objects285 = hidden constant [8 x i8] c"%mzone*\00"
define dllexport fastcc void @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0__926(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone973 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}*
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0Ptr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 0
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0Ptr = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}**** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0Ptr_
%stride_s_2Ptr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 1
%stride_s_2Ptr = load i64*, i64** %stride_s_2Ptr_
%elements_s_1Ptr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 2
%elements_s_1Ptr = load i64*, i64** %elements_s_1Ptr_
%usagePtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 3
%usagePtr = load i32*, i32** %usagePtr_
%buflenPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 4
%buflenPtr = load i64*, i64** %buflenPtr_
%bufPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 5
%bufPtr = load float**, float*** %bufPtr_
%vboPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 6
%vboPtr = load %VBO**, %VBO*** %vboPtr_
%fPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 7
%fPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %fPtr_
%hookPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 8
%hookPtr = load {i64,i8*,i8*}**, {i64,i8*,i8*}*** %hookPtr_
%hooksPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 9
%hooksPtr = load {i64,i8*,i8*}**, {i64,i8*,i8*}*** %hooksPtr_
%zonePtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 10
%zonePtr = load %mzone**, %mzone*** %zonePtr_

; setup arguments


%val974 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val975 = getelementptr %VBO, %VBO* %val974, i64 0, i32 0
call fastcc void @glDeleteBuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val975)
%var977 = bitcast [19 x i8]* @gsxtmgl-objects267 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var977)
ret void
}
define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0__925(i8* %_impz,i8* %_impenv, float* %buf, i64 %buflen, i32 %usage, i64 %elements_s_1, i64 %stride_s_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone927 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***}*
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0Ptr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***}* %impenv, i32 0, i32 0
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0Ptr = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}**** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0Ptr_

; setup arguments
%dat_buf = call i8* @llvm_zone_malloc(%mzone* %zone927, i64 8)
%bufPtr = bitcast i8* %dat_buf to float**
store float* %buf, float** %bufPtr
%dat_buflen = call i8* @llvm_zone_malloc(%mzone* %zone927, i64 8)
%buflenPtr = bitcast i8* %dat_buflen to i64*
store i64 %buflen, i64* %buflenPtr
%dat_usage = call i8* @llvm_zone_malloc(%mzone* %zone927, i64 4)
%usagePtr = bitcast i8* %dat_usage to i32*
store i32 %usage, i32* %usagePtr
%dat_elements_s_1 = call i8* @llvm_zone_malloc(%mzone* %zone927, i64 8)
%elements_s_1Ptr = bitcast i8* %dat_elements_s_1 to i64*
store i64 %elements_s_1, i64* %elements_s_1Ptr
%dat_stride_s_2 = call i8* @llvm_zone_malloc(%mzone* %zone927, i64 8)
%stride_s_2Ptr = bitcast i8* %dat_stride_s_2 to i64*
store i64 %stride_s_2, i64* %stride_s_2Ptr


%tzone936 = load i8*, i8** %_impzPtr
%zone937 = bitcast i8* %tzone936 to %mzone*

; let assign value to symbol vbo
%dat_vbo = call i8* @llvm_zone_malloc(%mzone* %zone937, i64 8)
%vboPtr = bitcast i8* %dat_vbo to %VBO**
%val928 = load i32, i32* @GL_FLOAT
%val929 = load i64, i64* %buflenPtr
%val930 = mul i64 4, %val929
%val931 = load float*, float** %bufPtr
%val932 = bitcast float* %val931 to i8*
%val933 = load i64, i64* %elements_s_1Ptr
%val934 = load i64, i64* %stride_s_2Ptr
%res935 = call fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd(i32 0, i32 %val928, i64 %val930, i8* %val932, i64 %val933, i64 %val934)

; let value assignment
%vbo = select i1 true, %VBO* %res935, %VBO* %res935
store %VBO* %vbo, %VBO** %vboPtr

%val938 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val939 = getelementptr %VBO, %VBO* %val938, i64 0, i32 0
call fastcc void @glGenBuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val939)
%var941 = bitcast [19 x i8]* @gsxtmgl-objects265 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var941)
%val943 = load i32, i32* @GL_ARRAY_BUFFER
%val944 = load %VBO*, %VBO** %vboPtr
%res945 = call fastcc i32 @id_adhoc_W2kzMixWQk8qXQ(%VBO* %val944)
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val943, i32 %res945)
%val947 = load i32, i32* @GL_ARRAY_BUFFER
%val948 = load %VBO*, %VBO** %vboPtr
%res949 = call fastcc i64 @size_adhoc_W2k2NCxWQk8qXQ(%VBO* %val948)
%val950 = load %VBO*, %VBO** %vboPtr
%res951 = call fastcc i8* @data_adhoc_W2k4KixWQk8qXQ(%VBO* %val950)
%val952 = load i32, i32* %usagePtr
call fastcc void @glBufferData_adhoc_W3ZvaWQsaTMyLGk2NCxpOCosaTMyXQ(i32 %val947, i64 %res949, i8* %res951, i32 %val952)
%var954 = bitcast [23 x i8]* @gsxtmgl-objects266 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var954)
%val956 = load i32, i32* @GL_ARRAY_BUFFER
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val956, i32 0)
%tzone959 = load i8*, i8** %_impzPtr
%zone960 = bitcast i8* %tzone959 to %mzone*

; let assign value to symbol zone
%dat_zone = call i8* @llvm_zone_malloc(%mzone* %zone960, i64 8)
%zonePtr = bitcast i8* %dat_zone to %mzone**
%tzone965 = load i8*, i8** %_impzPtr
%zone966 = bitcast i8* %tzone965 to %mzone*

; let assign value to symbol hooks
%dat_hooks = call i8* @llvm_zone_malloc(%mzone* %zone966, i64 8)
%hooksPtr = bitcast i8* %dat_hooks to {i64,i8*,i8*}**
%tzone971 = load i8*, i8** %_impzPtr
%zone972 = bitcast i8* %tzone971 to %mzone*

; let assign value to symbol hook
%dat_hook = call i8* @llvm_zone_malloc(%mzone* %zone972, i64 8)
%hookPtr = bitcast i8* %dat_hook to {i64,i8*,i8*}**
%tzone1049 = load i8*, i8** %_impzPtr
%zone1050 = bitcast i8* %tzone1049 to %mzone*

; let assign value to symbol f
%dat_f = call i8* @llvm_zone_malloc(%mzone* %zone1050, i64 8)
%fPtr = bitcast i8* %dat_f to { i8*, i8*, void (i8*, i8*)*}***
%res958 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%zone = select i1 true, %mzone* %res958, %mzone* %res958
store %mzone* %zone, %mzone** %zonePtr

%val961 = load %mzone*, %mzone** %zonePtr
; tuple ref
%val962 = getelementptr %mzone, %mzone* %val961, i64 0, i32 4
%val963 = load i8*, i8** %val962
%val964 = bitcast i8* %val963 to {i64,i8*,i8*}*

; let value assignment
%hooks = select i1 true, {i64,i8*,i8*}* %val964, {i64,i8*,i8*}* %val964
store {i64,i8*,i8*}* %hooks, {i64,i8*,i8*}** %hooksPtr

%tzone967 = load i8*, i8** %_impzPtr
%zone968 = bitcast i8* %tzone967 to %mzone*
%dat969 = call i8* @llvm_zone_malloc(%mzone* %zone968, i64 24)
call i8* @memset(i8* %dat969, i32 0, i64 24)
%val970 = bitcast i8* %dat969 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val970, {i64,i8*,i8*}* %val970
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%tzone980 = load i8*, i8** %_impzPtr
%zone981 = bitcast i8* %tzone980 to %mzone*
call void @llvm_zone_mark(%mzone* %zone981)
; malloc closure structure
%clsptr982 = call i8* @llvm_zone_malloc(%mzone* %zone981, i64 24)
%closure983 = bitcast i8* %clsptr982 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr984 = call i8* @llvm_zone_malloc(%mzone* %zone981, i64 88)
%environment985 = bitcast i8* %envptr984 to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}*

; malloc closure address table
%addytable986 = call %clsvar* @new_address_table()
%var987 = bitcast [50 x i8]* @gsxtmgl-objects268 to i8*
%var988 = bitcast [60 x i8]* @gsxtmgl-objects269 to i8*
%addytable989 = call %clsvar* @add_address_table(%mzone* %zone981, i8* %var987, i32 0, i8* %var988, i32 3, %clsvar* %addytable986)
%var990 = bitcast [11 x i8]* @gsxtmgl-objects270 to i8*
%var991 = bitcast [4 x i8]* @gsxtmgl-objects271 to i8*
%addytable992 = call %clsvar* @add_address_table(%mzone* %zone981, i8* %var990, i32 8, i8* %var991, i32 3, %clsvar* %addytable989)
%var993 = bitcast [13 x i8]* @gsxtmgl-objects272 to i8*
%var994 = bitcast [4 x i8]* @gsxtmgl-objects271 to i8*
%addytable995 = call %clsvar* @add_address_table(%mzone* %zone981, i8* %var993, i32 16, i8* %var994, i32 3, %clsvar* %addytable992)
%var996 = bitcast [6 x i8]* @gsxtmgl-objects273 to i8*
%var997 = bitcast [4 x i8]* @gsxtmgl-objects274 to i8*
%addytable998 = call %clsvar* @add_address_table(%mzone* %zone981, i8* %var996, i32 24, i8* %var997, i32 3, %clsvar* %addytable995)
%var999 = bitcast [7 x i8]* @gsxtmgl-objects275 to i8*
%var1000 = bitcast [4 x i8]* @gsxtmgl-objects271 to i8*
%addytable1001 = call %clsvar* @add_address_table(%mzone* %zone981, i8* %var999, i32 32, i8* %var1000, i32 3, %clsvar* %addytable998)
%var1002 = bitcast [4 x i8]* @gsxtmgl-objects276 to i8*
%var1003 = bitcast [7 x i8]* @gsxtmgl-objects277 to i8*
%addytable1004 = call %clsvar* @add_address_table(%mzone* %zone981, i8* %var1002, i32 40, i8* %var1003, i32 3, %clsvar* %addytable1001)
%var1005 = bitcast [4 x i8]* @gsxtmgl-objects278 to i8*
%var1006 = bitcast [6 x i8]* @gsxtmgl-objects279 to i8*
%addytable1007 = call %clsvar* @add_address_table(%mzone* %zone981, i8* %var1005, i32 48, i8* %var1006, i32 3, %clsvar* %addytable1004)
%var1008 = bitcast [2 x i8]* @gsxtmgl-objects280 to i8*
%var1009 = bitcast [31 x i8]* @gsxtmgl-objects211 to i8*
%addytable1010 = call %clsvar* @add_address_table(%mzone* %zone981, i8* %var1008, i32 56, i8* %var1009, i32 3, %clsvar* %addytable1007)
%var1011 = bitcast [5 x i8]* @gsxtmgl-objects281 to i8*
%var1012 = bitcast [15 x i8]* @gsxtmgl-objects282 to i8*
%addytable1013 = call %clsvar* @add_address_table(%mzone* %zone981, i8* %var1011, i32 64, i8* %var1012, i32 3, %clsvar* %addytable1010)
%var1014 = bitcast [6 x i8]* @gsxtmgl-objects283 to i8*
%var1015 = bitcast [15 x i8]* @gsxtmgl-objects282 to i8*
%addytable1016 = call %clsvar* @add_address_table(%mzone* %zone981, i8* %var1014, i32 72, i8* %var1015, i32 3, %clsvar* %addytable1013)
%var1017 = bitcast [5 x i8]* @gsxtmgl-objects284 to i8*
%var1018 = bitcast [8 x i8]* @gsxtmgl-objects285 to i8*
%addytable1019 = call %clsvar* @add_address_table(%mzone* %zone981, i8* %var1017, i32 80, i8* %var1018, i32 3, %clsvar* %addytable1016)
%address-table1020 = bitcast %clsvar* %addytable1019 to i8*

; insert table, function and environment into closure struct
%closure.table1043 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure983, i32 0, i32 0
store i8* %address-table1020, i8** %closure.table1043
%closure.env1044 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure983, i32 0, i32 1
store i8* %envptr984, i8** %closure.env1044
%closure.func1045 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure983, i32 0, i32 2
store void (i8*, i8*)* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0__926, void (i8*, i8*)** %closure.func1045
%closure_size1046 = call i64 @llvm_zone_mark_size(%mzone* %zone981)
call void @llvm_zone_ptr_set_size(i8* %clsptr982, i64 %closure_size1046)
%wrapper_ptr1047 = call i8* @llvm_zone_malloc(%mzone* %zone981, i64 8)
%closure_wrapper1048 = bitcast i8* %wrapper_ptr1047 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure983, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper1048

; let value assignment
%f = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper1048, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper1048
store { i8*, i8*, void (i8*, i8*)*}** %f, { i8*, i8*, void (i8*, i8*)*}*** %fPtr

; add data to environment
; don't need to alloc for env var VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0
%tmp_envptr1022 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment985, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0Ptr, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}**** %tmp_envptr1022

; don't need to alloc for env var stride_s_2
%tmp_envptr1024 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment985, i32 0, i32 1
store i64* %stride_s_2Ptr, i64** %tmp_envptr1024

; don't need to alloc for env var elements_s_1
%tmp_envptr1026 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment985, i32 0, i32 2
store i64* %elements_s_1Ptr, i64** %tmp_envptr1026

; don't need to alloc for env var usage
%tmp_envptr1028 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment985, i32 0, i32 3
store i32* %usagePtr, i32** %tmp_envptr1028

; don't need to alloc for env var buflen
%tmp_envptr1030 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment985, i32 0, i32 4
store i64* %buflenPtr, i64** %tmp_envptr1030

; don't need to alloc for env var buf
%tmp_envptr1032 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment985, i32 0, i32 5
store float** %bufPtr, float*** %tmp_envptr1032

; don't need to alloc for env var vbo
%tmp_envptr1034 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment985, i32 0, i32 6
store %VBO** %vboPtr, %VBO*** %tmp_envptr1034

; don't need to alloc for env var f
%tmp_envptr1036 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment985, i32 0, i32 7
store {i8*, i8*, void (i8*, i8*)*}*** %fPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr1036

; don't need to alloc for env var hook
%tmp_envptr1038 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment985, i32 0, i32 8
store {i64,i8*,i8*}** %hookPtr, {i64,i8*,i8*}*** %tmp_envptr1038

; don't need to alloc for env var hooks
%tmp_envptr1040 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment985, i32 0, i32 9
store {i64,i8*,i8*}** %hooksPtr, {i64,i8*,i8*}*** %tmp_envptr1040

; don't need to alloc for env var zone
%tmp_envptr1042 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, float**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment985, i32 0, i32 10
store %mzone** %zonePtr, %mzone*** %tmp_envptr1042


%val1051 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; set tuple
%val1052 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1051, i64 0, i32 0
store i64 0, i64* %val1052
%val1053 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1054 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val1055 = bitcast {i8*, i8*, void (i8*, i8*)*}** %val1054 to i8*
; set tuple
%val1056 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1053, i64 0, i32 1
store i8* %val1055, i8** %val1056
%val1057 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1058 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hooksPtr
%val1059 = bitcast {i64,i8*,i8*}* %val1058 to i8*
; set tuple
%val1060 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1057, i64 0, i32 2
store i8* %val1059, i8** %val1060
%val1061 = load %mzone*, %mzone** %zonePtr
%val1062 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1063 = bitcast {i64,i8*,i8*}* %val1062 to i8*
; set tuple
%val1064 = getelementptr %mzone, %mzone* %val1061, i64 0, i32 4
store i8* %val1063, i8** %val1064
%val1066 = load %VBO*, %VBO** %vboPtr
ret %VBO* %val1066
}
@gsxtmgl-objects286 = hidden constant [103 x i8] c"VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}** @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1086 = load i8*, i8** %_impzPtr
%zone1087 = bitcast i8* %tzone1086 to %mzone*

; let assign value to symbol VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0
%dat_VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone1087, i64 8)
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0Ptr = bitcast i8* %dat_VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***
%tzone1067 = load i8*, i8** %_impzPtr
%zone1068 = bitcast i8* %tzone1067 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1068)
; malloc closure structure
%clsptr1069 = call i8* @llvm_zone_malloc(%mzone* %zone1068, i64 24)
%closure1070 = bitcast i8* %clsptr1069 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}*

; malloc environment structure
%envptr1071 = call i8* @llvm_zone_malloc(%mzone* %zone1068, i64 8)
%environment1072 = bitcast i8* %envptr1071 to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***}*

; malloc closure address table
%addytable1073 = call %clsvar* @new_address_table()
%var1074 = bitcast [50 x i8]* @gsxtmgl-objects268 to i8*
%var1075 = bitcast [60 x i8]* @gsxtmgl-objects269 to i8*
%addytable1076 = call %clsvar* @add_address_table(%mzone* %zone1068, i8* %var1074, i32 0, i8* %var1075, i32 3, %clsvar* %addytable1073)
%address-table1077 = bitcast %clsvar* %addytable1076 to i8*

; insert table, function and environment into closure struct
%closure.table1080 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}* %closure1070, i32 0, i32 0
store i8* %address-table1077, i8** %closure.table1080
%closure.env1081 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}* %closure1070, i32 0, i32 1
store i8* %envptr1071, i8** %closure.env1081
%closure.func1082 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}* %closure1070, i32 0, i32 2
store %VBO* (i8*, i8*, float*, i64, i32, i64, i64)* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0__925, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)** %closure.func1082
%closure_size1083 = call i64 @llvm_zone_mark_size(%mzone* %zone1068)
call void @llvm_zone_ptr_set_size(i8* %clsptr1069, i64 %closure_size1083)
%wrapper_ptr1084 = call i8* @llvm_zone_malloc(%mzone* %zone1068, i64 8)
%closure_wrapper1085 = bitcast i8* %wrapper_ptr1084 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}* %closure1070, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}** %closure_wrapper1085

; let value assignment
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0 = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}** %closure_wrapper1085, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}** %closure_wrapper1085
store { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0Ptr

; add data to environment
; don't need to alloc for env var VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0
%tmp_envptr1079 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}***}* %environment1072, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0Ptr, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}**** %tmp_envptr1079


%val1088 = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0Ptr
ret {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}** %val1088
}


@VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}** @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0(float* %arg_0,i64 %arg_1,i32 %arg_2,i64 %arg_3,i64 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*,  %VBO* (i8*, i8*, float*, i64, i32, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i32 %arg_2, i64 %arg_3, i64 %arg_4)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_native(float* %arg_0,i64 %arg_1,i32 %arg_2,i64 %arg_3,i64 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*,  %VBO* (i8*, i8*, float*, i64, i32, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i32 %arg_2, i64 %arg_3, i64 %arg_4)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1089 = bitcast [103 x i8]* @gsxtmgl-objects286 to i8*
call i32 (i8*, ...) @printf(i8* %var1089)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1090 = bitcast [103 x i8]* @gsxtmgl-objects286 to i8*
call i32 (i8*, ...) @printf(i8* %var1090)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1091 = bitcast [103 x i8]* @gsxtmgl-objects286 to i8*
call i32 (i8*, ...) @printf(i8* %var1091)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1092 = bitcast [103 x i8]* @gsxtmgl-objects286 to i8*
call i32 (i8*, ...) @printf(i8* %var1092)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var1093 = bitcast [103 x i8]* @gsxtmgl-objects286 to i8*
call i32 (i8*, ...) @printf(i8* %var1093)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*,  %VBO* (i8*, i8*, float*, i64, i32, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i32 %arg_2, i64 %arg_3, i64 %arg_4)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, i32, i64, i64}*
%arg_p_0 = getelementptr {float*, i64, i32, i64, i64}, {float*, i64, i32, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, i32, i64, i64}, {float*, i64, i32, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, i32, i64, i64}, {float*, i64, i32, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {float*, i64, i32, i64, i64}, {float*, i64, i32, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {float*, i64, i32, i64, i64}, {float*, i64, i32, i64, i64}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i32, i64, i64)*,  %VBO* (i8*, i8*, float*, i64, i32, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i32 %arg_2, i64 %arg_3, i64 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects287 = hidden constant [47 x i8] c"VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd\00"
@gsxtmgl-objects288 = hidden constant [58 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}**\00"
@gsxtmgl-objects289 = hidden constant [11 x i8] c"stride_s_4\00"
@gsxtmgl-objects290 = hidden constant [13 x i8] c"elements_s_3\00"
@gsxtmgl-objects291 = hidden constant [5 x i8] c"i32*\00"
define dllexport fastcc void @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd__1095(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1142 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}*
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 0
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRdPtr = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}**** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRdPtr_
%stride_s_4Ptr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 1
%stride_s_4Ptr = load i64*, i64** %stride_s_4Ptr_
%elements_s_3Ptr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 2
%elements_s_3Ptr = load i64*, i64** %elements_s_3Ptr_
%usagePtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 3
%usagePtr = load i32*, i32** %usagePtr_
%buflenPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 4
%buflenPtr = load i64*, i64** %buflenPtr_
%bufPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 5
%bufPtr = load i32**, i32*** %bufPtr_
%vboPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 6
%vboPtr = load %VBO**, %VBO*** %vboPtr_
%fPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 7
%fPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %fPtr_
%hookPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 8
%hookPtr = load {i64,i8*,i8*}**, {i64,i8*,i8*}*** %hookPtr_
%hooksPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 9
%hooksPtr = load {i64,i8*,i8*}**, {i64,i8*,i8*}*** %hooksPtr_
%zonePtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 10
%zonePtr = load %mzone**, %mzone*** %zonePtr_

; setup arguments


%val1143 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val1144 = getelementptr %VBO, %VBO* %val1143, i64 0, i32 0
call fastcc void @glDeleteBuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val1144)
%var1146 = bitcast [19 x i8]* @gsxtmgl-objects267 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1146)
ret void
}
define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd__1094(i8* %_impz,i8* %_impenv, i32* %buf, i64 %buflen, i32 %usage, i64 %elements_s_3, i64 %stride_s_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1096 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***}*
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***}* %impenv, i32 0, i32 0
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRdPtr = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}**** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRdPtr_

; setup arguments
%dat_buf = call i8* @llvm_zone_malloc(%mzone* %zone1096, i64 8)
%bufPtr = bitcast i8* %dat_buf to i32**
store i32* %buf, i32** %bufPtr
%dat_buflen = call i8* @llvm_zone_malloc(%mzone* %zone1096, i64 8)
%buflenPtr = bitcast i8* %dat_buflen to i64*
store i64 %buflen, i64* %buflenPtr
%dat_usage = call i8* @llvm_zone_malloc(%mzone* %zone1096, i64 4)
%usagePtr = bitcast i8* %dat_usage to i32*
store i32 %usage, i32* %usagePtr
%dat_elements_s_3 = call i8* @llvm_zone_malloc(%mzone* %zone1096, i64 8)
%elements_s_3Ptr = bitcast i8* %dat_elements_s_3 to i64*
store i64 %elements_s_3, i64* %elements_s_3Ptr
%dat_stride_s_4 = call i8* @llvm_zone_malloc(%mzone* %zone1096, i64 8)
%stride_s_4Ptr = bitcast i8* %dat_stride_s_4 to i64*
store i64 %stride_s_4, i64* %stride_s_4Ptr


%tzone1105 = load i8*, i8** %_impzPtr
%zone1106 = bitcast i8* %tzone1105 to %mzone*

; let assign value to symbol vbo
%dat_vbo = call i8* @llvm_zone_malloc(%mzone* %zone1106, i64 8)
%vboPtr = bitcast i8* %dat_vbo to %VBO**
%val1097 = load i32, i32* @GL_INT
%val1098 = load i64, i64* %buflenPtr
%val1099 = mul i64 4, %val1098
%val1100 = load i32*, i32** %bufPtr
%val1101 = bitcast i32* %val1100 to i8*
%val1102 = load i64, i64* %elements_s_3Ptr
%val1103 = load i64, i64* %stride_s_4Ptr
%res1104 = call fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqLGk2NCxpNjRd(i32 0, i32 %val1097, i64 %val1099, i8* %val1101, i64 %val1102, i64 %val1103)

; let value assignment
%vbo = select i1 true, %VBO* %res1104, %VBO* %res1104
store %VBO* %vbo, %VBO** %vboPtr

%val1107 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val1108 = getelementptr %VBO, %VBO* %val1107, i64 0, i32 0
call fastcc void @glGenBuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val1108)
%var1110 = bitcast [19 x i8]* @gsxtmgl-objects265 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1110)
%val1112 = load i32, i32* @GL_ARRAY_BUFFER
%val1113 = load %VBO*, %VBO** %vboPtr
%res1114 = call fastcc i32 @id_adhoc_W2kzMixWQk8qXQ(%VBO* %val1113)
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val1112, i32 %res1114)
%val1116 = load i32, i32* @GL_ARRAY_BUFFER
%val1117 = load %VBO*, %VBO** %vboPtr
%res1118 = call fastcc i64 @size_adhoc_W2k2NCxWQk8qXQ(%VBO* %val1117)
%val1119 = load %VBO*, %VBO** %vboPtr
%res1120 = call fastcc i8* @data_adhoc_W2k4KixWQk8qXQ(%VBO* %val1119)
%val1121 = load i32, i32* %usagePtr
call fastcc void @glBufferData_adhoc_W3ZvaWQsaTMyLGk2NCxpOCosaTMyXQ(i32 %val1116, i64 %res1118, i8* %res1120, i32 %val1121)
%var1123 = bitcast [23 x i8]* @gsxtmgl-objects266 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1123)
%val1125 = load i32, i32* @GL_ARRAY_BUFFER
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val1125, i32 0)
%tzone1128 = load i8*, i8** %_impzPtr
%zone1129 = bitcast i8* %tzone1128 to %mzone*

; let assign value to symbol zone
%dat_zone = call i8* @llvm_zone_malloc(%mzone* %zone1129, i64 8)
%zonePtr = bitcast i8* %dat_zone to %mzone**
%tzone1134 = load i8*, i8** %_impzPtr
%zone1135 = bitcast i8* %tzone1134 to %mzone*

; let assign value to symbol hooks
%dat_hooks = call i8* @llvm_zone_malloc(%mzone* %zone1135, i64 8)
%hooksPtr = bitcast i8* %dat_hooks to {i64,i8*,i8*}**
%tzone1140 = load i8*, i8** %_impzPtr
%zone1141 = bitcast i8* %tzone1140 to %mzone*

; let assign value to symbol hook
%dat_hook = call i8* @llvm_zone_malloc(%mzone* %zone1141, i64 8)
%hookPtr = bitcast i8* %dat_hook to {i64,i8*,i8*}**
%tzone1218 = load i8*, i8** %_impzPtr
%zone1219 = bitcast i8* %tzone1218 to %mzone*

; let assign value to symbol f
%dat_f = call i8* @llvm_zone_malloc(%mzone* %zone1219, i64 8)
%fPtr = bitcast i8* %dat_f to { i8*, i8*, void (i8*, i8*)*}***
%res1127 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%zone = select i1 true, %mzone* %res1127, %mzone* %res1127
store %mzone* %zone, %mzone** %zonePtr

%val1130 = load %mzone*, %mzone** %zonePtr
; tuple ref
%val1131 = getelementptr %mzone, %mzone* %val1130, i64 0, i32 4
%val1132 = load i8*, i8** %val1131
%val1133 = bitcast i8* %val1132 to {i64,i8*,i8*}*

; let value assignment
%hooks = select i1 true, {i64,i8*,i8*}* %val1133, {i64,i8*,i8*}* %val1133
store {i64,i8*,i8*}* %hooks, {i64,i8*,i8*}** %hooksPtr

%tzone1136 = load i8*, i8** %_impzPtr
%zone1137 = bitcast i8* %tzone1136 to %mzone*
%dat1138 = call i8* @llvm_zone_malloc(%mzone* %zone1137, i64 24)
call i8* @memset(i8* %dat1138, i32 0, i64 24)
%val1139 = bitcast i8* %dat1138 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val1139, {i64,i8*,i8*}* %val1139
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%tzone1149 = load i8*, i8** %_impzPtr
%zone1150 = bitcast i8* %tzone1149 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1150)
; malloc closure structure
%clsptr1151 = call i8* @llvm_zone_malloc(%mzone* %zone1150, i64 24)
%closure1152 = bitcast i8* %clsptr1151 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr1153 = call i8* @llvm_zone_malloc(%mzone* %zone1150, i64 88)
%environment1154 = bitcast i8* %envptr1153 to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}*

; malloc closure address table
%addytable1155 = call %clsvar* @new_address_table()
%var1156 = bitcast [47 x i8]* @gsxtmgl-objects287 to i8*
%var1157 = bitcast [58 x i8]* @gsxtmgl-objects288 to i8*
%addytable1158 = call %clsvar* @add_address_table(%mzone* %zone1150, i8* %var1156, i32 0, i8* %var1157, i32 3, %clsvar* %addytable1155)
%var1159 = bitcast [11 x i8]* @gsxtmgl-objects289 to i8*
%var1160 = bitcast [4 x i8]* @gsxtmgl-objects271 to i8*
%addytable1161 = call %clsvar* @add_address_table(%mzone* %zone1150, i8* %var1159, i32 8, i8* %var1160, i32 3, %clsvar* %addytable1158)
%var1162 = bitcast [13 x i8]* @gsxtmgl-objects290 to i8*
%var1163 = bitcast [4 x i8]* @gsxtmgl-objects271 to i8*
%addytable1164 = call %clsvar* @add_address_table(%mzone* %zone1150, i8* %var1162, i32 16, i8* %var1163, i32 3, %clsvar* %addytable1161)
%var1165 = bitcast [6 x i8]* @gsxtmgl-objects273 to i8*
%var1166 = bitcast [4 x i8]* @gsxtmgl-objects274 to i8*
%addytable1167 = call %clsvar* @add_address_table(%mzone* %zone1150, i8* %var1165, i32 24, i8* %var1166, i32 3, %clsvar* %addytable1164)
%var1168 = bitcast [7 x i8]* @gsxtmgl-objects275 to i8*
%var1169 = bitcast [4 x i8]* @gsxtmgl-objects271 to i8*
%addytable1170 = call %clsvar* @add_address_table(%mzone* %zone1150, i8* %var1168, i32 32, i8* %var1169, i32 3, %clsvar* %addytable1167)
%var1171 = bitcast [4 x i8]* @gsxtmgl-objects276 to i8*
%var1172 = bitcast [5 x i8]* @gsxtmgl-objects291 to i8*
%addytable1173 = call %clsvar* @add_address_table(%mzone* %zone1150, i8* %var1171, i32 40, i8* %var1172, i32 3, %clsvar* %addytable1170)
%var1174 = bitcast [4 x i8]* @gsxtmgl-objects278 to i8*
%var1175 = bitcast [6 x i8]* @gsxtmgl-objects279 to i8*
%addytable1176 = call %clsvar* @add_address_table(%mzone* %zone1150, i8* %var1174, i32 48, i8* %var1175, i32 3, %clsvar* %addytable1173)
%var1177 = bitcast [2 x i8]* @gsxtmgl-objects280 to i8*
%var1178 = bitcast [31 x i8]* @gsxtmgl-objects211 to i8*
%addytable1179 = call %clsvar* @add_address_table(%mzone* %zone1150, i8* %var1177, i32 56, i8* %var1178, i32 3, %clsvar* %addytable1176)
%var1180 = bitcast [5 x i8]* @gsxtmgl-objects281 to i8*
%var1181 = bitcast [15 x i8]* @gsxtmgl-objects282 to i8*
%addytable1182 = call %clsvar* @add_address_table(%mzone* %zone1150, i8* %var1180, i32 64, i8* %var1181, i32 3, %clsvar* %addytable1179)
%var1183 = bitcast [6 x i8]* @gsxtmgl-objects283 to i8*
%var1184 = bitcast [15 x i8]* @gsxtmgl-objects282 to i8*
%addytable1185 = call %clsvar* @add_address_table(%mzone* %zone1150, i8* %var1183, i32 72, i8* %var1184, i32 3, %clsvar* %addytable1182)
%var1186 = bitcast [5 x i8]* @gsxtmgl-objects284 to i8*
%var1187 = bitcast [8 x i8]* @gsxtmgl-objects285 to i8*
%addytable1188 = call %clsvar* @add_address_table(%mzone* %zone1150, i8* %var1186, i32 80, i8* %var1187, i32 3, %clsvar* %addytable1185)
%address-table1189 = bitcast %clsvar* %addytable1188 to i8*

; insert table, function and environment into closure struct
%closure.table1212 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure1152, i32 0, i32 0
store i8* %address-table1189, i8** %closure.table1212
%closure.env1213 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure1152, i32 0, i32 1
store i8* %envptr1153, i8** %closure.env1213
%closure.func1214 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure1152, i32 0, i32 2
store void (i8*, i8*)* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd__1095, void (i8*, i8*)** %closure.func1214
%closure_size1215 = call i64 @llvm_zone_mark_size(%mzone* %zone1150)
call void @llvm_zone_ptr_set_size(i8* %clsptr1151, i64 %closure_size1215)
%wrapper_ptr1216 = call i8* @llvm_zone_malloc(%mzone* %zone1150, i64 8)
%closure_wrapper1217 = bitcast i8* %wrapper_ptr1216 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure1152, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper1217

; let value assignment
%f = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper1217, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper1217
store { i8*, i8*, void (i8*, i8*)*}** %f, { i8*, i8*, void (i8*, i8*)*}*** %fPtr

; add data to environment
; don't need to alloc for env var VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd
%tmp_envptr1191 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment1154, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRdPtr, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}**** %tmp_envptr1191

; don't need to alloc for env var stride_s_4
%tmp_envptr1193 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment1154, i32 0, i32 1
store i64* %stride_s_4Ptr, i64** %tmp_envptr1193

; don't need to alloc for env var elements_s_3
%tmp_envptr1195 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment1154, i32 0, i32 2
store i64* %elements_s_3Ptr, i64** %tmp_envptr1195

; don't need to alloc for env var usage
%tmp_envptr1197 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment1154, i32 0, i32 3
store i32* %usagePtr, i32** %tmp_envptr1197

; don't need to alloc for env var buflen
%tmp_envptr1199 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment1154, i32 0, i32 4
store i64* %buflenPtr, i64** %tmp_envptr1199

; don't need to alloc for env var buf
%tmp_envptr1201 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment1154, i32 0, i32 5
store i32** %bufPtr, i32*** %tmp_envptr1201

; don't need to alloc for env var vbo
%tmp_envptr1203 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment1154, i32 0, i32 6
store %VBO** %vboPtr, %VBO*** %tmp_envptr1203

; don't need to alloc for env var f
%tmp_envptr1205 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment1154, i32 0, i32 7
store {i8*, i8*, void (i8*, i8*)*}*** %fPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr1205

; don't need to alloc for env var hook
%tmp_envptr1207 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment1154, i32 0, i32 8
store {i64,i8*,i8*}** %hookPtr, {i64,i8*,i8*}*** %tmp_envptr1207

; don't need to alloc for env var hooks
%tmp_envptr1209 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment1154, i32 0, i32 9
store {i64,i8*,i8*}** %hooksPtr, {i64,i8*,i8*}*** %tmp_envptr1209

; don't need to alloc for env var zone
%tmp_envptr1211 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***, i64*, i64*, i32*, i64*, i32**, %VBO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment1154, i32 0, i32 10
store %mzone** %zonePtr, %mzone*** %tmp_envptr1211


%val1220 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; set tuple
%val1221 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1220, i64 0, i32 0
store i64 0, i64* %val1221
%val1222 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1223 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val1224 = bitcast {i8*, i8*, void (i8*, i8*)*}** %val1223 to i8*
; set tuple
%val1225 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1222, i64 0, i32 1
store i8* %val1224, i8** %val1225
%val1226 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1227 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hooksPtr
%val1228 = bitcast {i64,i8*,i8*}* %val1227 to i8*
; set tuple
%val1229 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val1226, i64 0, i32 2
store i8* %val1228, i8** %val1229
%val1230 = load %mzone*, %mzone** %zonePtr
%val1231 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val1232 = bitcast {i64,i8*,i8*}* %val1231 to i8*
; set tuple
%val1233 = getelementptr %mzone, %mzone* %val1230, i64 0, i32 4
store i8* %val1232, i8** %val1233
%val1235 = load %VBO*, %VBO** %vboPtr
ret %VBO* %val1235
}
@gsxtmgl-objects292 = hidden constant [100 x i8] c"VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}** @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1255 = load i8*, i8** %_impzPtr
%zone1256 = bitcast i8* %tzone1255 to %mzone*

; let assign value to symbol VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd
%dat_VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone1256, i64 8)
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRdPtr = bitcast i8* %dat_VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***
%tzone1236 = load i8*, i8** %_impzPtr
%zone1237 = bitcast i8* %tzone1236 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1237)
; malloc closure structure
%clsptr1238 = call i8* @llvm_zone_malloc(%mzone* %zone1237, i64 24)
%closure1239 = bitcast i8* %clsptr1238 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}*

; malloc environment structure
%envptr1240 = call i8* @llvm_zone_malloc(%mzone* %zone1237, i64 8)
%environment1241 = bitcast i8* %envptr1240 to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***}*

; malloc closure address table
%addytable1242 = call %clsvar* @new_address_table()
%var1243 = bitcast [47 x i8]* @gsxtmgl-objects287 to i8*
%var1244 = bitcast [58 x i8]* @gsxtmgl-objects288 to i8*
%addytable1245 = call %clsvar* @add_address_table(%mzone* %zone1237, i8* %var1243, i32 0, i8* %var1244, i32 3, %clsvar* %addytable1242)
%address-table1246 = bitcast %clsvar* %addytable1245 to i8*

; insert table, function and environment into closure struct
%closure.table1249 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}* %closure1239, i32 0, i32 0
store i8* %address-table1246, i8** %closure.table1249
%closure.env1250 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}* %closure1239, i32 0, i32 1
store i8* %envptr1240, i8** %closure.env1250
%closure.func1251 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}* %closure1239, i32 0, i32 2
store %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd__1094, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)** %closure.func1251
%closure_size1252 = call i64 @llvm_zone_mark_size(%mzone* %zone1237)
call void @llvm_zone_ptr_set_size(i8* %clsptr1238, i64 %closure_size1252)
%wrapper_ptr1253 = call i8* @llvm_zone_malloc(%mzone* %zone1237, i64 8)
%closure_wrapper1254 = bitcast i8* %wrapper_ptr1253 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}* %closure1239, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}** %closure_wrapper1254

; let value assignment
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}** %closure_wrapper1254, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}** %closure_wrapper1254
store { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRdPtr

; add data to environment
; don't need to alloc for env var VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd
%tmp_envptr1248 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}***}* %environment1241, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRdPtr, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}**** %tmp_envptr1248


%val1257 = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRdPtr
ret {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}** %val1257
}


@VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}** @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd(i32* %arg_0,i64 %arg_1,i32 %arg_2,i64 %arg_3,i64 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*,  %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i32 %arg_2, i64 %arg_3, i64 %arg_4)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_native(i32* %arg_0,i64 %arg_1,i32 %arg_2,i64 %arg_3,i64 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*,  %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i32 %arg_2, i64 %arg_3, i64 %arg_4)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1258 = bitcast [100 x i8]* @gsxtmgl-objects292 to i8*
call i32 (i8*, ...) @printf(i8* %var1258)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1259 = bitcast [100 x i8]* @gsxtmgl-objects292 to i8*
call i32 (i8*, ...) @printf(i8* %var1259)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1260 = bitcast [100 x i8]* @gsxtmgl-objects292 to i8*
call i32 (i8*, ...) @printf(i8* %var1260)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1261 = bitcast [100 x i8]* @gsxtmgl-objects292 to i8*
call i32 (i8*, ...) @printf(i8* %var1261)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var1262 = bitcast [100 x i8]* @gsxtmgl-objects292 to i8*
call i32 (i8*, ...) @printf(i8* %var1262)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i64  @i64value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*,  %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i32 %arg_2, i64 %arg_3, i64 %arg_4)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64, i32, i64, i64}*
%arg_p_0 = getelementptr {i32*, i64, i32, i64, i64}, {i32*, i64, i32, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64, i32, i64, i64}, {i32*, i64, i32, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i32*, i64, i32, i64, i64}, {i32*, i64, i32, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32*, i64, i32, i64, i64}, {i32*, i64, i32, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
%arg_p_4 = getelementptr {i32*, i64, i32, i64, i64}, {i32*, i64, i32, i64, i64}* %fstruct, i32 0, i32 4
%arg_4 = load i64, i64* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)*,  %VBO* (i8*, i8*, i32*, i64, i32, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i32 %arg_2, i64 %arg_3, i64 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects293 = hidden constant [45 x i8] c"VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ\00"
@gsxtmgl-objects294 = hidden constant [55 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}**\00"
define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ__1263(i8* %_impz,i8* %_impenv, float* %buf, i64 %buflen, i64 %elements_s_5, i64 %stride_s_6) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1264 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}***}*
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}***}* %impenv, i32 0, i32 0
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQPtr = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}**** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQPtr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%buflenPtr = alloca i64
store i64 %buflen, i64* %buflenPtr
%elements_s_5Ptr = alloca i64
store i64 %elements_s_5, i64* %elements_s_5Ptr
%stride_s_6Ptr = alloca i64
store i64 %stride_s_6, i64* %stride_s_6Ptr


%val1265 = load float*, float** %bufPtr
%val1266 = load i64, i64* %buflenPtr
%val1267 = load i32, i32* @GL_STREAM_DRAW
%val1268 = load i64, i64* %elements_s_5Ptr
%val1269 = load i64, i64* %stride_s_6Ptr
%res1270 = call fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0(float* %val1265, i64 %val1266, i32 %val1267, i64 %val1268, i64 %val1269)
ret %VBO* %res1270
}
@gsxtmgl-objects295 = hidden constant [98 x i8] c"VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}** @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1290 = load i8*, i8** %_impzPtr
%zone1291 = bitcast i8* %tzone1290 to %mzone*

; let assign value to symbol VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ
%dat_VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1291, i64 8)
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQPtr = bitcast i8* %dat_VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ to { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}***
%tzone1271 = load i8*, i8** %_impzPtr
%zone1272 = bitcast i8* %tzone1271 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1272)
; malloc closure structure
%clsptr1273 = call i8* @llvm_zone_malloc(%mzone* %zone1272, i64 24)
%closure1274 = bitcast i8* %clsptr1273 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}*

; malloc environment structure
%envptr1275 = call i8* @llvm_zone_malloc(%mzone* %zone1272, i64 8)
%environment1276 = bitcast i8* %envptr1275 to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}***}*

; malloc closure address table
%addytable1277 = call %clsvar* @new_address_table()
%var1278 = bitcast [45 x i8]* @gsxtmgl-objects293 to i8*
%var1279 = bitcast [55 x i8]* @gsxtmgl-objects294 to i8*
%addytable1280 = call %clsvar* @add_address_table(%mzone* %zone1272, i8* %var1278, i32 0, i8* %var1279, i32 3, %clsvar* %addytable1277)
%address-table1281 = bitcast %clsvar* %addytable1280 to i8*

; insert table, function and environment into closure struct
%closure.table1284 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}* %closure1274, i32 0, i32 0
store i8* %address-table1281, i8** %closure.table1284
%closure.env1285 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}* %closure1274, i32 0, i32 1
store i8* %envptr1275, i8** %closure.env1285
%closure.func1286 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}* %closure1274, i32 0, i32 2
store %VBO* (i8*, i8*, float*, i64, i64, i64)* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ__1263, %VBO* (i8*, i8*, float*, i64, i64, i64)** %closure.func1286
%closure_size1287 = call i64 @llvm_zone_mark_size(%mzone* %zone1272)
call void @llvm_zone_ptr_set_size(i8* %clsptr1273, i64 %closure_size1287)
%wrapper_ptr1288 = call i8* @llvm_zone_malloc(%mzone* %zone1272, i64 8)
%closure_wrapper1289 = bitcast i8* %wrapper_ptr1288 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}* %closure1274, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}** %closure_wrapper1289

; let value assignment
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}** %closure_wrapper1289, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}** %closure_wrapper1289
store { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ
%tmp_envptr1283 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}***}* %environment1276, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQPtr, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}**** %tmp_envptr1283


%val1292 = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQPtr
ret {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}** %val1292
}


@VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}** @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ(float* %arg_0,i64 %arg_1,i64 %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i64, i64)*,  %VBO* (i8*, i8*, float*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_native(float* %arg_0,i64 %arg_1,i64 %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i64, i64)*,  %VBO* (i8*, i8*, float*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1293 = bitcast [98 x i8]* @gsxtmgl-objects295 to i8*
call i32 (i8*, ...) @printf(i8* %var1293)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1294 = bitcast [98 x i8]* @gsxtmgl-objects295 to i8*
call i32 (i8*, ...) @printf(i8* %var1294)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1295 = bitcast [98 x i8]* @gsxtmgl-objects295 to i8*
call i32 (i8*, ...) @printf(i8* %var1295)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1296 = bitcast [98 x i8]* @gsxtmgl-objects295 to i8*
call i32 (i8*, ...) @printf(i8* %var1296)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i64, i64)*,  %VBO* (i8*, i8*, float*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, i64, i64}*
%arg_p_0 = getelementptr {float*, i64, i64, i64}, {float*, i64, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, i64, i64}, {float*, i64, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, i64, i64}, {float*, i64, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {float*, i64, i64, i64}, {float*, i64, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i64, i64)*,  %VBO* (i8*, i8*, float*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects296 = hidden constant [42 x i8] c"VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0\00"
@gsxtmgl-objects297 = hidden constant [53 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}**\00"
define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0__1297(i8* %_impz,i8* %_impenv, i32* %buf, i64 %buflen, i64 %elements_s_7, i64 %stride_s_8) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1298 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}***}*
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0Ptr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}***}* %impenv, i32 0, i32 0
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0Ptr = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}**** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0Ptr_

; setup arguments
%bufPtr = alloca i32*
store i32* %buf, i32** %bufPtr
%buflenPtr = alloca i64
store i64 %buflen, i64* %buflenPtr
%elements_s_7Ptr = alloca i64
store i64 %elements_s_7, i64* %elements_s_7Ptr
%stride_s_8Ptr = alloca i64
store i64 %stride_s_8, i64* %stride_s_8Ptr


%val1299 = load i32*, i32** %bufPtr
%val1300 = load i64, i64* %buflenPtr
%val1301 = load i32, i32* @GL_STREAM_DRAW
%val1302 = load i64, i64* %elements_s_7Ptr
%val1303 = load i64, i64* %stride_s_8Ptr
%res1304 = call fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd(i32* %val1299, i64 %val1300, i32 %val1301, i64 %val1302, i64 %val1303)
ret %VBO* %res1304
}
@gsxtmgl-objects298 = hidden constant [95 x i8] c"VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}** @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1324 = load i8*, i8** %_impzPtr
%zone1325 = bitcast i8* %tzone1324 to %mzone*

; let assign value to symbol VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0
%dat_VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone1325, i64 8)
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0Ptr = bitcast i8* %dat_VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}***
%tzone1305 = load i8*, i8** %_impzPtr
%zone1306 = bitcast i8* %tzone1305 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1306)
; malloc closure structure
%clsptr1307 = call i8* @llvm_zone_malloc(%mzone* %zone1306, i64 24)
%closure1308 = bitcast i8* %clsptr1307 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}*

; malloc environment structure
%envptr1309 = call i8* @llvm_zone_malloc(%mzone* %zone1306, i64 8)
%environment1310 = bitcast i8* %envptr1309 to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}***}*

; malloc closure address table
%addytable1311 = call %clsvar* @new_address_table()
%var1312 = bitcast [42 x i8]* @gsxtmgl-objects296 to i8*
%var1313 = bitcast [53 x i8]* @gsxtmgl-objects297 to i8*
%addytable1314 = call %clsvar* @add_address_table(%mzone* %zone1306, i8* %var1312, i32 0, i8* %var1313, i32 3, %clsvar* %addytable1311)
%address-table1315 = bitcast %clsvar* %addytable1314 to i8*

; insert table, function and environment into closure struct
%closure.table1318 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}* %closure1308, i32 0, i32 0
store i8* %address-table1315, i8** %closure.table1318
%closure.env1319 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}* %closure1308, i32 0, i32 1
store i8* %envptr1309, i8** %closure.env1319
%closure.func1320 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}* %closure1308, i32 0, i32 2
store %VBO* (i8*, i8*, i32*, i64, i64, i64)* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0__1297, %VBO* (i8*, i8*, i32*, i64, i64, i64)** %closure.func1320
%closure_size1321 = call i64 @llvm_zone_mark_size(%mzone* %zone1306)
call void @llvm_zone_ptr_set_size(i8* %clsptr1307, i64 %closure_size1321)
%wrapper_ptr1322 = call i8* @llvm_zone_malloc(%mzone* %zone1306, i64 8)
%closure_wrapper1323 = bitcast i8* %wrapper_ptr1322 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}* %closure1308, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}** %closure_wrapper1323

; let value assignment
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0 = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}** %closure_wrapper1323, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}** %closure_wrapper1323
store { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0Ptr

; add data to environment
; don't need to alloc for env var VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0
%tmp_envptr1317 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}***}* %environment1310, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0Ptr, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}**** %tmp_envptr1317


%val1326 = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0Ptr
ret {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}** %val1326
}


@VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}** @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0(i32* %arg_0,i64 %arg_1,i64 %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i64, i64)*,  %VBO* (i8*, i8*, i32*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_native(i32* %arg_0,i64 %arg_1,i64 %arg_2,i64 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i64, i64)*,  %VBO* (i8*, i8*, i32*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1327 = bitcast [95 x i8]* @gsxtmgl-objects298 to i8*
call i32 (i8*, ...) @printf(i8* %var1327)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1328 = bitcast [95 x i8]* @gsxtmgl-objects298 to i8*
call i32 (i8*, ...) @printf(i8* %var1328)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1329 = bitcast [95 x i8]* @gsxtmgl-objects298 to i8*
call i32 (i8*, ...) @printf(i8* %var1329)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1330 = bitcast [95 x i8]* @gsxtmgl-objects298 to i8*
call i32 (i8*, ...) @printf(i8* %var1330)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i64  @i64value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i64, i64)*,  %VBO* (i8*, i8*, i32*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64, i64, i64}*
%arg_p_0 = getelementptr {i32*, i64, i64, i64}, {i32*, i64, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64, i64, i64}, {i32*, i64, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i32*, i64, i64, i64}, {i32*, i64, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i32*, i64, i64, i64}, {i32*, i64, i64, i64}* %fstruct, i32 0, i32 3
%arg_3 = load i64, i64* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0LGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i64, i64)*,  %VBO* (i8*, i8*, i32*, i64, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2, i64 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects299 = hidden constant [39 x i8] c"VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd\00"
@gsxtmgl-objects2100 = hidden constant [50 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}**\00"
define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd__1331(i8* %_impz,i8* %_impenv, float* %buf, i64 %buflen, i64 %elements_s_9) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1332 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}***}*
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRdPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}***}* %impenv, i32 0, i32 0
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRdPtr = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}**** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRdPtr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%buflenPtr = alloca i64
store i64 %buflen, i64* %buflenPtr
%elements_s_9Ptr = alloca i64
store i64 %elements_s_9, i64* %elements_s_9Ptr


%val1333 = load float*, float** %bufPtr
%val1334 = load i64, i64* %buflenPtr
%val1335 = load i32, i32* @GL_STREAM_DRAW
%val1336 = load i64, i64* %elements_s_9Ptr
%res1337 = call fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0(float* %val1333, i64 %val1334, i32 %val1335, i64 %val1336, i64 0)
ret %VBO* %res1337
}
@gsxtmgl-objects2101 = hidden constant [92 x i8] c"VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}** @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1357 = load i8*, i8** %_impzPtr
%zone1358 = bitcast i8* %tzone1357 to %mzone*

; let assign value to symbol VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd
%dat_VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone1358, i64 8)
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRdPtr = bitcast i8* %dat_VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd to { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}***
%tzone1338 = load i8*, i8** %_impzPtr
%zone1339 = bitcast i8* %tzone1338 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1339)
; malloc closure structure
%clsptr1340 = call i8* @llvm_zone_malloc(%mzone* %zone1339, i64 24)
%closure1341 = bitcast i8* %clsptr1340 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}*

; malloc environment structure
%envptr1342 = call i8* @llvm_zone_malloc(%mzone* %zone1339, i64 8)
%environment1343 = bitcast i8* %envptr1342 to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}***}*

; malloc closure address table
%addytable1344 = call %clsvar* @new_address_table()
%var1345 = bitcast [39 x i8]* @gsxtmgl-objects299 to i8*
%var1346 = bitcast [50 x i8]* @gsxtmgl-objects2100 to i8*
%addytable1347 = call %clsvar* @add_address_table(%mzone* %zone1339, i8* %var1345, i32 0, i8* %var1346, i32 3, %clsvar* %addytable1344)
%address-table1348 = bitcast %clsvar* %addytable1347 to i8*

; insert table, function and environment into closure struct
%closure.table1351 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}* %closure1341, i32 0, i32 0
store i8* %address-table1348, i8** %closure.table1351
%closure.env1352 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}* %closure1341, i32 0, i32 1
store i8* %envptr1342, i8** %closure.env1352
%closure.func1353 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}* %closure1341, i32 0, i32 2
store %VBO* (i8*, i8*, float*, i64, i64)* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd__1331, %VBO* (i8*, i8*, float*, i64, i64)** %closure.func1353
%closure_size1354 = call i64 @llvm_zone_mark_size(%mzone* %zone1339)
call void @llvm_zone_ptr_set_size(i8* %clsptr1340, i64 %closure_size1354)
%wrapper_ptr1355 = call i8* @llvm_zone_malloc(%mzone* %zone1339, i64 8)
%closure_wrapper1356 = bitcast i8* %wrapper_ptr1355 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}* %closure1341, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}** %closure_wrapper1356

; let value assignment
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}** %closure_wrapper1356, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}** %closure_wrapper1356
store { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRdPtr

; add data to environment
; don't need to alloc for env var VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd
%tmp_envptr1350 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}***}* %environment1343, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRdPtr, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}**** %tmp_envptr1350


%val1359 = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRdPtr
ret {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}** %val1359
}


@VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}** @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd(float* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i64)*,  %VBO* (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_native(float* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i64)*,  %VBO* (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1360 = bitcast [92 x i8]* @gsxtmgl-objects2101 to i8*
call i32 (i8*, ...) @printf(i8* %var1360)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1361 = bitcast [92 x i8]* @gsxtmgl-objects2101 to i8*
call i32 (i8*, ...) @printf(i8* %var1361)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1362 = bitcast [92 x i8]* @gsxtmgl-objects2101 to i8*
call i32 (i8*, ...) @printf(i8* %var1362)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i64)*,  %VBO* (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, i64}*
%arg_p_0 = getelementptr {float*, i64, i64}, {float*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, i64}, {float*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, i64}, {float*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i64)*,  %VBO* (i8*, i8*, float*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2102 = hidden constant [37 x i8] c"VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ\00"
@gsxtmgl-objects2103 = hidden constant [48 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}**\00"
define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ__1363(i8* %_impz,i8* %_impenv, i32* %buf, i64 %buflen, i64 %elements_s_10) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1364 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}***}*
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}***}* %impenv, i32 0, i32 0
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQPtr = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}**** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQPtr_

; setup arguments
%bufPtr = alloca i32*
store i32* %buf, i32** %bufPtr
%buflenPtr = alloca i64
store i64 %buflen, i64* %buflenPtr
%elements_s_10Ptr = alloca i64
store i64 %elements_s_10, i64* %elements_s_10Ptr


%val1365 = load i32*, i32** %bufPtr
%val1366 = load i64, i64* %buflenPtr
%val1367 = load i32, i32* @GL_STREAM_DRAW
%val1368 = load i64, i64* %elements_s_10Ptr
%res1369 = call fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd(i32* %val1365, i64 %val1366, i32 %val1367, i64 %val1368, i64 0)
ret %VBO* %res1369
}
@gsxtmgl-objects2104 = hidden constant [90 x i8] c"VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}** @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1389 = load i8*, i8** %_impzPtr
%zone1390 = bitcast i8* %tzone1389 to %mzone*

; let assign value to symbol VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ
%dat_VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1390, i64 8)
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQPtr = bitcast i8* %dat_VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}***
%tzone1370 = load i8*, i8** %_impzPtr
%zone1371 = bitcast i8* %tzone1370 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1371)
; malloc closure structure
%clsptr1372 = call i8* @llvm_zone_malloc(%mzone* %zone1371, i64 24)
%closure1373 = bitcast i8* %clsptr1372 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}*

; malloc environment structure
%envptr1374 = call i8* @llvm_zone_malloc(%mzone* %zone1371, i64 8)
%environment1375 = bitcast i8* %envptr1374 to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}***}*

; malloc closure address table
%addytable1376 = call %clsvar* @new_address_table()
%var1377 = bitcast [37 x i8]* @gsxtmgl-objects2102 to i8*
%var1378 = bitcast [48 x i8]* @gsxtmgl-objects2103 to i8*
%addytable1379 = call %clsvar* @add_address_table(%mzone* %zone1371, i8* %var1377, i32 0, i8* %var1378, i32 3, %clsvar* %addytable1376)
%address-table1380 = bitcast %clsvar* %addytable1379 to i8*

; insert table, function and environment into closure struct
%closure.table1383 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}* %closure1373, i32 0, i32 0
store i8* %address-table1380, i8** %closure.table1383
%closure.env1384 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}* %closure1373, i32 0, i32 1
store i8* %envptr1374, i8** %closure.env1384
%closure.func1385 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}* %closure1373, i32 0, i32 2
store %VBO* (i8*, i8*, i32*, i64, i64)* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ__1363, %VBO* (i8*, i8*, i32*, i64, i64)** %closure.func1385
%closure_size1386 = call i64 @llvm_zone_mark_size(%mzone* %zone1371)
call void @llvm_zone_ptr_set_size(i8* %clsptr1372, i64 %closure_size1386)
%wrapper_ptr1387 = call i8* @llvm_zone_malloc(%mzone* %zone1371, i64 8)
%closure_wrapper1388 = bitcast i8* %wrapper_ptr1387 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}* %closure1373, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}** %closure_wrapper1388

; let value assignment
%VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}** %closure_wrapper1388, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}** %closure_wrapper1388
store { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQPtr

; add data to environment
; don't need to alloc for env var VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ
%tmp_envptr1382 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}***}* %environment1375, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQPtr, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}**** %tmp_envptr1382


%val1391 = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQPtr
ret {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}** %val1391
}


@VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}** @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ(i32* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i64)*,  %VBO* (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_native(i32* %arg_0,i64 %arg_1,i64 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i64)*,  %VBO* (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1392 = bitcast [90 x i8]* @gsxtmgl-objects2104 to i8*
call i32 (i8*, ...) @printf(i8* %var1392)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1393 = bitcast [90 x i8]* @gsxtmgl-objects2104 to i8*
call i32 (i8*, ...) @printf(i8* %var1393)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1394 = bitcast [90 x i8]* @gsxtmgl-objects2104 to i8*
call i32 (i8*, ...) @printf(i8* %var1394)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i64)*,  %VBO* (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64, i64}*
%arg_p_0 = getelementptr {i32*, i64, i64}, {i32*, i64, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64, i64}, {i32*, i64, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i32*, i64, i64}, {i32*, i64, i64}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i64)*,  %VBO* (i8*, i8*, i32*, i64, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i64 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2105 = hidden constant [34 x i8] c"VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0\00"
@gsxtmgl-objects2106 = hidden constant [45 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**\00"
define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0__1395(i8* %_impz,i8* %_impenv, float* %buf, i64 %buflen) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1396 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***}*
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%buflenPtr = alloca i64
store i64 %buflen, i64* %buflenPtr


%val1397 = load float*, float** %bufPtr
%val1398 = load i64, i64* %buflenPtr
%val1399 = load i32, i32* @GL_STREAM_DRAW
%val1400 = load i64, i64* %buflenPtr
%res1401 = call fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzIsaTY0LGk2NF0(float* %val1397, i64 %val1398, i32 %val1399, i64 %val1400, i64 0)
ret %VBO* %res1401
}
@gsxtmgl-objects2107 = hidden constant [87 x i8] c"VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1421 = load i8*, i8** %_impzPtr
%zone1422 = bitcast i8* %tzone1421 to %mzone*

; let assign value to symbol VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0
%dat_VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone1422, i64 8)
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr = bitcast i8* %dat_VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***
%tzone1402 = load i8*, i8** %_impzPtr
%zone1403 = bitcast i8* %tzone1402 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1403)
; malloc closure structure
%clsptr1404 = call i8* @llvm_zone_malloc(%mzone* %zone1403, i64 24)
%closure1405 = bitcast i8* %clsptr1404 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr1406 = call i8* @llvm_zone_malloc(%mzone* %zone1403, i64 8)
%environment1407 = bitcast i8* %envptr1406 to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable1408 = call %clsvar* @new_address_table()
%var1409 = bitcast [34 x i8]* @gsxtmgl-objects2105 to i8*
%var1410 = bitcast [45 x i8]* @gsxtmgl-objects2106 to i8*
%addytable1411 = call %clsvar* @add_address_table(%mzone* %zone1403, i8* %var1409, i32 0, i8* %var1410, i32 3, %clsvar* %addytable1408)
%address-table1412 = bitcast %clsvar* %addytable1411 to i8*

; insert table, function and environment into closure struct
%closure.table1415 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure1405, i32 0, i32 0
store i8* %address-table1412, i8** %closure.table1415
%closure.env1416 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure1405, i32 0, i32 1
store i8* %envptr1406, i8** %closure.env1416
%closure.func1417 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure1405, i32 0, i32 2
store %VBO* (i8*, i8*, float*, i64)* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0__1395, %VBO* (i8*, i8*, float*, i64)** %closure.func1417
%closure_size1418 = call i64 @llvm_zone_mark_size(%mzone* %zone1403)
call void @llvm_zone_ptr_set_size(i8* %clsptr1404, i64 %closure_size1418)
%wrapper_ptr1419 = call i8* @llvm_zone_malloc(%mzone* %zone1403, i64 8)
%closure_wrapper1420 = bitcast i8* %wrapper_ptr1419 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure1405, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_wrapper1420

; let value assignment
%VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0 = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_wrapper1420, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_wrapper1420
store { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0
%tmp_envptr1414 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***}* %environment1407, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**** %tmp_envptr1414


%val1423 = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*** %VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr
ret {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %val1423
}


@VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64)*,  %VBO* (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64)*,  %VBO* (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1424 = bitcast [87 x i8]* @gsxtmgl-objects2107 to i8*
call i32 (i8*, ...) @printf(i8* %var1424)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1425 = bitcast [87 x i8]* @gsxtmgl-objects2107 to i8*
call i32 (i8*, ...) @printf(i8* %var1425)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64)*,  %VBO* (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64)*,  %VBO* (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2108 = hidden constant [31 x i8] c"VBO_adhoc_W1ZCTyosaTMyKixpNjRd\00"
@gsxtmgl-objects2109 = hidden constant [43 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**\00"
define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjRd__1426(i8* %_impz,i8* %_impenv, i32* %buf, i64 %buflen) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1427 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***}*
%VBO_adhoc_W1ZCTyosaTMyKixpNjRdPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***}* %impenv, i32 0, i32 0
%VBO_adhoc_W1ZCTyosaTMyKixpNjRdPtr = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**** %VBO_adhoc_W1ZCTyosaTMyKixpNjRdPtr_

; setup arguments
%bufPtr = alloca i32*
store i32* %buf, i32** %bufPtr
%buflenPtr = alloca i64
store i64 %buflen, i64* %buflenPtr


%val1428 = load i32*, i32** %bufPtr
%val1429 = load i64, i64* %buflenPtr
%val1430 = load i32, i32* @GL_STREAM_DRAW
%val1431 = load i64, i64* %buflenPtr
%res1432 = call fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjQsaTMyLGk2NCxpNjRd(i32* %val1428, i64 %val1429, i32 %val1430, i64 %val1431, i64 0)
ret %VBO* %res1432
}
@gsxtmgl-objects2110 = hidden constant [84 x i8] c"VBO_adhoc_W1ZCTyosaTMyKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1452 = load i8*, i8** %_impzPtr
%zone1453 = bitcast i8* %tzone1452 to %mzone*

; let assign value to symbol VBO_adhoc_W1ZCTyosaTMyKixpNjRd
%dat_VBO_adhoc_W1ZCTyosaTMyKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone1453, i64 8)
%VBO_adhoc_W1ZCTyosaTMyKixpNjRdPtr = bitcast i8* %dat_VBO_adhoc_W1ZCTyosaTMyKixpNjRd to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***
%tzone1433 = load i8*, i8** %_impzPtr
%zone1434 = bitcast i8* %tzone1433 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1434)
; malloc closure structure
%clsptr1435 = call i8* @llvm_zone_malloc(%mzone* %zone1434, i64 24)
%closure1436 = bitcast i8* %clsptr1435 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*

; malloc environment structure
%envptr1437 = call i8* @llvm_zone_malloc(%mzone* %zone1434, i64 8)
%environment1438 = bitcast i8* %envptr1437 to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***}*

; malloc closure address table
%addytable1439 = call %clsvar* @new_address_table()
%var1440 = bitcast [31 x i8]* @gsxtmgl-objects2108 to i8*
%var1441 = bitcast [43 x i8]* @gsxtmgl-objects2109 to i8*
%addytable1442 = call %clsvar* @add_address_table(%mzone* %zone1434, i8* %var1440, i32 0, i8* %var1441, i32 3, %clsvar* %addytable1439)
%address-table1443 = bitcast %clsvar* %addytable1442 to i8*

; insert table, function and environment into closure struct
%closure.table1446 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure1436, i32 0, i32 0
store i8* %address-table1443, i8** %closure.table1446
%closure.env1447 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure1436, i32 0, i32 1
store i8* %envptr1437, i8** %closure.env1447
%closure.func1448 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure1436, i32 0, i32 2
store %VBO* (i8*, i8*, i32*, i64)* @VBO_adhoc_W1ZCTyosaTMyKixpNjRd__1426, %VBO* (i8*, i8*, i32*, i64)** %closure.func1448
%closure_size1449 = call i64 @llvm_zone_mark_size(%mzone* %zone1434)
call void @llvm_zone_ptr_set_size(i8* %clsptr1435, i64 %closure_size1449)
%wrapper_ptr1450 = call i8* @llvm_zone_malloc(%mzone* %zone1434, i64 8)
%closure_wrapper1451 = bitcast i8* %wrapper_ptr1450 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure1436, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_wrapper1451

; let value assignment
%VBO_adhoc_W1ZCTyosaTMyKixpNjRd = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_wrapper1451, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_wrapper1451
store { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %VBO_adhoc_W1ZCTyosaTMyKixpNjRd, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjRdPtr

; add data to environment
; don't need to alloc for env var VBO_adhoc_W1ZCTyosaTMyKixpNjRd
%tmp_envptr1445 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***}* %environment1438, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjRdPtr, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**** %tmp_envptr1445


%val1454 = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*** %VBO_adhoc_W1ZCTyosaTMyKixpNjRdPtr
ret {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %val1454
}


@VBO_adhoc_W1ZCTyosaTMyKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_adhoc_W1ZCTyosaTMyKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjRd(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64)*,  %VBO* (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_native(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64)*,  %VBO* (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1455 = bitcast [84 x i8]* @gsxtmgl-objects2110 to i8*
call i32 (i8*, ...) @printf(i8* %var1455)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1456 = bitcast [84 x i8]* @gsxtmgl-objects2110 to i8*
call i32 (i8*, ...) @printf(i8* %var1456)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64)*,  %VBO* (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64}*
%arg_p_0 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64)*,  %VBO* (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2111 = hidden constant [18 x i8] c"Error binding VBO\00"
@gsxtmgl-objects2112 = hidden constant [27 x i8] c"Error updating VBO subdata\00"
@gsxtmgl-objects2113 = hidden constant [29 x i8] c"update_adhoc_W3ZvaWQsVkJPKl0\00"
define dllexport fastcc void @update_adhoc_W3ZvaWQsVkJPKl0__1457(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1458 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*
%update_adhoc_W3ZvaWQsVkJPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%update_adhoc_W3ZvaWQsVkJPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %VBO*)*}***, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %update_adhoc_W3ZvaWQsVkJPKl0Ptr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%val1459 = load i32, i32* @GL_ARRAY_BUFFER
%val1460 = load %VBO*, %VBO** %vboPtr
%res1461 = call fastcc i32 @id_adhoc_W2kzMixWQk8qXQ(%VBO* %val1460)
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val1459, i32 %res1461)
%var1463 = bitcast [18 x i8]* @gsxtmgl-objects2111 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1463)
%val1465 = load i32, i32* @GL_ARRAY_BUFFER
%val1466 = load %VBO*, %VBO** %vboPtr
%res1467 = call fastcc i64 @size_adhoc_W2k2NCxWQk8qXQ(%VBO* %val1466)
%val1468 = load %VBO*, %VBO** %vboPtr
%res1469 = call fastcc i8* @data_adhoc_W2k4KixWQk8qXQ(%VBO* %val1468)
call fastcc void @glBufferSubData_adhoc_W3ZvaWQsaTMyLGk2NCxpNjQsaTgqXQ(i32 %val1465, i64 0, i64 %res1467, i8* %res1469)
%var1471 = bitcast [27 x i8]* @gsxtmgl-objects2112 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1471)
%val1473 = load i32, i32* @GL_ARRAY_BUFFER
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val1473, i32 0)
ret void
}
@gsxtmgl-objects2114 = hidden constant [82 x i8] c"update_adhoc_W3ZvaWQsVkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @update_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1494 = load i8*, i8** %_impzPtr
%zone1495 = bitcast i8* %tzone1494 to %mzone*

; let assign value to symbol update_adhoc_W3ZvaWQsVkJPKl0
%dat_update_adhoc_W3ZvaWQsVkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1495, i64 8)
%update_adhoc_W3ZvaWQsVkJPKl0Ptr = bitcast i8* %dat_update_adhoc_W3ZvaWQsVkJPKl0 to { i8*, i8*, void (i8*, i8*, %VBO*)*}***
%tzone1475 = load i8*, i8** %_impzPtr
%zone1476 = bitcast i8* %tzone1475 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1476)
; malloc closure structure
%clsptr1477 = call i8* @llvm_zone_malloc(%mzone* %zone1476, i64 24)
%closure1478 = bitcast i8* %clsptr1477 to { i8*, i8*, void (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr1479 = call i8* @llvm_zone_malloc(%mzone* %zone1476, i64 8)
%environment1480 = bitcast i8* %envptr1479 to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable1481 = call %clsvar* @new_address_table()
%var1482 = bitcast [29 x i8]* @gsxtmgl-objects2113 to i8*
%var1483 = bitcast [38 x i8]* @gsxtmgl-objects233 to i8*
%addytable1484 = call %clsvar* @add_address_table(%mzone* %zone1476, i8* %var1482, i32 0, i8* %var1483, i32 3, %clsvar* %addytable1481)
%address-table1485 = bitcast %clsvar* %addytable1484 to i8*

; insert table, function and environment into closure struct
%closure.table1488 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure1478, i32 0, i32 0
store i8* %address-table1485, i8** %closure.table1488
%closure.env1489 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure1478, i32 0, i32 1
store i8* %envptr1479, i8** %closure.env1489
%closure.func1490 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure1478, i32 0, i32 2
store void (i8*, i8*, %VBO*)* @update_adhoc_W3ZvaWQsVkJPKl0__1457, void (i8*, i8*, %VBO*)** %closure.func1490
%closure_size1491 = call i64 @llvm_zone_mark_size(%mzone* %zone1476)
call void @llvm_zone_ptr_set_size(i8* %clsptr1477, i64 %closure_size1491)
%wrapper_ptr1492 = call i8* @llvm_zone_malloc(%mzone* %zone1476, i64 8)
%closure_wrapper1493 = bitcast i8* %wrapper_ptr1492 to { i8*, i8*, void (i8*, i8*, %VBO*)*}**
store { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure1478, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper1493

; let value assignment
%update_adhoc_W3ZvaWQsVkJPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper1493, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper1493
store { i8*, i8*, void (i8*, i8*, %VBO*)*}** %update_adhoc_W3ZvaWQsVkJPKl0, { i8*, i8*, void (i8*, i8*, %VBO*)*}*** %update_adhoc_W3ZvaWQsVkJPKl0Ptr

; add data to environment
; don't need to alloc for env var update_adhoc_W3ZvaWQsVkJPKl0
%tmp_envptr1487 = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %environment1480, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %update_adhoc_W3ZvaWQsVkJPKl0Ptr, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %tmp_envptr1487


%val1496 = load {i8*, i8*, void (i8*, i8*, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %update_adhoc_W3ZvaWQsVkJPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VBO*)*}** %val1496
}


@update_adhoc_W3ZvaWQsVkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@update_adhoc_W3ZvaWQsVkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @update_adhoc_W3ZvaWQsVkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @update_adhoc_W3ZvaWQsVkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @update_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @update_adhoc_W3ZvaWQsVkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @update_adhoc_W3ZvaWQsVkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @update_adhoc_W3ZvaWQsVkJPKl0(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc void @update_adhoc_W3ZvaWQsVkJPKl0_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc i8*  @update_adhoc_W3ZvaWQsVkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1497 = bitcast [82 x i8]* @gsxtmgl-objects2114 to i8*
call i32 (i8*, ...) @printf(i8* %var1497)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @update_adhoc_W3ZvaWQsVkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%VAO = type {i32,[16 x i1],[16 x %VBO*]}
@gsxtmgl-objects2115 = hidden constant [49 x i8] c"VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ\00"
@gsxtmgl-objects2116 = hidden constant [62 x i8] c"{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**\00"
define dllexport fastcc %VAO* @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ__1498(i8* %_impz,i8* %_impenv, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1499 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}*
%VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}, {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}* %impenv, i32 0, i32 0
%VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**** %VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca [16 x i1]
store [16 x i1] %arg_1, [16 x i1]* %arg_1Ptr
%arg_2Ptr = alloca [16 x %VBO*]
store [16 x %VBO*] %arg_2, [16 x %VBO*]* %arg_2Ptr


%tzone1504 = load i8*, i8** %_impzPtr
%zone1505 = bitcast i8* %tzone1504 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VAO*
%tzone1500 = load i8*, i8** %_impzPtr
%zone1501 = bitcast i8* %tzone1500 to %mzone*
%dat1502 = call i8* @llvm_zone_malloc(%mzone* %zone1501, i64 152)
call i8* @memset(i8* %dat1502, i32 0, i64 152)
%val1503 = bitcast i8* %dat1502 to %VAO*

; let value assignment
%obj = select i1 true, %VAO* %val1503, %VAO* %val1503
store %VAO* %obj, %VAO** %objPtr

%val1506 = load %VAO*, %VAO** %objPtr
%val1507 = load i32, i32* %arg_0Ptr
; set tuple
%val1508 = getelementptr %VAO, %VAO* %val1506, i64 0, i32 0
store i32 %val1507, i32* %val1508
%val1509 = load %VAO*, %VAO** %objPtr
%val1510 = load [16 x i1], [16 x i1]* %arg_1Ptr
; set tuple
%val1511 = getelementptr %VAO, %VAO* %val1509, i64 0, i32 1
store [16 x i1] %val1510, [16 x i1]* %val1511
%val1512 = load %VAO*, %VAO** %objPtr
%val1513 = load [16 x %VBO*], [16 x %VBO*]* %arg_2Ptr
; set tuple
%val1514 = getelementptr %VAO, %VAO* %val1512, i64 0, i32 2
store [16 x %VBO*] %val1513, [16 x %VBO*]* %val1514
%val1515 = load %VAO*, %VAO** %objPtr
ret %VAO* %val1515
}
@gsxtmgl-objects2117 = hidden constant [102 x i8] c"VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1535 = load i8*, i8** %_impzPtr
%zone1536 = bitcast i8* %tzone1535 to %mzone*

; let assign value to symbol VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ
%dat_VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ = call i8* @llvm_zone_malloc(%mzone* %zone1536, i64 8)
%VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr = bitcast i8* %dat_VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ to { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***
%tzone1516 = load i8*, i8** %_impzPtr
%zone1517 = bitcast i8* %tzone1516 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1517)
; malloc closure structure
%clsptr1518 = call i8* @llvm_zone_malloc(%mzone* %zone1517, i64 24)
%closure1519 = bitcast i8* %clsptr1518 to { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*

; malloc environment structure
%envptr1520 = call i8* @llvm_zone_malloc(%mzone* %zone1517, i64 8)
%environment1521 = bitcast i8* %envptr1520 to {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}*

; malloc closure address table
%addytable1522 = call %clsvar* @new_address_table()
%var1523 = bitcast [49 x i8]* @gsxtmgl-objects2115 to i8*
%var1524 = bitcast [62 x i8]* @gsxtmgl-objects2116 to i8*
%addytable1525 = call %clsvar* @add_address_table(%mzone* %zone1517, i8* %var1523, i32 0, i8* %var1524, i32 3, %clsvar* %addytable1522)
%address-table1526 = bitcast %clsvar* %addytable1525 to i8*

; insert table, function and environment into closure struct
%closure.table1529 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1519, i32 0, i32 0
store i8* %address-table1526, i8** %closure.table1529
%closure.env1530 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1519, i32 0, i32 1
store i8* %envptr1520, i8** %closure.env1530
%closure.func1531 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1519, i32 0, i32 2
store %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])* @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ__1498, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %closure.func1531
%closure_size1532 = call i64 @llvm_zone_mark_size(%mzone* %zone1517)
call void @llvm_zone_ptr_set_size(i8* %clsptr1518, i64 %closure_size1532)
%wrapper_ptr1533 = call i8* @llvm_zone_malloc(%mzone* %zone1517, i64 8)
%closure_wrapper1534 = bitcast i8* %wrapper_ptr1533 to { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
store { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1519, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_wrapper1534

; let value assignment
%VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ = select i1 true, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_wrapper1534, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_wrapper1534
store { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*** %VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr

; add data to environment
; don't need to alloc for env var VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ
%tmp_envptr1528 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}, {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}* %environment1521, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*** %VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**** %tmp_envptr1528


%val1537 = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*** %VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr
ret {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %val1537
}


@VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ(i32 %arg_0,[16 x i1] %arg_1,[16 x %VBO*] %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*,  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2)
ret %VAO* %result
}


define dllexport ccc %VAO* @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_native(i32 %arg_0,[16 x i1] %arg_1,[16 x %VBO*] %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*,  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2)
ret %VAO* %result
}


define dllexport ccc void @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, [16 x i1], [16 x %VBO*]}*
%arg_p_0 = getelementptr {i32, [16 x i1], [16 x %VBO*]}, {i32, [16 x i1], [16 x %VBO*]}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, [16 x i1], [16 x %VBO*]}, {i32, [16 x i1], [16 x %VBO*]}* %fstruct, i32 0, i32 1
%arg_1 = load [16 x i1], [16 x i1]* %arg_p_1
%arg_p_2 = getelementptr {i32, [16 x i1], [16 x %VBO*]}, {i32, [16 x i1], [16 x %VBO*]}* %fstruct, i32 0, i32 2
%arg_2 = load [16 x %VBO*], [16 x %VBO*]* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*,  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2118 = hidden constant [51 x i8] c"VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ\00"
define dllexport fastcc %VAO* @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ__1539(i8* %_impz,i8* %_impenv, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1540 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}*
%VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}, {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}* %impenv, i32 0, i32 0
%VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**** %VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca [16 x i1]
store [16 x i1] %arg_1, [16 x i1]* %arg_1Ptr
%arg_2Ptr = alloca [16 x %VBO*]
store [16 x %VBO*] %arg_2, [16 x %VBO*]* %arg_2Ptr


%tzone1545 = load i8*, i8** %_impzPtr
%zone1546 = bitcast i8* %tzone1545 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VAO*
%tzone1541 = load i8*, i8** %_impzPtr
%zone1542 = bitcast i8* %tzone1541 to %mzone*
%dat1543 = call i8* @llvm_zone_malloc(%mzone* %zone1542, i64 152)
call i8* @memset(i8* %dat1543, i32 0, i64 152)
%val1544 = bitcast i8* %dat1543 to %VAO*

; let value assignment
%obj = select i1 true, %VAO* %val1544, %VAO* %val1544
store %VAO* %obj, %VAO** %objPtr

%val1547 = load %VAO*, %VAO** %objPtr
%val1548 = load i32, i32* %arg_0Ptr
; set tuple
%val1549 = getelementptr %VAO, %VAO* %val1547, i64 0, i32 0
store i32 %val1548, i32* %val1549
%val1550 = load %VAO*, %VAO** %objPtr
%val1551 = load [16 x i1], [16 x i1]* %arg_1Ptr
; set tuple
%val1552 = getelementptr %VAO, %VAO* %val1550, i64 0, i32 1
store [16 x i1] %val1551, [16 x i1]* %val1552
%val1553 = load %VAO*, %VAO** %objPtr
%val1554 = load [16 x %VBO*], [16 x %VBO*]* %arg_2Ptr
; set tuple
%val1555 = getelementptr %VAO, %VAO* %val1553, i64 0, i32 2
store [16 x %VBO*] %val1554, [16 x %VBO*]* %val1555
%val1556 = load %VAO*, %VAO** %objPtr
ret %VAO* %val1556
}
@gsxtmgl-objects2119 = hidden constant [104 x i8] c"VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1576 = load i8*, i8** %_impzPtr
%zone1577 = bitcast i8* %tzone1576 to %mzone*

; let assign value to symbol VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ
%dat_VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ = call i8* @llvm_zone_malloc(%mzone* %zone1577, i64 8)
%VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr = bitcast i8* %dat_VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ to { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***
%tzone1557 = load i8*, i8** %_impzPtr
%zone1558 = bitcast i8* %tzone1557 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1558)
; malloc closure structure
%clsptr1559 = call i8* @llvm_zone_malloc(%mzone* %zone1558, i64 24)
%closure1560 = bitcast i8* %clsptr1559 to { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*

; malloc environment structure
%envptr1561 = call i8* @llvm_zone_malloc(%mzone* %zone1558, i64 8)
%environment1562 = bitcast i8* %envptr1561 to {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}*

; malloc closure address table
%addytable1563 = call %clsvar* @new_address_table()
%var1564 = bitcast [51 x i8]* @gsxtmgl-objects2118 to i8*
%var1565 = bitcast [62 x i8]* @gsxtmgl-objects2116 to i8*
%addytable1566 = call %clsvar* @add_address_table(%mzone* %zone1558, i8* %var1564, i32 0, i8* %var1565, i32 3, %clsvar* %addytable1563)
%address-table1567 = bitcast %clsvar* %addytable1566 to i8*

; insert table, function and environment into closure struct
%closure.table1570 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1560, i32 0, i32 0
store i8* %address-table1567, i8** %closure.table1570
%closure.env1571 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1560, i32 0, i32 1
store i8* %envptr1561, i8** %closure.env1571
%closure.func1572 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1560, i32 0, i32 2
store %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])* @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ__1539, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %closure.func1572
%closure_size1573 = call i64 @llvm_zone_mark_size(%mzone* %zone1558)
call void @llvm_zone_ptr_set_size(i8* %clsptr1559, i64 %closure_size1573)
%wrapper_ptr1574 = call i8* @llvm_zone_malloc(%mzone* %zone1558, i64 8)
%closure_wrapper1575 = bitcast i8* %wrapper_ptr1574 to { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
store { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1560, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_wrapper1575

; let value assignment
%VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ = select i1 true, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_wrapper1575, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_wrapper1575
store { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*** %VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr

; add data to environment
; don't need to alloc for env var VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ
%tmp_envptr1569 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}, {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}* %environment1562, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*** %VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**** %tmp_envptr1569


%val1578 = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*** %VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr
ret {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %val1578
}


@VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ(i32 %arg_0,[16 x i1] %arg_1,[16 x %VBO*] %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*,  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2)
ret %VAO* %result
}


define dllexport ccc %VAO* @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_native(i32 %arg_0,[16 x i1] %arg_1,[16 x %VBO*] %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*,  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2)
ret %VAO* %result
}


define dllexport ccc void @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, [16 x i1], [16 x %VBO*]}*
%arg_p_0 = getelementptr {i32, [16 x i1], [16 x %VBO*]}, {i32, [16 x i1], [16 x %VBO*]}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, [16 x i1], [16 x %VBO*]}, {i32, [16 x i1], [16 x %VBO*]}* %fstruct, i32 0, i32 1
%arg_1 = load [16 x i1], [16 x i1]* %arg_p_1
%arg_p_2 = getelementptr {i32, [16 x i1], [16 x %VBO*]}, {i32, [16 x i1], [16 x %VBO*]}* %fstruct, i32 0, i32 2
%arg_2 = load [16 x %VBO*], [16 x %VBO*]* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*,  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2120 = hidden constant [51 x i8] c"VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ\00"
define dllexport fastcc %VAO* @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ__1580(i8* %_impz,i8* %_impenv, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1581 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}*
%VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}, {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}* %impenv, i32 0, i32 0
%VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**** %VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca [16 x i1]
store [16 x i1] %arg_1, [16 x i1]* %arg_1Ptr
%arg_2Ptr = alloca [16 x %VBO*]
store [16 x %VBO*] %arg_2, [16 x %VBO*]* %arg_2Ptr


%tzone1584 = load i8*, i8** %_impzPtr
%zone1585 = bitcast i8* %tzone1584 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VAO*
%dat1582 = call i8* @malloc(i64 152)
call i8* @memset(i8* %dat1582, i32 0, i64 152)
%val1583 = bitcast i8* %dat1582 to %VAO*

; let value assignment
%obj = select i1 true, %VAO* %val1583, %VAO* %val1583
store %VAO* %obj, %VAO** %objPtr

%val1586 = load %VAO*, %VAO** %objPtr
%val1587 = load i32, i32* %arg_0Ptr
; set tuple
%val1588 = getelementptr %VAO, %VAO* %val1586, i64 0, i32 0
store i32 %val1587, i32* %val1588
%val1589 = load %VAO*, %VAO** %objPtr
%val1590 = load [16 x i1], [16 x i1]* %arg_1Ptr
; set tuple
%val1591 = getelementptr %VAO, %VAO* %val1589, i64 0, i32 1
store [16 x i1] %val1590, [16 x i1]* %val1591
%val1592 = load %VAO*, %VAO** %objPtr
%val1593 = load [16 x %VBO*], [16 x %VBO*]* %arg_2Ptr
; set tuple
%val1594 = getelementptr %VAO, %VAO* %val1592, i64 0, i32 2
store [16 x %VBO*] %val1593, [16 x %VBO*]* %val1594
%val1595 = load %VAO*, %VAO** %objPtr
ret %VAO* %val1595
}
@gsxtmgl-objects2121 = hidden constant [104 x i8] c"VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1615 = load i8*, i8** %_impzPtr
%zone1616 = bitcast i8* %tzone1615 to %mzone*

; let assign value to symbol VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ
%dat_VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ = call i8* @llvm_zone_malloc(%mzone* %zone1616, i64 8)
%VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr = bitcast i8* %dat_VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ to { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***
%tzone1596 = load i8*, i8** %_impzPtr
%zone1597 = bitcast i8* %tzone1596 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1597)
; malloc closure structure
%clsptr1598 = call i8* @llvm_zone_malloc(%mzone* %zone1597, i64 24)
%closure1599 = bitcast i8* %clsptr1598 to { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*

; malloc environment structure
%envptr1600 = call i8* @llvm_zone_malloc(%mzone* %zone1597, i64 8)
%environment1601 = bitcast i8* %envptr1600 to {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}*

; malloc closure address table
%addytable1602 = call %clsvar* @new_address_table()
%var1603 = bitcast [51 x i8]* @gsxtmgl-objects2120 to i8*
%var1604 = bitcast [62 x i8]* @gsxtmgl-objects2116 to i8*
%addytable1605 = call %clsvar* @add_address_table(%mzone* %zone1597, i8* %var1603, i32 0, i8* %var1604, i32 3, %clsvar* %addytable1602)
%address-table1606 = bitcast %clsvar* %addytable1605 to i8*

; insert table, function and environment into closure struct
%closure.table1609 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1599, i32 0, i32 0
store i8* %address-table1606, i8** %closure.table1609
%closure.env1610 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1599, i32 0, i32 1
store i8* %envptr1600, i8** %closure.env1610
%closure.func1611 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1599, i32 0, i32 2
store %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])* @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ__1580, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %closure.func1611
%closure_size1612 = call i64 @llvm_zone_mark_size(%mzone* %zone1597)
call void @llvm_zone_ptr_set_size(i8* %clsptr1598, i64 %closure_size1612)
%wrapper_ptr1613 = call i8* @llvm_zone_malloc(%mzone* %zone1597, i64 8)
%closure_wrapper1614 = bitcast i8* %wrapper_ptr1613 to { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
store { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1599, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_wrapper1614

; let value assignment
%VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ = select i1 true, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_wrapper1614, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_wrapper1614
store { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ, { i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*** %VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr

; add data to environment
; don't need to alloc for env var VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ
%tmp_envptr1608 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}, {{i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}* %environment1601, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*** %VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**** %tmp_envptr1608


%val1617 = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*** %VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQPtr
ret {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %val1617
}


@VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ(i32 %arg_0,[16 x i1] %arg_1,[16 x %VBO*] %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*,  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2)
ret %VAO* %result
}


define dllexport ccc %VAO* @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_native(i32 %arg_0,[16 x i1] %arg_1,[16 x %VBO*] %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*,  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2)
ret %VAO* %result
}


define dllexport ccc void @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, [16 x i1], [16 x %VBO*]}*
%arg_p_0 = getelementptr {i32, [16 x i1], [16 x %VBO*]}, {i32, [16 x i1], [16 x %VBO*]}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, [16 x i1], [16 x %VBO*]}, {i32, [16 x i1], [16 x %VBO*]}* %fstruct, i32 0, i32 1
%arg_1 = load [16 x i1], [16 x i1]* %arg_p_1
%arg_p_2 = getelementptr {i32, [16 x i1], [16 x %VBO*]}, {i32, [16 x i1], [16 x %VBO*]}* %fstruct, i32 0, i32 2
%arg_2 = load [16 x %VBO*], [16 x %VBO*]* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyLHwxNixpMXwsfDE2LFZCTyp8XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*,  %VAO* (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2122 = hidden constant [51 x i8] c"VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd\00"
@gsxtmgl-objects2123 = hidden constant [61 x i8] c"{i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**\00"
define dllexport fastcc %VAO @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd__1619(i8* %_impz,i8* %_impenv, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1620 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}*
%VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxdPtr_ = getelementptr {{i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}, {{i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}* %impenv, i32 0, i32 0
%VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxdPtr = load {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***, {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**** %VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca [16 x i1]
store [16 x i1] %arg_1, [16 x i1]* %arg_1Ptr
%arg_2Ptr = alloca [16 x %VBO*]
store [16 x %VBO*] %arg_2, [16 x %VBO*]* %arg_2Ptr


%tzone1622 = load i8*, i8** %_impzPtr
%zone1623 = bitcast i8* %tzone1622 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VAO*
%dat1621 = alloca %VAO, align 16

; let value assignment
%obj = select i1 true, %VAO* %dat1621, %VAO* %dat1621
store %VAO* %obj, %VAO** %objPtr

%val1624 = load %VAO*, %VAO** %objPtr
%val1625 = load i32, i32* %arg_0Ptr
; set tuple
%val1626 = getelementptr %VAO, %VAO* %val1624, i64 0, i32 0
store i32 %val1625, i32* %val1626
%val1627 = load %VAO*, %VAO** %objPtr
%val1628 = load [16 x i1], [16 x i1]* %arg_1Ptr
; set tuple
%val1629 = getelementptr %VAO, %VAO* %val1627, i64 0, i32 1
store [16 x i1] %val1628, [16 x i1]* %val1629
%val1630 = load %VAO*, %VAO** %objPtr
%val1631 = load [16 x %VBO*], [16 x %VBO*]* %arg_2Ptr
; set tuple
%val1632 = getelementptr %VAO, %VAO* %val1630, i64 0, i32 2
store [16 x %VBO*] %val1631, [16 x %VBO*]* %val1632
%val1633 = load %VAO*, %VAO** %objPtr
; pointer ref
%val1634 = getelementptr %VAO, %VAO* %val1633, i64 0
%val1635 = load %VAO, %VAO* %val1634
ret %VAO %val1635
}
@gsxtmgl-objects2124 = hidden constant [104 x i8] c"VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1655 = load i8*, i8** %_impzPtr
%zone1656 = bitcast i8* %tzone1655 to %mzone*

; let assign value to symbol VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd
%dat_VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd = call i8* @llvm_zone_malloc(%mzone* %zone1656, i64 8)
%VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxdPtr = bitcast i8* %dat_VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd to { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***
%tzone1636 = load i8*, i8** %_impzPtr
%zone1637 = bitcast i8* %tzone1636 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1637)
; malloc closure structure
%clsptr1638 = call i8* @llvm_zone_malloc(%mzone* %zone1637, i64 24)
%closure1639 = bitcast i8* %clsptr1638 to { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*

; malloc environment structure
%envptr1640 = call i8* @llvm_zone_malloc(%mzone* %zone1637, i64 8)
%environment1641 = bitcast i8* %envptr1640 to {{i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}*

; malloc closure address table
%addytable1642 = call %clsvar* @new_address_table()
%var1643 = bitcast [51 x i8]* @gsxtmgl-objects2122 to i8*
%var1644 = bitcast [61 x i8]* @gsxtmgl-objects2123 to i8*
%addytable1645 = call %clsvar* @add_address_table(%mzone* %zone1637, i8* %var1643, i32 0, i8* %var1644, i32 3, %clsvar* %addytable1642)
%address-table1646 = bitcast %clsvar* %addytable1645 to i8*

; insert table, function and environment into closure struct
%closure.table1649 = getelementptr { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1639, i32 0, i32 0
store i8* %address-table1646, i8** %closure.table1649
%closure.env1650 = getelementptr { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1639, i32 0, i32 1
store i8* %envptr1640, i8** %closure.env1650
%closure.func1651 = getelementptr { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1639, i32 0, i32 2
store %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])* @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd__1619, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %closure.func1651
%closure_size1652 = call i64 @llvm_zone_mark_size(%mzone* %zone1637)
call void @llvm_zone_ptr_set_size(i8* %clsptr1638, i64 %closure_size1652)
%wrapper_ptr1653 = call i8* @llvm_zone_malloc(%mzone* %zone1637, i64 8)
%closure_wrapper1654 = bitcast i8* %wrapper_ptr1653 to { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
store { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure1639, { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_wrapper1654

; let value assignment
%VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd = select i1 true, { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_wrapper1654, { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_wrapper1654
store { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd, { i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*** %VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxdPtr

; add data to environment
; don't need to alloc for env var VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd
%tmp_envptr1648 = getelementptr {{i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}, {{i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}***}* %environment1641, i32 0, i32 0
store {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*** %VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxdPtr, {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**** %tmp_envptr1648


%val1657 = load {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**, {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*** %VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxdPtr
ret {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %val1657
}


@VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd(i32 %arg_0,[16 x i1] %arg_1,[16 x %VBO*] %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
%closure = load {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*, {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 1
%ff = load  %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*,  %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO %ff(i8* %_impz, i8* %ee, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2)
ret %VAO %result
}


define dllexport ccc %VAO @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_native(i32 %arg_0,[16 x i1] %arg_1,[16 x %VBO*] %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
%closure = load {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*, {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 1
%ff = load  %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*,  %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO %ff(i8* %_impz, i8* %ee, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2)
ret %VAO %result
}


define dllexport ccc void @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, [16 x i1], [16 x %VBO*]}*
%arg_p_0 = getelementptr {i32, [16 x i1], [16 x %VBO*]}, {i32, [16 x i1], [16 x %VBO*]}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, [16 x i1], [16 x %VBO*]}, {i32, [16 x i1], [16 x %VBO*]}* %fstruct, i32 0, i32 1
%arg_1 = load [16 x i1], [16 x i1]* %arg_p_1
%arg_p_2 = getelementptr {i32, [16 x i1], [16 x %VBO*]}, {i32, [16 x i1], [16 x %VBO*]}* %fstruct, i32 0, i32 2
%arg_2 = load [16 x %VBO*], [16 x %VBO*]* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_val_adhoc_W1ZBTyxpMzIsfDE2LGkxfCx8MTYsVkJPKnxd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}**
%closure = load {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}*, {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}, {i8*, i8*, %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*}* %closure, i32 0, i32 1
%ff = load  %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])*,  %VAO (i8*, i8*, i32, [16 x i1], [16 x %VBO*])** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO %ff(i8* %_impz, i8* %ee, i32 %arg_0, [16 x i1] %arg_1, [16 x %VBO*] %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2125 = hidden constant [28 x i8] c"hcopy_adhoc_W1ZBTyosVkFPKl0\00"
@gsxtmgl-objects2126 = hidden constant [39 x i8] c"{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**\00"
define dllexport fastcc %VAO* @hcopy_adhoc_W1ZBTyosVkFPKl0__1659(i8* %_impz,i8* %_impenv, %VAO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1660 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***}*
%hcopy_adhoc_W1ZBTyosVkFPKl0Ptr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1ZBTyosVkFPKl0Ptr = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**** %hcopy_adhoc_W1ZBTyosVkFPKl0Ptr_

; setup arguments
%xPtr = alloca %VAO*
store %VAO* %x, %VAO** %xPtr


%tzone1663 = load i8*, i8** %_impzPtr
%zone1664 = bitcast i8* %tzone1663 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VAO*
%dat1661 = call i8* @malloc(i64 152)
call i8* @memset(i8* %dat1661, i32 0, i64 152)
%val1662 = bitcast i8* %dat1661 to %VAO*

; let value assignment
%obj = select i1 true, %VAO* %val1662, %VAO* %val1662
store %VAO* %obj, %VAO** %objPtr

%val1665 = load %VAO*, %VAO** %objPtr
%val1666 = load %VAO*, %VAO** %xPtr
; tuple ref
%val1667 = getelementptr %VAO, %VAO* %val1666, i64 0, i32 0
%val1668 = load i32, i32* %val1667
; set tuple
%val1669 = getelementptr %VAO, %VAO* %val1665, i64 0, i32 0
store i32 %val1668, i32* %val1669
%val1670 = load %VAO*, %VAO** %objPtr
%val1671 = load %VAO*, %VAO** %xPtr
; tuple ref
%val1672 = getelementptr %VAO, %VAO* %val1671, i64 0, i32 1
%val1673 = load [16 x i1], [16 x i1]* %val1672
; set tuple
%val1674 = getelementptr %VAO, %VAO* %val1670, i64 0, i32 1
store [16 x i1] %val1673, [16 x i1]* %val1674
%val1675 = load %VAO*, %VAO** %objPtr
%val1676 = load %VAO*, %VAO** %xPtr
; tuple ref
%val1677 = getelementptr %VAO, %VAO* %val1676, i64 0, i32 2
%val1678 = load [16 x %VBO*], [16 x %VBO*]* %val1677
; set tuple
%val1679 = getelementptr %VAO, %VAO* %val1675, i64 0, i32 2
store [16 x %VBO*] %val1678, [16 x %VBO*]* %val1679
%val1680 = load %VAO*, %VAO** %objPtr
ret %VAO* %val1680
}
@gsxtmgl-objects2127 = hidden constant [81 x i8] c"hcopy_adhoc_W1ZBTyosVkFPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** @hcopy_adhoc_W1ZBTyosVkFPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1700 = load i8*, i8** %_impzPtr
%zone1701 = bitcast i8* %tzone1700 to %mzone*

; let assign value to symbol hcopy_adhoc_W1ZBTyosVkFPKl0
%dat_hcopy_adhoc_W1ZBTyosVkFPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1701, i64 8)
%hcopy_adhoc_W1ZBTyosVkFPKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1ZBTyosVkFPKl0 to { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***
%tzone1681 = load i8*, i8** %_impzPtr
%zone1682 = bitcast i8* %tzone1681 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1682)
; malloc closure structure
%clsptr1683 = call i8* @llvm_zone_malloc(%mzone* %zone1682, i64 24)
%closure1684 = bitcast i8* %clsptr1683 to { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr1685 = call i8* @llvm_zone_malloc(%mzone* %zone1682, i64 8)
%environment1686 = bitcast i8* %envptr1685 to {{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable1687 = call %clsvar* @new_address_table()
%var1688 = bitcast [28 x i8]* @gsxtmgl-objects2125 to i8*
%var1689 = bitcast [39 x i8]* @gsxtmgl-objects2126 to i8*
%addytable1690 = call %clsvar* @add_address_table(%mzone* %zone1682, i8* %var1688, i32 0, i8* %var1689, i32 3, %clsvar* %addytable1687)
%address-table1691 = bitcast %clsvar* %addytable1690 to i8*

; insert table, function and environment into closure struct
%closure.table1694 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure1684, i32 0, i32 0
store i8* %address-table1691, i8** %closure.table1694
%closure.env1695 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure1684, i32 0, i32 1
store i8* %envptr1685, i8** %closure.env1695
%closure.func1696 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure1684, i32 0, i32 2
store %VAO* (i8*, i8*, %VAO*)* @hcopy_adhoc_W1ZBTyosVkFPKl0__1659, %VAO* (i8*, i8*, %VAO*)** %closure.func1696
%closure_size1697 = call i64 @llvm_zone_mark_size(%mzone* %zone1682)
call void @llvm_zone_ptr_set_size(i8* %clsptr1683, i64 %closure_size1697)
%wrapper_ptr1698 = call i8* @llvm_zone_malloc(%mzone* %zone1682, i64 8)
%closure_wrapper1699 = bitcast i8* %wrapper_ptr1698 to { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**
store { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure1684, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_wrapper1699

; let value assignment
%hcopy_adhoc_W1ZBTyosVkFPKl0 = select i1 true, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_wrapper1699, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_wrapper1699
store { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %hcopy_adhoc_W1ZBTyosVkFPKl0, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*** %hcopy_adhoc_W1ZBTyosVkFPKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1ZBTyosVkFPKl0
%tmp_envptr1693 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***}* %environment1686, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*** %hcopy_adhoc_W1ZBTyosVkFPKl0Ptr, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**** %tmp_envptr1693


%val1702 = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*** %hcopy_adhoc_W1ZBTyosVkFPKl0Ptr
ret {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %val1702
}


@hcopy_adhoc_W1ZBTyosVkFPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1ZBTyosVkFPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1ZBTyosVkFPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** @hcopy_adhoc_W1ZBTyosVkFPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1ZBTyosVkFPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @hcopy_adhoc_W1ZBTyosVkFPKl0(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*)*,  %VAO* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret %VAO* %result
}


define dllexport ccc %VAO* @hcopy_adhoc_W1ZBTyosVkFPKl0_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*)*,  %VAO* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret %VAO* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1ZBTyosVkFPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1703 = bitcast [81 x i8]* @gsxtmgl-objects2127 to i8*
call i32 (i8*, ...) @printf(i8* %var1703)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*)*,  %VAO* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%tmpres = bitcast %VAO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1ZBTyosVkFPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*)*,  %VAO* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2128 = hidden constant [28 x i8] c"hfree_adhoc_W3ZvaWQsVkFPKl0\00"
@gsxtmgl-objects2129 = hidden constant [38 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsVkFPKl0__1704(i8* %_impz,i8* %_impenv, %VAO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1705 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}*
%hfree_adhoc_W3ZvaWQsVkFPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsVkFPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %VAO*)*}***, {i8*, i8*, void (i8*, i8*, %VAO*)*}**** %hfree_adhoc_W3ZvaWQsVkFPKl0Ptr_

; setup arguments
%xPtr = alloca %VAO*
store %VAO* %x, %VAO** %xPtr


%val1706 = load %VAO*, %VAO** %xPtr
%val1707 = bitcast %VAO* %val1706 to i8*
call ccc void @free(i8* %val1707)
ret void
}
@gsxtmgl-objects2130 = hidden constant [81 x i8] c"hfree_adhoc_W3ZvaWQsVkFPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*)*}** @hfree_adhoc_W3ZvaWQsVkFPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1729 = load i8*, i8** %_impzPtr
%zone1730 = bitcast i8* %tzone1729 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsVkFPKl0
%dat_hfree_adhoc_W3ZvaWQsVkFPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1730, i64 8)
%hfree_adhoc_W3ZvaWQsVkFPKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsVkFPKl0 to { i8*, i8*, void (i8*, i8*, %VAO*)*}***
%tzone1710 = load i8*, i8** %_impzPtr
%zone1711 = bitcast i8* %tzone1710 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1711)
; malloc closure structure
%clsptr1712 = call i8* @llvm_zone_malloc(%mzone* %zone1711, i64 24)
%closure1713 = bitcast i8* %clsptr1712 to { i8*, i8*, void (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr1714 = call i8* @llvm_zone_malloc(%mzone* %zone1711, i64 8)
%environment1715 = bitcast i8* %envptr1714 to {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable1716 = call %clsvar* @new_address_table()
%var1717 = bitcast [28 x i8]* @gsxtmgl-objects2128 to i8*
%var1718 = bitcast [38 x i8]* @gsxtmgl-objects2129 to i8*
%addytable1719 = call %clsvar* @add_address_table(%mzone* %zone1711, i8* %var1717, i32 0, i8* %var1718, i32 3, %clsvar* %addytable1716)
%address-table1720 = bitcast %clsvar* %addytable1719 to i8*

; insert table, function and environment into closure struct
%closure.table1723 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1713, i32 0, i32 0
store i8* %address-table1720, i8** %closure.table1723
%closure.env1724 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1713, i32 0, i32 1
store i8* %envptr1714, i8** %closure.env1724
%closure.func1725 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1713, i32 0, i32 2
store void (i8*, i8*, %VAO*)* @hfree_adhoc_W3ZvaWQsVkFPKl0__1704, void (i8*, i8*, %VAO*)** %closure.func1725
%closure_size1726 = call i64 @llvm_zone_mark_size(%mzone* %zone1711)
call void @llvm_zone_ptr_set_size(i8* %clsptr1712, i64 %closure_size1726)
%wrapper_ptr1727 = call i8* @llvm_zone_malloc(%mzone* %zone1711, i64 8)
%closure_wrapper1728 = bitcast i8* %wrapper_ptr1727 to { i8*, i8*, void (i8*, i8*, %VAO*)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1713, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper1728

; let value assignment
%hfree_adhoc_W3ZvaWQsVkFPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper1728, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper1728
store { i8*, i8*, void (i8*, i8*, %VAO*)*}** %hfree_adhoc_W3ZvaWQsVkFPKl0, { i8*, i8*, void (i8*, i8*, %VAO*)*}*** %hfree_adhoc_W3ZvaWQsVkFPKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsVkFPKl0
%tmp_envptr1722 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}* %environment1715, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*)*}*** %hfree_adhoc_W3ZvaWQsVkFPKl0Ptr, {i8*, i8*, void (i8*, i8*, %VAO*)*}**** %tmp_envptr1722


%val1731 = load {i8*, i8*, void (i8*, i8*, %VAO*)*}**, {i8*, i8*, void (i8*, i8*, %VAO*)*}*** %hfree_adhoc_W3ZvaWQsVkFPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VAO*)*}** %val1731
}


@hfree_adhoc_W3ZvaWQsVkFPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsVkFPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsVkFPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*)*}** @hfree_adhoc_W3ZvaWQsVkFPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsVkFPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsVkFPKl0(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsVkFPKl0_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsVkFPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1732 = bitcast [81 x i8]* @gsxtmgl-objects2130 to i8*
call i32 (i8*, ...) @printf(i8* %var1732)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsVkFPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2131 = hidden constant [47 x i8] c"zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmgl-objects2132 = hidden constant [57 x i8] c"{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %VAO* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ__1733(i8* %_impz,i8* %_impenv, %VAO* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1734 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %VAO*
store %VAO* %x, %VAO** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val1736 = load %mzone*, %mzone** %fromzPtr
%val1737 = load %VAO*, %VAO** %xPtr
%val1738 = bitcast %VAO* %val1737 to i8*
%res1739 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1736, i8* %val1738)
br i1 %res1739, label %then1735, label %else1735

then1735:
%val1740 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val1740)
%zone_ptr1741 = bitcast %mzone* %val1740 to i8*
store i8* %zone_ptr1741, i8** %_impzPtr
%tzone1747 = load i8*, i8** %_impzPtr
%zone1748 = bitcast i8* %tzone1747 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VAO*
%tzone1743 = load i8*, i8** %_impzPtr
%zone1744 = bitcast i8* %tzone1743 to %mzone*
%dat1745 = call i8* @llvm_zone_malloc(%mzone* %zone1744, i64 152)
call i8* @memset(i8* %dat1745, i32 0, i64 152)
%val1746 = bitcast i8* %dat1745 to %VAO*

; let value assignment
%obj = select i1 true, %VAO* %val1746, %VAO* %val1746
store %VAO* %obj, %VAO** %objPtr

%val1749 = load %VAO*, %VAO** %objPtr
%val1750 = load %VAO*, %VAO** %xPtr
; tuple ref
%val1751 = getelementptr %VAO, %VAO* %val1750, i64 0, i32 0
%val1752 = load i32, i32* %val1751
; set tuple
%val1753 = getelementptr %VAO, %VAO* %val1749, i64 0, i32 0
store i32 %val1752, i32* %val1753
%val1754 = load %VAO*, %VAO** %objPtr
%val1755 = load %VAO*, %VAO** %xPtr
; tuple ref
%val1756 = getelementptr %VAO, %VAO* %val1755, i64 0, i32 1
%val1757 = load [16 x i1], [16 x i1]* %val1756
; set tuple
%val1758 = getelementptr %VAO, %VAO* %val1754, i64 0, i32 1
store [16 x i1] %val1757, [16 x i1]* %val1758
%val1759 = load %VAO*, %VAO** %objPtr
%val1760 = load %VAO*, %VAO** %xPtr
; tuple ref
%val1761 = getelementptr %VAO, %VAO* %val1760, i64 0, i32 2
%val1762 = load [16 x %VBO*], [16 x %VBO*]* %val1761
; set tuple
%val1763 = getelementptr %VAO, %VAO* %val1759, i64 0, i32 2
store [16 x %VBO*] %val1762, [16 x %VBO*]* %val1763
%oldzone1764 = call %mzone* @llvm_pop_zone_stack()
%newzone1765 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1766 = bitcast %mzone* %newzone1765 to i8*
store i8* %zone_ptr1766, i8** %_impzPtr
%val1767 = load %VAO*, %VAO** %objPtr
ret %VAO* %val1767

else1735:
%val1768 = load %VAO*, %VAO** %xPtr
ret %VAO* %val1768
}
@gsxtmgl-objects2133 = hidden constant [100 x i8] c"zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1788 = load i8*, i8** %_impzPtr
%zone1789 = bitcast i8* %tzone1788 to %mzone*

; let assign value to symbol zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1789, i64 8)
%zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***
%tzone1769 = load i8*, i8** %_impzPtr
%zone1770 = bitcast i8* %tzone1769 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1770)
; malloc closure structure
%clsptr1771 = call i8* @llvm_zone_malloc(%mzone* %zone1770, i64 24)
%closure1772 = bitcast i8* %clsptr1771 to { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr1773 = call i8* @llvm_zone_malloc(%mzone* %zone1770, i64 8)
%environment1774 = bitcast i8* %envptr1773 to {{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable1775 = call %clsvar* @new_address_table()
%var1776 = bitcast [47 x i8]* @gsxtmgl-objects2131 to i8*
%var1777 = bitcast [57 x i8]* @gsxtmgl-objects2132 to i8*
%addytable1778 = call %clsvar* @add_address_table(%mzone* %zone1770, i8* %var1776, i32 0, i8* %var1777, i32 3, %clsvar* %addytable1775)
%address-table1779 = bitcast %clsvar* %addytable1778 to i8*

; insert table, function and environment into closure struct
%closure.table1782 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure1772, i32 0, i32 0
store i8* %address-table1779, i8** %closure.table1782
%closure.env1783 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure1772, i32 0, i32 1
store i8* %envptr1773, i8** %closure.env1783
%closure.func1784 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure1772, i32 0, i32 2
store %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ__1733, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)** %closure.func1784
%closure_size1785 = call i64 @llvm_zone_mark_size(%mzone* %zone1770)
call void @llvm_zone_ptr_set_size(i8* %clsptr1771, i64 %closure_size1785)
%wrapper_ptr1786 = call i8* @llvm_zone_malloc(%mzone* %zone1770, i64 8)
%closure_wrapper1787 = bitcast i8* %wrapper_ptr1786 to { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**
store { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure1772, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_wrapper1787

; let value assignment
%zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_wrapper1787, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_wrapper1787
store { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ
%tmp_envptr1781 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***}* %environment1774, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**** %tmp_envptr1781


%val1790 = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %val1790
}


@zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ(%VAO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*,  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %VAO* %result
}


define dllexport ccc %VAO* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_native(%VAO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*,  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %VAO* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1791 = bitcast [100 x i8]* @gsxtmgl-objects2133 to i8*
call i32 (i8*, ...) @printf(i8* %var1791)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1792 = bitcast [100 x i8]* @gsxtmgl-objects2133 to i8*
call i32 (i8*, ...) @printf(i8* %var1792)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1793 = bitcast [100 x i8]* @gsxtmgl-objects2133 to i8*
call i32 (i8*, ...) @printf(i8* %var1793)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*,  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %VAO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%VAO*, %mzone*, %mzone*}, {%VAO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, %mzone*, %mzone*}, {%VAO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, %mzone*, %mzone*}, {%VAO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*,  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@VAO_NULL_ATTRIBS = dllexport global [16 x i1]*zeroinitializer
@VAO_NULL_VBOS = dllexport global [16 x %VBO*]*zeroinitializer
@gsxtmgl-objects2134 = hidden constant [24 x i8] c"id_adhoc_W2kzMixWQU8qXQ\00"
@gsxtmgl-objects2135 = hidden constant [37 x i8] c"{i8*, i8*, i32 (i8*, i8*, %VAO*)*}**\00"
define dllexport fastcc i32 @id_adhoc_W2kzMixWQU8qXQ__1794(i8* %_impz,i8* %_impenv, %VAO* %vao) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1795 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %VAO*)*}***}*
%id_adhoc_W2kzMixWQU8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%id_adhoc_W2kzMixWQU8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %VAO*)*}***, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**** %id_adhoc_W2kzMixWQU8qXQPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr


%val1797 = load %VAO*, %VAO** %vaoPtr
%val1798 = icmp eq %VAO* %val1797, null
br i1 %val1798, label %then1796, label %else1796

then1796:
ret i32 -1

else1796:
%val1799 = load %VAO*, %VAO** %vaoPtr
; tuple ref
%val1800 = getelementptr %VAO, %VAO* %val1799, i64 0, i32 0
%val1801 = load i32, i32* %val1800
ret i32 %val1801
}
@gsxtmgl-objects2136 = hidden constant [77 x i8] c"id_adhoc_W2kzMixWQU8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** @id_adhoc_W2kzMixWQU8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1821 = load i8*, i8** %_impzPtr
%zone1822 = bitcast i8* %tzone1821 to %mzone*

; let assign value to symbol id_adhoc_W2kzMixWQU8qXQ
%dat_id_adhoc_W2kzMixWQU8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone1822, i64 8)
%id_adhoc_W2kzMixWQU8qXQPtr = bitcast i8* %dat_id_adhoc_W2kzMixWQU8qXQ to { i8*, i8*, i32 (i8*, i8*, %VAO*)*}***
%tzone1802 = load i8*, i8** %_impzPtr
%zone1803 = bitcast i8* %tzone1802 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1803)
; malloc closure structure
%clsptr1804 = call i8* @llvm_zone_malloc(%mzone* %zone1803, i64 24)
%closure1805 = bitcast i8* %clsptr1804 to { i8*, i8*, i32 (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr1806 = call i8* @llvm_zone_malloc(%mzone* %zone1803, i64 8)
%environment1807 = bitcast i8* %envptr1806 to {{i8*, i8*, i32 (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable1808 = call %clsvar* @new_address_table()
%var1809 = bitcast [24 x i8]* @gsxtmgl-objects2134 to i8*
%var1810 = bitcast [37 x i8]* @gsxtmgl-objects2135 to i8*
%addytable1811 = call %clsvar* @add_address_table(%mzone* %zone1803, i8* %var1809, i32 0, i8* %var1810, i32 3, %clsvar* %addytable1808)
%address-table1812 = bitcast %clsvar* %addytable1811 to i8*

; insert table, function and environment into closure struct
%closure.table1815 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VAO*)*}, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure1805, i32 0, i32 0
store i8* %address-table1812, i8** %closure.table1815
%closure.env1816 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VAO*)*}, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure1805, i32 0, i32 1
store i8* %envptr1806, i8** %closure.env1816
%closure.func1817 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VAO*)*}, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure1805, i32 0, i32 2
store i32 (i8*, i8*, %VAO*)* @id_adhoc_W2kzMixWQU8qXQ__1794, i32 (i8*, i8*, %VAO*)** %closure.func1817
%closure_size1818 = call i64 @llvm_zone_mark_size(%mzone* %zone1803)
call void @llvm_zone_ptr_set_size(i8* %clsptr1804, i64 %closure_size1818)
%wrapper_ptr1819 = call i8* @llvm_zone_malloc(%mzone* %zone1803, i64 8)
%closure_wrapper1820 = bitcast i8* %wrapper_ptr1819 to { i8*, i8*, i32 (i8*, i8*, %VAO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure1805, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_wrapper1820

; let value assignment
%id_adhoc_W2kzMixWQU8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_wrapper1820, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_wrapper1820
store { i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %id_adhoc_W2kzMixWQU8qXQ, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}*** %id_adhoc_W2kzMixWQU8qXQPtr

; add data to environment
; don't need to alloc for env var id_adhoc_W2kzMixWQU8qXQ
%tmp_envptr1814 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %VAO*)*}***}* %environment1807, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %VAO*)*}*** %id_adhoc_W2kzMixWQU8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**** %tmp_envptr1814


%val1823 = load {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}*** %id_adhoc_W2kzMixWQU8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %val1823
}


@id_adhoc_W2kzMixWQU8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@id_adhoc_W2kzMixWQU8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @id_adhoc_W2kzMixWQU8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixWQU8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** @id_adhoc_W2kzMixWQU8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @id_adhoc_W2kzMixWQU8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @id_adhoc_W2kzMixWQU8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixWQU8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @id_adhoc_W2kzMixWQU8qXQ(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixWQU8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VAO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VAO*)*,  i32 (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @id_adhoc_W2kzMixWQU8qXQ_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixWQU8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VAO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VAO*)*,  i32 (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @id_adhoc_W2kzMixWQU8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1824 = bitcast [77 x i8]* @gsxtmgl-objects2136 to i8*
call i32 (i8*, ...) @printf(i8* %var1824)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixWQU8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VAO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VAO*)*,  i32 (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @id_adhoc_W2kzMixWQU8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixWQU8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VAO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VAO*)*,  i32 (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2137 = hidden constant [35 x i8] c"attribs_adhoc_W3wxNixpMXwqLFZBTypd\00"
@gsxtmgl-objects2138 = hidden constant [44 x i8] c"{i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}**\00"
define dllexport fastcc [16 x i1]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd__1825(i8* %_impz,i8* %_impenv, %VAO* %vao) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1826 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}***}*
%attribs_adhoc_W3wxNixpMXwqLFZBTypdPtr_ = getelementptr {{i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%attribs_adhoc_W3wxNixpMXwqLFZBTypdPtr = load {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}***, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}**** %attribs_adhoc_W3wxNixpMXwqLFZBTypdPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr


%val1828 = load %VAO*, %VAO** %vaoPtr
%val1829 = icmp eq %VAO* %val1828, null
br i1 %val1829, label %then1827, label %else1827

then1827:
%val1830 = load [16 x i1]*, [16 x i1]** @VAO_NULL_ATTRIBS
ret [16 x i1]* %val1830

else1827:
%val1831 = load %VAO*, %VAO** %vaoPtr
; tuple ref
%val1832 = getelementptr %VAO, %VAO* %val1831, i64 0, i32 1
ret [16 x i1]* %val1832
}
@gsxtmgl-objects2139 = hidden constant [88 x i8] c"attribs_adhoc_W3wxNixpMXwqLFZBTypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}** @attribs_adhoc_W3wxNixpMXwqLFZBTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1852 = load i8*, i8** %_impzPtr
%zone1853 = bitcast i8* %tzone1852 to %mzone*

; let assign value to symbol attribs_adhoc_W3wxNixpMXwqLFZBTypd
%dat_attribs_adhoc_W3wxNixpMXwqLFZBTypd = call i8* @llvm_zone_malloc(%mzone* %zone1853, i64 8)
%attribs_adhoc_W3wxNixpMXwqLFZBTypdPtr = bitcast i8* %dat_attribs_adhoc_W3wxNixpMXwqLFZBTypd to { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}***
%tzone1833 = load i8*, i8** %_impzPtr
%zone1834 = bitcast i8* %tzone1833 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1834)
; malloc closure structure
%clsptr1835 = call i8* @llvm_zone_malloc(%mzone* %zone1834, i64 24)
%closure1836 = bitcast i8* %clsptr1835 to { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr1837 = call i8* @llvm_zone_malloc(%mzone* %zone1834, i64 8)
%environment1838 = bitcast i8* %envptr1837 to {{i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable1839 = call %clsvar* @new_address_table()
%var1840 = bitcast [35 x i8]* @gsxtmgl-objects2137 to i8*
%var1841 = bitcast [44 x i8]* @gsxtmgl-objects2138 to i8*
%addytable1842 = call %clsvar* @add_address_table(%mzone* %zone1834, i8* %var1840, i32 0, i8* %var1841, i32 3, %clsvar* %addytable1839)
%address-table1843 = bitcast %clsvar* %addytable1842 to i8*

; insert table, function and environment into closure struct
%closure.table1846 = getelementptr { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}, { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}* %closure1836, i32 0, i32 0
store i8* %address-table1843, i8** %closure.table1846
%closure.env1847 = getelementptr { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}, { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}* %closure1836, i32 0, i32 1
store i8* %envptr1837, i8** %closure.env1847
%closure.func1848 = getelementptr { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}, { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}* %closure1836, i32 0, i32 2
store [16 x i1]* (i8*, i8*, %VAO*)* @attribs_adhoc_W3wxNixpMXwqLFZBTypd__1825, [16 x i1]* (i8*, i8*, %VAO*)** %closure.func1848
%closure_size1849 = call i64 @llvm_zone_mark_size(%mzone* %zone1834)
call void @llvm_zone_ptr_set_size(i8* %clsptr1835, i64 %closure_size1849)
%wrapper_ptr1850 = call i8* @llvm_zone_malloc(%mzone* %zone1834, i64 8)
%closure_wrapper1851 = bitcast i8* %wrapper_ptr1850 to { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}**
store { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}* %closure1836, { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}** %closure_wrapper1851

; let value assignment
%attribs_adhoc_W3wxNixpMXwqLFZBTypd = select i1 true, { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}** %closure_wrapper1851, { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}** %closure_wrapper1851
store { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}** %attribs_adhoc_W3wxNixpMXwqLFZBTypd, { i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}*** %attribs_adhoc_W3wxNixpMXwqLFZBTypdPtr

; add data to environment
; don't need to alloc for env var attribs_adhoc_W3wxNixpMXwqLFZBTypd
%tmp_envptr1845 = getelementptr {{i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}***}* %environment1838, i32 0, i32 0
store {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}*** %attribs_adhoc_W3wxNixpMXwqLFZBTypdPtr, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}**** %tmp_envptr1845


%val1854 = load {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}**, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}*** %attribs_adhoc_W3wxNixpMXwqLFZBTypdPtr
ret {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}** %val1854
}


@attribs_adhoc_W3wxNixpMXwqLFZBTypd_var = dllexport global [1 x i8*] [ i8* null ]

@attribs_adhoc_W3wxNixpMXwqLFZBTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @attribs_adhoc_W3wxNixpMXwqLFZBTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}** @attribs_adhoc_W3wxNixpMXwqLFZBTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @attribs_adhoc_W3wxNixpMXwqLFZBTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc [16 x i1]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}*, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  [16 x i1]* (i8*, i8*, %VAO*)*,  [16 x i1]* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc [16 x i1]* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret [16 x i1]* %result
}


define dllexport ccc [16 x i1]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}*, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  [16 x i1]* (i8*, i8*, %VAO*)*,  [16 x i1]* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc [16 x i1]* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret [16 x i1]* %result
}


define dllexport ccc i8*  @attribs_adhoc_W3wxNixpMXwqLFZBTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1855 = bitcast [88 x i8]* @gsxtmgl-objects2139 to i8*
call i32 (i8*, ...) @printf(i8* %var1855)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}*, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  [16 x i1]* (i8*, i8*, %VAO*)*,  [16 x i1]* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc [16 x i1]* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%tmpres = bitcast [16 x i1]* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @attribs_adhoc_W3wxNixpMXwqLFZBTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}*, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x i1]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  [16 x i1]* (i8*, i8*, %VAO*)*,  [16 x i1]* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc [16 x i1]* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2140 = hidden constant [38 x i8] c"buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0\00"
@gsxtmgl-objects2141 = hidden constant [47 x i8] c"{i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}**\00"
define dllexport fastcc [16 x %VBO*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0__1856(i8* %_impz,i8* %_impenv, %VAO* %vao) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1857 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}***}*
%buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0Ptr_ = getelementptr {{i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0Ptr = load {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}***, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}**** %buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0Ptr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr


%val1859 = load %VAO*, %VAO** %vaoPtr
%val1860 = icmp eq %VAO* %val1859, null
br i1 %val1860, label %then1858, label %else1858

then1858:
%val1861 = load [16 x %VBO*]*, [16 x %VBO*]** @VAO_NULL_VBOS
ret [16 x %VBO*]* %val1861

else1858:
%val1862 = load %VAO*, %VAO** %vaoPtr
; tuple ref
%val1863 = getelementptr %VAO, %VAO* %val1862, i64 0, i32 2
ret [16 x %VBO*]* %val1863
}
@gsxtmgl-objects2142 = hidden constant [91 x i8] c"buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}** @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1883 = load i8*, i8** %_impzPtr
%zone1884 = bitcast i8* %tzone1883 to %mzone*

; let assign value to symbol buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0
%dat_buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1884, i64 8)
%buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0Ptr = bitcast i8* %dat_buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0 to { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}***
%tzone1864 = load i8*, i8** %_impzPtr
%zone1865 = bitcast i8* %tzone1864 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1865)
; malloc closure structure
%clsptr1866 = call i8* @llvm_zone_malloc(%mzone* %zone1865, i64 24)
%closure1867 = bitcast i8* %clsptr1866 to { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr1868 = call i8* @llvm_zone_malloc(%mzone* %zone1865, i64 8)
%environment1869 = bitcast i8* %envptr1868 to {{i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable1870 = call %clsvar* @new_address_table()
%var1871 = bitcast [38 x i8]* @gsxtmgl-objects2140 to i8*
%var1872 = bitcast [47 x i8]* @gsxtmgl-objects2141 to i8*
%addytable1873 = call %clsvar* @add_address_table(%mzone* %zone1865, i8* %var1871, i32 0, i8* %var1872, i32 3, %clsvar* %addytable1870)
%address-table1874 = bitcast %clsvar* %addytable1873 to i8*

; insert table, function and environment into closure struct
%closure.table1877 = getelementptr { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}, { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}* %closure1867, i32 0, i32 0
store i8* %address-table1874, i8** %closure.table1877
%closure.env1878 = getelementptr { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}, { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}* %closure1867, i32 0, i32 1
store i8* %envptr1868, i8** %closure.env1878
%closure.func1879 = getelementptr { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}, { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}* %closure1867, i32 0, i32 2
store [16 x %VBO*]* (i8*, i8*, %VAO*)* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0__1856, [16 x %VBO*]* (i8*, i8*, %VAO*)** %closure.func1879
%closure_size1880 = call i64 @llvm_zone_mark_size(%mzone* %zone1865)
call void @llvm_zone_ptr_set_size(i8* %clsptr1866, i64 %closure_size1880)
%wrapper_ptr1881 = call i8* @llvm_zone_malloc(%mzone* %zone1865, i64 8)
%closure_wrapper1882 = bitcast i8* %wrapper_ptr1881 to { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}**
store { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}* %closure1867, { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}** %closure_wrapper1882

; let value assignment
%buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0 = select i1 true, { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}** %closure_wrapper1882, { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}** %closure_wrapper1882
store { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}** %buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0, { i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}*** %buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0Ptr

; add data to environment
; don't need to alloc for env var buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0
%tmp_envptr1876 = getelementptr {{i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}***}* %environment1869, i32 0, i32 0
store {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}*** %buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0Ptr, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}**** %tmp_envptr1876


%val1885 = load {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}**, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}*** %buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0Ptr
ret {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}** %val1885
}


@buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}** @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc [16 x %VBO*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}*, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  [16 x %VBO*]* (i8*, i8*, %VAO*)*,  [16 x %VBO*]* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc [16 x %VBO*]* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret [16 x %VBO*]* %result
}


define dllexport ccc [16 x %VBO*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}*, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  [16 x %VBO*]* (i8*, i8*, %VAO*)*,  [16 x %VBO*]* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc [16 x %VBO*]* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret [16 x %VBO*]* %result
}


define dllexport ccc i8*  @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1886 = bitcast [91 x i8]* @gsxtmgl-objects2142 to i8*
call i32 (i8*, ...) @printf(i8* %var1886)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}*, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  [16 x %VBO*]* (i8*, i8*, %VAO*)*,  [16 x %VBO*]* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc [16 x %VBO*]* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%tmpres = bitcast [16 x %VBO*]* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}*, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}, {i8*, i8*, [16 x %VBO*]* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  [16 x %VBO*]* (i8*, i8*, %VAO*)*,  [16 x %VBO*]* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc [16 x %VBO*]* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2143 = hidden constant [35 x i8] c"get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd\00"
@gsxtmgl-objects2144 = hidden constant [44 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}**\00"
define dllexport fastcc %VBO* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd__1887(i8* %_impz,i8* %_impenv, %VAO* %vao, i64 %idx) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1888 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}***}*
%get_vbo_adhoc_W1ZCTyosVkFPKixpNjRdPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}***}* %impenv, i32 0, i32 0
%get_vbo_adhoc_W1ZCTyosVkFPKixpNjRdPtr = load {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}**** %get_vbo_adhoc_W1ZCTyosVkFPKixpNjRdPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%idxPtr = alloca i64
store i64 %idx, i64* %idxPtr


%val1890 = load i64, i64* %idxPtr
%cmp1891 = icmp slt i64 %val1890, 16
br i1 %cmp1891, label %then1889, label %else1889

then1889:
%val1892 = load i64, i64* %idxPtr
%val1893 = load %VAO*, %VAO** %vaoPtr
; tuple ref
%val1894 = getelementptr %VAO, %VAO* %val1893, i64 0, i32 2
; array ref
%_val1895 = getelementptr [16 x %VBO*], [16 x %VBO*]* %val1894, i32 0, i64 %val1892
%val1896 = load %VBO*, %VBO** %_val1895
ret %VBO* %val1896

else1889:
%null1897 = bitcast i8* null to i8*
%val1898 = bitcast i8* %null1897 to %VBO*
ret %VBO* %val1898
}
@gsxtmgl-objects2145 = hidden constant [88 x i8] c"get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}** @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1918 = load i8*, i8** %_impzPtr
%zone1919 = bitcast i8* %tzone1918 to %mzone*

; let assign value to symbol get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd
%dat_get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone1919, i64 8)
%get_vbo_adhoc_W1ZCTyosVkFPKixpNjRdPtr = bitcast i8* %dat_get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd to { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}***
%tzone1899 = load i8*, i8** %_impzPtr
%zone1900 = bitcast i8* %tzone1899 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1900)
; malloc closure structure
%clsptr1901 = call i8* @llvm_zone_malloc(%mzone* %zone1900, i64 24)
%closure1902 = bitcast i8* %clsptr1901 to { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}*

; malloc environment structure
%envptr1903 = call i8* @llvm_zone_malloc(%mzone* %zone1900, i64 8)
%environment1904 = bitcast i8* %envptr1903 to {{i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}***}*

; malloc closure address table
%addytable1905 = call %clsvar* @new_address_table()
%var1906 = bitcast [35 x i8]* @gsxtmgl-objects2143 to i8*
%var1907 = bitcast [44 x i8]* @gsxtmgl-objects2144 to i8*
%addytable1908 = call %clsvar* @add_address_table(%mzone* %zone1900, i8* %var1906, i32 0, i8* %var1907, i32 3, %clsvar* %addytable1905)
%address-table1909 = bitcast %clsvar* %addytable1908 to i8*

; insert table, function and environment into closure struct
%closure.table1912 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}* %closure1902, i32 0, i32 0
store i8* %address-table1909, i8** %closure.table1912
%closure.env1913 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}* %closure1902, i32 0, i32 1
store i8* %envptr1903, i8** %closure.env1913
%closure.func1914 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}* %closure1902, i32 0, i32 2
store %VBO* (i8*, i8*, %VAO*, i64)* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd__1887, %VBO* (i8*, i8*, %VAO*, i64)** %closure.func1914
%closure_size1915 = call i64 @llvm_zone_mark_size(%mzone* %zone1900)
call void @llvm_zone_ptr_set_size(i8* %clsptr1901, i64 %closure_size1915)
%wrapper_ptr1916 = call i8* @llvm_zone_malloc(%mzone* %zone1900, i64 8)
%closure_wrapper1917 = bitcast i8* %wrapper_ptr1916 to { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}* %closure1902, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}** %closure_wrapper1917

; let value assignment
%get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}** %closure_wrapper1917, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}** %closure_wrapper1917
store { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}** %get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd, { i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}*** %get_vbo_adhoc_W1ZCTyosVkFPKixpNjRdPtr

; add data to environment
; don't need to alloc for env var get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd
%tmp_envptr1911 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}***}* %environment1904, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}*** %get_vbo_adhoc_W1ZCTyosVkFPKixpNjRdPtr, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}**** %tmp_envptr1911


%val1920 = load {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}*** %get_vbo_adhoc_W1ZCTyosVkFPKixpNjRdPtr
ret {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}** %val1920
}


@get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}** @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd(%VAO* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VAO*, i64)*,  %VBO* (i8*, i8*, %VAO*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i64 %arg_1)
ret %VBO* %result
}


define dllexport ccc %VBO* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_native(%VAO* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VAO*, i64)*,  %VBO* (i8*, i8*, %VAO*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i64 %arg_1)
ret %VBO* %result
}


define dllexport ccc i8*  @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1921 = bitcast [88 x i8]* @gsxtmgl-objects2145 to i8*
call i32 (i8*, ...) @printf(i8* %var1921)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1922 = bitcast [88 x i8]* @gsxtmgl-objects2145 to i8*
call i32 (i8*, ...) @printf(i8* %var1922)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VAO*, i64)*,  %VBO* (i8*, i8*, %VAO*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i64 %arg_1)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, i64}*
%arg_p_0 = getelementptr {%VAO*, i64}, {%VAO*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, i64}, {%VAO*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @get_vbo_adhoc_W1ZCTyosVkFPKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VAO*, i64)*,  %VBO* (i8*, i8*, %VAO*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2146 = hidden constant [38 x i8] c"attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ\00"
@gsxtmgl-objects2147 = hidden constant [41 x i8] c"{i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}**\00"
define dllexport fastcc i1 @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ__1923(i8* %_impz,i8* %_impenv, %VAO* %vao, i64 %index) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1924 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}***}*
%attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQPtr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}***}, {{i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}***}* %impenv, i32 0, i32 0
%attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQPtr = load {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}***, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}**** %attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%indexPtr = alloca i64
store i64 %index, i64* %indexPtr


%val1926 = load i64, i64* %indexPtr
%cmp1927 = icmp slt i64 %val1926, 16
br i1 %cmp1927, label %then1925, label %else1925

then1925:
%val1928 = load i64, i64* %indexPtr
%val1929 = load %VAO*, %VAO** %vaoPtr
; tuple ref
%val1930 = getelementptr %VAO, %VAO* %val1929, i64 0, i32 1
; array ref
%_val1931 = getelementptr [16 x i1], [16 x i1]* %val1930, i32 0, i64 %val1928
%val1932 = load i1, i1* %_val1931
ret i1 %val1932

else1925:
%res1933 = call ccc i1 @impc_false()
ret i1 %res1933
}
@gsxtmgl-objects2148 = hidden constant [91 x i8] c"attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}** @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1953 = load i8*, i8** %_impzPtr
%zone1954 = bitcast i8* %tzone1953 to %mzone*

; let assign value to symbol attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ
%dat_attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ = call i8* @llvm_zone_malloc(%mzone* %zone1954, i64 8)
%attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQPtr = bitcast i8* %dat_attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ to { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}***
%tzone1934 = load i8*, i8** %_impzPtr
%zone1935 = bitcast i8* %tzone1934 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1935)
; malloc closure structure
%clsptr1936 = call i8* @llvm_zone_malloc(%mzone* %zone1935, i64 24)
%closure1937 = bitcast i8* %clsptr1936 to { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}*

; malloc environment structure
%envptr1938 = call i8* @llvm_zone_malloc(%mzone* %zone1935, i64 8)
%environment1939 = bitcast i8* %envptr1938 to {{i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}***}*

; malloc closure address table
%addytable1940 = call %clsvar* @new_address_table()
%var1941 = bitcast [38 x i8]* @gsxtmgl-objects2146 to i8*
%var1942 = bitcast [41 x i8]* @gsxtmgl-objects2147 to i8*
%addytable1943 = call %clsvar* @add_address_table(%mzone* %zone1935, i8* %var1941, i32 0, i8* %var1942, i32 3, %clsvar* %addytable1940)
%address-table1944 = bitcast %clsvar* %addytable1943 to i8*

; insert table, function and environment into closure struct
%closure.table1947 = getelementptr { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}, { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}* %closure1937, i32 0, i32 0
store i8* %address-table1944, i8** %closure.table1947
%closure.env1948 = getelementptr { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}, { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}* %closure1937, i32 0, i32 1
store i8* %envptr1938, i8** %closure.env1948
%closure.func1949 = getelementptr { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}, { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}* %closure1937, i32 0, i32 2
store i1 (i8*, i8*, %VAO*, i64)* @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ__1923, i1 (i8*, i8*, %VAO*, i64)** %closure.func1949
%closure_size1950 = call i64 @llvm_zone_mark_size(%mzone* %zone1935)
call void @llvm_zone_ptr_set_size(i8* %clsptr1936, i64 %closure_size1950)
%wrapper_ptr1951 = call i8* @llvm_zone_malloc(%mzone* %zone1935, i64 8)
%closure_wrapper1952 = bitcast i8* %wrapper_ptr1951 to { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}**
store { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}* %closure1937, { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}** %closure_wrapper1952

; let value assignment
%attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ = select i1 true, { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}** %closure_wrapper1952, { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}** %closure_wrapper1952
store { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}** %attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ, { i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}*** %attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQPtr

; add data to environment
; don't need to alloc for env var attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ
%tmp_envptr1946 = getelementptr {{i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}***}, {{i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}***}* %environment1939, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}*** %attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQPtr, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}**** %tmp_envptr1946


%val1955 = load {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}**, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}*** %attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQPtr
ret {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}** %val1955
}


@attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_var = dllexport global [1 x i8*] [ i8* null ]

@attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}** @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ(%VAO* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %VAO*, i64)*,  i1 (i8*, i8*, %VAO*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i64 %arg_1)
ret i1 %result
}


define dllexport ccc i1 @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_native(%VAO* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %VAO*, i64)*,  i1 (i8*, i8*, %VAO*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i64 %arg_1)
ret i1 %result
}


define dllexport ccc i8*  @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1956 = bitcast [91 x i8]* @gsxtmgl-objects2148 to i8*
call i32 (i8*, ...) @printf(i8* %var1956)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1957 = bitcast [91 x i8]* @gsxtmgl-objects2148 to i8*
call i32 (i8*, ...) @printf(i8* %var1957)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %VAO*, i64)*,  i1 (i8*, i8*, %VAO*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i64 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, i64}*
%arg_p_0 = getelementptr {%VAO*, i64}, {%VAO*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, i64}, {%VAO*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @attrib_set_p_adhoc_W2kxLFZBTyosaTY0XQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}*, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}, {i8*, i8*, i1 (i8*, i8*, %VAO*, i64)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, %VAO*, i64)*,  i1 (i8*, i8*, %VAO*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2149 = hidden constant [19 x i8] c"Error creating VAO\00"
@gsxtmgl-objects2150 = hidden constant [19 x i8] c"Error deleting VAO\00"
@gsxtmgl-objects2151 = hidden constant [19 x i8] c"VAO_adhoc_W1ZBTypd\00"
@gsxtmgl-objects2152 = hidden constant [32 x i8] c"{i8*, i8*, %VAO* (i8*, i8*)*}**\00"
@gsxtmgl-objects2153 = hidden constant [2 x i8] c"i\00"
@gsxtmgl-objects2154 = hidden constant [8 x i8] c"id_s_11\00"
@gsxtmgl-objects2155 = hidden constant [3 x i8] c"bs\00"
@gsxtmgl-objects2156 = hidden constant [14 x i8] c"[16 x %VBO*]*\00"
@gsxtmgl-objects2157 = hidden constant [3 x i8] c"as\00"
@gsxtmgl-objects2158 = hidden constant [11 x i8] c"[16 x i1]*\00"
@gsxtmgl-objects2159 = hidden constant [4 x i8] c"vao\00"
@gsxtmgl-objects2160 = hidden constant [6 x i8] c"%VAO*\00"
define dllexport fastcc void @VAO_adhoc_W1ZBTypd__1959(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2017 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}*
%VAO_adhoc_W1ZBTypdPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 0
%VAO_adhoc_W1ZBTypdPtr = load {i8*, i8*, %VAO* (i8*, i8*)*}***, {i8*, i8*, %VAO* (i8*, i8*)*}**** %VAO_adhoc_W1ZBTypdPtr_
%iPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 1
%iPtr = load i64*, i64** %iPtr_
%id_s_11Ptr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 2
%id_s_11Ptr = load i32**, i32*** %id_s_11Ptr_
%bsPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 3
%bsPtr = load [16 x %VBO*]**, [16 x %VBO*]*** %bsPtr_
%asPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 4
%asPtr = load [16 x i1]**, [16 x i1]*** %asPtr_
%vaoPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 5
%vaoPtr = load %VAO**, %VAO*** %vaoPtr_
%fPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 6
%fPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %fPtr_
%hookPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 7
%hookPtr = load {i64,i8*,i8*}**, {i64,i8*,i8*}*** %hookPtr_
%hooksPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 8
%hooksPtr = load {i64,i8*,i8*}**, {i64,i8*,i8*}*** %hooksPtr_
%zonePtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 9
%zonePtr = load %mzone**, %mzone*** %zonePtr_

; setup arguments


%val2018 = load %VAO*, %VAO** %vaoPtr
; tuple ref
%val2019 = getelementptr %VAO, %VAO* %val2018, i64 0, i32 0
call fastcc void @glDeleteVertexArrays_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val2019)
%var2021 = bitcast [19 x i8]* @gsxtmgl-objects2150 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var2021)
ret void
}
define dllexport fastcc %VAO* @VAO_adhoc_W1ZBTypd__1958(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1960 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*)*}***}*
%VAO_adhoc_W1ZBTypdPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%VAO_adhoc_W1ZBTypdPtr = load {i8*, i8*, %VAO* (i8*, i8*)*}***, {i8*, i8*, %VAO* (i8*, i8*)*}**** %VAO_adhoc_W1ZBTypdPtr_

; setup arguments


%tzone1965 = load i8*, i8** %_impzPtr
%zone1966 = bitcast i8* %tzone1965 to %mzone*

; let assign value to symbol vao
%dat_vao = call i8* @llvm_zone_malloc(%mzone* %zone1966, i64 8)
%vaoPtr = bitcast i8* %dat_vao to %VAO**
%tzone1969 = load i8*, i8** %_impzPtr
%zone1970 = bitcast i8* %tzone1969 to %mzone*

; let assign value to symbol as
%dat_as = call i8* @llvm_zone_malloc(%mzone* %zone1970, i64 8)
%asPtr = bitcast i8* %dat_as to [16 x i1]**
%tzone1973 = load i8*, i8** %_impzPtr
%zone1974 = bitcast i8* %tzone1973 to %mzone*

; let assign value to symbol bs
%dat_bs = call i8* @llvm_zone_malloc(%mzone* %zone1974, i64 8)
%bsPtr = bitcast i8* %dat_bs to [16 x %VBO*]**
%tzone1976 = load i8*, i8** %_impzPtr
%zone1977 = bitcast i8* %tzone1976 to %mzone*

; let assign value to symbol id_s_11
%dat_id_s_11 = call i8* @llvm_zone_malloc(%mzone* %zone1977, i64 8)
%id_s_11Ptr = bitcast i8* %dat_id_s_11 to i32**
%tzone1978 = load i8*, i8** %_impzPtr
%zone1979 = bitcast i8* %tzone1978 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone1979, i64 8)
%iPtr = bitcast i8* %dat_i to i64*
%tzone1961 = load i8*, i8** %_impzPtr
%zone1962 = bitcast i8* %tzone1961 to %mzone*
%dat1963 = call i8* @llvm_zone_malloc(%mzone* %zone1962, i64 152)
call i8* @memset(i8* %dat1963, i32 0, i64 152)
%val1964 = bitcast i8* %dat1963 to %VAO*

; let value assignment
%vao = select i1 true, %VAO* %val1964, %VAO* %val1964
store %VAO* %vao, %VAO** %vaoPtr

%val1967 = load %VAO*, %VAO** %vaoPtr
%res1968 = call fastcc [16 x i1]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd(%VAO* %val1967)

; let value assignment
%as = select i1 true, [16 x i1]* %res1968, [16 x i1]* %res1968
store [16 x i1]* %as, [16 x i1]** %asPtr

%val1971 = load %VAO*, %VAO** %vaoPtr
%res1972 = call fastcc [16 x %VBO*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0(%VAO* %val1971)

; let value assignment
%bs = select i1 true, [16 x %VBO*]* %res1972, [16 x %VBO*]* %res1972
store [16 x %VBO*]* %bs, [16 x %VBO*]** %bsPtr

%dat1975 = alloca i32, align 16

; let value assignment
%id_s_11 = select i1 true, i32* %dat1975, i32* %dat1975
store i32* %id_s_11, i32** %id_s_11Ptr


; let value assignment
%i = select i1 true, i64 0, i64 0
store i64 %i, i64* %iPtr

%val1980 = load i32*, i32** %id_s_11Ptr
call fastcc void @glGenVertexArrays_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val1980)
%val1982 = load %VAO*, %VAO** %vaoPtr
%val1983 = load i32*, i32** %id_s_11Ptr
; pointer ref
%val1984 = getelementptr i32, i32* %val1983, i64 0
%val1985 = load i32, i32* %val1984
; set tuple
%val1986 = getelementptr %VAO, %VAO* %val1982, i64 0, i32 0
store i32 %val1985, i32* %val1986
%var1987 = bitcast [19 x i8]* @gsxtmgl-objects2149 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1987)
; setup loop
store i64 0, i64* %iPtr
%val1998 = load i64, i64* %iPtr
%num1999 = add i64 16, %val1998
%comp2000 = icmp ult i64 16, 1
br i1 %comp2000, label %after1989, label %loop1989

loop1989:
%val1990 = load i64, i64* %iPtr
%val1991 = load [16 x i1]*, [16 x i1]** %asPtr
%res1992 = call ccc i1 @impc_false()
; set array
%val1993 = getelementptr [16 x i1], [16 x i1]* %val1991, i32 0, i64 %val1990
store i1 %res1992, i1* %val1993
%val1994 = load i64, i64* %iPtr
%val1995 = load [16 x %VBO*]*, [16 x %VBO*]** %bsPtr
%null1996 = bitcast i8* null to %VBO*
; set array
%val1997 = getelementptr [16 x %VBO*], [16 x %VBO*]* %val1995, i32 0, i64 %val1994
store %VBO* %null1996, %VBO** %val1997
%loop_cnt1989 = load i64, i64* %iPtr
%next1989 = add i64 %loop_cnt1989, 1
store i64 %next1989, i64* %iPtr
%cmp1989 = icmp ult i64 %next1989, %num1999
br i1 %cmp1989, label %loop1989, label %after1989

after1989:
%tzone2003 = load i8*, i8** %_impzPtr
%zone2004 = bitcast i8* %tzone2003 to %mzone*

; let assign value to symbol zone
%dat_zone = call i8* @llvm_zone_malloc(%mzone* %zone2004, i64 8)
%zonePtr = bitcast i8* %dat_zone to %mzone**
%tzone2009 = load i8*, i8** %_impzPtr
%zone2010 = bitcast i8* %tzone2009 to %mzone*

; let assign value to symbol hooks
%dat_hooks = call i8* @llvm_zone_malloc(%mzone* %zone2010, i64 8)
%hooksPtr = bitcast i8* %dat_hooks to {i64,i8*,i8*}**
%tzone2015 = load i8*, i8** %_impzPtr
%zone2016 = bitcast i8* %tzone2015 to %mzone*

; let assign value to symbol hook
%dat_hook = call i8* @llvm_zone_malloc(%mzone* %zone2016, i64 8)
%hookPtr = bitcast i8* %dat_hook to {i64,i8*,i8*}**
%tzone2088 = load i8*, i8** %_impzPtr
%zone2089 = bitcast i8* %tzone2088 to %mzone*

; let assign value to symbol f
%dat_f = call i8* @llvm_zone_malloc(%mzone* %zone2089, i64 8)
%fPtr = bitcast i8* %dat_f to { i8*, i8*, void (i8*, i8*)*}***
%res2002 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%zone = select i1 true, %mzone* %res2002, %mzone* %res2002
store %mzone* %zone, %mzone** %zonePtr

%val2005 = load %mzone*, %mzone** %zonePtr
; tuple ref
%val2006 = getelementptr %mzone, %mzone* %val2005, i64 0, i32 4
%val2007 = load i8*, i8** %val2006
%val2008 = bitcast i8* %val2007 to {i64,i8*,i8*}*

; let value assignment
%hooks = select i1 true, {i64,i8*,i8*}* %val2008, {i64,i8*,i8*}* %val2008
store {i64,i8*,i8*}* %hooks, {i64,i8*,i8*}** %hooksPtr

%tzone2011 = load i8*, i8** %_impzPtr
%zone2012 = bitcast i8* %tzone2011 to %mzone*
%dat2013 = call i8* @llvm_zone_malloc(%mzone* %zone2012, i64 24)
call i8* @memset(i8* %dat2013, i32 0, i64 24)
%val2014 = bitcast i8* %dat2013 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val2014, {i64,i8*,i8*}* %val2014
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%tzone2024 = load i8*, i8** %_impzPtr
%zone2025 = bitcast i8* %tzone2024 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2025)
; malloc closure structure
%clsptr2026 = call i8* @llvm_zone_malloc(%mzone* %zone2025, i64 24)
%closure2027 = bitcast i8* %clsptr2026 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr2028 = call i8* @llvm_zone_malloc(%mzone* %zone2025, i64 80)
%environment2029 = bitcast i8* %envptr2028 to {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}*

; malloc closure address table
%addytable2030 = call %clsvar* @new_address_table()
%var2031 = bitcast [19 x i8]* @gsxtmgl-objects2151 to i8*
%var2032 = bitcast [32 x i8]* @gsxtmgl-objects2152 to i8*
%addytable2033 = call %clsvar* @add_address_table(%mzone* %zone2025, i8* %var2031, i32 0, i8* %var2032, i32 3, %clsvar* %addytable2030)
%var2034 = bitcast [2 x i8]* @gsxtmgl-objects2153 to i8*
%var2035 = bitcast [4 x i8]* @gsxtmgl-objects271 to i8*
%addytable2036 = call %clsvar* @add_address_table(%mzone* %zone2025, i8* %var2034, i32 8, i8* %var2035, i32 3, %clsvar* %addytable2033)
%var2037 = bitcast [8 x i8]* @gsxtmgl-objects2154 to i8*
%var2038 = bitcast [5 x i8]* @gsxtmgl-objects291 to i8*
%addytable2039 = call %clsvar* @add_address_table(%mzone* %zone2025, i8* %var2037, i32 16, i8* %var2038, i32 3, %clsvar* %addytable2036)
%var2040 = bitcast [3 x i8]* @gsxtmgl-objects2155 to i8*
%var2041 = bitcast [14 x i8]* @gsxtmgl-objects2156 to i8*
%addytable2042 = call %clsvar* @add_address_table(%mzone* %zone2025, i8* %var2040, i32 24, i8* %var2041, i32 3, %clsvar* %addytable2039)
%var2043 = bitcast [3 x i8]* @gsxtmgl-objects2157 to i8*
%var2044 = bitcast [11 x i8]* @gsxtmgl-objects2158 to i8*
%addytable2045 = call %clsvar* @add_address_table(%mzone* %zone2025, i8* %var2043, i32 32, i8* %var2044, i32 3, %clsvar* %addytable2042)
%var2046 = bitcast [4 x i8]* @gsxtmgl-objects2159 to i8*
%var2047 = bitcast [6 x i8]* @gsxtmgl-objects2160 to i8*
%addytable2048 = call %clsvar* @add_address_table(%mzone* %zone2025, i8* %var2046, i32 40, i8* %var2047, i32 3, %clsvar* %addytable2045)
%var2049 = bitcast [2 x i8]* @gsxtmgl-objects280 to i8*
%var2050 = bitcast [31 x i8]* @gsxtmgl-objects211 to i8*
%addytable2051 = call %clsvar* @add_address_table(%mzone* %zone2025, i8* %var2049, i32 48, i8* %var2050, i32 3, %clsvar* %addytable2048)
%var2052 = bitcast [5 x i8]* @gsxtmgl-objects281 to i8*
%var2053 = bitcast [15 x i8]* @gsxtmgl-objects282 to i8*
%addytable2054 = call %clsvar* @add_address_table(%mzone* %zone2025, i8* %var2052, i32 56, i8* %var2053, i32 3, %clsvar* %addytable2051)
%var2055 = bitcast [6 x i8]* @gsxtmgl-objects283 to i8*
%var2056 = bitcast [15 x i8]* @gsxtmgl-objects282 to i8*
%addytable2057 = call %clsvar* @add_address_table(%mzone* %zone2025, i8* %var2055, i32 64, i8* %var2056, i32 3, %clsvar* %addytable2054)
%var2058 = bitcast [5 x i8]* @gsxtmgl-objects284 to i8*
%var2059 = bitcast [8 x i8]* @gsxtmgl-objects285 to i8*
%addytable2060 = call %clsvar* @add_address_table(%mzone* %zone2025, i8* %var2058, i32 72, i8* %var2059, i32 3, %clsvar* %addytable2057)
%address-table2061 = bitcast %clsvar* %addytable2060 to i8*

; insert table, function and environment into closure struct
%closure.table2082 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2027, i32 0, i32 0
store i8* %address-table2061, i8** %closure.table2082
%closure.env2083 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2027, i32 0, i32 1
store i8* %envptr2028, i8** %closure.env2083
%closure.func2084 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure2027, i32 0, i32 2
store void (i8*, i8*)* @VAO_adhoc_W1ZBTypd__1959, void (i8*, i8*)** %closure.func2084
%closure_size2085 = call i64 @llvm_zone_mark_size(%mzone* %zone2025)
call void @llvm_zone_ptr_set_size(i8* %clsptr2026, i64 %closure_size2085)
%wrapper_ptr2086 = call i8* @llvm_zone_malloc(%mzone* %zone2025, i64 8)
%closure_wrapper2087 = bitcast i8* %wrapper_ptr2086 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure2027, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2087

; let value assignment
%f = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2087, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper2087
store { i8*, i8*, void (i8*, i8*)*}** %f, { i8*, i8*, void (i8*, i8*)*}*** %fPtr

; add data to environment
; don't need to alloc for env var VAO_adhoc_W1ZBTypd
%tmp_envptr2063 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment2029, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*)*}*** %VAO_adhoc_W1ZBTypdPtr, {i8*, i8*, %VAO* (i8*, i8*)*}**** %tmp_envptr2063

; don't need to alloc for env var i
%tmp_envptr2065 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment2029, i32 0, i32 1
store i64* %iPtr, i64** %tmp_envptr2065

; don't need to alloc for env var id_s_11
%tmp_envptr2067 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment2029, i32 0, i32 2
store i32** %id_s_11Ptr, i32*** %tmp_envptr2067

; don't need to alloc for env var bs
%tmp_envptr2069 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment2029, i32 0, i32 3
store [16 x %VBO*]** %bsPtr, [16 x %VBO*]*** %tmp_envptr2069

; don't need to alloc for env var as
%tmp_envptr2071 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment2029, i32 0, i32 4
store [16 x i1]** %asPtr, [16 x i1]*** %tmp_envptr2071

; don't need to alloc for env var vao
%tmp_envptr2073 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment2029, i32 0, i32 5
store %VAO** %vaoPtr, %VAO*** %tmp_envptr2073

; don't need to alloc for env var f
%tmp_envptr2075 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment2029, i32 0, i32 6
store {i8*, i8*, void (i8*, i8*)*}*** %fPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr2075

; don't need to alloc for env var hook
%tmp_envptr2077 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment2029, i32 0, i32 7
store {i64,i8*,i8*}** %hookPtr, {i64,i8*,i8*}*** %tmp_envptr2077

; don't need to alloc for env var hooks
%tmp_envptr2079 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment2029, i32 0, i32 8
store {i64,i8*,i8*}** %hooksPtr, {i64,i8*,i8*}*** %tmp_envptr2079

; don't need to alloc for env var zone
%tmp_envptr2081 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %VAO* (i8*, i8*)*}***, i64*, i32**, [16 x %VBO*]**, [16 x i1]**, %VAO**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment2029, i32 0, i32 9
store %mzone** %zonePtr, %mzone*** %tmp_envptr2081


%val2090 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; set tuple
%val2091 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2090, i64 0, i32 0
store i64 0, i64* %val2091
%val2092 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2093 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val2094 = bitcast {i8*, i8*, void (i8*, i8*)*}** %val2093 to i8*
; set tuple
%val2095 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2092, i64 0, i32 1
store i8* %val2094, i8** %val2095
%val2096 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2097 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hooksPtr
%val2098 = bitcast {i64,i8*,i8*}* %val2097 to i8*
; set tuple
%val2099 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2096, i64 0, i32 2
store i8* %val2098, i8** %val2099
%val2100 = load %mzone*, %mzone** %zonePtr
%val2101 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2102 = bitcast {i64,i8*,i8*}* %val2101 to i8*
; set tuple
%val2103 = getelementptr %mzone, %mzone* %val2100, i64 0, i32 4
store i8* %val2102, i8** %val2103
%val2105 = load %VAO*, %VAO** %vaoPtr
ret %VAO* %val2105
}
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*)*}** @VAO_adhoc_W1ZBTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2125 = load i8*, i8** %_impzPtr
%zone2126 = bitcast i8* %tzone2125 to %mzone*

; let assign value to symbol VAO_adhoc_W1ZBTypd
%dat_VAO_adhoc_W1ZBTypd = call i8* @llvm_zone_malloc(%mzone* %zone2126, i64 8)
%VAO_adhoc_W1ZBTypdPtr = bitcast i8* %dat_VAO_adhoc_W1ZBTypd to { i8*, i8*, %VAO* (i8*, i8*)*}***
%tzone2106 = load i8*, i8** %_impzPtr
%zone2107 = bitcast i8* %tzone2106 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2107)
; malloc closure structure
%clsptr2108 = call i8* @llvm_zone_malloc(%mzone* %zone2107, i64 24)
%closure2109 = bitcast i8* %clsptr2108 to { i8*, i8*, %VAO* (i8*, i8*)*}*

; malloc environment structure
%envptr2110 = call i8* @llvm_zone_malloc(%mzone* %zone2107, i64 8)
%environment2111 = bitcast i8* %envptr2110 to {{i8*, i8*, %VAO* (i8*, i8*)*}***}*

; malloc closure address table
%addytable2112 = call %clsvar* @new_address_table()
%var2113 = bitcast [19 x i8]* @gsxtmgl-objects2151 to i8*
%var2114 = bitcast [32 x i8]* @gsxtmgl-objects2152 to i8*
%addytable2115 = call %clsvar* @add_address_table(%mzone* %zone2107, i8* %var2113, i32 0, i8* %var2114, i32 3, %clsvar* %addytable2112)
%address-table2116 = bitcast %clsvar* %addytable2115 to i8*

; insert table, function and environment into closure struct
%closure.table2119 = getelementptr { i8*, i8*, %VAO* (i8*, i8*)*}, { i8*, i8*, %VAO* (i8*, i8*)*}* %closure2109, i32 0, i32 0
store i8* %address-table2116, i8** %closure.table2119
%closure.env2120 = getelementptr { i8*, i8*, %VAO* (i8*, i8*)*}, { i8*, i8*, %VAO* (i8*, i8*)*}* %closure2109, i32 0, i32 1
store i8* %envptr2110, i8** %closure.env2120
%closure.func2121 = getelementptr { i8*, i8*, %VAO* (i8*, i8*)*}, { i8*, i8*, %VAO* (i8*, i8*)*}* %closure2109, i32 0, i32 2
store %VAO* (i8*, i8*)* @VAO_adhoc_W1ZBTypd__1958, %VAO* (i8*, i8*)** %closure.func2121
%closure_size2122 = call i64 @llvm_zone_mark_size(%mzone* %zone2107)
call void @llvm_zone_ptr_set_size(i8* %clsptr2108, i64 %closure_size2122)
%wrapper_ptr2123 = call i8* @llvm_zone_malloc(%mzone* %zone2107, i64 8)
%closure_wrapper2124 = bitcast i8* %wrapper_ptr2123 to { i8*, i8*, %VAO* (i8*, i8*)*}**
store { i8*, i8*, %VAO* (i8*, i8*)*}* %closure2109, { i8*, i8*, %VAO* (i8*, i8*)*}** %closure_wrapper2124

; let value assignment
%VAO_adhoc_W1ZBTypd = select i1 true, { i8*, i8*, %VAO* (i8*, i8*)*}** %closure_wrapper2124, { i8*, i8*, %VAO* (i8*, i8*)*}** %closure_wrapper2124
store { i8*, i8*, %VAO* (i8*, i8*)*}** %VAO_adhoc_W1ZBTypd, { i8*, i8*, %VAO* (i8*, i8*)*}*** %VAO_adhoc_W1ZBTypdPtr

; add data to environment
; don't need to alloc for env var VAO_adhoc_W1ZBTypd
%tmp_envptr2118 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*)*}***}* %environment2111, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*)*}*** %VAO_adhoc_W1ZBTypdPtr, {i8*, i8*, %VAO* (i8*, i8*)*}**** %tmp_envptr2118


%val2127 = load {i8*, i8*, %VAO* (i8*, i8*)*}**, {i8*, i8*, %VAO* (i8*, i8*)*}*** %VAO_adhoc_W1ZBTypdPtr
ret {i8*, i8*, %VAO* (i8*, i8*)*}** %val2127
}


@VAO_adhoc_W1ZBTypd_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_adhoc_W1ZBTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_adhoc_W1ZBTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*)*}** @VAO_adhoc_W1ZBTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_adhoc_W1ZBTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_adhoc_W1ZBTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @VAO_adhoc_W1ZBTypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*)*}*, {i8*, i8*, %VAO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*)*,  %VAO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee)
ret %VAO* %result
}


define dllexport ccc %VAO* @VAO_adhoc_W1ZBTypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*)*}*, {i8*, i8*, %VAO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*)*,  %VAO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee)
ret %VAO* %result
}


define dllexport ccc i8*  @VAO_adhoc_W1ZBTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*)*}*, {i8*, i8*, %VAO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*)*,  %VAO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %VAO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VAO_adhoc_W1ZBTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*)*}*, {i8*, i8*, %VAO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*)*,  %VAO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2161 = hidden constant [11 x i8] c"<VAO: 0x0>\00"
@gsxtmgl-objects2162 = hidden constant [13 x i8] c"<VAO: id %d>\00"
@gsxtmgl-objects2163 = hidden constant [28 x i8] c"print_adhoc_W3ZvaWQsVkFPKl0\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsVkFPKl0__2128(i8* %_impz,i8* %_impenv, %VAO* %vao) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2129 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}*
%print_adhoc_W3ZvaWQsVkFPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsVkFPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %VAO*)*}***, {i8*, i8*, void (i8*, i8*, %VAO*)*}**** %print_adhoc_W3ZvaWQsVkFPKl0Ptr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr

; promote local stack var allocations
%tzone2142 = load i8*, i8** %_impzPtr
%zone2143 = bitcast i8* %tzone2142 to %mzone*
%ifptr2130 = alloca i32

%val2131 = load %VAO*, %VAO** %vaoPtr
%val2132 = icmp eq %VAO* %val2131, null
br i1 %val2132, label %then2130, label %else2130

then2130:
%var2133 = bitcast [11 x i8]* @gsxtmgl-objects2161 to i8*

%val2134 = call i32 (i8*, ...) @printf(i8* %var2133)
store i32 %val2134, i32* %ifptr2130
br label %ifcont2130

else2130:
%var2135 = bitcast [13 x i8]* @gsxtmgl-objects2162 to i8*
%val2136 = load %VAO*, %VAO** %vaoPtr
; tuple ref
%val2137 = getelementptr %VAO, %VAO* %val2136, i64 0, i32 0
%val2138 = load i32, i32* %val2137

%val2139 = call i32 (i8*, ...) @printf(i8* %var2135, i32 %val2138)
store i32 %val2139, i32* %ifptr2130
br label %ifcont2130

ifcont2130:
%ifres2140 = load i32, i32* %ifptr2130

ret void
}
@gsxtmgl-objects2164 = hidden constant [81 x i8] c"print_adhoc_W3ZvaWQsVkFPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*)*}** @print_adhoc_W3ZvaWQsVkFPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2163 = load i8*, i8** %_impzPtr
%zone2164 = bitcast i8* %tzone2163 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsVkFPKl0
%dat_print_adhoc_W3ZvaWQsVkFPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2164, i64 8)
%print_adhoc_W3ZvaWQsVkFPKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsVkFPKl0 to { i8*, i8*, void (i8*, i8*, %VAO*)*}***
%tzone2144 = load i8*, i8** %_impzPtr
%zone2145 = bitcast i8* %tzone2144 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2145)
; malloc closure structure
%clsptr2146 = call i8* @llvm_zone_malloc(%mzone* %zone2145, i64 24)
%closure2147 = bitcast i8* %clsptr2146 to { i8*, i8*, void (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr2148 = call i8* @llvm_zone_malloc(%mzone* %zone2145, i64 8)
%environment2149 = bitcast i8* %envptr2148 to {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable2150 = call %clsvar* @new_address_table()
%var2151 = bitcast [28 x i8]* @gsxtmgl-objects2163 to i8*
%var2152 = bitcast [38 x i8]* @gsxtmgl-objects2129 to i8*
%addytable2153 = call %clsvar* @add_address_table(%mzone* %zone2145, i8* %var2151, i32 0, i8* %var2152, i32 3, %clsvar* %addytable2150)
%address-table2154 = bitcast %clsvar* %addytable2153 to i8*

; insert table, function and environment into closure struct
%closure.table2157 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure2147, i32 0, i32 0
store i8* %address-table2154, i8** %closure.table2157
%closure.env2158 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure2147, i32 0, i32 1
store i8* %envptr2148, i8** %closure.env2158
%closure.func2159 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure2147, i32 0, i32 2
store void (i8*, i8*, %VAO*)* @print_adhoc_W3ZvaWQsVkFPKl0__2128, void (i8*, i8*, %VAO*)** %closure.func2159
%closure_size2160 = call i64 @llvm_zone_mark_size(%mzone* %zone2145)
call void @llvm_zone_ptr_set_size(i8* %clsptr2146, i64 %closure_size2160)
%wrapper_ptr2161 = call i8* @llvm_zone_malloc(%mzone* %zone2145, i64 8)
%closure_wrapper2162 = bitcast i8* %wrapper_ptr2161 to { i8*, i8*, void (i8*, i8*, %VAO*)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure2147, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper2162

; let value assignment
%print_adhoc_W3ZvaWQsVkFPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper2162, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper2162
store { i8*, i8*, void (i8*, i8*, %VAO*)*}** %print_adhoc_W3ZvaWQsVkFPKl0, { i8*, i8*, void (i8*, i8*, %VAO*)*}*** %print_adhoc_W3ZvaWQsVkFPKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsVkFPKl0
%tmp_envptr2156 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}* %environment2149, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*)*}*** %print_adhoc_W3ZvaWQsVkFPKl0Ptr, {i8*, i8*, void (i8*, i8*, %VAO*)*}**** %tmp_envptr2156


%val2165 = load {i8*, i8*, void (i8*, i8*, %VAO*)*}**, {i8*, i8*, void (i8*, i8*, %VAO*)*}*** %print_adhoc_W3ZvaWQsVkFPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VAO*)*}** %val2165
}


@print_adhoc_W3ZvaWQsVkFPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsVkFPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsVkFPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*)*}** @print_adhoc_W3ZvaWQsVkFPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsVkFPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsVkFPKl0(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsVkFPKl0_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsVkFPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2166 = bitcast [81 x i8]* @gsxtmgl-objects2164 to i8*
call i32 (i8*, ...) @printf(i8* %var2166)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsVkFPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2165 = hidden constant [35 x i8] c"toString_adhoc_W1N0cmluZyosVkFPKl0\00"
@gsxtmgl-objects2166 = hidden constant [42 x i8] c"{i8*, i8*, %String* (i8*, i8*, %VAO*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosVkFPKl0__2167(i8* %_impz,i8* %_impenv, %VAO* %vao) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2168 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %VAO*)*}***}*
%toString_adhoc_W1N0cmluZyosVkFPKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosVkFPKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %VAO*)*}***, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**** %toString_adhoc_W1N0cmluZyosVkFPKl0Ptr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr


%tzone2170 = load i8*, i8** %_impzPtr
%zone2171 = bitcast i8* %tzone2170 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat2169 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat2169, i8* %dat2169
store i8* %s, i8** %sPtr

; promote local stack var allocations
%tzone2187 = load i8*, i8** %_impzPtr
%zone2188 = bitcast i8* %tzone2187 to %mzone*
%ifptr2172 = alloca i32
%val2173 = load %VAO*, %VAO** %vaoPtr
%val2174 = icmp eq %VAO* %val2173, null
br i1 %val2174, label %then2172, label %else2172

then2172:
%val2175 = load i8*, i8** %sPtr
%var2176 = bitcast [11 x i8]* @gsxtmgl-objects2161 to i8*

%val2177 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2175, i8* %var2176)
store i32 %val2177, i32* %ifptr2172
br label %ifcont2172

else2172:
%val2178 = load i8*, i8** %sPtr
%var2179 = bitcast [13 x i8]* @gsxtmgl-objects2162 to i8*
%val2180 = load %VAO*, %VAO** %vaoPtr
; tuple ref
%val2181 = getelementptr %VAO, %VAO* %val2180, i64 0, i32 0
%val2182 = load i32, i32* %val2181

%val2183 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2178, i8* %var2179, i32 %val2182)
store i32 %val2183, i32* %ifptr2172
br label %ifcont2172

ifcont2172:
%ifres2184 = load i32, i32* %ifptr2172

%val2185 = load i8*, i8** %sPtr
%res2186 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2185)
ret %String* %res2186
}
@gsxtmgl-objects2167 = hidden constant [88 x i8] c"toString_adhoc_W1N0cmluZyosVkFPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** @toString_adhoc_W1N0cmluZyosVkFPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2208 = load i8*, i8** %_impzPtr
%zone2209 = bitcast i8* %tzone2208 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosVkFPKl0
%dat_toString_adhoc_W1N0cmluZyosVkFPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2209, i64 8)
%toString_adhoc_W1N0cmluZyosVkFPKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosVkFPKl0 to { i8*, i8*, %String* (i8*, i8*, %VAO*)*}***
%tzone2189 = load i8*, i8** %_impzPtr
%zone2190 = bitcast i8* %tzone2189 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2190)
; malloc closure structure
%clsptr2191 = call i8* @llvm_zone_malloc(%mzone* %zone2190, i64 24)
%closure2192 = bitcast i8* %clsptr2191 to { i8*, i8*, %String* (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr2193 = call i8* @llvm_zone_malloc(%mzone* %zone2190, i64 8)
%environment2194 = bitcast i8* %envptr2193 to {{i8*, i8*, %String* (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable2195 = call %clsvar* @new_address_table()
%var2196 = bitcast [35 x i8]* @gsxtmgl-objects2165 to i8*
%var2197 = bitcast [42 x i8]* @gsxtmgl-objects2166 to i8*
%addytable2198 = call %clsvar* @add_address_table(%mzone* %zone2190, i8* %var2196, i32 0, i8* %var2197, i32 3, %clsvar* %addytable2195)
%address-table2199 = bitcast %clsvar* %addytable2198 to i8*

; insert table, function and environment into closure struct
%closure.table2202 = getelementptr { i8*, i8*, %String* (i8*, i8*, %VAO*)*}, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure2192, i32 0, i32 0
store i8* %address-table2199, i8** %closure.table2202
%closure.env2203 = getelementptr { i8*, i8*, %String* (i8*, i8*, %VAO*)*}, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure2192, i32 0, i32 1
store i8* %envptr2193, i8** %closure.env2203
%closure.func2204 = getelementptr { i8*, i8*, %String* (i8*, i8*, %VAO*)*}, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure2192, i32 0, i32 2
store %String* (i8*, i8*, %VAO*)* @toString_adhoc_W1N0cmluZyosVkFPKl0__2167, %String* (i8*, i8*, %VAO*)** %closure.func2204
%closure_size2205 = call i64 @llvm_zone_mark_size(%mzone* %zone2190)
call void @llvm_zone_ptr_set_size(i8* %clsptr2191, i64 %closure_size2205)
%wrapper_ptr2206 = call i8* @llvm_zone_malloc(%mzone* %zone2190, i64 8)
%closure_wrapper2207 = bitcast i8* %wrapper_ptr2206 to { i8*, i8*, %String* (i8*, i8*, %VAO*)*}**
store { i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure2192, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_wrapper2207

; let value assignment
%toString_adhoc_W1N0cmluZyosVkFPKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_wrapper2207, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_wrapper2207
store { i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %toString_adhoc_W1N0cmluZyosVkFPKl0, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}*** %toString_adhoc_W1N0cmluZyosVkFPKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosVkFPKl0
%tmp_envptr2201 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %VAO*)*}***}* %environment2194, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %VAO*)*}*** %toString_adhoc_W1N0cmluZyosVkFPKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**** %tmp_envptr2201


%val2210 = load {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}*** %toString_adhoc_W1N0cmluZyosVkFPKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %val2210
}


@toString_adhoc_W1N0cmluZyosVkFPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosVkFPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosVkFPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** @toString_adhoc_W1N0cmluZyosVkFPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosVkFPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosVkFPKl0(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VAO*)*,  %String* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosVkFPKl0_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VAO*)*,  %String* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosVkFPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2211 = bitcast [88 x i8]* @gsxtmgl-objects2167 to i8*
call i32 (i8*, ...) @printf(i8* %var2211)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VAO*)*,  %String* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosVkFPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VAO*)*,  %String* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2168 = hidden constant [43 x i8] c"unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd\00"
@gsxtmgl-objects2169 = hidden constant [43 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, i32)*}**\00"
define dllexport fastcc void @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd__2212(i8* %_impz,i8* %_impenv, %VAO* %vao, i32 %index) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2213 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, i32)*}***}*
%unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, i32)*}***}* %impenv, i32 0, i32 0
%unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJdPtr = load {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}**** %unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJdPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%indexPtr = alloca i32
store i32 %index, i32* %indexPtr


%val2214 = load %VAO*, %VAO** %vaoPtr
%res2215 = call fastcc i32 @id_adhoc_W2kzMixWQU8qXQ(%VAO* %val2214)
call fastcc void @glBindVertexArray_adhoc_W3ZvaWQsaTMyXQ(i32 %res2215)
%val2217 = load i32, i32* %indexPtr
%val2218 = load %VAO*, %VAO** %vaoPtr
%res2219 = call fastcc [16 x i1]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd(%VAO* %val2218)
%res2220 = call ccc i1 @impc_false()
; set array
%val2221 = getelementptr [16 x i1], [16 x i1]* %res2219, i32 0, i32 %val2217
store i1 %res2220, i1* %val2221
%val2222 = load i32, i32* %indexPtr
%val2223 = load %VAO*, %VAO** %vaoPtr
%res2224 = call fastcc [16 x %VBO*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0(%VAO* %val2223)
%null2225 = bitcast i8* null to %VBO*
; set array
%val2226 = getelementptr [16 x %VBO*], [16 x %VBO*]* %res2224, i32 0, i32 %val2222
store %VBO* %null2225, %VBO** %val2226
%val2227 = load i32, i32* %indexPtr
call fastcc void @glDisableVertexAttribArray_adhoc_W3ZvaWQsaTMyXQ(i32 %val2227)
%val2229 = load i32, i32* %indexPtr
call fastcc void @glVertexAttribDivisor_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val2229, i32 0)
call fastcc void @glBindVertexArray_adhoc_W3ZvaWQsaTMyXQ(i32 0)
ret void
}
@gsxtmgl-objects2170 = hidden constant [96 x i8] c"unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}** @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2252 = load i8*, i8** %_impzPtr
%zone2253 = bitcast i8* %tzone2252 to %mzone*

; let assign value to symbol unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd
%dat_unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone2253, i64 8)
%unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJdPtr = bitcast i8* %dat_unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd to { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}***
%tzone2233 = load i8*, i8** %_impzPtr
%zone2234 = bitcast i8* %tzone2233 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2234)
; malloc closure structure
%clsptr2235 = call i8* @llvm_zone_malloc(%mzone* %zone2234, i64 24)
%closure2236 = bitcast i8* %clsptr2235 to { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}*

; malloc environment structure
%envptr2237 = call i8* @llvm_zone_malloc(%mzone* %zone2234, i64 8)
%environment2238 = bitcast i8* %envptr2237 to {{i8*, i8*, void (i8*, i8*, %VAO*, i32)*}***}*

; malloc closure address table
%addytable2239 = call %clsvar* @new_address_table()
%var2240 = bitcast [43 x i8]* @gsxtmgl-objects2168 to i8*
%var2241 = bitcast [43 x i8]* @gsxtmgl-objects2169 to i8*
%addytable2242 = call %clsvar* @add_address_table(%mzone* %zone2234, i8* %var2240, i32 0, i8* %var2241, i32 3, %clsvar* %addytable2239)
%address-table2243 = bitcast %clsvar* %addytable2242 to i8*

; insert table, function and environment into closure struct
%closure.table2246 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}* %closure2236, i32 0, i32 0
store i8* %address-table2243, i8** %closure.table2246
%closure.env2247 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}* %closure2236, i32 0, i32 1
store i8* %envptr2237, i8** %closure.env2247
%closure.func2248 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}* %closure2236, i32 0, i32 2
store void (i8*, i8*, %VAO*, i32)* @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd__2212, void (i8*, i8*, %VAO*, i32)** %closure.func2248
%closure_size2249 = call i64 @llvm_zone_mark_size(%mzone* %zone2234)
call void @llvm_zone_ptr_set_size(i8* %clsptr2235, i64 %closure_size2249)
%wrapper_ptr2250 = call i8* @llvm_zone_malloc(%mzone* %zone2234, i64 8)
%closure_wrapper2251 = bitcast i8* %wrapper_ptr2250 to { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}* %closure2236, { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}** %closure_wrapper2251

; let value assignment
%unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}** %closure_wrapper2251, { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}** %closure_wrapper2251
store { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}** %unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd, { i8*, i8*, void (i8*, i8*, %VAO*, i32)*}*** %unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJdPtr

; add data to environment
; don't need to alloc for env var unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd
%tmp_envptr2245 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, i32)*}***}* %environment2238, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}*** %unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJdPtr, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}**** %tmp_envptr2245


%val2254 = load {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}*** %unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJdPtr
ret {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}** %val2254
}


@unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}** @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd(%VAO* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32)*,  void (i8*, i8*, %VAO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc void @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_native(%VAO* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32)*,  void (i8*, i8*, %VAO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc i8*  @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2255 = bitcast [96 x i8]* @gsxtmgl-objects2170 to i8*
call i32 (i8*, ...) @printf(i8* %var2255)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2256 = bitcast [96 x i8]* @gsxtmgl-objects2170 to i8*
call i32 (i8*, ...) @printf(i8* %var2256)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32)*,  void (i8*, i8*, %VAO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, i32}*
%arg_p_0 = getelementptr {%VAO*, i32}, {%VAO*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, i32}, {%VAO*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unset_attribute_adhoc_W3ZvaWQsVkFPKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32)*,  void (i8*, i8*, %VAO*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2171 = hidden constant [18 x i8] c"Error binding VAO\00"
@gsxtmgl-objects2172 = hidden constant [28 x i8] c"Error binding VAO attribute\00"
@gsxtmgl-objects2173 = hidden constant [36 x i8] c"Error setting VAO attribute divisor\00"
@gsxtmgl-objects2174 = hidden constant [73 x i8] c"set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd\00"
@gsxtmgl-objects2175 = hidden constant [74 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}**\00"
define dllexport fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd__2257(i8* %_impz,i8* %_impenv, %VAO* %vao, %VBO* %vbo, i32 %type_s_12, i32 %index, i32 %size_s_13, i32 %stride_s_14, i32 %offset, i1 %instance_attr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2258 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}***}*
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}***}* %impenv, i32 0, i32 0
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFdPtr = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}**** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFdPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr
%type_s_12Ptr = alloca i32
store i32 %type_s_12, i32* %type_s_12Ptr
%indexPtr = alloca i32
store i32 %index, i32* %indexPtr
%size_s_13Ptr = alloca i32
store i32 %size_s_13, i32* %size_s_13Ptr
%stride_s_14Ptr = alloca i32
store i32 %stride_s_14, i32* %stride_s_14Ptr
%offsetPtr = alloca i32
store i32 %offset, i32* %offsetPtr
%instance_attrPtr = alloca i1
store i1 %instance_attr, i1* %instance_attrPtr

; promote local stack var allocations
%tzone2453 = load i8*, i8** %_impzPtr
%zone2454 = bitcast i8* %tzone2453 to %mzone*
%ifptr2426 = alloca i1
%ifptr2428 = alloca i1
%ifptr2410 = alloca i1
%ifptr2412 = alloca i1
%ifptr2393 = alloca i1
%ifptr2365 = alloca i1

%val2259 = load %VAO*, %VAO** %vaoPtr
%res2260 = call fastcc i32 @id_adhoc_W2kzMixWQU8qXQ(%VAO* %val2259)
call fastcc void @glBindVertexArray_adhoc_W3ZvaWQsaTMyXQ(i32 %res2260)
%var2262 = bitcast [18 x i8]* @gsxtmgl-objects2171 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var2262)
%val2264 = load i32, i32* @GL_ARRAY_BUFFER
%val2265 = load %VBO*, %VBO** %vboPtr
%res2266 = call fastcc i32 @id_adhoc_W2kzMixWQk8qXQ(%VBO* %val2265)
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val2264, i32 %res2266)
%var2268 = bitcast [18 x i8]* @gsxtmgl-objects2111 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var2268)
%tzone2270 = load i8*, i8** %_impzPtr
%zone2271 = bitcast i8* %tzone2270 to %mzone*

; let assign value to symbol component_size
%component_sizePtr = alloca i32

; let value assignment
%component_size = select i1 true, i32 4, i32 4
store i32 %component_size, i32* %component_sizePtr

%val2273 = load i32, i32* %size_s_13Ptr
%cmp2274 = icmp eq i32 %val2273, 16
br i1 %cmp2274, label %then2272, label %else2272

then2272:
%val2275 = load i32, i32* %indexPtr
%val2276 = add i32 %val2275, 0
call fastcc void @glEnableVertexAttribArray_adhoc_W3ZvaWQsaTMyXQ(i32 %val2276)
%val2278 = load i32, i32* %indexPtr
%val2279 = add i32 %val2278, 0
%val2280 = load i32, i32* %type_s_12Ptr
%val2281 = load i8, i8* @GL_FALSE
%val2282 = load i32, i32* %stride_s_14Ptr
%val2283 = load i32, i32* %component_sizePtr
%val2284 = mul i32 %val2282, %val2283
%val2285 = load i32, i32* %component_sizePtr
%val2286 = load i32, i32* %offsetPtr
%val2287 = add i32 %val2286, 0
%val2288 = mul i32 %val2285, %val2287
%null2289 = bitcast i8* null to i8*
%val2290 = bitcast i8* %null2289 to i8*
; pointer ref
%val2291 = getelementptr i8, i8* %val2290, i32 %val2288
call fastcc void @glVertexAttribPointer_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTgsaTMyLGk4Kl0(i32 %val2279, i32 4, i32 %val2280, i8 %val2281, i32 %val2284, i8* %val2291)
%val2293 = load i32, i32* %indexPtr
%val2294 = add i32 %val2293, 1
call fastcc void @glEnableVertexAttribArray_adhoc_W3ZvaWQsaTMyXQ(i32 %val2294)
%val2296 = load i32, i32* %indexPtr
%val2297 = add i32 %val2296, 1
%val2298 = load i32, i32* %type_s_12Ptr
%val2299 = load i8, i8* @GL_FALSE
%val2300 = load i32, i32* %stride_s_14Ptr
%val2301 = load i32, i32* %component_sizePtr
%val2302 = mul i32 %val2300, %val2301
%val2303 = load i32, i32* %component_sizePtr
%val2304 = load i32, i32* %offsetPtr
%val2305 = add i32 %val2304, 4
%val2306 = mul i32 %val2303, %val2305
%null2307 = bitcast i8* null to i8*
%val2308 = bitcast i8* %null2307 to i8*
; pointer ref
%val2309 = getelementptr i8, i8* %val2308, i32 %val2306
call fastcc void @glVertexAttribPointer_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTgsaTMyLGk4Kl0(i32 %val2297, i32 4, i32 %val2298, i8 %val2299, i32 %val2302, i8* %val2309)
%val2311 = load i32, i32* %indexPtr
%val2312 = add i32 %val2311, 2
call fastcc void @glEnableVertexAttribArray_adhoc_W3ZvaWQsaTMyXQ(i32 %val2312)
%val2314 = load i32, i32* %indexPtr
%val2315 = add i32 %val2314, 2
%val2316 = load i32, i32* %type_s_12Ptr
%val2317 = load i8, i8* @GL_FALSE
%val2318 = load i32, i32* %stride_s_14Ptr
%val2319 = load i32, i32* %component_sizePtr
%val2320 = mul i32 %val2318, %val2319
%val2321 = load i32, i32* %component_sizePtr
%val2322 = load i32, i32* %offsetPtr
%val2323 = add i32 %val2322, 8
%val2324 = mul i32 %val2321, %val2323
%null2325 = bitcast i8* null to i8*
%val2326 = bitcast i8* %null2325 to i8*
; pointer ref
%val2327 = getelementptr i8, i8* %val2326, i32 %val2324
call fastcc void @glVertexAttribPointer_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTgsaTMyLGk4Kl0(i32 %val2315, i32 4, i32 %val2316, i8 %val2317, i32 %val2320, i8* %val2327)
%val2329 = load i32, i32* %indexPtr
%val2330 = add i32 %val2329, 3
call fastcc void @glEnableVertexAttribArray_adhoc_W3ZvaWQsaTMyXQ(i32 %val2330)
%val2332 = load i32, i32* %indexPtr
%val2333 = add i32 %val2332, 3
%val2334 = load i32, i32* %type_s_12Ptr
%val2335 = load i8, i8* @GL_FALSE
%val2336 = load i32, i32* %stride_s_14Ptr
%val2337 = load i32, i32* %component_sizePtr
%val2338 = mul i32 %val2336, %val2337
%val2339 = load i32, i32* %component_sizePtr
%val2340 = load i32, i32* %offsetPtr
%val2341 = add i32 %val2340, 12
%val2342 = mul i32 %val2339, %val2341
%null2343 = bitcast i8* null to i8*
%val2344 = bitcast i8* %null2343 to i8*
; pointer ref
%val2345 = getelementptr i8, i8* %val2344, i32 %val2342
call fastcc void @glVertexAttribPointer_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTgsaTMyLGk4Kl0(i32 %val2333, i32 4, i32 %val2334, i8 %val2335, i32 %val2338, i8* %val2345)
br label %ifcont2272

else2272:
%val2347 = load i32, i32* %indexPtr
call fastcc void @glEnableVertexAttribArray_adhoc_W3ZvaWQsaTMyXQ(i32 %val2347)
%val2349 = load i32, i32* %indexPtr
%val2350 = load i32, i32* %size_s_13Ptr
%val2351 = load i32, i32* %type_s_12Ptr
%val2352 = load i8, i8* @GL_FALSE
%val2353 = load i32, i32* %component_sizePtr
%val2354 = load i32, i32* %stride_s_14Ptr
%val2355 = mul i32 %val2353, %val2354
%val2356 = load i32, i32* %component_sizePtr
%val2357 = load i32, i32* %offsetPtr
%val2358 = mul i32 %val2356, %val2357
%null2359 = bitcast i8* null to i8*
%val2360 = bitcast i8* %null2359 to i8*
; pointer ref
%val2361 = getelementptr i8, i8* %val2360, i32 %val2358
call fastcc void @glVertexAttribPointer_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTgsaTMyLGk4Kl0(i32 %val2349, i32 %val2350, i32 %val2351, i8 %val2352, i32 %val2355, i8* %val2361)
br label %ifcont2272

ifcont2272:
%var2363 = bitcast [28 x i8]* @gsxtmgl-objects2172 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var2363)
%val2366 = load i32, i32* %size_s_13Ptr
%cmp2367 = icmp eq i32 %val2366, 16
br i1 %cmp2367, label %then2365, label %else2365

then2365:
%val2368 = load i32, i32* %indexPtr
%val2369 = add i32 %val2368, 0
%val2370 = load %VAO*, %VAO** %vaoPtr
%res2371 = call fastcc [16 x i1]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd(%VAO* %val2370)
%res2372 = call ccc i1 @impc_true()
; set array
%val2373 = getelementptr [16 x i1], [16 x i1]* %res2371, i32 0, i32 %val2369
store i1 %res2372, i1* %val2373
%val2374 = load i32, i32* %indexPtr
%val2375 = add i32 %val2374, 1
%val2376 = load %VAO*, %VAO** %vaoPtr
%res2377 = call fastcc [16 x i1]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd(%VAO* %val2376)
%res2378 = call ccc i1 @impc_true()
; set array
%val2379 = getelementptr [16 x i1], [16 x i1]* %res2377, i32 0, i32 %val2375
store i1 %res2378, i1* %val2379
%val2380 = load i32, i32* %indexPtr
%val2381 = add i32 %val2380, 2
%val2382 = load %VAO*, %VAO** %vaoPtr
%res2383 = call fastcc [16 x i1]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd(%VAO* %val2382)
%res2384 = call ccc i1 @impc_true()
; set array
%val2385 = getelementptr [16 x i1], [16 x i1]* %res2383, i32 0, i32 %val2381
store i1 %res2384, i1* %val2385
%val2386 = load i32, i32* %indexPtr
%val2387 = add i32 %val2386, 3
%val2388 = load %VAO*, %VAO** %vaoPtr
%res2389 = call fastcc [16 x i1]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd(%VAO* %val2388)
%res2390 = call ccc i1 @impc_true()
; set array
%val2391 = getelementptr [16 x i1], [16 x i1]* %res2389, i32 0, i32 %val2387
store i1 %res2390, i1* %val2391
store i1 %res2390, i1* %ifptr2365
br label %ifcont2365

else2365:
br label %ifcont2365

ifcont2365:
%ifres2392 = load i1, i1* %ifptr2365

%val2394 = load i32, i32* %size_s_13Ptr
%cmp2395 = icmp ne i32 %val2394, 16
br i1 %cmp2395, label %then2393, label %else2393

then2393:
%val2396 = load i32, i32* %indexPtr
%val2397 = load %VAO*, %VAO** %vaoPtr
%res2398 = call fastcc [16 x i1]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd(%VAO* %val2397)
%res2399 = call ccc i1 @impc_true()
; set array
%val2400 = getelementptr [16 x i1], [16 x i1]* %res2398, i32 0, i32 %val2396
store i1 %res2399, i1* %val2400
store i1 %res2399, i1* %ifptr2393
br label %ifcont2393

else2393:
br label %ifcont2393

ifcont2393:
%ifres2401 = load i1, i1* %ifptr2393

%val2402 = load i32, i32* %indexPtr
%val2403 = load %VAO*, %VAO** %vaoPtr
%res2404 = call fastcc [16 x %VBO*]* @buffers_adhoc_W3wxNixWQk8qfCosVkFPKl0(%VAO* %val2403)
%val2405 = load %VBO*, %VBO** %vboPtr
; set array
%val2406 = getelementptr [16 x %VBO*], [16 x %VBO*]* %res2404, i32 0, i32 %val2402
store %VBO* %val2405, %VBO** %val2406
%val2407 = load i32, i32* @GL_ARRAY_BUFFER
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val2407, i32 0)
%val2411 = load i1, i1* %instance_attrPtr
br i1 %val2411, label %then2410, label %else2410

then2410:
%val2413 = load i32, i32* %size_s_13Ptr
%cmp2414 = icmp ne i32 %val2413, 16
br i1 %cmp2414, label %then2412, label %else2412

then2412:
%val2415 = load i32, i32* %size_s_13Ptr
%cmp2416 = icmp ne i32 %val2415, 16
store i1 %cmp2416, i1* %ifptr2412
br label %ifcont2412

else2412:
%res2417 = call ccc i1 @impc_false()
store i1 %res2417, i1* %ifptr2412
br label %ifcont2412

ifcont2412:
%ifres2418 = load i1, i1* %ifptr2412

store i1 %ifres2418, i1* %ifptr2410
br label %ifcont2410

else2410:
%res2419 = call ccc i1 @impc_false()
store i1 %res2419, i1* %ifptr2410
br label %ifcont2410

ifcont2410:
%ifres2420 = load i1, i1* %ifptr2410

br i1 %ifres2420, label %then2409, label %else2409

then2409:
%val2421 = load i32, i32* %indexPtr
call fastcc void @glVertexAttribDivisor_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val2421, i32 1)
%var2423 = bitcast [36 x i8]* @gsxtmgl-objects2173 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var2423)
br label %ifcont2409

else2409:
br label %ifcont2409

ifcont2409:
%val2427 = load i1, i1* %instance_attrPtr
br i1 %val2427, label %then2426, label %else2426

then2426:
%val2429 = load i32, i32* %size_s_13Ptr
%cmp2430 = icmp eq i32 %val2429, 16
br i1 %cmp2430, label %then2428, label %else2428

then2428:
%val2431 = load i32, i32* %size_s_13Ptr
%cmp2432 = icmp eq i32 %val2431, 16
store i1 %cmp2432, i1* %ifptr2428
br label %ifcont2428

else2428:
%res2433 = call ccc i1 @impc_false()
store i1 %res2433, i1* %ifptr2428
br label %ifcont2428

ifcont2428:
%ifres2434 = load i1, i1* %ifptr2428

store i1 %ifres2434, i1* %ifptr2426
br label %ifcont2426

else2426:
%res2435 = call ccc i1 @impc_false()
store i1 %res2435, i1* %ifptr2426
br label %ifcont2426

ifcont2426:
%ifres2436 = load i1, i1* %ifptr2426

br i1 %ifres2436, label %then2425, label %else2425

then2425:
%val2437 = load i32, i32* %indexPtr
%val2438 = add i32 %val2437, 0
call fastcc void @glVertexAttribDivisor_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val2438, i32 1)
%val2440 = load i32, i32* %indexPtr
%val2441 = add i32 %val2440, 1
call fastcc void @glVertexAttribDivisor_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val2441, i32 1)
%val2443 = load i32, i32* %indexPtr
%val2444 = add i32 %val2443, 2
call fastcc void @glVertexAttribDivisor_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val2444, i32 1)
%val2446 = load i32, i32* %indexPtr
%val2447 = add i32 %val2446, 3
call fastcc void @glVertexAttribDivisor_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val2447, i32 1)
%var2449 = bitcast [36 x i8]* @gsxtmgl-objects2173 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var2449)
br label %ifcont2425

else2425:
br label %ifcont2425

ifcont2425:
call fastcc void @glBindVertexArray_adhoc_W3ZvaWQsaTMyXQ(i32 0)
ret void
}
@gsxtmgl-objects2176 = hidden constant [126 x i8] c"set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}** @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2474 = load i8*, i8** %_impzPtr
%zone2475 = bitcast i8* %tzone2474 to %mzone*

; let assign value to symbol set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd
%dat_set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd = call i8* @llvm_zone_malloc(%mzone* %zone2475, i64 8)
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFdPtr = bitcast i8* %dat_set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}***
%tzone2455 = load i8*, i8** %_impzPtr
%zone2456 = bitcast i8* %tzone2455 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2456)
; malloc closure structure
%clsptr2457 = call i8* @llvm_zone_malloc(%mzone* %zone2456, i64 24)
%closure2458 = bitcast i8* %clsptr2457 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}*

; malloc environment structure
%envptr2459 = call i8* @llvm_zone_malloc(%mzone* %zone2456, i64 8)
%environment2460 = bitcast i8* %envptr2459 to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}***}*

; malloc closure address table
%addytable2461 = call %clsvar* @new_address_table()
%var2462 = bitcast [73 x i8]* @gsxtmgl-objects2174 to i8*
%var2463 = bitcast [74 x i8]* @gsxtmgl-objects2175 to i8*
%addytable2464 = call %clsvar* @add_address_table(%mzone* %zone2456, i8* %var2462, i32 0, i8* %var2463, i32 3, %clsvar* %addytable2461)
%address-table2465 = bitcast %clsvar* %addytable2464 to i8*

; insert table, function and environment into closure struct
%closure.table2468 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}* %closure2458, i32 0, i32 0
store i8* %address-table2465, i8** %closure.table2468
%closure.env2469 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}* %closure2458, i32 0, i32 1
store i8* %envptr2459, i8** %closure.env2469
%closure.func2470 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}* %closure2458, i32 0, i32 2
store void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd__2257, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)** %closure.func2470
%closure_size2471 = call i64 @llvm_zone_mark_size(%mzone* %zone2456)
call void @llvm_zone_ptr_set_size(i8* %clsptr2457, i64 %closure_size2471)
%wrapper_ptr2472 = call i8* @llvm_zone_malloc(%mzone* %zone2456, i64 8)
%closure_wrapper2473 = bitcast i8* %wrapper_ptr2472 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}* %closure2458, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}** %closure_wrapper2473

; let value assignment
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}** %closure_wrapper2473, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}** %closure_wrapper2473
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFdPtr

; add data to environment
; don't need to alloc for env var set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd
%tmp_envptr2467 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}***}* %environment2460, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFdPtr, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}**** %tmp_envptr2467


%val2476 = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFdPtr
ret {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}** %val2476
}


@set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}** @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5,i32 %arg_6,i1 %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i32 %arg_6, i1 %arg_7)
ret void
}


define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_native(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5,i32 %arg_6,i1 %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i32 %arg_6, i1 %arg_7)
ret void
}


define dllexport ccc i8*  @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2477 = bitcast [126 x i8]* @gsxtmgl-objects2176 to i8*
call i32 (i8*, ...) @printf(i8* %var2477)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2478 = bitcast [126 x i8]* @gsxtmgl-objects2176 to i8*
call i32 (i8*, ...) @printf(i8* %var2478)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %VBO*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2479 = bitcast [126 x i8]* @gsxtmgl-objects2176 to i8*
call i32 (i8*, ...) @printf(i8* %var2479)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2480 = bitcast [126 x i8]* @gsxtmgl-objects2176 to i8*
call i32 (i8*, ...) @printf(i8* %var2480)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2481 = bitcast [126 x i8]* @gsxtmgl-objects2176 to i8*
call i32 (i8*, ...) @printf(i8* %var2481)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var2482 = bitcast [126 x i8]* @gsxtmgl-objects2176 to i8*
call i32 (i8*, ...) @printf(i8* %var2482)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_integer(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var2483 = bitcast [126 x i8]* @gsxtmgl-objects2176 to i8*
call i32 (i8*, ...) @printf(i8* %var2483)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc i32  @i32value(i8* %arg_6_val)
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_integer(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var2484 = bitcast [126 x i8]* @gsxtmgl-objects2176 to i8*
call i32 (i8*, ...) @printf(i8* %var2484)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%arg_7 = call ccc i1  @i1value(i8* %arg_7_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i32 %arg_6, i1 %arg_7)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}*
%arg_p_0 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 1
%arg_1 = load %VBO*, %VBO** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 6
%arg_6 = load i32, i32* %arg_p_6
%arg_p_7 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 7
%arg_7 = load i1, i1* %arg_p_7
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i32 %arg_6, i1 %arg_7)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2177 = hidden constant [69 x i8] c"set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd\00"
@gsxtmgl-objects2178 = hidden constant [70 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}**\00"
define dllexport fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd__2485(i8* %_impz,i8* %_impenv, %VAO* %vao, %VBO* %vbo, i32 %type_s_15, i32 %index, i32 %size_s_16, i64 %stride_s_17, i32 %offset) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2486 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}***}*
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}***}* %impenv, i32 0, i32 0
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJdPtr = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}**** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJdPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr
%type_s_15Ptr = alloca i32
store i32 %type_s_15, i32* %type_s_15Ptr
%indexPtr = alloca i32
store i32 %index, i32* %indexPtr
%size_s_16Ptr = alloca i32
store i32 %size_s_16, i32* %size_s_16Ptr
%stride_s_17Ptr = alloca i64
store i64 %stride_s_17, i64* %stride_s_17Ptr
%offsetPtr = alloca i32
store i32 %offset, i32* %offsetPtr


%val2487 = load %VAO*, %VAO** %vaoPtr
%val2488 = load %VBO*, %VBO** %vboPtr
%val2489 = load i32, i32* %type_s_15Ptr
%val2490 = load i32, i32* %indexPtr
%val2491 = load i32, i32* %size_s_16Ptr
%val2492 = load i64, i64* %stride_s_17Ptr
%res2493 = call ccc i32 @i64toi32(i64 %val2492)
%val2494 = load i32, i32* %offsetPtr
%res2495 = call ccc i1 @impc_false()
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd(%VAO* %val2487, %VBO* %val2488, i32 %val2489, i32 %val2490, i32 %val2491, i32 %res2493, i32 %val2494, i1 %res2495)
ret void
}
@gsxtmgl-objects2179 = hidden constant [122 x i8] c"set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}** @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2516 = load i8*, i8** %_impzPtr
%zone2517 = bitcast i8* %tzone2516 to %mzone*

; let assign value to symbol set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd
%dat_set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone2517, i64 8)
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJdPtr = bitcast i8* %dat_set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}***
%tzone2497 = load i8*, i8** %_impzPtr
%zone2498 = bitcast i8* %tzone2497 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2498)
; malloc closure structure
%clsptr2499 = call i8* @llvm_zone_malloc(%mzone* %zone2498, i64 24)
%closure2500 = bitcast i8* %clsptr2499 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}*

; malloc environment structure
%envptr2501 = call i8* @llvm_zone_malloc(%mzone* %zone2498, i64 8)
%environment2502 = bitcast i8* %envptr2501 to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}***}*

; malloc closure address table
%addytable2503 = call %clsvar* @new_address_table()
%var2504 = bitcast [69 x i8]* @gsxtmgl-objects2177 to i8*
%var2505 = bitcast [70 x i8]* @gsxtmgl-objects2178 to i8*
%addytable2506 = call %clsvar* @add_address_table(%mzone* %zone2498, i8* %var2504, i32 0, i8* %var2505, i32 3, %clsvar* %addytable2503)
%address-table2507 = bitcast %clsvar* %addytable2506 to i8*

; insert table, function and environment into closure struct
%closure.table2510 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}* %closure2500, i32 0, i32 0
store i8* %address-table2507, i8** %closure.table2510
%closure.env2511 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}* %closure2500, i32 0, i32 1
store i8* %envptr2501, i8** %closure.env2511
%closure.func2512 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}* %closure2500, i32 0, i32 2
store void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd__2485, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)** %closure.func2512
%closure_size2513 = call i64 @llvm_zone_mark_size(%mzone* %zone2498)
call void @llvm_zone_ptr_set_size(i8* %clsptr2499, i64 %closure_size2513)
%wrapper_ptr2514 = call i8* @llvm_zone_malloc(%mzone* %zone2498, i64 8)
%closure_wrapper2515 = bitcast i8* %wrapper_ptr2514 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}* %closure2500, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}** %closure_wrapper2515

; let value assignment
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}** %closure_wrapper2515, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}** %closure_wrapper2515
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJdPtr

; add data to environment
; don't need to alloc for env var set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd
%tmp_envptr2509 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}***}* %environment2502, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJdPtr, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}**** %tmp_envptr2509


%val2518 = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJdPtr
ret {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}** %val2518
}


@set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}** @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i64 %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i64 %arg_5, i32 %arg_6)
ret void
}


define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_native(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i64 %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i64 %arg_5, i32 %arg_6)
ret void
}


define dllexport ccc i8*  @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2519 = bitcast [122 x i8]* @gsxtmgl-objects2179 to i8*
call i32 (i8*, ...) @printf(i8* %var2519)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2520 = bitcast [122 x i8]* @gsxtmgl-objects2179 to i8*
call i32 (i8*, ...) @printf(i8* %var2520)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %VBO*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2521 = bitcast [122 x i8]* @gsxtmgl-objects2179 to i8*
call i32 (i8*, ...) @printf(i8* %var2521)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2522 = bitcast [122 x i8]* @gsxtmgl-objects2179 to i8*
call i32 (i8*, ...) @printf(i8* %var2522)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2523 = bitcast [122 x i8]* @gsxtmgl-objects2179 to i8*
call i32 (i8*, ...) @printf(i8* %var2523)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var2524 = bitcast [122 x i8]* @gsxtmgl-objects2179 to i8*
call i32 (i8*, ...) @printf(i8* %var2524)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i64  @i64value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_integer(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var2525 = bitcast [122 x i8]* @gsxtmgl-objects2179 to i8*
call i32 (i8*, ...) @printf(i8* %var2525)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc i32  @i32value(i8* %arg_6_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i64 %arg_5, i32 %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, %VBO*, i32, i32, i32, i64, i32}*
%arg_p_0 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i64, i32}, {%VAO*, %VBO*, i32, i32, i32, i64, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i64, i32}, {%VAO*, %VBO*, i32, i32, i32, i64, i32}* %fstruct, i32 0, i32 1
%arg_1 = load %VBO*, %VBO** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i64, i32}, {%VAO*, %VBO*, i32, i32, i32, i64, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i64, i32}, {%VAO*, %VBO*, i32, i32, i32, i64, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i64, i32}, {%VAO*, %VBO*, i32, i32, i32, i64, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i64, i32}, {%VAO*, %VBO*, i32, i32, i32, i64, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i64, i64* %arg_p_5
%arg_p_6 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i64, i32}, {%VAO*, %VBO*, i32, i32, i32, i64, i32}* %fstruct, i32 0, i32 6
%arg_6 = load i32, i32* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGk2NCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i64, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i64 %arg_5, i32 %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2180 = hidden constant [64 x i8] c"set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0\00"
@gsxtmgl-objects2181 = hidden constant [65 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**\00"
define dllexport fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0__2526(i8* %_impz,i8* %_impenv, %VAO* %vao, %VBO* %vbo, i32 %index, i32 %size_s_18, i32 %stride_s_19, i32 %offset) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2527 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***}*
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr
%indexPtr = alloca i32
store i32 %index, i32* %indexPtr
%size_s_18Ptr = alloca i32
store i32 %size_s_18, i32* %size_s_18Ptr
%stride_s_19Ptr = alloca i32
store i32 %stride_s_19, i32* %stride_s_19Ptr
%offsetPtr = alloca i32
store i32 %offset, i32* %offsetPtr


%val2528 = load %VAO*, %VAO** %vaoPtr
%val2529 = load %VBO*, %VBO** %vboPtr
%val2530 = load %VBO*, %VBO** %vboPtr
%res2531 = call fastcc i32 @type_adhoc_W2kzMixWQk8qXQ(%VBO* %val2530)
%val2532 = load i32, i32* %indexPtr
%val2533 = load i32, i32* %size_s_18Ptr
%val2534 = load i32, i32* %stride_s_19Ptr
%val2535 = load i32, i32* %offsetPtr
%res2536 = call ccc i1 @impc_false()
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd(%VAO* %val2528, %VBO* %val2529, i32 %res2531, i32 %val2532, i32 %val2533, i32 %val2534, i32 %val2535, i1 %res2536)
ret void
}
@gsxtmgl-objects2182 = hidden constant [117 x i8] c"set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2557 = load i8*, i8** %_impzPtr
%zone2558 = bitcast i8* %tzone2557 to %mzone*

; let assign value to symbol set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0
%dat_set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2558, i64 8)
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***
%tzone2538 = load i8*, i8** %_impzPtr
%zone2539 = bitcast i8* %tzone2538 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2539)
; malloc closure structure
%clsptr2540 = call i8* @llvm_zone_malloc(%mzone* %zone2539, i64 24)
%closure2541 = bitcast i8* %clsptr2540 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr2542 = call i8* @llvm_zone_malloc(%mzone* %zone2539, i64 8)
%environment2543 = bitcast i8* %envptr2542 to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable2544 = call %clsvar* @new_address_table()
%var2545 = bitcast [64 x i8]* @gsxtmgl-objects2180 to i8*
%var2546 = bitcast [65 x i8]* @gsxtmgl-objects2181 to i8*
%addytable2547 = call %clsvar* @add_address_table(%mzone* %zone2539, i8* %var2545, i32 0, i8* %var2546, i32 3, %clsvar* %addytable2544)
%address-table2548 = bitcast %clsvar* %addytable2547 to i8*

; insert table, function and environment into closure struct
%closure.table2551 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure2541, i32 0, i32 0
store i8* %address-table2548, i8** %closure.table2551
%closure.env2552 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure2541, i32 0, i32 1
store i8* %envptr2542, i8** %closure.env2552
%closure.func2553 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure2541, i32 0, i32 2
store void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0__2526, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)** %closure.func2553
%closure_size2554 = call i64 @llvm_zone_mark_size(%mzone* %zone2539)
call void @llvm_zone_ptr_set_size(i8* %clsptr2540, i64 %closure_size2554)
%wrapper_ptr2555 = call i8* @llvm_zone_malloc(%mzone* %zone2539, i64 8)
%closure_wrapper2556 = bitcast i8* %wrapper_ptr2555 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure2541, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_wrapper2556

; let value assignment
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_wrapper2556, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_wrapper2556
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0
%tmp_envptr2550 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***}* %environment2543, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**** %tmp_envptr2550


%val2559 = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %val2559
}


@set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret void
}


define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_native(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret void
}


define dllexport ccc i8*  @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2560 = bitcast [117 x i8]* @gsxtmgl-objects2182 to i8*
call i32 (i8*, ...) @printf(i8* %var2560)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2561 = bitcast [117 x i8]* @gsxtmgl-objects2182 to i8*
call i32 (i8*, ...) @printf(i8* %var2561)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %VBO*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2562 = bitcast [117 x i8]* @gsxtmgl-objects2182 to i8*
call i32 (i8*, ...) @printf(i8* %var2562)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2563 = bitcast [117 x i8]* @gsxtmgl-objects2182 to i8*
call i32 (i8*, ...) @printf(i8* %var2563)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2564 = bitcast [117 x i8]* @gsxtmgl-objects2182 to i8*
call i32 (i8*, ...) @printf(i8* %var2564)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var2565 = bitcast [117 x i8]* @gsxtmgl-objects2182 to i8*
call i32 (i8*, ...) @printf(i8* %var2565)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, %VBO*, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32}, {%VAO*, %VBO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32}, {%VAO*, %VBO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load %VBO*, %VBO** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32}, {%VAO*, %VBO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32}, {%VAO*, %VBO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32}, {%VAO*, %VBO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32}, {%VAO*, %VBO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2183 = hidden constant [68 x i8] c"set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0\00"
@gsxtmgl-objects2184 = hidden constant [69 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}**\00"
define dllexport fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0__2566(i8* %_impz,i8* %_impenv, %VAO* %vao, %VBO* %vbo, i32 %index, i32 %size_s_20, i32 %stride_s_21, i32 %offset, i1 %instance_attr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2567 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}***}*
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}***}* %impenv, i32 0, i32 0
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0Ptr = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}**** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0Ptr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr
%indexPtr = alloca i32
store i32 %index, i32* %indexPtr
%size_s_20Ptr = alloca i32
store i32 %size_s_20, i32* %size_s_20Ptr
%stride_s_21Ptr = alloca i32
store i32 %stride_s_21, i32* %stride_s_21Ptr
%offsetPtr = alloca i32
store i32 %offset, i32* %offsetPtr
%instance_attrPtr = alloca i1
store i1 %instance_attr, i1* %instance_attrPtr


%val2568 = load %VAO*, %VAO** %vaoPtr
%val2569 = load %VBO*, %VBO** %vboPtr
%val2570 = load %VBO*, %VBO** %vboPtr
%res2571 = call fastcc i32 @type_adhoc_W2kzMixWQk8qXQ(%VBO* %val2570)
%val2572 = load i32, i32* %indexPtr
%val2573 = load i32, i32* %size_s_20Ptr
%val2574 = load i32, i32* %stride_s_21Ptr
%val2575 = load i32, i32* %offsetPtr
%val2576 = load i1, i1* %instance_attrPtr
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd(%VAO* %val2568, %VBO* %val2569, i32 %res2571, i32 %val2572, i32 %val2573, i32 %val2574, i32 %val2575, i1 %val2576)
ret void
}
@gsxtmgl-objects2185 = hidden constant [121 x i8] c"set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}** @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2597 = load i8*, i8** %_impzPtr
%zone2598 = bitcast i8* %tzone2597 to %mzone*

; let assign value to symbol set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0
%dat_set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0 = call i8* @llvm_zone_malloc(%mzone* %zone2598, i64 8)
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0Ptr = bitcast i8* %dat_set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}***
%tzone2578 = load i8*, i8** %_impzPtr
%zone2579 = bitcast i8* %tzone2578 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2579)
; malloc closure structure
%clsptr2580 = call i8* @llvm_zone_malloc(%mzone* %zone2579, i64 24)
%closure2581 = bitcast i8* %clsptr2580 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}*

; malloc environment structure
%envptr2582 = call i8* @llvm_zone_malloc(%mzone* %zone2579, i64 8)
%environment2583 = bitcast i8* %envptr2582 to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}***}*

; malloc closure address table
%addytable2584 = call %clsvar* @new_address_table()
%var2585 = bitcast [68 x i8]* @gsxtmgl-objects2183 to i8*
%var2586 = bitcast [69 x i8]* @gsxtmgl-objects2184 to i8*
%addytable2587 = call %clsvar* @add_address_table(%mzone* %zone2579, i8* %var2585, i32 0, i8* %var2586, i32 3, %clsvar* %addytable2584)
%address-table2588 = bitcast %clsvar* %addytable2587 to i8*

; insert table, function and environment into closure struct
%closure.table2591 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}* %closure2581, i32 0, i32 0
store i8* %address-table2588, i8** %closure.table2591
%closure.env2592 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}* %closure2581, i32 0, i32 1
store i8* %envptr2582, i8** %closure.env2592
%closure.func2593 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}* %closure2581, i32 0, i32 2
store void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0__2566, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)** %closure.func2593
%closure_size2594 = call i64 @llvm_zone_mark_size(%mzone* %zone2579)
call void @llvm_zone_ptr_set_size(i8* %clsptr2580, i64 %closure_size2594)
%wrapper_ptr2595 = call i8* @llvm_zone_malloc(%mzone* %zone2579, i64 8)
%closure_wrapper2596 = bitcast i8* %wrapper_ptr2595 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}* %closure2581, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}** %closure_wrapper2596

; let value assignment
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}** %closure_wrapper2596, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}** %closure_wrapper2596
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0Ptr

; add data to environment
; don't need to alloc for env var set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0
%tmp_envptr2590 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}***}* %environment2583, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0Ptr, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}**** %tmp_envptr2590


%val2599 = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0Ptr
ret {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}** %val2599
}


@set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_var = dllexport global [1 x i8*] [ i8* null ]

@set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}** @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5,i1 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i1 %arg_6)
ret void
}


define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_native(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5,i1 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i1 %arg_6)
ret void
}


define dllexport ccc i8*  @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2600 = bitcast [121 x i8]* @gsxtmgl-objects2185 to i8*
call i32 (i8*, ...) @printf(i8* %var2600)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2601 = bitcast [121 x i8]* @gsxtmgl-objects2185 to i8*
call i32 (i8*, ...) @printf(i8* %var2601)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %VBO*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2602 = bitcast [121 x i8]* @gsxtmgl-objects2185 to i8*
call i32 (i8*, ...) @printf(i8* %var2602)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2603 = bitcast [121 x i8]* @gsxtmgl-objects2185 to i8*
call i32 (i8*, ...) @printf(i8* %var2603)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2604 = bitcast [121 x i8]* @gsxtmgl-objects2185 to i8*
call i32 (i8*, ...) @printf(i8* %var2604)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var2605 = bitcast [121 x i8]* @gsxtmgl-objects2185 to i8*
call i32 (i8*, ...) @printf(i8* %var2605)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_integer(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var2606 = bitcast [121 x i8]* @gsxtmgl-objects2185 to i8*
call i32 (i8*, ...) @printf(i8* %var2606)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc i1  @i1value(i8* %arg_6_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i1 %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, %VBO*, i32, i32, i32, i32, i1}*
%arg_p_0 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 1
%arg_1 = load %VBO*, %VBO** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i32, i32, i1}* %fstruct, i32 0, i32 6
%arg_6 = load i1, i1* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i1 %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2186 = hidden constant [53 x i8] c"set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd\00"
@gsxtmgl-objects2187 = hidden constant [55 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**\00"
define dllexport fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd__2607(i8* %_impz,i8* %_impenv, %VAO* %vao, %VBO* %vbo, i32 %index, i32 %size_s_22) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2608 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***}*
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***}* %impenv, i32 0, i32 0
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr
%indexPtr = alloca i32
store i32 %index, i32* %indexPtr
%size_s_22Ptr = alloca i32
store i32 %size_s_22, i32* %size_s_22Ptr


%val2609 = load %VAO*, %VAO** %vaoPtr
%val2610 = load %VBO*, %VBO** %vboPtr
%val2611 = load %VBO*, %VBO** %vboPtr
%res2612 = call fastcc i32 @type_adhoc_W2kzMixWQk8qXQ(%VBO* %val2611)
%val2613 = load i32, i32* %indexPtr
%val2614 = load i32, i32* %size_s_22Ptr
%res2615 = call ccc i1 @impc_false()
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd(%VAO* %val2609, %VBO* %val2610, i32 %res2612, i32 %val2613, i32 %val2614, i32 0, i32 0, i1 %res2615)
ret void
}
@gsxtmgl-objects2188 = hidden constant [106 x i8] c"set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2636 = load i8*, i8** %_impzPtr
%zone2637 = bitcast i8* %tzone2636 to %mzone*

; let assign value to symbol set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd
%dat_set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone2637, i64 8)
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr = bitcast i8* %dat_set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***
%tzone2617 = load i8*, i8** %_impzPtr
%zone2618 = bitcast i8* %tzone2617 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2618)
; malloc closure structure
%clsptr2619 = call i8* @llvm_zone_malloc(%mzone* %zone2618, i64 24)
%closure2620 = bitcast i8* %clsptr2619 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*

; malloc environment structure
%envptr2621 = call i8* @llvm_zone_malloc(%mzone* %zone2618, i64 8)
%environment2622 = bitcast i8* %envptr2621 to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***}*

; malloc closure address table
%addytable2623 = call %clsvar* @new_address_table()
%var2624 = bitcast [53 x i8]* @gsxtmgl-objects2186 to i8*
%var2625 = bitcast [55 x i8]* @gsxtmgl-objects2187 to i8*
%addytable2626 = call %clsvar* @add_address_table(%mzone* %zone2618, i8* %var2624, i32 0, i8* %var2625, i32 3, %clsvar* %addytable2623)
%address-table2627 = bitcast %clsvar* %addytable2626 to i8*

; insert table, function and environment into closure struct
%closure.table2630 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure2620, i32 0, i32 0
store i8* %address-table2627, i8** %closure.table2630
%closure.env2631 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure2620, i32 0, i32 1
store i8* %envptr2621, i8** %closure.env2631
%closure.func2632 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure2620, i32 0, i32 2
store void (i8*, i8*, %VAO*, %VBO*, i32, i32)* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd__2607, void (i8*, i8*, %VAO*, %VBO*, i32, i32)** %closure.func2632
%closure_size2633 = call i64 @llvm_zone_mark_size(%mzone* %zone2618)
call void @llvm_zone_ptr_set_size(i8* %clsptr2619, i64 %closure_size2633)
%wrapper_ptr2634 = call i8* @llvm_zone_malloc(%mzone* %zone2618, i64 8)
%closure_wrapper2635 = bitcast i8* %wrapper_ptr2634 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure2620, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_wrapper2635

; let value assignment
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_wrapper2635, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_wrapper2635
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd
%tmp_envptr2629 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***}* %environment2622, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**** %tmp_envptr2629


%val2638 = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr
ret {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %val2638
}


@set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3)
ret void
}


define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_native(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3)
ret void
}


define dllexport ccc i8*  @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2639 = bitcast [106 x i8]* @gsxtmgl-objects2188 to i8*
call i32 (i8*, ...) @printf(i8* %var2639)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2640 = bitcast [106 x i8]* @gsxtmgl-objects2188 to i8*
call i32 (i8*, ...) @printf(i8* %var2640)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %VBO*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2641 = bitcast [106 x i8]* @gsxtmgl-objects2188 to i8*
call i32 (i8*, ...) @printf(i8* %var2641)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2642 = bitcast [106 x i8]* @gsxtmgl-objects2188 to i8*
call i32 (i8*, ...) @printf(i8* %var2642)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, %VBO*, i32, i32}*
%arg_p_0 = getelementptr {%VAO*, %VBO*, i32, i32}, {%VAO*, %VBO*, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, %VBO*, i32, i32}, {%VAO*, %VBO*, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load %VBO*, %VBO** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, %VBO*, i32, i32}, {%VAO*, %VBO*, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%VAO*, %VBO*, i32, i32}, {%VAO*, %VBO*, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2189 = hidden constant [57 x i8] c"set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd\00"
@gsxtmgl-objects2190 = hidden constant [59 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}**\00"
define dllexport fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd__2643(i8* %_impz,i8* %_impenv, %VAO* %vao, %VBO* %vbo, i32 %index, i32 %size_s_23, i1 %instance_attr) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2644 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}***}*
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}***}* %impenv, i32 0, i32 0
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFdPtr = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}**** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFdPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr
%indexPtr = alloca i32
store i32 %index, i32* %indexPtr
%size_s_23Ptr = alloca i32
store i32 %size_s_23, i32* %size_s_23Ptr
%instance_attrPtr = alloca i1
store i1 %instance_attr, i1* %instance_attrPtr


%val2645 = load %VAO*, %VAO** %vaoPtr
%val2646 = load %VBO*, %VBO** %vboPtr
%val2647 = load %VBO*, %VBO** %vboPtr
%res2648 = call fastcc i32 @type_adhoc_W2kzMixWQk8qXQ(%VBO* %val2647)
%val2649 = load i32, i32* %indexPtr
%val2650 = load i32, i32* %size_s_23Ptr
%val2651 = load i1, i1* %instance_attrPtr
call fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMixpMzIsaTFd(%VAO* %val2645, %VBO* %val2646, i32 %res2648, i32 %val2649, i32 %val2650, i32 0, i32 0, i1 %val2651)
ret void
}
@gsxtmgl-objects2191 = hidden constant [110 x i8] c"set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}** @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2672 = load i8*, i8** %_impzPtr
%zone2673 = bitcast i8* %tzone2672 to %mzone*

; let assign value to symbol set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd
%dat_set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd = call i8* @llvm_zone_malloc(%mzone* %zone2673, i64 8)
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFdPtr = bitcast i8* %dat_set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}***
%tzone2653 = load i8*, i8** %_impzPtr
%zone2654 = bitcast i8* %tzone2653 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2654)
; malloc closure structure
%clsptr2655 = call i8* @llvm_zone_malloc(%mzone* %zone2654, i64 24)
%closure2656 = bitcast i8* %clsptr2655 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}*

; malloc environment structure
%envptr2657 = call i8* @llvm_zone_malloc(%mzone* %zone2654, i64 8)
%environment2658 = bitcast i8* %envptr2657 to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}***}*

; malloc closure address table
%addytable2659 = call %clsvar* @new_address_table()
%var2660 = bitcast [57 x i8]* @gsxtmgl-objects2189 to i8*
%var2661 = bitcast [59 x i8]* @gsxtmgl-objects2190 to i8*
%addytable2662 = call %clsvar* @add_address_table(%mzone* %zone2654, i8* %var2660, i32 0, i8* %var2661, i32 3, %clsvar* %addytable2659)
%address-table2663 = bitcast %clsvar* %addytable2662 to i8*

; insert table, function and environment into closure struct
%closure.table2666 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}* %closure2656, i32 0, i32 0
store i8* %address-table2663, i8** %closure.table2666
%closure.env2667 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}* %closure2656, i32 0, i32 1
store i8* %envptr2657, i8** %closure.env2667
%closure.func2668 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}* %closure2656, i32 0, i32 2
store void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd__2643, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)** %closure.func2668
%closure_size2669 = call i64 @llvm_zone_mark_size(%mzone* %zone2654)
call void @llvm_zone_ptr_set_size(i8* %clsptr2655, i64 %closure_size2669)
%wrapper_ptr2670 = call i8* @llvm_zone_malloc(%mzone* %zone2654, i64 8)
%closure_wrapper2671 = bitcast i8* %wrapper_ptr2670 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}* %closure2656, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}** %closure_wrapper2671

; let value assignment
%set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}** %closure_wrapper2671, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}** %closure_wrapper2671
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFdPtr

; add data to environment
; don't need to alloc for env var set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd
%tmp_envptr2665 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}***}* %environment2658, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFdPtr, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}**** %tmp_envptr2665


%val2674 = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}*** %set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFdPtr
ret {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}** %val2674
}


@set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_var = dllexport global [1 x i8*] [ i8* null ]

@set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}** @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3,i1 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i1 %arg_4)
ret void
}


define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_native(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3,i1 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i1 %arg_4)
ret void
}


define dllexport ccc i8*  @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2675 = bitcast [110 x i8]* @gsxtmgl-objects2191 to i8*
call i32 (i8*, ...) @printf(i8* %var2675)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2676 = bitcast [110 x i8]* @gsxtmgl-objects2191 to i8*
call i32 (i8*, ...) @printf(i8* %var2676)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %VBO*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2677 = bitcast [110 x i8]* @gsxtmgl-objects2191 to i8*
call i32 (i8*, ...) @printf(i8* %var2677)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2678 = bitcast [110 x i8]* @gsxtmgl-objects2191 to i8*
call i32 (i8*, ...) @printf(i8* %var2678)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2679 = bitcast [110 x i8]* @gsxtmgl-objects2191 to i8*
call i32 (i8*, ...) @printf(i8* %var2679)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i1  @i1value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i1 %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, %VBO*, i32, i32, i1}*
%arg_p_0 = getelementptr {%VAO*, %VBO*, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, %VBO*, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i1}* %fstruct, i32 0, i32 1
%arg_1 = load %VBO*, %VBO** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, %VBO*, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i1}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%VAO*, %VBO*, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i1}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {%VAO*, %VBO*, i32, i32, i1}, {%VAO*, %VBO*, i32, i32, i1}* %fstruct, i32 0, i32 4
%arg_4 = load i1, i1* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @set_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTFd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i1 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2192 = hidden constant [27 x i8] c"Error binding vertex array\00"
@gsxtmgl-objects2193 = hidden constant [38 x i8] c"Error enablling attrib arrays in VAO!\00"
@gsxtmgl-objects2194 = hidden constant [19 x i8] c"Error drawing VAO!\00"
@gsxtmgl-objects2195 = hidden constant [38 x i8] c"Error disabling attrib arrays in VAO!\00"
@gsxtmgl-objects2196 = hidden constant [48 x i8] c"draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd\00"
@gsxtmgl-objects2197 = hidden constant [58 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}**\00"
@gsxtmgl-objects2198 = hidden constant [15 x i8] c"_anon_lambda_1\00"
define dllexport fastcc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd__2680(i8* %_impz,i8* %_impenv, %VAO* %vao, i32 %draw_mode, i32 %first_element, i32 %count, i32 %instances) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2683 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}*
%draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJdPtr = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}**** %draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJdPtr_
%iPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 1
%iPtr = load i32*, i32** %iPtr_
%_anon_lambda_1Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 2
%_anon_lambda_1Ptr = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}**** %_anon_lambda_1Ptr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%draw_modePtr = alloca i32
store i32 %draw_mode, i32* %draw_modePtr
%first_elementPtr = alloca i32
store i32 %first_element, i32* %first_elementPtr
%countPtr = alloca i32
store i32 %count, i32* %countPtr
%instancesPtr = alloca i32
store i32 %instances, i32* %instancesPtr


%val2684 = load %VAO*, %VAO** %vaoPtr
%res2685 = call fastcc i32 @id_adhoc_W2kzMixWQU8qXQ(%VAO* %val2684)
call fastcc void @glBindVertexArray_adhoc_W3ZvaWQsaTMyXQ(i32 %res2685)
%var2687 = bitcast [27 x i8]* @gsxtmgl-objects2192 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var2687)
; setup loop
store i32 0, i32* %iPtr
%val2698 = load i32, i32* %iPtr
%num2699 = add i32 16, %val2698
%comp2700 = icmp ult i32 16, 1
br i1 %comp2700, label %after2689, label %loop2689

loop2689:
%val2691 = load i32, i32* %iPtr
%val2692 = load %VAO*, %VAO** %vaoPtr
%res2693 = call fastcc [16 x i1]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd(%VAO* %val2692)
; array ref
%_val2694 = getelementptr [16 x i1], [16 x i1]* %res2693, i32 0, i32 %val2691
%val2695 = load i1, i1* %_val2694
br i1 %val2695, label %then2690, label %else2690

then2690:
%val2696 = load i32, i32* %iPtr
call fastcc void @glEnableVertexAttribArray_adhoc_W3ZvaWQsaTMyXQ(i32 %val2696)
br label %ifcont2690

else2690:
br label %ifcont2690

ifcont2690:
%loop_cnt2689 = load i32, i32* %iPtr
%next2689 = add i32 %loop_cnt2689, 1
store i32 %next2689, i32* %iPtr
%cmp2689 = icmp ult i32 %next2689, %num2699
br i1 %cmp2689, label %loop2689, label %after2689

after2689:
%var2702 = bitcast [38 x i8]* @gsxtmgl-objects2193 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var2702)
%val2705 = load i32, i32* %instancesPtr
%cmp2706 = icmp sgt i32 %val2705, 0
br i1 %cmp2706, label %then2704, label %else2704

then2704:
%val2707 = load i32, i32* %draw_modePtr
%val2708 = load i32, i32* %first_elementPtr
%val2709 = load i32, i32* %countPtr
%val2710 = load i32, i32* %instancesPtr
call fastcc void @glDrawArraysInstanced_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyXQ(i32 %val2707, i32 %val2708, i32 %val2709, i32 %val2710)
br label %ifcont2704

else2704:
%val2712 = load i32, i32* %draw_modePtr
%val2713 = load i32, i32* %first_elementPtr
%val2714 = load i32, i32* %countPtr
call fastcc void @glDrawArrays_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val2712, i32 %val2713, i32 %val2714)
br label %ifcont2704

ifcont2704:
%var2716 = bitcast [19 x i8]* @gsxtmgl-objects2194 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var2716)
; setup loop
store i32 0, i32* %iPtr
%val2727 = load i32, i32* %iPtr
%num2728 = add i32 16, %val2727
%comp2729 = icmp ult i32 16, 1
br i1 %comp2729, label %after2718, label %loop2718

loop2718:
%val2720 = load i32, i32* %iPtr
%val2721 = load %VAO*, %VAO** %vaoPtr
%res2722 = call fastcc [16 x i1]* @attribs_adhoc_W3wxNixpMXwqLFZBTypd(%VAO* %val2721)
; array ref
%_val2723 = getelementptr [16 x i1], [16 x i1]* %res2722, i32 0, i32 %val2720
%val2724 = load i1, i1* %_val2723
br i1 %val2724, label %then2719, label %else2719

then2719:
%val2725 = load i32, i32* %iPtr
call fastcc void @glDisableVertexAttribArray_adhoc_W3ZvaWQsaTMyXQ(i32 %val2725)
br label %ifcont2719

else2719:
br label %ifcont2719

ifcont2719:
%loop_cnt2718 = load i32, i32* %iPtr
%next2718 = add i32 %loop_cnt2718, 1
store i32 %next2718, i32* %iPtr
%cmp2718 = icmp ult i32 %next2718, %num2728
br i1 %cmp2718, label %loop2718, label %after2718

after2718:
%var2731 = bitcast [38 x i8]* @gsxtmgl-objects2195 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var2731)
call fastcc void @glBindVertexArray_adhoc_W3ZvaWQsaTMyXQ(i32 0)
ret void
}
@gsxtmgl-objects2199 = hidden constant [101 x i8] c"draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2766 = load i8*, i8** %_impzPtr
%zone2767 = bitcast i8* %tzone2766 to %mzone*

; let assign value to symbol draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd
%dat_draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone2767, i64 8)
%draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJdPtr = bitcast i8* %dat_draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***
%tzone2681 = load i8*, i8** %_impzPtr
%zone2682 = bitcast i8* %tzone2681 to %mzone*

; let assign value to symbol i
%dat_i = call i8* @llvm_zone_malloc(%mzone* %zone2682, i64 4)
%iPtr = bitcast i8* %dat_i to i32*

; let value assignment
%i = select i1 true, i32 0, i32 0
store i32 %i, i32* %iPtr

%tzone2763 = load i8*, i8** %_impzPtr
%zone2764 = bitcast i8* %tzone2763 to %mzone*

; let assign value to symbol _anon_lambda_1
%dat__anon_lambda_1 = call i8* @llvm_zone_malloc(%mzone* %zone2764, i64 8)
%_anon_lambda_1Ptr = bitcast i8* %dat__anon_lambda_1 to { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***
%tzone2734 = load i8*, i8** %_impzPtr
%zone2735 = bitcast i8* %tzone2734 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2735)
; malloc closure structure
%clsptr2736 = call i8* @llvm_zone_malloc(%mzone* %zone2735, i64 24)
%closure2737 = bitcast i8* %clsptr2736 to { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr2738 = call i8* @llvm_zone_malloc(%mzone* %zone2735, i64 24)
%environment2739 = bitcast i8* %envptr2738 to {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable2740 = call %clsvar* @new_address_table()
%var2741 = bitcast [48 x i8]* @gsxtmgl-objects2196 to i8*
%var2742 = bitcast [58 x i8]* @gsxtmgl-objects2197 to i8*
%addytable2743 = call %clsvar* @add_address_table(%mzone* %zone2735, i8* %var2741, i32 0, i8* %var2742, i32 3, %clsvar* %addytable2740)
%var2744 = bitcast [2 x i8]* @gsxtmgl-objects2153 to i8*
%var2745 = bitcast [4 x i8]* @gsxtmgl-objects274 to i8*
%addytable2746 = call %clsvar* @add_address_table(%mzone* %zone2735, i8* %var2744, i32 8, i8* %var2745, i32 3, %clsvar* %addytable2743)
%var2747 = bitcast [15 x i8]* @gsxtmgl-objects2198 to i8*
%var2748 = bitcast [58 x i8]* @gsxtmgl-objects2197 to i8*
%addytable2749 = call %clsvar* @add_address_table(%mzone* %zone2735, i8* %var2747, i32 16, i8* %var2748, i32 3, %clsvar* %addytable2746)
%address-table2750 = bitcast %clsvar* %addytable2749 to i8*

; insert table, function and environment into closure struct
%closure.table2757 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}* %closure2737, i32 0, i32 0
store i8* %address-table2750, i8** %closure.table2757
%closure.env2758 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}* %closure2737, i32 0, i32 1
store i8* %envptr2738, i8** %closure.env2758
%closure.func2759 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}* %closure2737, i32 0, i32 2
store void (i8*, i8*, %VAO*, i32, i32, i32, i32)* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd__2680, void (i8*, i8*, %VAO*, i32, i32, i32, i32)** %closure.func2759
%closure_size2760 = call i64 @llvm_zone_mark_size(%mzone* %zone2735)
call void @llvm_zone_ptr_set_size(i8* %clsptr2736, i64 %closure_size2760)
%wrapper_ptr2761 = call i8* @llvm_zone_malloc(%mzone* %zone2735, i64 8)
%closure_wrapper2762 = bitcast i8* %wrapper_ptr2761 to { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}* %closure2737, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %closure_wrapper2762

; let value assignment
%_anon_lambda_1 = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %closure_wrapper2762, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %closure_wrapper2762
store { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %_anon_lambda_1, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}*** %_anon_lambda_1Ptr

; add data to environment
; don't need to alloc for env var draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd
%tmp_envptr2752 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}* %environment2739, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}*** %draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJdPtr, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}**** %tmp_envptr2752

; don't need to alloc for env var i
%tmp_envptr2754 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}* %environment2739, i32 0, i32 1
store i32* %iPtr, i32** %tmp_envptr2754

; don't need to alloc for env var _anon_lambda_1
%tmp_envptr2756 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***, i32*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}***}* %environment2739, i32 0, i32 2
store {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}*** %_anon_lambda_1Ptr, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}**** %tmp_envptr2756


%val2765 = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}*** %_anon_lambda_1Ptr

; let value assignment
%draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd = select i1 true, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %val2765, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %val2765
store {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}*** %draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJdPtr

%val2768 = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}*** %draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJdPtr
ret {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %val2768
}


@draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd(%VAO* %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32, i32, i32, i32)*,  void (i8*, i8*, %VAO*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
ret void
}


define dllexport ccc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_native(%VAO* %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32, i32, i32, i32)*,  void (i8*, i8*, %VAO*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
ret void
}


define dllexport ccc i8*  @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2769 = bitcast [101 x i8]* @gsxtmgl-objects2199 to i8*
call i32 (i8*, ...) @printf(i8* %var2769)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2770 = bitcast [101 x i8]* @gsxtmgl-objects2199 to i8*
call i32 (i8*, ...) @printf(i8* %var2770)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2771 = bitcast [101 x i8]* @gsxtmgl-objects2199 to i8*
call i32 (i8*, ...) @printf(i8* %var2771)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2772 = bitcast [101 x i8]* @gsxtmgl-objects2199 to i8*
call i32 (i8*, ...) @printf(i8* %var2772)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2773 = bitcast [101 x i8]* @gsxtmgl-objects2199 to i8*
call i32 (i8*, ...) @printf(i8* %var2773)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32, i32, i32, i32)*,  void (i8*, i8*, %VAO*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {%VAO*, i32, i32, i32, i32}, {%VAO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, i32, i32, i32, i32}, {%VAO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%VAO*, i32, i32, i32, i32}, {%VAO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%VAO*, i32, i32, i32, i32}, {%VAO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {%VAO*, i32, i32, i32, i32}, {%VAO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32, i32, i32, i32)*,  void (i8*, i8*, %VAO*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2200 = hidden constant [43 x i8] c"draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0\00"
@gsxtmgl-objects2201 = hidden constant [53 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**\00"
define dllexport fastcc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0__2774(i8* %_impz,i8* %_impenv, %VAO* %vao, i32 %draw_mode, i32 %first_element, i32 %count) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2775 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***}*
%draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**** %draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%draw_modePtr = alloca i32
store i32 %draw_mode, i32* %draw_modePtr
%first_elementPtr = alloca i32
store i32 %first_element, i32* %first_elementPtr
%countPtr = alloca i32
store i32 %count, i32* %countPtr


%val2776 = load %VAO*, %VAO** %vaoPtr
%val2777 = load i32, i32* %draw_modePtr
%val2778 = load i32, i32* %first_elementPtr
%val2779 = load i32, i32* %countPtr
call fastcc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMixpMzJd(%VAO* %val2776, i32 %val2777, i32 %val2778, i32 %val2779, i32 0)
ret void
}
@gsxtmgl-objects2202 = hidden constant [96 x i8] c"draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2800 = load i8*, i8** %_impzPtr
%zone2801 = bitcast i8* %tzone2800 to %mzone*

; let assign value to symbol draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0
%dat_draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2801, i64 8)
%draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0 to { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***
%tzone2781 = load i8*, i8** %_impzPtr
%zone2782 = bitcast i8* %tzone2781 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2782)
; malloc closure structure
%clsptr2783 = call i8* @llvm_zone_malloc(%mzone* %zone2782, i64 24)
%closure2784 = bitcast i8* %clsptr2783 to { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*

; malloc environment structure
%envptr2785 = call i8* @llvm_zone_malloc(%mzone* %zone2782, i64 8)
%environment2786 = bitcast i8* %envptr2785 to {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***}*

; malloc closure address table
%addytable2787 = call %clsvar* @new_address_table()
%var2788 = bitcast [43 x i8]* @gsxtmgl-objects2200 to i8*
%var2789 = bitcast [53 x i8]* @gsxtmgl-objects2201 to i8*
%addytable2790 = call %clsvar* @add_address_table(%mzone* %zone2782, i8* %var2788, i32 0, i8* %var2789, i32 3, %clsvar* %addytable2787)
%address-table2791 = bitcast %clsvar* %addytable2790 to i8*

; insert table, function and environment into closure struct
%closure.table2794 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure2784, i32 0, i32 0
store i8* %address-table2791, i8** %closure.table2794
%closure.env2795 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure2784, i32 0, i32 1
store i8* %envptr2785, i8** %closure.env2795
%closure.func2796 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure2784, i32 0, i32 2
store void (i8*, i8*, %VAO*, i32, i32, i32)* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0__2774, void (i8*, i8*, %VAO*, i32, i32, i32)** %closure.func2796
%closure_size2797 = call i64 @llvm_zone_mark_size(%mzone* %zone2782)
call void @llvm_zone_ptr_set_size(i8* %clsptr2783, i64 %closure_size2797)
%wrapper_ptr2798 = call i8* @llvm_zone_malloc(%mzone* %zone2782, i64 8)
%closure_wrapper2799 = bitcast i8* %wrapper_ptr2798 to { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure2784, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_wrapper2799

; let value assignment
%draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_wrapper2799, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_wrapper2799
store { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*** %draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0
%tmp_envptr2793 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***}* %environment2786, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*** %draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**** %tmp_envptr2793


%val2802 = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*** %draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %val2802
}


@draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0(%VAO* %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32, i32, i32)*,  void (i8*, i8*, %VAO*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret void
}


define dllexport ccc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_native(%VAO* %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32, i32, i32)*,  void (i8*, i8*, %VAO*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret void
}


define dllexport ccc i8*  @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2803 = bitcast [96 x i8]* @gsxtmgl-objects2202 to i8*
call i32 (i8*, ...) @printf(i8* %var2803)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2804 = bitcast [96 x i8]* @gsxtmgl-objects2202 to i8*
call i32 (i8*, ...) @printf(i8* %var2804)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2805 = bitcast [96 x i8]* @gsxtmgl-objects2202 to i8*
call i32 (i8*, ...) @printf(i8* %var2805)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2806 = bitcast [96 x i8]* @gsxtmgl-objects2202 to i8*
call i32 (i8*, ...) @printf(i8* %var2806)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32, i32, i32)*,  void (i8*, i8*, %VAO*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, i32, i32, i32}*
%arg_p_0 = getelementptr {%VAO*, i32, i32, i32}, {%VAO*, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, i32, i32, i32}, {%VAO*, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%VAO*, i32, i32, i32}, {%VAO*, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%VAO*, i32, i32, i32}, {%VAO*, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @draw_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32, i32, i32)*,  void (i8*, i8*, %VAO*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%Texture = type {i32,i32,i32,i32,i8*}
@gsxtmgl-objects2203 = hidden constant [55 x i8] c"Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd\00"
@gsxtmgl-objects2204 = hidden constant [61 x i8] c"{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**\00"
define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd__2807(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2808 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}*
%Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}* %impenv, i32 0, i32 0
%Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i8*
store i8* %arg_4, i8** %arg_4Ptr


%tzone2813 = load i8*, i8** %_impzPtr
%zone2814 = bitcast i8* %tzone2813 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Texture*
%tzone2809 = load i8*, i8** %_impzPtr
%zone2810 = bitcast i8* %tzone2809 to %mzone*
%dat2811 = call i8* @llvm_zone_malloc(%mzone* %zone2810, i64 24)
call i8* @memset(i8* %dat2811, i32 0, i64 24)
%val2812 = bitcast i8* %dat2811 to %Texture*

; let value assignment
%obj = select i1 true, %Texture* %val2812, %Texture* %val2812
store %Texture* %obj, %Texture** %objPtr

%val2815 = load %Texture*, %Texture** %objPtr
%val2816 = load i32, i32* %arg_0Ptr
; set tuple
%val2817 = getelementptr %Texture, %Texture* %val2815, i64 0, i32 0
store i32 %val2816, i32* %val2817
%val2818 = load %Texture*, %Texture** %objPtr
%val2819 = load i32, i32* %arg_1Ptr
; set tuple
%val2820 = getelementptr %Texture, %Texture* %val2818, i64 0, i32 1
store i32 %val2819, i32* %val2820
%val2821 = load %Texture*, %Texture** %objPtr
%val2822 = load i32, i32* %arg_2Ptr
; set tuple
%val2823 = getelementptr %Texture, %Texture* %val2821, i64 0, i32 2
store i32 %val2822, i32* %val2823
%val2824 = load %Texture*, %Texture** %objPtr
%val2825 = load i32, i32* %arg_3Ptr
; set tuple
%val2826 = getelementptr %Texture, %Texture* %val2824, i64 0, i32 3
store i32 %val2825, i32* %val2826
%val2827 = load %Texture*, %Texture** %objPtr
%val2828 = load i8*, i8** %arg_4Ptr
; set tuple
%val2829 = getelementptr %Texture, %Texture* %val2827, i64 0, i32 4
store i8* %val2828, i8** %val2829
%val2830 = load %Texture*, %Texture** %objPtr
ret %Texture* %val2830
}
@gsxtmgl-objects2205 = hidden constant [108 x i8] c"Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2850 = load i8*, i8** %_impzPtr
%zone2851 = bitcast i8* %tzone2850 to %mzone*

; let assign value to symbol Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd
%dat_Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone2851, i64 8)
%Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr = bitcast i8* %dat_Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***
%tzone2831 = load i8*, i8** %_impzPtr
%zone2832 = bitcast i8* %tzone2831 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2832)
; malloc closure structure
%clsptr2833 = call i8* @llvm_zone_malloc(%mzone* %zone2832, i64 24)
%closure2834 = bitcast i8* %clsptr2833 to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*

; malloc environment structure
%envptr2835 = call i8* @llvm_zone_malloc(%mzone* %zone2832, i64 8)
%environment2836 = bitcast i8* %envptr2835 to {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}*

; malloc closure address table
%addytable2837 = call %clsvar* @new_address_table()
%var2838 = bitcast [55 x i8]* @gsxtmgl-objects2203 to i8*
%var2839 = bitcast [61 x i8]* @gsxtmgl-objects2204 to i8*
%addytable2840 = call %clsvar* @add_address_table(%mzone* %zone2832, i8* %var2838, i32 0, i8* %var2839, i32 3, %clsvar* %addytable2837)
%address-table2841 = bitcast %clsvar* %addytable2840 to i8*

; insert table, function and environment into closure struct
%closure.table2844 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2834, i32 0, i32 0
store i8* %address-table2841, i8** %closure.table2844
%closure.env2845 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2834, i32 0, i32 1
store i8* %envptr2835, i8** %closure.env2845
%closure.func2846 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2834, i32 0, i32 2
store %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd__2807, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %closure.func2846
%closure_size2847 = call i64 @llvm_zone_mark_size(%mzone* %zone2832)
call void @llvm_zone_ptr_set_size(i8* %clsptr2833, i64 %closure_size2847)
%wrapper_ptr2848 = call i8* @llvm_zone_malloc(%mzone* %zone2832, i64 8)
%closure_wrapper2849 = bitcast i8* %wrapper_ptr2848 to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
store { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2834, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_wrapper2849

; let value assignment
%Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd = select i1 true, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_wrapper2849, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_wrapper2849
store { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr

; add data to environment
; don't need to alloc for env var Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd
%tmp_envptr2843 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}* %environment2836, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**** %tmp_envptr2843


%val2852 = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr
ret {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %val2852
}


@Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i8* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
ret %Texture* %result
}


define dllexport ccc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i8* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
ret %Texture* %result
}


define dllexport ccc i8*  @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2853 = bitcast [108 x i8]* @gsxtmgl-objects2205 to i8*
call i32 (i8*, ...) @printf(i8* %var2853)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2854 = bitcast [108 x i8]* @gsxtmgl-objects2205 to i8*
call i32 (i8*, ...) @printf(i8* %var2854)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2855 = bitcast [108 x i8]* @gsxtmgl-objects2205 to i8*
call i32 (i8*, ...) @printf(i8* %var2855)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2856 = bitcast [108 x i8]* @gsxtmgl-objects2205 to i8*
call i32 (i8*, ...) @printf(i8* %var2856)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr_or_str(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2857 = bitcast [108 x i8]* @gsxtmgl-objects2205 to i8*
call i32 (i8*, ...) @printf(i8* %var2857)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i8*  @cptr_value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32, i8*}*
%arg_p_0 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 4
%arg_4 = load i8*, i8** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2206 = hidden constant [57 x i8] c"Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd\00"
define dllexport fastcc %Texture* @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd__2858(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2859 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}*
%Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}* %impenv, i32 0, i32 0
%Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**** %Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i8*
store i8* %arg_4, i8** %arg_4Ptr


%tzone2864 = load i8*, i8** %_impzPtr
%zone2865 = bitcast i8* %tzone2864 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Texture*
%tzone2860 = load i8*, i8** %_impzPtr
%zone2861 = bitcast i8* %tzone2860 to %mzone*
%dat2862 = call i8* @llvm_zone_malloc(%mzone* %zone2861, i64 24)
call i8* @memset(i8* %dat2862, i32 0, i64 24)
%val2863 = bitcast i8* %dat2862 to %Texture*

; let value assignment
%obj = select i1 true, %Texture* %val2863, %Texture* %val2863
store %Texture* %obj, %Texture** %objPtr

%val2866 = load %Texture*, %Texture** %objPtr
%val2867 = load i32, i32* %arg_0Ptr
; set tuple
%val2868 = getelementptr %Texture, %Texture* %val2866, i64 0, i32 0
store i32 %val2867, i32* %val2868
%val2869 = load %Texture*, %Texture** %objPtr
%val2870 = load i32, i32* %arg_1Ptr
; set tuple
%val2871 = getelementptr %Texture, %Texture* %val2869, i64 0, i32 1
store i32 %val2870, i32* %val2871
%val2872 = load %Texture*, %Texture** %objPtr
%val2873 = load i32, i32* %arg_2Ptr
; set tuple
%val2874 = getelementptr %Texture, %Texture* %val2872, i64 0, i32 2
store i32 %val2873, i32* %val2874
%val2875 = load %Texture*, %Texture** %objPtr
%val2876 = load i32, i32* %arg_3Ptr
; set tuple
%val2877 = getelementptr %Texture, %Texture* %val2875, i64 0, i32 3
store i32 %val2876, i32* %val2877
%val2878 = load %Texture*, %Texture** %objPtr
%val2879 = load i8*, i8** %arg_4Ptr
; set tuple
%val2880 = getelementptr %Texture, %Texture* %val2878, i64 0, i32 4
store i8* %val2879, i8** %val2880
%val2881 = load %Texture*, %Texture** %objPtr
ret %Texture* %val2881
}
@gsxtmgl-objects2207 = hidden constant [110 x i8] c"Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2901 = load i8*, i8** %_impzPtr
%zone2902 = bitcast i8* %tzone2901 to %mzone*

; let assign value to symbol Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd
%dat_Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone2902, i64 8)
%Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr = bitcast i8* %dat_Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***
%tzone2882 = load i8*, i8** %_impzPtr
%zone2883 = bitcast i8* %tzone2882 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2883)
; malloc closure structure
%clsptr2884 = call i8* @llvm_zone_malloc(%mzone* %zone2883, i64 24)
%closure2885 = bitcast i8* %clsptr2884 to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*

; malloc environment structure
%envptr2886 = call i8* @llvm_zone_malloc(%mzone* %zone2883, i64 8)
%environment2887 = bitcast i8* %envptr2886 to {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}*

; malloc closure address table
%addytable2888 = call %clsvar* @new_address_table()
%var2889 = bitcast [57 x i8]* @gsxtmgl-objects2206 to i8*
%var2890 = bitcast [61 x i8]* @gsxtmgl-objects2204 to i8*
%addytable2891 = call %clsvar* @add_address_table(%mzone* %zone2883, i8* %var2889, i32 0, i8* %var2890, i32 3, %clsvar* %addytable2888)
%address-table2892 = bitcast %clsvar* %addytable2891 to i8*

; insert table, function and environment into closure struct
%closure.table2895 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2885, i32 0, i32 0
store i8* %address-table2892, i8** %closure.table2895
%closure.env2896 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2885, i32 0, i32 1
store i8* %envptr2886, i8** %closure.env2896
%closure.func2897 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2885, i32 0, i32 2
store %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)* @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd__2858, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %closure.func2897
%closure_size2898 = call i64 @llvm_zone_mark_size(%mzone* %zone2883)
call void @llvm_zone_ptr_set_size(i8* %clsptr2884, i64 %closure_size2898)
%wrapper_ptr2899 = call i8* @llvm_zone_malloc(%mzone* %zone2883, i64 8)
%closure_wrapper2900 = bitcast i8* %wrapper_ptr2899 to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
store { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2885, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_wrapper2900

; let value assignment
%Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd = select i1 true, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_wrapper2900, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_wrapper2900
store { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*** %Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr

; add data to environment
; don't need to alloc for env var Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd
%tmp_envptr2894 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}* %environment2887, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*** %Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**** %tmp_envptr2894


%val2903 = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*** %Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr
ret {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %val2903
}


@Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i8* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
ret %Texture* %result
}


define dllexport ccc %Texture* @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i8* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
ret %Texture* %result
}


define dllexport ccc i8*  @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2904 = bitcast [110 x i8]* @gsxtmgl-objects2207 to i8*
call i32 (i8*, ...) @printf(i8* %var2904)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2905 = bitcast [110 x i8]* @gsxtmgl-objects2207 to i8*
call i32 (i8*, ...) @printf(i8* %var2905)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2906 = bitcast [110 x i8]* @gsxtmgl-objects2207 to i8*
call i32 (i8*, ...) @printf(i8* %var2906)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2907 = bitcast [110 x i8]* @gsxtmgl-objects2207 to i8*
call i32 (i8*, ...) @printf(i8* %var2907)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr_or_str(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2908 = bitcast [110 x i8]* @gsxtmgl-objects2207 to i8*
call i32 (i8*, ...) @printf(i8* %var2908)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i8*  @cptr_value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32, i8*}*
%arg_p_0 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 4
%arg_4 = load i8*, i8** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_z_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2208 = hidden constant [57 x i8] c"Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd\00"
define dllexport fastcc %Texture* @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd__2909(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2910 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}*
%Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}* %impenv, i32 0, i32 0
%Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**** %Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i8*
store i8* %arg_4, i8** %arg_4Ptr


%tzone2913 = load i8*, i8** %_impzPtr
%zone2914 = bitcast i8* %tzone2913 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Texture*
%dat2911 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat2911, i32 0, i64 24)
%val2912 = bitcast i8* %dat2911 to %Texture*

; let value assignment
%obj = select i1 true, %Texture* %val2912, %Texture* %val2912
store %Texture* %obj, %Texture** %objPtr

%val2915 = load %Texture*, %Texture** %objPtr
%val2916 = load i32, i32* %arg_0Ptr
; set tuple
%val2917 = getelementptr %Texture, %Texture* %val2915, i64 0, i32 0
store i32 %val2916, i32* %val2917
%val2918 = load %Texture*, %Texture** %objPtr
%val2919 = load i32, i32* %arg_1Ptr
; set tuple
%val2920 = getelementptr %Texture, %Texture* %val2918, i64 0, i32 1
store i32 %val2919, i32* %val2920
%val2921 = load %Texture*, %Texture** %objPtr
%val2922 = load i32, i32* %arg_2Ptr
; set tuple
%val2923 = getelementptr %Texture, %Texture* %val2921, i64 0, i32 2
store i32 %val2922, i32* %val2923
%val2924 = load %Texture*, %Texture** %objPtr
%val2925 = load i32, i32* %arg_3Ptr
; set tuple
%val2926 = getelementptr %Texture, %Texture* %val2924, i64 0, i32 3
store i32 %val2925, i32* %val2926
%val2927 = load %Texture*, %Texture** %objPtr
%val2928 = load i8*, i8** %arg_4Ptr
; set tuple
%val2929 = getelementptr %Texture, %Texture* %val2927, i64 0, i32 4
store i8* %val2928, i8** %val2929
%val2930 = load %Texture*, %Texture** %objPtr
ret %Texture* %val2930
}
@gsxtmgl-objects2209 = hidden constant [110 x i8] c"Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2950 = load i8*, i8** %_impzPtr
%zone2951 = bitcast i8* %tzone2950 to %mzone*

; let assign value to symbol Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd
%dat_Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone2951, i64 8)
%Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr = bitcast i8* %dat_Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***
%tzone2931 = load i8*, i8** %_impzPtr
%zone2932 = bitcast i8* %tzone2931 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2932)
; malloc closure structure
%clsptr2933 = call i8* @llvm_zone_malloc(%mzone* %zone2932, i64 24)
%closure2934 = bitcast i8* %clsptr2933 to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*

; malloc environment structure
%envptr2935 = call i8* @llvm_zone_malloc(%mzone* %zone2932, i64 8)
%environment2936 = bitcast i8* %envptr2935 to {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}*

; malloc closure address table
%addytable2937 = call %clsvar* @new_address_table()
%var2938 = bitcast [57 x i8]* @gsxtmgl-objects2208 to i8*
%var2939 = bitcast [61 x i8]* @gsxtmgl-objects2204 to i8*
%addytable2940 = call %clsvar* @add_address_table(%mzone* %zone2932, i8* %var2938, i32 0, i8* %var2939, i32 3, %clsvar* %addytable2937)
%address-table2941 = bitcast %clsvar* %addytable2940 to i8*

; insert table, function and environment into closure struct
%closure.table2944 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2934, i32 0, i32 0
store i8* %address-table2941, i8** %closure.table2944
%closure.env2945 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2934, i32 0, i32 1
store i8* %envptr2935, i8** %closure.env2945
%closure.func2946 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2934, i32 0, i32 2
store %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)* @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd__2909, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %closure.func2946
%closure_size2947 = call i64 @llvm_zone_mark_size(%mzone* %zone2932)
call void @llvm_zone_ptr_set_size(i8* %clsptr2933, i64 %closure_size2947)
%wrapper_ptr2948 = call i8* @llvm_zone_malloc(%mzone* %zone2932, i64 8)
%closure_wrapper2949 = bitcast i8* %wrapper_ptr2948 to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
store { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2934, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_wrapper2949

; let value assignment
%Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd = select i1 true, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_wrapper2949, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_wrapper2949
store { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*** %Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr

; add data to environment
; don't need to alloc for env var Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd
%tmp_envptr2943 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}***}* %environment2936, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*** %Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**** %tmp_envptr2943


%val2952 = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*** %Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpdPtr
ret {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %val2952
}


@Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i8* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
ret %Texture* %result
}


define dllexport ccc %Texture* @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i8* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
ret %Texture* %result
}


define dllexport ccc i8*  @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2953 = bitcast [110 x i8]* @gsxtmgl-objects2209 to i8*
call i32 (i8*, ...) @printf(i8* %var2953)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2954 = bitcast [110 x i8]* @gsxtmgl-objects2209 to i8*
call i32 (i8*, ...) @printf(i8* %var2954)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2955 = bitcast [110 x i8]* @gsxtmgl-objects2209 to i8*
call i32 (i8*, ...) @printf(i8* %var2955)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2956 = bitcast [110 x i8]* @gsxtmgl-objects2209 to i8*
call i32 (i8*, ...) @printf(i8* %var2956)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr_or_str(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2957 = bitcast [110 x i8]* @gsxtmgl-objects2209 to i8*
call i32 (i8*, ...) @printf(i8* %var2957)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i8*  @cptr_value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32, i8*}*
%arg_p_0 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 4
%arg_4 = load i8*, i8** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_h_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2210 = hidden constant [58 x i8] c"Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0\00"
@gsxtmgl-objects2211 = hidden constant [60 x i8] c"{i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}**\00"
define dllexport fastcc %Texture @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0__2958(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2959 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}***}*
%Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}***}, {{i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}***}* %impenv, i32 0, i32 0
%Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0Ptr = load {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}***, {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}**** %Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i8*
store i8* %arg_4, i8** %arg_4Ptr


%tzone2961 = load i8*, i8** %_impzPtr
%zone2962 = bitcast i8* %tzone2961 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Texture*
%dat2960 = alloca %Texture, align 16

; let value assignment
%obj = select i1 true, %Texture* %dat2960, %Texture* %dat2960
store %Texture* %obj, %Texture** %objPtr

%val2963 = load %Texture*, %Texture** %objPtr
%val2964 = load i32, i32* %arg_0Ptr
; set tuple
%val2965 = getelementptr %Texture, %Texture* %val2963, i64 0, i32 0
store i32 %val2964, i32* %val2965
%val2966 = load %Texture*, %Texture** %objPtr
%val2967 = load i32, i32* %arg_1Ptr
; set tuple
%val2968 = getelementptr %Texture, %Texture* %val2966, i64 0, i32 1
store i32 %val2967, i32* %val2968
%val2969 = load %Texture*, %Texture** %objPtr
%val2970 = load i32, i32* %arg_2Ptr
; set tuple
%val2971 = getelementptr %Texture, %Texture* %val2969, i64 0, i32 2
store i32 %val2970, i32* %val2971
%val2972 = load %Texture*, %Texture** %objPtr
%val2973 = load i32, i32* %arg_3Ptr
; set tuple
%val2974 = getelementptr %Texture, %Texture* %val2972, i64 0, i32 3
store i32 %val2973, i32* %val2974
%val2975 = load %Texture*, %Texture** %objPtr
%val2976 = load i8*, i8** %arg_4Ptr
; set tuple
%val2977 = getelementptr %Texture, %Texture* %val2975, i64 0, i32 4
store i8* %val2976, i8** %val2977
%val2978 = load %Texture*, %Texture** %objPtr
; pointer ref
%val2979 = getelementptr %Texture, %Texture* %val2978, i64 0
%val2980 = load %Texture, %Texture* %val2979
ret %Texture %val2980
}
@gsxtmgl-objects2212 = hidden constant [111 x i8] c"Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}** @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3000 = load i8*, i8** %_impzPtr
%zone3001 = bitcast i8* %tzone3000 to %mzone*

; let assign value to symbol Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0
%dat_Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3001, i64 8)
%Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0Ptr = bitcast i8* %dat_Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0 to { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}***
%tzone2981 = load i8*, i8** %_impzPtr
%zone2982 = bitcast i8* %tzone2981 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2982)
; malloc closure structure
%clsptr2983 = call i8* @llvm_zone_malloc(%mzone* %zone2982, i64 24)
%closure2984 = bitcast i8* %clsptr2983 to { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}*

; malloc environment structure
%envptr2985 = call i8* @llvm_zone_malloc(%mzone* %zone2982, i64 8)
%environment2986 = bitcast i8* %envptr2985 to {{i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}***}*

; malloc closure address table
%addytable2987 = call %clsvar* @new_address_table()
%var2988 = bitcast [58 x i8]* @gsxtmgl-objects2210 to i8*
%var2989 = bitcast [60 x i8]* @gsxtmgl-objects2211 to i8*
%addytable2990 = call %clsvar* @add_address_table(%mzone* %zone2982, i8* %var2988, i32 0, i8* %var2989, i32 3, %clsvar* %addytable2987)
%address-table2991 = bitcast %clsvar* %addytable2990 to i8*

; insert table, function and environment into closure struct
%closure.table2994 = getelementptr { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2984, i32 0, i32 0
store i8* %address-table2991, i8** %closure.table2994
%closure.env2995 = getelementptr { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2984, i32 0, i32 1
store i8* %envptr2985, i8** %closure.env2995
%closure.func2996 = getelementptr { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2984, i32 0, i32 2
store %Texture (i8*, i8*, i32, i32, i32, i32, i8*)* @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0__2958, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)** %closure.func2996
%closure_size2997 = call i64 @llvm_zone_mark_size(%mzone* %zone2982)
call void @llvm_zone_ptr_set_size(i8* %clsptr2983, i64 %closure_size2997)
%wrapper_ptr2998 = call i8* @llvm_zone_malloc(%mzone* %zone2982, i64 8)
%closure_wrapper2999 = bitcast i8* %wrapper_ptr2998 to { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}**
store { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure2984, { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_wrapper2999

; let value assignment
%Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0 = select i1 true, { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_wrapper2999, { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_wrapper2999
store { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}** %Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0, { i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}*** %Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0
%tmp_envptr2993 = getelementptr {{i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}***}, {{i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}***}* %environment2986, i32 0, i32 0
store {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}*** %Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0Ptr, {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}**** %tmp_envptr2993


%val3002 = load {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}**, {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}*** %Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0Ptr
ret {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}** %val3002
}


@Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}** @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i8* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
ret %Texture %result
}


define dllexport ccc %Texture @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i8* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
ret %Texture %result
}


define dllexport ccc void @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32, i8*}*
%arg_p_0 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i32, i32, i8*}, {i32, i32, i32, i32, i8*}* %fstruct, i32 0, i32 4
%arg_4 = load i8*, i8** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_val_adhoc_W1RleHR1cmUsaTMyLGkzMixpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture (i8*, i8*, i32, i32, i32, i32, i8*)*,  %Texture (i8*, i8*, i32, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i8* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2213 = hidden constant [39 x i8] c"hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ\00"
@gsxtmgl-objects2214 = hidden constant [47 x i8] c"{i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}**\00"
define dllexport fastcc %Texture* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ__3008(i8* %_impz,i8* %_impenv, %Texture* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3009 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}***}*
%hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQPtr = load {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}***, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}**** %hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQPtr_

; setup arguments
%xPtr = alloca %Texture*
store %Texture* %x, %Texture** %xPtr


%tzone3012 = load i8*, i8** %_impzPtr
%zone3013 = bitcast i8* %tzone3012 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Texture*
%dat3010 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat3010, i32 0, i64 24)
%val3011 = bitcast i8* %dat3010 to %Texture*

; let value assignment
%obj = select i1 true, %Texture* %val3011, %Texture* %val3011
store %Texture* %obj, %Texture** %objPtr

%val3014 = load %Texture*, %Texture** %objPtr
%val3015 = load %Texture*, %Texture** %xPtr
; tuple ref
%val3016 = getelementptr %Texture, %Texture* %val3015, i64 0, i32 0
%val3017 = load i32, i32* %val3016
; set tuple
%val3018 = getelementptr %Texture, %Texture* %val3014, i64 0, i32 0
store i32 %val3017, i32* %val3018
%val3019 = load %Texture*, %Texture** %objPtr
%val3020 = load %Texture*, %Texture** %xPtr
; tuple ref
%val3021 = getelementptr %Texture, %Texture* %val3020, i64 0, i32 1
%val3022 = load i32, i32* %val3021
; set tuple
%val3023 = getelementptr %Texture, %Texture* %val3019, i64 0, i32 1
store i32 %val3022, i32* %val3023
%val3024 = load %Texture*, %Texture** %objPtr
%val3025 = load %Texture*, %Texture** %xPtr
; tuple ref
%val3026 = getelementptr %Texture, %Texture* %val3025, i64 0, i32 2
%val3027 = load i32, i32* %val3026
; set tuple
%val3028 = getelementptr %Texture, %Texture* %val3024, i64 0, i32 2
store i32 %val3027, i32* %val3028
%val3029 = load %Texture*, %Texture** %objPtr
%val3030 = load %Texture*, %Texture** %xPtr
; tuple ref
%val3031 = getelementptr %Texture, %Texture* %val3030, i64 0, i32 3
%val3032 = load i32, i32* %val3031
; set tuple
%val3033 = getelementptr %Texture, %Texture* %val3029, i64 0, i32 3
store i32 %val3032, i32* %val3033
%val3034 = load %Texture*, %Texture** %objPtr
%val3035 = load %Texture*, %Texture** %xPtr
; tuple ref
%val3036 = getelementptr %Texture, %Texture* %val3035, i64 0, i32 4
%val3037 = load i8*, i8** %val3036
; set tuple
%val3038 = getelementptr %Texture, %Texture* %val3034, i64 0, i32 4
store i8* %val3037, i8** %val3038
%val3039 = load %Texture*, %Texture** %objPtr
ret %Texture* %val3039
}
@gsxtmgl-objects2215 = hidden constant [92 x i8] c"hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}** @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3059 = load i8*, i8** %_impzPtr
%zone3060 = bitcast i8* %tzone3059 to %mzone*

; let assign value to symbol hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ
%dat_hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3060, i64 8)
%hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQPtr = bitcast i8* %dat_hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ to { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}***
%tzone3040 = load i8*, i8** %_impzPtr
%zone3041 = bitcast i8* %tzone3040 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3041)
; malloc closure structure
%clsptr3042 = call i8* @llvm_zone_malloc(%mzone* %zone3041, i64 24)
%closure3043 = bitcast i8* %clsptr3042 to { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr3044 = call i8* @llvm_zone_malloc(%mzone* %zone3041, i64 8)
%environment3045 = bitcast i8* %envptr3044 to {{i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable3046 = call %clsvar* @new_address_table()
%var3047 = bitcast [39 x i8]* @gsxtmgl-objects2213 to i8*
%var3048 = bitcast [47 x i8]* @gsxtmgl-objects2214 to i8*
%addytable3049 = call %clsvar* @add_address_table(%mzone* %zone3041, i8* %var3047, i32 0, i8* %var3048, i32 3, %clsvar* %addytable3046)
%address-table3050 = bitcast %clsvar* %addytable3049 to i8*

; insert table, function and environment into closure struct
%closure.table3053 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}, { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}* %closure3043, i32 0, i32 0
store i8* %address-table3050, i8** %closure.table3053
%closure.env3054 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}, { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}* %closure3043, i32 0, i32 1
store i8* %envptr3044, i8** %closure.env3054
%closure.func3055 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}, { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}* %closure3043, i32 0, i32 2
store %Texture* (i8*, i8*, %Texture*)* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ__3008, %Texture* (i8*, i8*, %Texture*)** %closure.func3055
%closure_size3056 = call i64 @llvm_zone_mark_size(%mzone* %zone3041)
call void @llvm_zone_ptr_set_size(i8* %clsptr3042, i64 %closure_size3056)
%wrapper_ptr3057 = call i8* @llvm_zone_malloc(%mzone* %zone3041, i64 8)
%closure_wrapper3058 = bitcast i8* %wrapper_ptr3057 to { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}**
store { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}* %closure3043, { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}** %closure_wrapper3058

; let value assignment
%hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ = select i1 true, { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}** %closure_wrapper3058, { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}** %closure_wrapper3058
store { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}** %hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ, { i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}*** %hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ
%tmp_envptr3052 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}***}* %environment3045, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}*** %hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQPtr, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}**** %tmp_envptr3052


%val3061 = load {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}**, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}*** %hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQPtr
ret {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}** %val3061
}


@hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}** @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %Texture*)*,  %Texture* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret %Texture* %result
}


define dllexport ccc %Texture* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %Texture*)*,  %Texture* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret %Texture* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3062 = bitcast [92 x i8]* @gsxtmgl-objects2215 to i8*
call i32 (i8*, ...) @printf(i8* %var3062)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %Texture*)*,  %Texture* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %Texture*)*,  %Texture* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2216 = hidden constant [33 x i8] c"hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd\00"
@gsxtmgl-objects2217 = hidden constant [42 x i8] c"{i8*, i8*, void (i8*, i8*, %Texture*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd__3063(i8* %_impz,i8* %_impenv, %Texture* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3064 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*
%hfree_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = load {i8*, i8*, void (i8*, i8*, %Texture*)*}***, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %hfree_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_

; setup arguments
%xPtr = alloca %Texture*
store %Texture* %x, %Texture** %xPtr


%val3065 = load %Texture*, %Texture** %xPtr
%val3066 = bitcast %Texture* %val3065 to i8*
call ccc void @free(i8* %val3066)
ret void
}
@gsxtmgl-objects2218 = hidden constant [86 x i8] c"hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3088 = load i8*, i8** %_impzPtr
%zone3089 = bitcast i8* %tzone3088 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd
%dat_hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3089, i64 8)
%hfree_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd to { i8*, i8*, void (i8*, i8*, %Texture*)*}***
%tzone3069 = load i8*, i8** %_impzPtr
%zone3070 = bitcast i8* %tzone3069 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3070)
; malloc closure structure
%clsptr3071 = call i8* @llvm_zone_malloc(%mzone* %zone3070, i64 24)
%closure3072 = bitcast i8* %clsptr3071 to { i8*, i8*, void (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr3073 = call i8* @llvm_zone_malloc(%mzone* %zone3070, i64 8)
%environment3074 = bitcast i8* %envptr3073 to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable3075 = call %clsvar* @new_address_table()
%var3076 = bitcast [33 x i8]* @gsxtmgl-objects2216 to i8*
%var3077 = bitcast [42 x i8]* @gsxtmgl-objects2217 to i8*
%addytable3078 = call %clsvar* @add_address_table(%mzone* %zone3070, i8* %var3076, i32 0, i8* %var3077, i32 3, %clsvar* %addytable3075)
%address-table3079 = bitcast %clsvar* %addytable3078 to i8*

; insert table, function and environment into closure struct
%closure.table3082 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure3072, i32 0, i32 0
store i8* %address-table3079, i8** %closure.table3082
%closure.env3083 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure3072, i32 0, i32 1
store i8* %envptr3073, i8** %closure.env3083
%closure.func3084 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure3072, i32 0, i32 2
store void (i8*, i8*, %Texture*)* @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd__3063, void (i8*, i8*, %Texture*)** %closure.func3084
%closure_size3085 = call i64 @llvm_zone_mark_size(%mzone* %zone3070)
call void @llvm_zone_ptr_set_size(i8* %clsptr3071, i64 %closure_size3085)
%wrapper_ptr3086 = call i8* @llvm_zone_malloc(%mzone* %zone3070, i64 8)
%closure_wrapper3087 = bitcast i8* %wrapper_ptr3086 to { i8*, i8*, void (i8*, i8*, %Texture*)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure3072, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper3087

; let value assignment
%hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper3087, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper3087
store { i8*, i8*, void (i8*, i8*, %Texture*)*}** %hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd, { i8*, i8*, void (i8*, i8*, %Texture*)*}*** %hfree_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd
%tmp_envptr3081 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %environment3074, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %hfree_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %tmp_envptr3081


%val3090 = load {i8*, i8*, void (i8*, i8*, %Texture*)*}**, {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %hfree_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr
ret {i8*, i8*, void (i8*, i8*, %Texture*)*}** %val3090
}


@hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3091 = bitcast [86 x i8]* @gsxtmgl-objects2218 to i8*
call i32 (i8*, ...) @printf(i8* %var3091)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2219 = hidden constant [57 x i8] c"zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd\00"
@gsxtmgl-objects2220 = hidden constant [65 x i8] c"{i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %Texture* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd__3092(i8* %_impz,i8* %_impenv, %Texture* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3093 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}***, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %Texture*
store %Texture* %x, %Texture** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val3095 = load %mzone*, %mzone** %fromzPtr
%val3096 = load %Texture*, %Texture** %xPtr
%val3097 = bitcast %Texture* %val3096 to i8*
%res3098 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3095, i8* %val3097)
br i1 %res3098, label %then3094, label %else3094

then3094:
%val3099 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val3099)
%zone_ptr3100 = bitcast %mzone* %val3099 to i8*
store i8* %zone_ptr3100, i8** %_impzPtr
%tzone3106 = load i8*, i8** %_impzPtr
%zone3107 = bitcast i8* %tzone3106 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Texture*
%tzone3102 = load i8*, i8** %_impzPtr
%zone3103 = bitcast i8* %tzone3102 to %mzone*
%dat3104 = call i8* @llvm_zone_malloc(%mzone* %zone3103, i64 24)
call i8* @memset(i8* %dat3104, i32 0, i64 24)
%val3105 = bitcast i8* %dat3104 to %Texture*

; let value assignment
%obj = select i1 true, %Texture* %val3105, %Texture* %val3105
store %Texture* %obj, %Texture** %objPtr

; promote local stack var allocations
%tzone3161 = load i8*, i8** %_impzPtr
%zone3162 = bitcast i8* %tzone3161 to %mzone*
%ifptr3128 = alloca i8*
%val3108 = load %Texture*, %Texture** %objPtr
%val3109 = load %Texture*, %Texture** %xPtr
; tuple ref
%val3110 = getelementptr %Texture, %Texture* %val3109, i64 0, i32 0
%val3111 = load i32, i32* %val3110
; set tuple
%val3112 = getelementptr %Texture, %Texture* %val3108, i64 0, i32 0
store i32 %val3111, i32* %val3112
%val3113 = load %Texture*, %Texture** %objPtr
%val3114 = load %Texture*, %Texture** %xPtr
; tuple ref
%val3115 = getelementptr %Texture, %Texture* %val3114, i64 0, i32 1
%val3116 = load i32, i32* %val3115
; set tuple
%val3117 = getelementptr %Texture, %Texture* %val3113, i64 0, i32 1
store i32 %val3116, i32* %val3117
%val3118 = load %Texture*, %Texture** %objPtr
%val3119 = load %Texture*, %Texture** %xPtr
; tuple ref
%val3120 = getelementptr %Texture, %Texture* %val3119, i64 0, i32 2
%val3121 = load i32, i32* %val3120
; set tuple
%val3122 = getelementptr %Texture, %Texture* %val3118, i64 0, i32 2
store i32 %val3121, i32* %val3122
%val3123 = load %Texture*, %Texture** %objPtr
%val3124 = load %Texture*, %Texture** %xPtr
; tuple ref
%val3125 = getelementptr %Texture, %Texture* %val3124, i64 0, i32 3
%val3126 = load i32, i32* %val3125
; set tuple
%val3127 = getelementptr %Texture, %Texture* %val3123, i64 0, i32 3
store i32 %val3126, i32* %val3127
%val3129 = load %mzone*, %mzone** %fromzPtr
%val3130 = load %Texture*, %Texture** %xPtr
; tuple ref
%val3131 = getelementptr %Texture, %Texture* %val3130, i64 0, i32 4
%val3132 = load i8*, i8** %val3131
%val3133 = bitcast i8* %val3132 to i8*
%res3134 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3129, i8* %val3133)
br i1 %res3134, label %then3128, label %else3128

then3128:
%tzone3139 = load i8*, i8** %_impzPtr
%zone3140 = bitcast i8* %tzone3139 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i8*
%tzone3135 = load i8*, i8** %_impzPtr
%zone3136 = bitcast i8* %tzone3135 to %mzone*
%dat3137 = call i8* @llvm_zone_malloc(%mzone* %zone3136, i64 1)
call i8* @memset(i8* %dat3137, i32 0, i64 1)
%val3138 = bitcast i8* %dat3137 to i8*

; let value assignment
%newptr = select i1 true, i8* %val3138, i8* %val3138
store i8* %newptr, i8** %newptrPtr

%val3141 = load i8*, i8** %newptrPtr
%val3142 = bitcast i8* %val3141 to i8*
%val3143 = load %Texture*, %Texture** %xPtr
; tuple ref
%val3144 = getelementptr %Texture, %Texture* %val3143, i64 0, i32 4
%val3145 = load i8*, i8** %val3144
%val3146 = bitcast i8* %val3145 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val3142, i8* %val3146, i64 1, i32 1, i1 0)
%val3148 = load %Texture*, %Texture** %objPtr
%val3149 = load i8*, i8** %newptrPtr
; set tuple
%val3150 = getelementptr %Texture, %Texture* %val3148, i64 0, i32 4
store i8* %val3149, i8** %val3150
store i8* %val3149, i8** %ifptr3128
br label %ifcont3128

else3128:
%val3151 = load %Texture*, %Texture** %objPtr
%val3152 = load %Texture*, %Texture** %xPtr
; tuple ref
%val3153 = getelementptr %Texture, %Texture* %val3152, i64 0, i32 4
%val3154 = load i8*, i8** %val3153
; set tuple
%val3155 = getelementptr %Texture, %Texture* %val3151, i64 0, i32 4
store i8* %val3154, i8** %val3155
store i8* %val3154, i8** %ifptr3128
br label %ifcont3128

ifcont3128:
%ifres3156 = load i8*, i8** %ifptr3128

%oldzone3157 = call %mzone* @llvm_pop_zone_stack()
%newzone3158 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3159 = bitcast %mzone* %newzone3158 to i8*
store i8* %zone_ptr3159, i8** %_impzPtr
%val3160 = load %Texture*, %Texture** %objPtr
ret %Texture* %val3160

else3094:
%val3163 = load %Texture*, %Texture** %xPtr
ret %Texture* %val3163
}
@gsxtmgl-objects2221 = hidden constant [110 x i8] c"zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3183 = load i8*, i8** %_impzPtr
%zone3184 = bitcast i8* %tzone3183 to %mzone*

; let assign value to symbol zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3184, i64 8)
%zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd to { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}***
%tzone3164 = load i8*, i8** %_impzPtr
%zone3165 = bitcast i8* %tzone3164 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3165)
; malloc closure structure
%clsptr3166 = call i8* @llvm_zone_malloc(%mzone* %zone3165, i64 24)
%closure3167 = bitcast i8* %clsptr3166 to { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr3168 = call i8* @llvm_zone_malloc(%mzone* %zone3165, i64 8)
%environment3169 = bitcast i8* %envptr3168 to {{i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable3170 = call %clsvar* @new_address_table()
%var3171 = bitcast [57 x i8]* @gsxtmgl-objects2219 to i8*
%var3172 = bitcast [65 x i8]* @gsxtmgl-objects2220 to i8*
%addytable3173 = call %clsvar* @add_address_table(%mzone* %zone3165, i8* %var3171, i32 0, i8* %var3172, i32 3, %clsvar* %addytable3170)
%address-table3174 = bitcast %clsvar* %addytable3173 to i8*

; insert table, function and environment into closure struct
%closure.table3177 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}, { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}* %closure3167, i32 0, i32 0
store i8* %address-table3174, i8** %closure.table3177
%closure.env3178 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}, { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}* %closure3167, i32 0, i32 1
store i8* %envptr3168, i8** %closure.env3178
%closure.func3179 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}, { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}* %closure3167, i32 0, i32 2
store %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd__3092, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)** %closure.func3179
%closure_size3180 = call i64 @llvm_zone_mark_size(%mzone* %zone3165)
call void @llvm_zone_ptr_set_size(i8* %clsptr3166, i64 %closure_size3180)
%wrapper_ptr3181 = call i8* @llvm_zone_malloc(%mzone* %zone3165, i64 8)
%closure_wrapper3182 = bitcast i8* %wrapper_ptr3181 to { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}**
store { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}* %closure3167, { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}** %closure_wrapper3182

; let value assignment
%zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}** %closure_wrapper3182, { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}** %closure_wrapper3182
store { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd, { i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd
%tmp_envptr3176 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}***}* %environment3169, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}**** %tmp_envptr3176


%val3185 = load {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}**, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}** %val3185
}


@zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd(%Texture* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*,  %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Texture* %result
}


define dllexport ccc %Texture* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_native(%Texture* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*,  %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Texture* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3186 = bitcast [110 x i8]* @gsxtmgl-objects2221 to i8*
call i32 (i8*, ...) @printf(i8* %var3186)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3187 = bitcast [110 x i8]* @gsxtmgl-objects2221 to i8*
call i32 (i8*, ...) @printf(i8* %var3187)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3188 = bitcast [110 x i8]* @gsxtmgl-objects2221 to i8*
call i32 (i8*, ...) @printf(i8* %var3188)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*,  %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%Texture*, %mzone*, %mzone*}, {%Texture*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, %mzone*, %mzone*}, {%Texture*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%Texture*, %mzone*, %mzone*}, {%Texture*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}, {i8*, i8*, %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)*,  %Texture* (i8*, i8*, %Texture*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2222 = hidden constant [29 x i8] c"id_adhoc_W2kzMixUZXh0dXJlKl0\00"
@gsxtmgl-objects2223 = hidden constant [41 x i8] c"{i8*, i8*, i32 (i8*, i8*, %Texture*)*}**\00"
define dllexport fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0__3189(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3190 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}*
%id_adhoc_W2kzMixUZXh0dXJlKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%id_adhoc_W2kzMixUZXh0dXJlKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}***, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**** %id_adhoc_W2kzMixUZXh0dXJlKl0Ptr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr


%val3192 = load %Texture*, %Texture** %texPtr
%val3193 = icmp eq %Texture* %val3192, null
br i1 %val3193, label %then3191, label %else3191

then3191:
ret i32 -1

else3191:
%val3194 = load %Texture*, %Texture** %texPtr
; tuple ref
%val3195 = getelementptr %Texture, %Texture* %val3194, i64 0, i32 0
%val3196 = load i32, i32* %val3195
ret i32 %val3196
}
@gsxtmgl-objects2224 = hidden constant [82 x i8] c"id_adhoc_W2kzMixUZXh0dXJlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** @id_adhoc_W2kzMixUZXh0dXJlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3216 = load i8*, i8** %_impzPtr
%zone3217 = bitcast i8* %tzone3216 to %mzone*

; let assign value to symbol id_adhoc_W2kzMixUZXh0dXJlKl0
%dat_id_adhoc_W2kzMixUZXh0dXJlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3217, i64 8)
%id_adhoc_W2kzMixUZXh0dXJlKl0Ptr = bitcast i8* %dat_id_adhoc_W2kzMixUZXh0dXJlKl0 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}***
%tzone3197 = load i8*, i8** %_impzPtr
%zone3198 = bitcast i8* %tzone3197 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3198)
; malloc closure structure
%clsptr3199 = call i8* @llvm_zone_malloc(%mzone* %zone3198, i64 24)
%closure3200 = bitcast i8* %clsptr3199 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr3201 = call i8* @llvm_zone_malloc(%mzone* %zone3198, i64 8)
%environment3202 = bitcast i8* %envptr3201 to {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable3203 = call %clsvar* @new_address_table()
%var3204 = bitcast [29 x i8]* @gsxtmgl-objects2222 to i8*
%var3205 = bitcast [41 x i8]* @gsxtmgl-objects2223 to i8*
%addytable3206 = call %clsvar* @add_address_table(%mzone* %zone3198, i8* %var3204, i32 0, i8* %var3205, i32 3, %clsvar* %addytable3203)
%address-table3207 = bitcast %clsvar* %addytable3206 to i8*

; insert table, function and environment into closure struct
%closure.table3210 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3200, i32 0, i32 0
store i8* %address-table3207, i8** %closure.table3210
%closure.env3211 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3200, i32 0, i32 1
store i8* %envptr3201, i8** %closure.env3211
%closure.func3212 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3200, i32 0, i32 2
store i32 (i8*, i8*, %Texture*)* @id_adhoc_W2kzMixUZXh0dXJlKl0__3189, i32 (i8*, i8*, %Texture*)** %closure.func3212
%closure_size3213 = call i64 @llvm_zone_mark_size(%mzone* %zone3198)
call void @llvm_zone_ptr_set_size(i8* %clsptr3199, i64 %closure_size3213)
%wrapper_ptr3214 = call i8* @llvm_zone_malloc(%mzone* %zone3198, i64 8)
%closure_wrapper3215 = bitcast i8* %wrapper_ptr3214 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
store { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3200, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper3215

; let value assignment
%id_adhoc_W2kzMixUZXh0dXJlKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper3215, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper3215
store { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %id_adhoc_W2kzMixUZXh0dXJlKl0, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %id_adhoc_W2kzMixUZXh0dXJlKl0Ptr

; add data to environment
; don't need to alloc for env var id_adhoc_W2kzMixUZXh0dXJlKl0
%tmp_envptr3209 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}* %environment3202, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %id_adhoc_W2kzMixUZXh0dXJlKl0Ptr, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**** %tmp_envptr3209


%val3218 = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %id_adhoc_W2kzMixUZXh0dXJlKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %val3218
}


@id_adhoc_W2kzMixUZXh0dXJlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@id_adhoc_W2kzMixUZXh0dXJlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @id_adhoc_W2kzMixUZXh0dXJlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixUZXh0dXJlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** @id_adhoc_W2kzMixUZXh0dXJlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @id_adhoc_W2kzMixUZXh0dXJlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @id_adhoc_W2kzMixUZXh0dXJlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @id_adhoc_W2kzMixUZXh0dXJlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3219 = bitcast [82 x i8]* @gsxtmgl-objects2224 to i8*
call i32 (i8*, ...) @printf(i8* %var3219)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @id_adhoc_W2kzMixUZXh0dXJlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2225 = hidden constant [31 x i8] c"type_adhoc_W2kzMixUZXh0dXJlKl0\00"
define dllexport fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0__3220(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3221 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}*
%type_adhoc_W2kzMixUZXh0dXJlKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%type_adhoc_W2kzMixUZXh0dXJlKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}***, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**** %type_adhoc_W2kzMixUZXh0dXJlKl0Ptr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr


%val3223 = load %Texture*, %Texture** %texPtr
%val3224 = icmp eq %Texture* %val3223, null
br i1 %val3224, label %then3222, label %else3222

then3222:
ret i32 -1

else3222:
%val3225 = load %Texture*, %Texture** %texPtr
; tuple ref
%val3226 = getelementptr %Texture, %Texture* %val3225, i64 0, i32 1
%val3227 = load i32, i32* %val3226
ret i32 %val3227
}
@gsxtmgl-objects2226 = hidden constant [84 x i8] c"type_adhoc_W2kzMixUZXh0dXJlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** @type_adhoc_W2kzMixUZXh0dXJlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3247 = load i8*, i8** %_impzPtr
%zone3248 = bitcast i8* %tzone3247 to %mzone*

; let assign value to symbol type_adhoc_W2kzMixUZXh0dXJlKl0
%dat_type_adhoc_W2kzMixUZXh0dXJlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3248, i64 8)
%type_adhoc_W2kzMixUZXh0dXJlKl0Ptr = bitcast i8* %dat_type_adhoc_W2kzMixUZXh0dXJlKl0 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}***
%tzone3228 = load i8*, i8** %_impzPtr
%zone3229 = bitcast i8* %tzone3228 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3229)
; malloc closure structure
%clsptr3230 = call i8* @llvm_zone_malloc(%mzone* %zone3229, i64 24)
%closure3231 = bitcast i8* %clsptr3230 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr3232 = call i8* @llvm_zone_malloc(%mzone* %zone3229, i64 8)
%environment3233 = bitcast i8* %envptr3232 to {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable3234 = call %clsvar* @new_address_table()
%var3235 = bitcast [31 x i8]* @gsxtmgl-objects2225 to i8*
%var3236 = bitcast [41 x i8]* @gsxtmgl-objects2223 to i8*
%addytable3237 = call %clsvar* @add_address_table(%mzone* %zone3229, i8* %var3235, i32 0, i8* %var3236, i32 3, %clsvar* %addytable3234)
%address-table3238 = bitcast %clsvar* %addytable3237 to i8*

; insert table, function and environment into closure struct
%closure.table3241 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3231, i32 0, i32 0
store i8* %address-table3238, i8** %closure.table3241
%closure.env3242 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3231, i32 0, i32 1
store i8* %envptr3232, i8** %closure.env3242
%closure.func3243 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3231, i32 0, i32 2
store i32 (i8*, i8*, %Texture*)* @type_adhoc_W2kzMixUZXh0dXJlKl0__3220, i32 (i8*, i8*, %Texture*)** %closure.func3243
%closure_size3244 = call i64 @llvm_zone_mark_size(%mzone* %zone3229)
call void @llvm_zone_ptr_set_size(i8* %clsptr3230, i64 %closure_size3244)
%wrapper_ptr3245 = call i8* @llvm_zone_malloc(%mzone* %zone3229, i64 8)
%closure_wrapper3246 = bitcast i8* %wrapper_ptr3245 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
store { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3231, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper3246

; let value assignment
%type_adhoc_W2kzMixUZXh0dXJlKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper3246, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper3246
store { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %type_adhoc_W2kzMixUZXh0dXJlKl0, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %type_adhoc_W2kzMixUZXh0dXJlKl0Ptr

; add data to environment
; don't need to alloc for env var type_adhoc_W2kzMixUZXh0dXJlKl0
%tmp_envptr3240 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}* %environment3233, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %type_adhoc_W2kzMixUZXh0dXJlKl0Ptr, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**** %tmp_envptr3240


%val3249 = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %type_adhoc_W2kzMixUZXh0dXJlKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %val3249
}


@type_adhoc_W2kzMixUZXh0dXJlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@type_adhoc_W2kzMixUZXh0dXJlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @type_adhoc_W2kzMixUZXh0dXJlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** @type_adhoc_W2kzMixUZXh0dXJlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @type_adhoc_W2kzMixUZXh0dXJlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @type_adhoc_W2kzMixUZXh0dXJlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3250 = bitcast [84 x i8]* @gsxtmgl-objects2226 to i8*
call i32 (i8*, ...) @printf(i8* %var3250)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @type_adhoc_W2kzMixUZXh0dXJlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2227 = hidden constant [36 x i8] c"type_adhoc_W2kzMixUZXh0dXJlKixpMzJd\00"
@gsxtmgl-objects2228 = hidden constant [46 x i8] c"{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**\00"
define dllexport fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd__3251(i8* %_impz,i8* %_impenv, %Texture* %tex, i32 %value) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3252 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}*
%type_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}* %impenv, i32 0, i32 0
%type_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**** %type_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%valuePtr = alloca i32
store i32 %value, i32* %valuePtr


%val3254 = load %Texture*, %Texture** %texPtr
%val3255 = icmp eq %Texture* %val3254, null
br i1 %val3255, label %then3253, label %else3253

then3253:
ret i32 -1

else3253:
%val3256 = load %Texture*, %Texture** %texPtr
%val3257 = load i32, i32* %valuePtr
; set tuple
%val3258 = getelementptr %Texture, %Texture* %val3256, i64 0, i32 1
store i32 %val3257, i32* %val3258
ret i32 %val3257
}
@gsxtmgl-objects2229 = hidden constant [89 x i8] c"type_adhoc_W2kzMixUZXh0dXJlKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3278 = load i8*, i8** %_impzPtr
%zone3279 = bitcast i8* %tzone3278 to %mzone*

; let assign value to symbol type_adhoc_W2kzMixUZXh0dXJlKixpMzJd
%dat_type_adhoc_W2kzMixUZXh0dXJlKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone3279, i64 8)
%type_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr = bitcast i8* %dat_type_adhoc_W2kzMixUZXh0dXJlKixpMzJd to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***
%tzone3259 = load i8*, i8** %_impzPtr
%zone3260 = bitcast i8* %tzone3259 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3260)
; malloc closure structure
%clsptr3261 = call i8* @llvm_zone_malloc(%mzone* %zone3260, i64 24)
%closure3262 = bitcast i8* %clsptr3261 to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*

; malloc environment structure
%envptr3263 = call i8* @llvm_zone_malloc(%mzone* %zone3260, i64 8)
%environment3264 = bitcast i8* %envptr3263 to {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}*

; malloc closure address table
%addytable3265 = call %clsvar* @new_address_table()
%var3266 = bitcast [36 x i8]* @gsxtmgl-objects2227 to i8*
%var3267 = bitcast [46 x i8]* @gsxtmgl-objects2228 to i8*
%addytable3268 = call %clsvar* @add_address_table(%mzone* %zone3260, i8* %var3266, i32 0, i8* %var3267, i32 3, %clsvar* %addytable3265)
%address-table3269 = bitcast %clsvar* %addytable3268 to i8*

; insert table, function and environment into closure struct
%closure.table3272 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure3262, i32 0, i32 0
store i8* %address-table3269, i8** %closure.table3272
%closure.env3273 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure3262, i32 0, i32 1
store i8* %envptr3263, i8** %closure.env3273
%closure.func3274 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure3262, i32 0, i32 2
store i32 (i8*, i8*, %Texture*, i32)* @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd__3251, i32 (i8*, i8*, %Texture*, i32)** %closure.func3274
%closure_size3275 = call i64 @llvm_zone_mark_size(%mzone* %zone3260)
call void @llvm_zone_ptr_set_size(i8* %clsptr3261, i64 %closure_size3275)
%wrapper_ptr3276 = call i8* @llvm_zone_malloc(%mzone* %zone3260, i64 8)
%closure_wrapper3277 = bitcast i8* %wrapper_ptr3276 to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
store { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure3262, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper3277

; let value assignment
%type_adhoc_W2kzMixUZXh0dXJlKixpMzJd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper3277, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper3277
store { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %type_adhoc_W2kzMixUZXh0dXJlKixpMzJd, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %type_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr

; add data to environment
; don't need to alloc for env var type_adhoc_W2kzMixUZXh0dXJlKixpMzJd
%tmp_envptr3271 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}* %environment3264, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %type_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**** %tmp_envptr3271


%val3280 = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %type_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr
ret {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %val3280
}


@type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_native(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3281 = bitcast [89 x i8]* @gsxtmgl-objects2229 to i8*
call i32 (i8*, ...) @printf(i8* %var3281)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3282 = bitcast [89 x i8]* @gsxtmgl-objects2229 to i8*
call i32 (i8*, ...) @printf(i8* %var3282)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, i32}*
%arg_p_0 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2230 = hidden constant [32 x i8] c"width_adhoc_W2kzMixUZXh0dXJlKl0\00"
define dllexport fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0__3283(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3284 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}*
%width_adhoc_W2kzMixUZXh0dXJlKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%width_adhoc_W2kzMixUZXh0dXJlKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}***, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**** %width_adhoc_W2kzMixUZXh0dXJlKl0Ptr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr


%val3286 = load %Texture*, %Texture** %texPtr
%val3287 = icmp eq %Texture* %val3286, null
br i1 %val3287, label %then3285, label %else3285

then3285:
ret i32 0

else3285:
%val3288 = load %Texture*, %Texture** %texPtr
; tuple ref
%val3289 = getelementptr %Texture, %Texture* %val3288, i64 0, i32 2
%val3290 = load i32, i32* %val3289
ret i32 %val3290
}
@gsxtmgl-objects2231 = hidden constant [85 x i8] c"width_adhoc_W2kzMixUZXh0dXJlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** @width_adhoc_W2kzMixUZXh0dXJlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3310 = load i8*, i8** %_impzPtr
%zone3311 = bitcast i8* %tzone3310 to %mzone*

; let assign value to symbol width_adhoc_W2kzMixUZXh0dXJlKl0
%dat_width_adhoc_W2kzMixUZXh0dXJlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3311, i64 8)
%width_adhoc_W2kzMixUZXh0dXJlKl0Ptr = bitcast i8* %dat_width_adhoc_W2kzMixUZXh0dXJlKl0 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}***
%tzone3291 = load i8*, i8** %_impzPtr
%zone3292 = bitcast i8* %tzone3291 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3292)
; malloc closure structure
%clsptr3293 = call i8* @llvm_zone_malloc(%mzone* %zone3292, i64 24)
%closure3294 = bitcast i8* %clsptr3293 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr3295 = call i8* @llvm_zone_malloc(%mzone* %zone3292, i64 8)
%environment3296 = bitcast i8* %envptr3295 to {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable3297 = call %clsvar* @new_address_table()
%var3298 = bitcast [32 x i8]* @gsxtmgl-objects2230 to i8*
%var3299 = bitcast [41 x i8]* @gsxtmgl-objects2223 to i8*
%addytable3300 = call %clsvar* @add_address_table(%mzone* %zone3292, i8* %var3298, i32 0, i8* %var3299, i32 3, %clsvar* %addytable3297)
%address-table3301 = bitcast %clsvar* %addytable3300 to i8*

; insert table, function and environment into closure struct
%closure.table3304 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3294, i32 0, i32 0
store i8* %address-table3301, i8** %closure.table3304
%closure.env3305 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3294, i32 0, i32 1
store i8* %envptr3295, i8** %closure.env3305
%closure.func3306 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3294, i32 0, i32 2
store i32 (i8*, i8*, %Texture*)* @width_adhoc_W2kzMixUZXh0dXJlKl0__3283, i32 (i8*, i8*, %Texture*)** %closure.func3306
%closure_size3307 = call i64 @llvm_zone_mark_size(%mzone* %zone3292)
call void @llvm_zone_ptr_set_size(i8* %clsptr3293, i64 %closure_size3307)
%wrapper_ptr3308 = call i8* @llvm_zone_malloc(%mzone* %zone3292, i64 8)
%closure_wrapper3309 = bitcast i8* %wrapper_ptr3308 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
store { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3294, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper3309

; let value assignment
%width_adhoc_W2kzMixUZXh0dXJlKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper3309, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper3309
store { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %width_adhoc_W2kzMixUZXh0dXJlKl0, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %width_adhoc_W2kzMixUZXh0dXJlKl0Ptr

; add data to environment
; don't need to alloc for env var width_adhoc_W2kzMixUZXh0dXJlKl0
%tmp_envptr3303 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}* %environment3296, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %width_adhoc_W2kzMixUZXh0dXJlKl0Ptr, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**** %tmp_envptr3303


%val3312 = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %width_adhoc_W2kzMixUZXh0dXJlKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %val3312
}


@width_adhoc_W2kzMixUZXh0dXJlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@width_adhoc_W2kzMixUZXh0dXJlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @width_adhoc_W2kzMixUZXh0dXJlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** @width_adhoc_W2kzMixUZXh0dXJlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @width_adhoc_W2kzMixUZXh0dXJlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @width_adhoc_W2kzMixUZXh0dXJlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3313 = bitcast [85 x i8]* @gsxtmgl-objects2231 to i8*
call i32 (i8*, ...) @printf(i8* %var3313)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @width_adhoc_W2kzMixUZXh0dXJlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2232 = hidden constant [37 x i8] c"width_adhoc_W2kzMixUZXh0dXJlKixpMzJd\00"
define dllexport fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd__3314(i8* %_impz,i8* %_impenv, %Texture* %tex, i32 %value) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3315 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}*
%width_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}* %impenv, i32 0, i32 0
%width_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**** %width_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%valuePtr = alloca i32
store i32 %value, i32* %valuePtr


%val3317 = load %Texture*, %Texture** %texPtr
%val3318 = icmp eq %Texture* %val3317, null
br i1 %val3318, label %then3316, label %else3316

then3316:
ret i32 0

else3316:
%val3319 = load %Texture*, %Texture** %texPtr
%val3320 = load i32, i32* %valuePtr
; set tuple
%val3321 = getelementptr %Texture, %Texture* %val3319, i64 0, i32 2
store i32 %val3320, i32* %val3321
ret i32 %val3320
}
@gsxtmgl-objects2233 = hidden constant [90 x i8] c"width_adhoc_W2kzMixUZXh0dXJlKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3341 = load i8*, i8** %_impzPtr
%zone3342 = bitcast i8* %tzone3341 to %mzone*

; let assign value to symbol width_adhoc_W2kzMixUZXh0dXJlKixpMzJd
%dat_width_adhoc_W2kzMixUZXh0dXJlKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone3342, i64 8)
%width_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr = bitcast i8* %dat_width_adhoc_W2kzMixUZXh0dXJlKixpMzJd to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***
%tzone3322 = load i8*, i8** %_impzPtr
%zone3323 = bitcast i8* %tzone3322 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3323)
; malloc closure structure
%clsptr3324 = call i8* @llvm_zone_malloc(%mzone* %zone3323, i64 24)
%closure3325 = bitcast i8* %clsptr3324 to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*

; malloc environment structure
%envptr3326 = call i8* @llvm_zone_malloc(%mzone* %zone3323, i64 8)
%environment3327 = bitcast i8* %envptr3326 to {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}*

; malloc closure address table
%addytable3328 = call %clsvar* @new_address_table()
%var3329 = bitcast [37 x i8]* @gsxtmgl-objects2232 to i8*
%var3330 = bitcast [46 x i8]* @gsxtmgl-objects2228 to i8*
%addytable3331 = call %clsvar* @add_address_table(%mzone* %zone3323, i8* %var3329, i32 0, i8* %var3330, i32 3, %clsvar* %addytable3328)
%address-table3332 = bitcast %clsvar* %addytable3331 to i8*

; insert table, function and environment into closure struct
%closure.table3335 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure3325, i32 0, i32 0
store i8* %address-table3332, i8** %closure.table3335
%closure.env3336 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure3325, i32 0, i32 1
store i8* %envptr3326, i8** %closure.env3336
%closure.func3337 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure3325, i32 0, i32 2
store i32 (i8*, i8*, %Texture*, i32)* @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd__3314, i32 (i8*, i8*, %Texture*, i32)** %closure.func3337
%closure_size3338 = call i64 @llvm_zone_mark_size(%mzone* %zone3323)
call void @llvm_zone_ptr_set_size(i8* %clsptr3324, i64 %closure_size3338)
%wrapper_ptr3339 = call i8* @llvm_zone_malloc(%mzone* %zone3323, i64 8)
%closure_wrapper3340 = bitcast i8* %wrapper_ptr3339 to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
store { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure3325, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper3340

; let value assignment
%width_adhoc_W2kzMixUZXh0dXJlKixpMzJd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper3340, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper3340
store { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %width_adhoc_W2kzMixUZXh0dXJlKixpMzJd, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %width_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr

; add data to environment
; don't need to alloc for env var width_adhoc_W2kzMixUZXh0dXJlKixpMzJd
%tmp_envptr3334 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}* %environment3327, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %width_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**** %tmp_envptr3334


%val3343 = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %width_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr
ret {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %val3343
}


@width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_native(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3344 = bitcast [90 x i8]* @gsxtmgl-objects2233 to i8*
call i32 (i8*, ...) @printf(i8* %var3344)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3345 = bitcast [90 x i8]* @gsxtmgl-objects2233 to i8*
call i32 (i8*, ...) @printf(i8* %var3345)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, i32}*
%arg_p_0 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2234 = hidden constant [33 x i8] c"height_adhoc_W2kzMixUZXh0dXJlKl0\00"
define dllexport fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0__3346(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3347 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}*
%height_adhoc_W2kzMixUZXh0dXJlKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%height_adhoc_W2kzMixUZXh0dXJlKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}***, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**** %height_adhoc_W2kzMixUZXh0dXJlKl0Ptr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr


%val3349 = load %Texture*, %Texture** %texPtr
%val3350 = icmp eq %Texture* %val3349, null
br i1 %val3350, label %then3348, label %else3348

then3348:
ret i32 0

else3348:
%val3351 = load %Texture*, %Texture** %texPtr
; tuple ref
%val3352 = getelementptr %Texture, %Texture* %val3351, i64 0, i32 3
%val3353 = load i32, i32* %val3352
ret i32 %val3353
}
@gsxtmgl-objects2235 = hidden constant [86 x i8] c"height_adhoc_W2kzMixUZXh0dXJlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** @height_adhoc_W2kzMixUZXh0dXJlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3373 = load i8*, i8** %_impzPtr
%zone3374 = bitcast i8* %tzone3373 to %mzone*

; let assign value to symbol height_adhoc_W2kzMixUZXh0dXJlKl0
%dat_height_adhoc_W2kzMixUZXh0dXJlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3374, i64 8)
%height_adhoc_W2kzMixUZXh0dXJlKl0Ptr = bitcast i8* %dat_height_adhoc_W2kzMixUZXh0dXJlKl0 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}***
%tzone3354 = load i8*, i8** %_impzPtr
%zone3355 = bitcast i8* %tzone3354 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3355)
; malloc closure structure
%clsptr3356 = call i8* @llvm_zone_malloc(%mzone* %zone3355, i64 24)
%closure3357 = bitcast i8* %clsptr3356 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr3358 = call i8* @llvm_zone_malloc(%mzone* %zone3355, i64 8)
%environment3359 = bitcast i8* %envptr3358 to {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable3360 = call %clsvar* @new_address_table()
%var3361 = bitcast [33 x i8]* @gsxtmgl-objects2234 to i8*
%var3362 = bitcast [41 x i8]* @gsxtmgl-objects2223 to i8*
%addytable3363 = call %clsvar* @add_address_table(%mzone* %zone3355, i8* %var3361, i32 0, i8* %var3362, i32 3, %clsvar* %addytable3360)
%address-table3364 = bitcast %clsvar* %addytable3363 to i8*

; insert table, function and environment into closure struct
%closure.table3367 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3357, i32 0, i32 0
store i8* %address-table3364, i8** %closure.table3367
%closure.env3368 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3357, i32 0, i32 1
store i8* %envptr3358, i8** %closure.env3368
%closure.func3369 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3357, i32 0, i32 2
store i32 (i8*, i8*, %Texture*)* @height_adhoc_W2kzMixUZXh0dXJlKl0__3346, i32 (i8*, i8*, %Texture*)** %closure.func3369
%closure_size3370 = call i64 @llvm_zone_mark_size(%mzone* %zone3355)
call void @llvm_zone_ptr_set_size(i8* %clsptr3356, i64 %closure_size3370)
%wrapper_ptr3371 = call i8* @llvm_zone_malloc(%mzone* %zone3355, i64 8)
%closure_wrapper3372 = bitcast i8* %wrapper_ptr3371 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
store { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure3357, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper3372

; let value assignment
%height_adhoc_W2kzMixUZXh0dXJlKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper3372, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper3372
store { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %height_adhoc_W2kzMixUZXh0dXJlKl0, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %height_adhoc_W2kzMixUZXh0dXJlKl0Ptr

; add data to environment
; don't need to alloc for env var height_adhoc_W2kzMixUZXh0dXJlKl0
%tmp_envptr3366 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}* %environment3359, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %height_adhoc_W2kzMixUZXh0dXJlKl0Ptr, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**** %tmp_envptr3366


%val3375 = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %height_adhoc_W2kzMixUZXh0dXJlKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %val3375
}


@height_adhoc_W2kzMixUZXh0dXJlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@height_adhoc_W2kzMixUZXh0dXJlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @height_adhoc_W2kzMixUZXh0dXJlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** @height_adhoc_W2kzMixUZXh0dXJlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @height_adhoc_W2kzMixUZXh0dXJlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @height_adhoc_W2kzMixUZXh0dXJlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3376 = bitcast [86 x i8]* @gsxtmgl-objects2235 to i8*
call i32 (i8*, ...) @printf(i8* %var3376)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @height_adhoc_W2kzMixUZXh0dXJlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2236 = hidden constant [38 x i8] c"height_adhoc_W2kzMixUZXh0dXJlKixpMzJd\00"
define dllexport fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd__3377(i8* %_impz,i8* %_impenv, %Texture* %tex, i32 %value) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3378 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}*
%height_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}* %impenv, i32 0, i32 0
%height_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**** %height_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%valuePtr = alloca i32
store i32 %value, i32* %valuePtr


%val3380 = load %Texture*, %Texture** %texPtr
%val3381 = icmp eq %Texture* %val3380, null
br i1 %val3381, label %then3379, label %else3379

then3379:
ret i32 0

else3379:
%val3382 = load %Texture*, %Texture** %texPtr
%val3383 = load i32, i32* %valuePtr
; set tuple
%val3384 = getelementptr %Texture, %Texture* %val3382, i64 0, i32 3
store i32 %val3383, i32* %val3384
ret i32 %val3383
}
@gsxtmgl-objects2237 = hidden constant [91 x i8] c"height_adhoc_W2kzMixUZXh0dXJlKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3404 = load i8*, i8** %_impzPtr
%zone3405 = bitcast i8* %tzone3404 to %mzone*

; let assign value to symbol height_adhoc_W2kzMixUZXh0dXJlKixpMzJd
%dat_height_adhoc_W2kzMixUZXh0dXJlKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone3405, i64 8)
%height_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr = bitcast i8* %dat_height_adhoc_W2kzMixUZXh0dXJlKixpMzJd to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***
%tzone3385 = load i8*, i8** %_impzPtr
%zone3386 = bitcast i8* %tzone3385 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3386)
; malloc closure structure
%clsptr3387 = call i8* @llvm_zone_malloc(%mzone* %zone3386, i64 24)
%closure3388 = bitcast i8* %clsptr3387 to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*

; malloc environment structure
%envptr3389 = call i8* @llvm_zone_malloc(%mzone* %zone3386, i64 8)
%environment3390 = bitcast i8* %envptr3389 to {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}*

; malloc closure address table
%addytable3391 = call %clsvar* @new_address_table()
%var3392 = bitcast [38 x i8]* @gsxtmgl-objects2236 to i8*
%var3393 = bitcast [46 x i8]* @gsxtmgl-objects2228 to i8*
%addytable3394 = call %clsvar* @add_address_table(%mzone* %zone3386, i8* %var3392, i32 0, i8* %var3393, i32 3, %clsvar* %addytable3391)
%address-table3395 = bitcast %clsvar* %addytable3394 to i8*

; insert table, function and environment into closure struct
%closure.table3398 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure3388, i32 0, i32 0
store i8* %address-table3395, i8** %closure.table3398
%closure.env3399 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure3388, i32 0, i32 1
store i8* %envptr3389, i8** %closure.env3399
%closure.func3400 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure3388, i32 0, i32 2
store i32 (i8*, i8*, %Texture*, i32)* @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd__3377, i32 (i8*, i8*, %Texture*, i32)** %closure.func3400
%closure_size3401 = call i64 @llvm_zone_mark_size(%mzone* %zone3386)
call void @llvm_zone_ptr_set_size(i8* %clsptr3387, i64 %closure_size3401)
%wrapper_ptr3402 = call i8* @llvm_zone_malloc(%mzone* %zone3386, i64 8)
%closure_wrapper3403 = bitcast i8* %wrapper_ptr3402 to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
store { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure3388, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper3403

; let value assignment
%height_adhoc_W2kzMixUZXh0dXJlKixpMzJd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper3403, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper3403
store { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %height_adhoc_W2kzMixUZXh0dXJlKixpMzJd, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %height_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr

; add data to environment
; don't need to alloc for env var height_adhoc_W2kzMixUZXh0dXJlKixpMzJd
%tmp_envptr3397 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}* %environment3390, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %height_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**** %tmp_envptr3397


%val3406 = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %height_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr
ret {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %val3406
}


@height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_native(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3407 = bitcast [91 x i8]* @gsxtmgl-objects2237 to i8*
call i32 (i8*, ...) @printf(i8* %var3407)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3408 = bitcast [91 x i8]* @gsxtmgl-objects2237 to i8*
call i32 (i8*, ...) @printf(i8* %var3408)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, i32}*
%arg_p_0 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2238 = hidden constant [31 x i8] c"data_adhoc_W2k4KixUZXh0dXJlKl0\00"
@gsxtmgl-objects2239 = hidden constant [41 x i8] c"{i8*, i8*, i8* (i8*, i8*, %Texture*)*}**\00"
define dllexport fastcc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0__3409(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3410 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, %Texture*)*}***}*
%data_adhoc_W2k4KixUZXh0dXJlKl0Ptr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%data_adhoc_W2k4KixUZXh0dXJlKl0Ptr = load {i8*, i8*, i8* (i8*, i8*, %Texture*)*}***, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}**** %data_adhoc_W2k4KixUZXh0dXJlKl0Ptr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr


%val3412 = load %Texture*, %Texture** %texPtr
%val3413 = icmp eq %Texture* %val3412, null
br i1 %val3413, label %then3411, label %else3411

then3411:
%null3414 = bitcast i8* null to i8*
ret i8* %null3414

else3411:
%val3415 = load %Texture*, %Texture** %texPtr
; tuple ref
%val3416 = getelementptr %Texture, %Texture* %val3415, i64 0, i32 4
%val3417 = load i8*, i8** %val3416
ret i8* %val3417
}
@gsxtmgl-objects2240 = hidden constant [84 x i8] c"data_adhoc_W2k4KixUZXh0dXJlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, %Texture*)*}** @data_adhoc_W2k4KixUZXh0dXJlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3437 = load i8*, i8** %_impzPtr
%zone3438 = bitcast i8* %tzone3437 to %mzone*

; let assign value to symbol data_adhoc_W2k4KixUZXh0dXJlKl0
%dat_data_adhoc_W2k4KixUZXh0dXJlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3438, i64 8)
%data_adhoc_W2k4KixUZXh0dXJlKl0Ptr = bitcast i8* %dat_data_adhoc_W2k4KixUZXh0dXJlKl0 to { i8*, i8*, i8* (i8*, i8*, %Texture*)*}***
%tzone3418 = load i8*, i8** %_impzPtr
%zone3419 = bitcast i8* %tzone3418 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3419)
; malloc closure structure
%clsptr3420 = call i8* @llvm_zone_malloc(%mzone* %zone3419, i64 24)
%closure3421 = bitcast i8* %clsptr3420 to { i8*, i8*, i8* (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr3422 = call i8* @llvm_zone_malloc(%mzone* %zone3419, i64 8)
%environment3423 = bitcast i8* %envptr3422 to {{i8*, i8*, i8* (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable3424 = call %clsvar* @new_address_table()
%var3425 = bitcast [31 x i8]* @gsxtmgl-objects2238 to i8*
%var3426 = bitcast [41 x i8]* @gsxtmgl-objects2239 to i8*
%addytable3427 = call %clsvar* @add_address_table(%mzone* %zone3419, i8* %var3425, i32 0, i8* %var3426, i32 3, %clsvar* %addytable3424)
%address-table3428 = bitcast %clsvar* %addytable3427 to i8*

; insert table, function and environment into closure struct
%closure.table3431 = getelementptr { i8*, i8*, i8* (i8*, i8*, %Texture*)*}, { i8*, i8*, i8* (i8*, i8*, %Texture*)*}* %closure3421, i32 0, i32 0
store i8* %address-table3428, i8** %closure.table3431
%closure.env3432 = getelementptr { i8*, i8*, i8* (i8*, i8*, %Texture*)*}, { i8*, i8*, i8* (i8*, i8*, %Texture*)*}* %closure3421, i32 0, i32 1
store i8* %envptr3422, i8** %closure.env3432
%closure.func3433 = getelementptr { i8*, i8*, i8* (i8*, i8*, %Texture*)*}, { i8*, i8*, i8* (i8*, i8*, %Texture*)*}* %closure3421, i32 0, i32 2
store i8* (i8*, i8*, %Texture*)* @data_adhoc_W2k4KixUZXh0dXJlKl0__3409, i8* (i8*, i8*, %Texture*)** %closure.func3433
%closure_size3434 = call i64 @llvm_zone_mark_size(%mzone* %zone3419)
call void @llvm_zone_ptr_set_size(i8* %clsptr3420, i64 %closure_size3434)
%wrapper_ptr3435 = call i8* @llvm_zone_malloc(%mzone* %zone3419, i64 8)
%closure_wrapper3436 = bitcast i8* %wrapper_ptr3435 to { i8*, i8*, i8* (i8*, i8*, %Texture*)*}**
store { i8*, i8*, i8* (i8*, i8*, %Texture*)*}* %closure3421, { i8*, i8*, i8* (i8*, i8*, %Texture*)*}** %closure_wrapper3436

; let value assignment
%data_adhoc_W2k4KixUZXh0dXJlKl0 = select i1 true, { i8*, i8*, i8* (i8*, i8*, %Texture*)*}** %closure_wrapper3436, { i8*, i8*, i8* (i8*, i8*, %Texture*)*}** %closure_wrapper3436
store { i8*, i8*, i8* (i8*, i8*, %Texture*)*}** %data_adhoc_W2k4KixUZXh0dXJlKl0, { i8*, i8*, i8* (i8*, i8*, %Texture*)*}*** %data_adhoc_W2k4KixUZXh0dXJlKl0Ptr

; add data to environment
; don't need to alloc for env var data_adhoc_W2k4KixUZXh0dXJlKl0
%tmp_envptr3430 = getelementptr {{i8*, i8*, i8* (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %Texture*)*}***}* %environment3423, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, %Texture*)*}*** %data_adhoc_W2k4KixUZXh0dXJlKl0Ptr, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}**** %tmp_envptr3430


%val3439 = load {i8*, i8*, i8* (i8*, i8*, %Texture*)*}**, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}*** %data_adhoc_W2k4KixUZXh0dXJlKl0Ptr
ret {i8*, i8*, i8* (i8*, i8*, %Texture*)*}** %val3439
}


@data_adhoc_W2k4KixUZXh0dXJlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@data_adhoc_W2k4KixUZXh0dXJlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @data_adhoc_W2k4KixUZXh0dXJlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @data_adhoc_W2k4KixUZXh0dXJlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, %Texture*)*}** @data_adhoc_W2k4KixUZXh0dXJlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @data_adhoc_W2k4KixUZXh0dXJlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @data_adhoc_W2k4KixUZXh0dXJlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @data_adhoc_W2k4KixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %Texture*)*}*, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Texture*)*}, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Texture*)*}, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %Texture*)*,  i8* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret i8* %result
}


define dllexport ccc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @data_adhoc_W2k4KixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %Texture*)*}*, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Texture*)*}, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Texture*)*}, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %Texture*)*,  i8* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @data_adhoc_W2k4KixUZXh0dXJlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3440 = bitcast [84 x i8]* @gsxtmgl-objects2240 to i8*
call i32 (i8*, ...) @printf(i8* %var3440)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @data_adhoc_W2k4KixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %Texture*)*}*, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Texture*)*}, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Texture*)*}, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %Texture*)*,  i8* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @data_adhoc_W2k4KixUZXh0dXJlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @data_adhoc_W2k4KixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %Texture*)*}*, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Texture*)*}, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %Texture*)*}, {i8*, i8*, i8* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %Texture*)*,  i8* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2241 = hidden constant [11 x i8] c"<TEX: 0x0>\00"
@gsxtmgl-objects2242 = hidden constant [40 x i8] c"<TEX: id:%d type:%d width:%d height:%d>\00"
@gsxtmgl-objects2243 = hidden constant [33 x i8] c"print_adhoc_W3ZvaWQsVGV4dHVyZSpd\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsVGV4dHVyZSpd__3441(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3442 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*
%print_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = load {i8*, i8*, void (i8*, i8*, %Texture*)*}***, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %print_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr

; promote local stack var allocations
%tzone3460 = load i8*, i8** %_impzPtr
%zone3461 = bitcast i8* %tzone3460 to %mzone*
%ifptr3443 = alloca i32

%val3444 = load %Texture*, %Texture** %texPtr
%val3445 = icmp eq %Texture* %val3444, null
br i1 %val3445, label %then3443, label %else3443

then3443:
%var3446 = bitcast [11 x i8]* @gsxtmgl-objects2241 to i8*

%val3447 = call i32 (i8*, ...) @printf(i8* %var3446)
store i32 %val3447, i32* %ifptr3443
br label %ifcont3443

else3443:
%var3448 = bitcast [40 x i8]* @gsxtmgl-objects2242 to i8*
%val3449 = load %Texture*, %Texture** %texPtr
%res3450 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val3449)
%val3451 = load %Texture*, %Texture** %texPtr
%res3452 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val3451)
%val3453 = load %Texture*, %Texture** %texPtr
%res3454 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val3453)
%val3455 = load %Texture*, %Texture** %texPtr
%res3456 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val3455)

%val3457 = call i32 (i8*, ...) @printf(i8* %var3448, i32 %res3450, i32 %res3452, i32 %res3454, i32 %res3456)
store i32 %val3457, i32* %ifptr3443
br label %ifcont3443

ifcont3443:
%ifres3458 = load i32, i32* %ifptr3443

ret void
}
@gsxtmgl-objects2244 = hidden constant [86 x i8] c"print_adhoc_W3ZvaWQsVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3481 = load i8*, i8** %_impzPtr
%zone3482 = bitcast i8* %tzone3481 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsVGV4dHVyZSpd
%dat_print_adhoc_W3ZvaWQsVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3482, i64 8)
%print_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsVGV4dHVyZSpd to { i8*, i8*, void (i8*, i8*, %Texture*)*}***
%tzone3462 = load i8*, i8** %_impzPtr
%zone3463 = bitcast i8* %tzone3462 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3463)
; malloc closure structure
%clsptr3464 = call i8* @llvm_zone_malloc(%mzone* %zone3463, i64 24)
%closure3465 = bitcast i8* %clsptr3464 to { i8*, i8*, void (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr3466 = call i8* @llvm_zone_malloc(%mzone* %zone3463, i64 8)
%environment3467 = bitcast i8* %envptr3466 to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable3468 = call %clsvar* @new_address_table()
%var3469 = bitcast [33 x i8]* @gsxtmgl-objects2243 to i8*
%var3470 = bitcast [42 x i8]* @gsxtmgl-objects2217 to i8*
%addytable3471 = call %clsvar* @add_address_table(%mzone* %zone3463, i8* %var3469, i32 0, i8* %var3470, i32 3, %clsvar* %addytable3468)
%address-table3472 = bitcast %clsvar* %addytable3471 to i8*

; insert table, function and environment into closure struct
%closure.table3475 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure3465, i32 0, i32 0
store i8* %address-table3472, i8** %closure.table3475
%closure.env3476 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure3465, i32 0, i32 1
store i8* %envptr3466, i8** %closure.env3476
%closure.func3477 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure3465, i32 0, i32 2
store void (i8*, i8*, %Texture*)* @print_adhoc_W3ZvaWQsVGV4dHVyZSpd__3441, void (i8*, i8*, %Texture*)** %closure.func3477
%closure_size3478 = call i64 @llvm_zone_mark_size(%mzone* %zone3463)
call void @llvm_zone_ptr_set_size(i8* %clsptr3464, i64 %closure_size3478)
%wrapper_ptr3479 = call i8* @llvm_zone_malloc(%mzone* %zone3463, i64 8)
%closure_wrapper3480 = bitcast i8* %wrapper_ptr3479 to { i8*, i8*, void (i8*, i8*, %Texture*)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure3465, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper3480

; let value assignment
%print_adhoc_W3ZvaWQsVGV4dHVyZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper3480, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper3480
store { i8*, i8*, void (i8*, i8*, %Texture*)*}** %print_adhoc_W3ZvaWQsVGV4dHVyZSpd, { i8*, i8*, void (i8*, i8*, %Texture*)*}*** %print_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsVGV4dHVyZSpd
%tmp_envptr3474 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %environment3467, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %print_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %tmp_envptr3474


%val3483 = load {i8*, i8*, void (i8*, i8*, %Texture*)*}**, {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %print_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr
ret {i8*, i8*, void (i8*, i8*, %Texture*)*}** %val3483
}


@print_adhoc_W3ZvaWQsVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3484 = bitcast [86 x i8]* @gsxtmgl-objects2244 to i8*
call i32 (i8*, ...) @printf(i8* %var3484)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2245 = hidden constant [40 x i8] c"toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd\00"
@gsxtmgl-objects2246 = hidden constant [46 x i8] c"{i8*, i8*, %String* (i8*, i8*, %Texture*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd__3485(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3486 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %Texture*)*}***}*
%toString_adhoc_W1N0cmluZyosVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosVGV4dHVyZSpdPtr = load {i8*, i8*, %String* (i8*, i8*, %Texture*)*}***, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}**** %toString_adhoc_W1N0cmluZyosVGV4dHVyZSpdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr


%tzone3488 = load i8*, i8** %_impzPtr
%zone3489 = bitcast i8* %tzone3488 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat3487 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat3487, i8* %dat3487
store i8* %s, i8** %sPtr

; promote local stack var allocations
%tzone3508 = load i8*, i8** %_impzPtr
%zone3509 = bitcast i8* %tzone3508 to %mzone*
%ifptr3490 = alloca i32
%val3491 = load %Texture*, %Texture** %texPtr
%val3492 = icmp eq %Texture* %val3491, null
br i1 %val3492, label %then3490, label %else3490

then3490:
%var3493 = bitcast [11 x i8]* @gsxtmgl-objects2241 to i8*

%val3494 = call i32 (i8*, ...) @printf(i8* %var3493)
store i32 %val3494, i32* %ifptr3490
br label %ifcont3490

else3490:
%var3495 = bitcast [40 x i8]* @gsxtmgl-objects2242 to i8*
%val3496 = load %Texture*, %Texture** %texPtr
%res3497 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val3496)
%val3498 = load %Texture*, %Texture** %texPtr
%res3499 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val3498)
%val3500 = load %Texture*, %Texture** %texPtr
%res3501 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val3500)
%val3502 = load %Texture*, %Texture** %texPtr
%res3503 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val3502)

%val3504 = call i32 (i8*, ...) @printf(i8* %var3495, i32 %res3497, i32 %res3499, i32 %res3501, i32 %res3503)
store i32 %val3504, i32* %ifptr3490
br label %ifcont3490

ifcont3490:
%ifres3505 = load i32, i32* %ifptr3490

%val3506 = load i8*, i8** %sPtr
%res3507 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3506)
ret %String* %res3507
}
@gsxtmgl-objects2247 = hidden constant [93 x i8] c"toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %Texture*)*}** @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3529 = load i8*, i8** %_impzPtr
%zone3530 = bitcast i8* %tzone3529 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd
%dat_toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3530, i64 8)
%toString_adhoc_W1N0cmluZyosVGV4dHVyZSpdPtr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd to { i8*, i8*, %String* (i8*, i8*, %Texture*)*}***
%tzone3510 = load i8*, i8** %_impzPtr
%zone3511 = bitcast i8* %tzone3510 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3511)
; malloc closure structure
%clsptr3512 = call i8* @llvm_zone_malloc(%mzone* %zone3511, i64 24)
%closure3513 = bitcast i8* %clsptr3512 to { i8*, i8*, %String* (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr3514 = call i8* @llvm_zone_malloc(%mzone* %zone3511, i64 8)
%environment3515 = bitcast i8* %envptr3514 to {{i8*, i8*, %String* (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable3516 = call %clsvar* @new_address_table()
%var3517 = bitcast [40 x i8]* @gsxtmgl-objects2245 to i8*
%var3518 = bitcast [46 x i8]* @gsxtmgl-objects2246 to i8*
%addytable3519 = call %clsvar* @add_address_table(%mzone* %zone3511, i8* %var3517, i32 0, i8* %var3518, i32 3, %clsvar* %addytable3516)
%address-table3520 = bitcast %clsvar* %addytable3519 to i8*

; insert table, function and environment into closure struct
%closure.table3523 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Texture*)*}, { i8*, i8*, %String* (i8*, i8*, %Texture*)*}* %closure3513, i32 0, i32 0
store i8* %address-table3520, i8** %closure.table3523
%closure.env3524 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Texture*)*}, { i8*, i8*, %String* (i8*, i8*, %Texture*)*}* %closure3513, i32 0, i32 1
store i8* %envptr3514, i8** %closure.env3524
%closure.func3525 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Texture*)*}, { i8*, i8*, %String* (i8*, i8*, %Texture*)*}* %closure3513, i32 0, i32 2
store %String* (i8*, i8*, %Texture*)* @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd__3485, %String* (i8*, i8*, %Texture*)** %closure.func3525
%closure_size3526 = call i64 @llvm_zone_mark_size(%mzone* %zone3511)
call void @llvm_zone_ptr_set_size(i8* %clsptr3512, i64 %closure_size3526)
%wrapper_ptr3527 = call i8* @llvm_zone_malloc(%mzone* %zone3511, i64 8)
%closure_wrapper3528 = bitcast i8* %wrapper_ptr3527 to { i8*, i8*, %String* (i8*, i8*, %Texture*)*}**
store { i8*, i8*, %String* (i8*, i8*, %Texture*)*}* %closure3513, { i8*, i8*, %String* (i8*, i8*, %Texture*)*}** %closure_wrapper3528

; let value assignment
%toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %Texture*)*}** %closure_wrapper3528, { i8*, i8*, %String* (i8*, i8*, %Texture*)*}** %closure_wrapper3528
store { i8*, i8*, %String* (i8*, i8*, %Texture*)*}** %toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd, { i8*, i8*, %String* (i8*, i8*, %Texture*)*}*** %toString_adhoc_W1N0cmluZyosVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd
%tmp_envptr3522 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Texture*)*}***}* %environment3515, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %Texture*)*}*** %toString_adhoc_W1N0cmluZyosVGV4dHVyZSpdPtr, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}**** %tmp_envptr3522


%val3531 = load {i8*, i8*, %String* (i8*, i8*, %Texture*)*}**, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}*** %toString_adhoc_W1N0cmluZyosVGV4dHVyZSpdPtr
ret {i8*, i8*, %String* (i8*, i8*, %Texture*)*}** %val3531
}


@toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %Texture*)*}** @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Texture*)*}*, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Texture*)*}, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Texture*)*}, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Texture*)*,  %String* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Texture*)*}*, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Texture*)*}, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Texture*)*}, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Texture*)*,  %String* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3532 = bitcast [93 x i8]* @gsxtmgl-objects2247 to i8*
call i32 (i8*, ...) @printf(i8* %var3532)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Texture*)*}*, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Texture*)*}, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Texture*)*}, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Texture*)*,  %String* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Texture*)*}*, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Texture*)*}, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Texture*)*}, {i8*, i8*, %String* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Texture*)*,  %String* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2248 = hidden constant [38 x i8] c"free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd\00"
define dllexport fastcc void @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd__3533(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3534 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*
%free_image_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%free_image_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = load {i8*, i8*, void (i8*, i8*, %Texture*)*}***, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %free_image_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr

; promote local stack var allocations
%tzone3556 = load i8*, i8** %_impzPtr
%zone3557 = bitcast i8* %tzone3556 to %mzone*
%ifptr3536 = alloca i1

%val3537 = load %Texture*, %Texture** %texPtr
; tuple ref
%val3538 = getelementptr %Texture, %Texture* %val3537, i64 0, i32 4
%val3539 = load i8*, i8** %val3538
%val3540 = icmp eq i8* %val3539, null
br i1 %val3540, label %then3536, label %else3536

then3536:
%res3541 = call ccc i1 @impc_false()
store i1 %res3541, i1* %ifptr3536
br label %ifcont3536

else3536:
%res3542 = call ccc i1 @impc_true()
store i1 %res3542, i1* %ifptr3536
br label %ifcont3536

ifcont3536:
%ifres3543 = load i1, i1* %ifptr3536

br i1 %ifres3543, label %then3535, label %else3535

then3535:
%val3544 = load %Texture*, %Texture** %texPtr
; tuple ref
%val3545 = getelementptr %Texture, %Texture* %val3544, i64 0, i32 4
%val3546 = load i8*, i8** %val3545
%val3547 = bitcast i8* %val3546 to i8*
call ccc void @free(i8* %val3547)
br label %ifcont3535

else3535:
br label %ifcont3535

ifcont3535:
%val3549 = load %Texture*, %Texture** %texPtr
; set tuple
%val3550 = getelementptr %Texture, %Texture* %val3549, i64 0, i32 1
store i32 0, i32* %val3550
%val3551 = load %Texture*, %Texture** %texPtr
; set tuple
%val3552 = getelementptr %Texture, %Texture* %val3551, i64 0, i32 2
store i32 0, i32* %val3552
%val3553 = load %Texture*, %Texture** %texPtr
; set tuple
%val3554 = getelementptr %Texture, %Texture* %val3553, i64 0, i32 3
store i32 0, i32* %val3554
ret void
}
@gsxtmgl-objects2249 = hidden constant [91 x i8] c"free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3577 = load i8*, i8** %_impzPtr
%zone3578 = bitcast i8* %tzone3577 to %mzone*

; let assign value to symbol free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd
%dat_free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone3578, i64 8)
%free_image_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = bitcast i8* %dat_free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd to { i8*, i8*, void (i8*, i8*, %Texture*)*}***
%tzone3558 = load i8*, i8** %_impzPtr
%zone3559 = bitcast i8* %tzone3558 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3559)
; malloc closure structure
%clsptr3560 = call i8* @llvm_zone_malloc(%mzone* %zone3559, i64 24)
%closure3561 = bitcast i8* %clsptr3560 to { i8*, i8*, void (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr3562 = call i8* @llvm_zone_malloc(%mzone* %zone3559, i64 8)
%environment3563 = bitcast i8* %envptr3562 to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable3564 = call %clsvar* @new_address_table()
%var3565 = bitcast [38 x i8]* @gsxtmgl-objects2248 to i8*
%var3566 = bitcast [42 x i8]* @gsxtmgl-objects2217 to i8*
%addytable3567 = call %clsvar* @add_address_table(%mzone* %zone3559, i8* %var3565, i32 0, i8* %var3566, i32 3, %clsvar* %addytable3564)
%address-table3568 = bitcast %clsvar* %addytable3567 to i8*

; insert table, function and environment into closure struct
%closure.table3571 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure3561, i32 0, i32 0
store i8* %address-table3568, i8** %closure.table3571
%closure.env3572 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure3561, i32 0, i32 1
store i8* %envptr3562, i8** %closure.env3572
%closure.func3573 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure3561, i32 0, i32 2
store void (i8*, i8*, %Texture*)* @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd__3533, void (i8*, i8*, %Texture*)** %closure.func3573
%closure_size3574 = call i64 @llvm_zone_mark_size(%mzone* %zone3559)
call void @llvm_zone_ptr_set_size(i8* %clsptr3560, i64 %closure_size3574)
%wrapper_ptr3575 = call i8* @llvm_zone_malloc(%mzone* %zone3559, i64 8)
%closure_wrapper3576 = bitcast i8* %wrapper_ptr3575 to { i8*, i8*, void (i8*, i8*, %Texture*)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure3561, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper3576

; let value assignment
%free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper3576, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper3576
store { i8*, i8*, void (i8*, i8*, %Texture*)*}** %free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd, { i8*, i8*, void (i8*, i8*, %Texture*)*}*** %free_image_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd
%tmp_envptr3570 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %environment3563, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %free_image_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %tmp_envptr3570


%val3579 = load {i8*, i8*, void (i8*, i8*, %Texture*)*}**, {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %free_image_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr
ret {i8*, i8*, void (i8*, i8*, %Texture*)*}** %val3579
}


@free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc void @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc i8*  @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3580 = bitcast [91 x i8]* @gsxtmgl-objects2249 to i8*
call i32 (i8*, ...) @printf(i8* %var3580)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2250 = hidden constant [27 x i8] c"Unknown componenet depth: \00"
@gsxtmgl-objects2251 = hidden constant [53 x i8] c"load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd\00"
@gsxtmgl-objects2252 = hidden constant [57 x i8] c"{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}**\00"
define dllexport fastcc void @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd__3581(i8* %_impz,i8* %_impenv, %Texture* %tex, i32 %flipped, %String* %filename) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3582 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}***}*
%load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}***}* %impenv, i32 0, i32 0
%load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypdPtr = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}***, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}**** %load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%flippedPtr = alloca i32
store i32 %flipped, i32* %flippedPtr
%filenamePtr = alloca %String*
store %String* %filename, %String** %filenamePtr


%val3583 = load i32, i32* %flippedPtr
call ccc void @stbi_set_flip_vertically_on_load(i32 %val3583)
%tzone3587 = load i8*, i8** %_impzPtr
%zone3588 = bitcast i8* %tzone3587 to %mzone*

; let assign value to symbol width_ptr
%width_ptrPtr = alloca i32*
%tzone3591 = load i8*, i8** %_impzPtr
%zone3592 = bitcast i8* %tzone3591 to %mzone*

; let assign value to symbol height_ptr
%height_ptrPtr = alloca i32*
%tzone3594 = load i8*, i8** %_impzPtr
%zone3595 = bitcast i8* %tzone3594 to %mzone*

; let assign value to symbol comp_ptr
%comp_ptrPtr = alloca i32*
%tzone3602 = load i8*, i8** %_impzPtr
%zone3603 = bitcast i8* %tzone3602 to %mzone*

; let assign value to symbol data_s_24
%data_s_24Ptr = alloca i8*
%val3585 = load %Texture*, %Texture** %texPtr
; tuple ref
%val3586 = getelementptr %Texture, %Texture* %val3585, i64 0, i32 2

; let value assignment
%width_ptr = select i1 true, i32* %val3586, i32* %val3586
store i32* %width_ptr, i32** %width_ptrPtr

%val3589 = load %Texture*, %Texture** %texPtr
; tuple ref
%val3590 = getelementptr %Texture, %Texture* %val3589, i64 0, i32 3

; let value assignment
%height_ptr = select i1 true, i32* %val3590, i32* %val3590
store i32* %height_ptr, i32** %height_ptrPtr

%dat3593 = alloca i32, align 16

; let value assignment
%comp_ptr = select i1 true, i32* %dat3593, i32* %dat3593
store i32* %comp_ptr, i32** %comp_ptrPtr

%val3596 = load %String*, %String** %filenamePtr
%res3597 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val3596)
%val3598 = load i32*, i32** %width_ptrPtr
%val3599 = load i32*, i32** %height_ptrPtr
%val3600 = load i32*, i32** %comp_ptrPtr
%res3601 = call ccc i8* @stbi_load(i8* %res3597, i32* %val3598, i32* %val3599, i32* %val3600, i32 4)

; let value assignment
%data_s_24 = select i1 true, i8* %res3601, i8* %res3601
store i8* %data_s_24, i8** %data_s_24Ptr

; promote local stack var allocations
%tzone3652 = load i8*, i8** %_impzPtr
%zone3653 = bitcast i8* %tzone3652 to %mzone*
%ifptr3641 = alloca i64
%ifptr3604 = alloca i32
%ifptr3612 = alloca i32
%ifptr3620 = alloca i32
%val3605 = load i32*, i32** %comp_ptrPtr
; pointer ref
%val3606 = getelementptr i32, i32* %val3605, i64 0
%val3607 = load i32, i32* %val3606
%cmp3608 = icmp eq i32 %val3607, 4
br i1 %cmp3608, label %then3604, label %else3604

then3604:
%val3609 = load %Texture*, %Texture** %texPtr
%val3610 = load i32, i32* @GL_RGBA
; set tuple
%val3611 = getelementptr %Texture, %Texture* %val3609, i64 0, i32 1
store i32 %val3610, i32* %val3611
store i32 %val3610, i32* %ifptr3604
br label %ifcont3604

else3604:
%val3613 = load i32*, i32** %comp_ptrPtr
; pointer ref
%val3614 = getelementptr i32, i32* %val3613, i64 0
%val3615 = load i32, i32* %val3614
%cmp3616 = icmp eq i32 %val3615, 3
br i1 %cmp3616, label %then3612, label %else3612

then3612:
%val3617 = load %Texture*, %Texture** %texPtr
%val3618 = load i32, i32* @GL_RGBA
; set tuple
%val3619 = getelementptr %Texture, %Texture* %val3617, i64 0, i32 1
store i32 %val3618, i32* %val3619
store i32 %val3618, i32* %ifptr3612
br label %ifcont3612

else3612:
%val3621 = load i32*, i32** %comp_ptrPtr
; pointer ref
%val3622 = getelementptr i32, i32* %val3621, i64 0
%val3623 = load i32, i32* %val3622
%cmp3624 = icmp eq i32 %val3623, 1
br i1 %cmp3624, label %then3620, label %else3620

then3620:
%val3625 = load %Texture*, %Texture** %texPtr
%val3626 = load i32, i32* @GL_DEPTH_COMPONENT
; set tuple
%val3627 = getelementptr %Texture, %Texture* %val3625, i64 0, i32 1
store i32 %val3626, i32* %val3627
store i32 %val3626, i32* %ifptr3620
br label %ifcont3620

else3620:
%var3628 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var3629 = bitcast [27 x i8]* @gsxtmgl-objects2250 to i8*

%val3630 = call i32 (i8*, ...) @printf(i8* %var3628, i8* %var3629)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%val3632 = load i32*, i32** %comp_ptrPtr
; pointer ref
%val3633 = getelementptr i32, i32* %val3632, i64 0
%val3634 = load i32, i32* %val3633
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val3634)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val3637 = trunc i64 1 to i32
store i32 %val3637, i32* %ifptr3620
br label %ifcont3620

ifcont3620:
%ifres3638 = load i32, i32* %ifptr3620

store i32 %ifres3638, i32* %ifptr3612
br label %ifcont3612

ifcont3612:
%ifres3639 = load i32, i32* %ifptr3612

store i32 %ifres3639, i32* %ifptr3604
br label %ifcont3604

ifcont3604:
%ifres3640 = load i32, i32* %ifptr3604

%val3642 = load i8*, i8** %data_s_24Ptr
%val3643 = icmp eq i8* %val3642, null
br i1 %val3643, label %then3641, label %else3641

then3641:
%res3644 = call ccc i8* @stbi_failure_reason()
call fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %res3644)
call fastcc void @print_return_adhoc_W3ZvaWRd()
store i64 1, i64* %ifptr3641
br label %ifcont3641

else3641:
%val3647 = load %Texture*, %Texture** %texPtr
%val3648 = load i8*, i8** %data_s_24Ptr
; set tuple
%val3649 = getelementptr %Texture, %Texture* %val3647, i64 0, i32 4
store i8* %val3648, i8** %val3649
store i64 1, i64* %ifptr3641
br label %ifcont3641

ifcont3641:
%ifres3650 = load i64, i64* %ifptr3641

ret void
}
@gsxtmgl-objects2253 = hidden constant [106 x i8] c"load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}** @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3673 = load i8*, i8** %_impzPtr
%zone3674 = bitcast i8* %tzone3673 to %mzone*

; let assign value to symbol load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd
%dat_load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone3674, i64 8)
%load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypdPtr = bitcast i8* %dat_load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd to { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}***
%tzone3654 = load i8*, i8** %_impzPtr
%zone3655 = bitcast i8* %tzone3654 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3655)
; malloc closure structure
%clsptr3656 = call i8* @llvm_zone_malloc(%mzone* %zone3655, i64 24)
%closure3657 = bitcast i8* %clsptr3656 to { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}*

; malloc environment structure
%envptr3658 = call i8* @llvm_zone_malloc(%mzone* %zone3655, i64 8)
%environment3659 = bitcast i8* %envptr3658 to {{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}***}*

; malloc closure address table
%addytable3660 = call %clsvar* @new_address_table()
%var3661 = bitcast [53 x i8]* @gsxtmgl-objects2251 to i8*
%var3662 = bitcast [57 x i8]* @gsxtmgl-objects2252 to i8*
%addytable3663 = call %clsvar* @add_address_table(%mzone* %zone3655, i8* %var3661, i32 0, i8* %var3662, i32 3, %clsvar* %addytable3660)
%address-table3664 = bitcast %clsvar* %addytable3663 to i8*

; insert table, function and environment into closure struct
%closure.table3667 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}* %closure3657, i32 0, i32 0
store i8* %address-table3664, i8** %closure.table3667
%closure.env3668 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}* %closure3657, i32 0, i32 1
store i8* %envptr3658, i8** %closure.env3668
%closure.func3669 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}* %closure3657, i32 0, i32 2
store void (i8*, i8*, %Texture*, i32, %String*)* @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd__3581, void (i8*, i8*, %Texture*, i32, %String*)** %closure.func3669
%closure_size3670 = call i64 @llvm_zone_mark_size(%mzone* %zone3655)
call void @llvm_zone_ptr_set_size(i8* %clsptr3656, i64 %closure_size3670)
%wrapper_ptr3671 = call i8* @llvm_zone_malloc(%mzone* %zone3655, i64 8)
%closure_wrapper3672 = bitcast i8* %wrapper_ptr3671 to { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}* %closure3657, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}** %closure_wrapper3672

; let value assignment
%load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}** %closure_wrapper3672, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}** %closure_wrapper3672
store { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}** %load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}*** %load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd
%tmp_envptr3666 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}***}* %environment3659, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}*** %load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypdPtr, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}**** %tmp_envptr3666


%val3675 = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}**, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}*** %load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypdPtr
ret {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}** %val3675
}


@load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}** @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd(%Texture* %arg_0,i32 %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32, %String*)*,  void (i8*, i8*, %Texture*, i32, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1, %String* %arg_2)
ret void
}


define dllexport ccc void @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_native(%Texture* %arg_0,i32 %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32, %String*)*,  void (i8*, i8*, %Texture*, i32, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1, %String* %arg_2)
ret void
}


define dllexport ccc i8*  @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3676 = bitcast [106 x i8]* @gsxtmgl-objects2253 to i8*
call i32 (i8*, ...) @printf(i8* %var3676)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3677 = bitcast [106 x i8]* @gsxtmgl-objects2253 to i8*
call i32 (i8*, ...) @printf(i8* %var3677)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3678 = bitcast [106 x i8]* @gsxtmgl-objects2253 to i8*
call i32 (i8*, ...) @printf(i8* %var3678)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32, %String*)*,  void (i8*, i8*, %Texture*, i32, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1, %String* %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, i32, %String*}*
%arg_p_0 = getelementptr {%Texture*, i32, %String*}, {%Texture*, i32, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, i32, %String*}, {%Texture*, i32, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%Texture*, i32, %String*}, {%Texture*, i32, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32, %String*)*,  void (i8*, i8*, %Texture*, i32, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1, %String* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2254 = hidden constant [54 x i8] c"Bad cube map!  All 6 images must have the same width!\00"
@gsxtmgl-objects2255 = hidden constant [55 x i8] c"Bad cube map!  All 6 images must have the same height!\00"
@gsxtmgl-objects2256 = hidden constant [68 x i8] c"Bad cube map!  All 6 images must have the same number of components\00"
@gsxtmgl-objects2257 = hidden constant [27 x i8] c"failed to load some images\00"
@gsxtmgl-objects2258 = hidden constant [112 x i8] c"load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ\00"
@gsxtmgl-objects2259 = hidden constant [107 x i8] c"{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}**\00"
define dllexport fastcc void @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ__3679(i8* %_impz,i8* %_impenv, %Texture* %tex, i32 %flipped, %String* %front, %String* %back, %String* %top, %String* %bottom, %String* %left, %String* %right) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3680 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}***}*
%load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}***, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}**** %load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%flippedPtr = alloca i32
store i32 %flipped, i32* %flippedPtr
%frontPtr = alloca %String*
store %String* %front, %String** %frontPtr
%backPtr = alloca %String*
store %String* %back, %String** %backPtr
%topPtr = alloca %String*
store %String* %top, %String** %topPtr
%bottomPtr = alloca %String*
store %String* %bottom, %String** %bottomPtr
%leftPtr = alloca %String*
store %String* %left, %String** %leftPtr
%rightPtr = alloca %String*
store %String* %right, %String** %rightPtr


%val3681 = load i32, i32* %flippedPtr
call ccc void @stbi_set_flip_vertically_on_load(i32 %val3681)
%tzone3685 = load i8*, i8** %_impzPtr
%zone3686 = bitcast i8* %tzone3685 to %mzone*

; let assign value to symbol width_ptr
%width_ptrPtr = alloca i32*
%tzone3689 = load i8*, i8** %_impzPtr
%zone3690 = bitcast i8* %tzone3689 to %mzone*

; let assign value to symbol height_ptr
%height_ptrPtr = alloca i32*
%tzone3692 = load i8*, i8** %_impzPtr
%zone3693 = bitcast i8* %tzone3692 to %mzone*

; let assign value to symbol comp_ptr
%comp_ptrPtr = alloca i32*
%tzone3694 = load i8*, i8** %_impzPtr
%zone3695 = bitcast i8* %tzone3694 to %mzone*

; let assign value to symbol i
%iPtr = alloca i32
%tzone3697 = load i8*, i8** %_impzPtr
%zone3698 = bitcast i8* %tzone3697 to %mzone*

; let assign value to symbol wp
%wpPtr = alloca i32*
%tzone3700 = load i8*, i8** %_impzPtr
%zone3701 = bitcast i8* %tzone3700 to %mzone*

; let assign value to symbol hp
%hpPtr = alloca i32*
%tzone3703 = load i8*, i8** %_impzPtr
%zone3704 = bitcast i8* %tzone3703 to %mzone*

; let assign value to symbol cp
%cpPtr = alloca i32*
%tzone3705 = load i8*, i8** %_impzPtr
%zone3706 = bitcast i8* %tzone3705 to %mzone*

; let assign value to symbol wpt
%wptPtr = alloca i32
%tzone3707 = load i8*, i8** %_impzPtr
%zone3708 = bitcast i8* %tzone3707 to %mzone*

; let assign value to symbol hpt
%hptPtr = alloca i32
%tzone3709 = load i8*, i8** %_impzPtr
%zone3710 = bitcast i8* %tzone3709 to %mzone*

; let assign value to symbol cpt
%cptPtr = alloca i32
%tzone3720 = load i8*, i8** %_impzPtr
%zone3721 = bitcast i8* %tzone3720 to %mzone*

; let assign value to symbol front_data
%front_dataPtr = alloca i8*
%tzone3731 = load i8*, i8** %_impzPtr
%zone3732 = bitcast i8* %tzone3731 to %mzone*

; let assign value to symbol back_data
%back_dataPtr = alloca i8*
%tzone3742 = load i8*, i8** %_impzPtr
%zone3743 = bitcast i8* %tzone3742 to %mzone*

; let assign value to symbol top_data
%top_dataPtr = alloca i8*
%tzone3753 = load i8*, i8** %_impzPtr
%zone3754 = bitcast i8* %tzone3753 to %mzone*

; let assign value to symbol bottom_data
%bottom_dataPtr = alloca i8*
%tzone3764 = load i8*, i8** %_impzPtr
%zone3765 = bitcast i8* %tzone3764 to %mzone*

; let assign value to symbol left_data
%left_dataPtr = alloca i8*
%tzone3775 = load i8*, i8** %_impzPtr
%zone3776 = bitcast i8* %tzone3775 to %mzone*

; let assign value to symbol right_data
%right_dataPtr = alloca i8*
%tzone3780 = load i8*, i8** %_impzPtr
%zone3781 = bitcast i8* %tzone3780 to %mzone*

; let assign value to symbol w
%wPtr = alloca i32
%tzone3785 = load i8*, i8** %_impzPtr
%zone3786 = bitcast i8* %tzone3785 to %mzone*

; let assign value to symbol h
%hPtr = alloca i32
%tzone3790 = load i8*, i8** %_impzPtr
%zone3791 = bitcast i8* %tzone3790 to %mzone*

; let assign value to symbol c
%cPtr = alloca i32
%tzone3797 = load i8*, i8** %_impzPtr
%zone3798 = bitcast i8* %tzone3797 to %mzone*

; let assign value to symbol whc
%whcPtr = alloca i64
%tzone3807 = load i8*, i8** %_impzPtr
%zone3808 = bitcast i8* %tzone3807 to %mzone*

; let assign value to symbol data_s_25
%data_s_25Ptr = alloca i8*
%val3683 = load %Texture*, %Texture** %texPtr
; tuple ref
%val3684 = getelementptr %Texture, %Texture* %val3683, i64 0, i32 2

; let value assignment
%width_ptr = select i1 true, i32* %val3684, i32* %val3684
store i32* %width_ptr, i32** %width_ptrPtr

%val3687 = load %Texture*, %Texture** %texPtr
; tuple ref
%val3688 = getelementptr %Texture, %Texture* %val3687, i64 0, i32 3

; let value assignment
%height_ptr = select i1 true, i32* %val3688, i32* %val3688
store i32* %height_ptr, i32** %height_ptrPtr

%dat3691 = alloca i32, align 16

; let value assignment
%comp_ptr = select i1 true, i32* %dat3691, i32* %dat3691
store i32* %comp_ptr, i32** %comp_ptrPtr


; let value assignment
%i = select i1 true, i32 0, i32 0
store i32 %i, i32* %iPtr

%dat3696 = alloca i32, i64 6, align 16

; let value assignment
%wp = select i1 true, i32* %dat3696, i32* %dat3696
store i32* %wp, i32** %wpPtr

%dat3699 = alloca i32, i64 6, align 16

; let value assignment
%hp = select i1 true, i32* %dat3699, i32* %dat3699
store i32* %hp, i32** %hpPtr

%dat3702 = alloca i32, i64 6, align 16

; let value assignment
%cp = select i1 true, i32* %dat3702, i32* %dat3702
store i32* %cp, i32** %cpPtr


; let value assignment
%wpt = select i1 true, i32 0, i32 0
store i32 %wpt, i32* %wptPtr


; let value assignment
%hpt = select i1 true, i32 0, i32 0
store i32 %hpt, i32* %hptPtr


; let value assignment
%cpt = select i1 true, i32 0, i32 0
store i32 %cpt, i32* %cptPtr

%val3711 = load %String*, %String** %frontPtr
%res3712 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val3711)
%val3713 = load i32*, i32** %wpPtr
; pointer ref
%val3714 = getelementptr i32, i32* %val3713, i64 0
%val3715 = load i32*, i32** %hpPtr
; pointer ref
%val3716 = getelementptr i32, i32* %val3715, i64 0
%val3717 = load i32*, i32** %cpPtr
; pointer ref
%val3718 = getelementptr i32, i32* %val3717, i64 0
%res3719 = call ccc i8* @stbi_load(i8* %res3712, i32* %val3714, i32* %val3716, i32* %val3718, i32 4)

; let value assignment
%front_data = select i1 true, i8* %res3719, i8* %res3719
store i8* %front_data, i8** %front_dataPtr

%val3722 = load %String*, %String** %backPtr
%res3723 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val3722)
%val3724 = load i32*, i32** %wpPtr
; pointer ref
%val3725 = getelementptr i32, i32* %val3724, i64 1
%val3726 = load i32*, i32** %hpPtr
; pointer ref
%val3727 = getelementptr i32, i32* %val3726, i64 1
%val3728 = load i32*, i32** %cpPtr
; pointer ref
%val3729 = getelementptr i32, i32* %val3728, i64 1
%res3730 = call ccc i8* @stbi_load(i8* %res3723, i32* %val3725, i32* %val3727, i32* %val3729, i32 4)

; let value assignment
%back_data = select i1 true, i8* %res3730, i8* %res3730
store i8* %back_data, i8** %back_dataPtr

%val3733 = load %String*, %String** %topPtr
%res3734 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val3733)
%val3735 = load i32*, i32** %wpPtr
; pointer ref
%val3736 = getelementptr i32, i32* %val3735, i64 2
%val3737 = load i32*, i32** %hpPtr
; pointer ref
%val3738 = getelementptr i32, i32* %val3737, i64 2
%val3739 = load i32*, i32** %cpPtr
; pointer ref
%val3740 = getelementptr i32, i32* %val3739, i64 2
%res3741 = call ccc i8* @stbi_load(i8* %res3734, i32* %val3736, i32* %val3738, i32* %val3740, i32 4)

; let value assignment
%top_data = select i1 true, i8* %res3741, i8* %res3741
store i8* %top_data, i8** %top_dataPtr

%val3744 = load %String*, %String** %bottomPtr
%res3745 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val3744)
%val3746 = load i32*, i32** %wpPtr
; pointer ref
%val3747 = getelementptr i32, i32* %val3746, i64 3
%val3748 = load i32*, i32** %hpPtr
; pointer ref
%val3749 = getelementptr i32, i32* %val3748, i64 3
%val3750 = load i32*, i32** %cpPtr
; pointer ref
%val3751 = getelementptr i32, i32* %val3750, i64 3
%res3752 = call ccc i8* @stbi_load(i8* %res3745, i32* %val3747, i32* %val3749, i32* %val3751, i32 4)

; let value assignment
%bottom_data = select i1 true, i8* %res3752, i8* %res3752
store i8* %bottom_data, i8** %bottom_dataPtr

%val3755 = load %String*, %String** %leftPtr
%res3756 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val3755)
%val3757 = load i32*, i32** %wpPtr
; pointer ref
%val3758 = getelementptr i32, i32* %val3757, i64 4
%val3759 = load i32*, i32** %hpPtr
; pointer ref
%val3760 = getelementptr i32, i32* %val3759, i64 4
%val3761 = load i32*, i32** %cpPtr
; pointer ref
%val3762 = getelementptr i32, i32* %val3761, i64 4
%res3763 = call ccc i8* @stbi_load(i8* %res3756, i32* %val3758, i32* %val3760, i32* %val3762, i32 4)

; let value assignment
%left_data = select i1 true, i8* %res3763, i8* %res3763
store i8* %left_data, i8** %left_dataPtr

%val3766 = load %String*, %String** %rightPtr
%res3767 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val3766)
%val3768 = load i32*, i32** %wpPtr
; pointer ref
%val3769 = getelementptr i32, i32* %val3768, i64 5
%val3770 = load i32*, i32** %hpPtr
; pointer ref
%val3771 = getelementptr i32, i32* %val3770, i64 5
%val3772 = load i32*, i32** %cpPtr
; pointer ref
%val3773 = getelementptr i32, i32* %val3772, i64 5
%res3774 = call ccc i8* @stbi_load(i8* %res3767, i32* %val3769, i32* %val3771, i32* %val3773, i32 4)

; let value assignment
%right_data = select i1 true, i8* %res3774, i8* %res3774
store i8* %right_data, i8** %right_dataPtr

%val3777 = load i32*, i32** %wpPtr
; pointer ref
%val3778 = getelementptr i32, i32* %val3777, i64 0
%val3779 = load i32, i32* %val3778

; let value assignment
%w = select i1 true, i32 %val3779, i32 %val3779
store i32 %w, i32* %wPtr

%val3782 = load i32*, i32** %hpPtr
; pointer ref
%val3783 = getelementptr i32, i32* %val3782, i64 0
%val3784 = load i32, i32* %val3783

; let value assignment
%h = select i1 true, i32 %val3784, i32 %val3784
store i32 %h, i32* %hPtr

%val3787 = load i32*, i32** %cpPtr
; pointer ref
%val3788 = getelementptr i32, i32* %val3787, i64 0
%val3789 = load i32, i32* %val3788

; let value assignment
%c = select i1 true, i32 %val3789, i32 %val3789
store i32 %c, i32* %cPtr

%val3792 = load i32, i32* %wPtr
%val3793 = load i32, i32* %hPtr
%val3794 = mul i32 %val3792, %val3793
%val3795 = mul i32 %val3794, 4
%val3796 = sext i32 %val3795 to i64

; let value assignment
%whc = select i1 true, i64 %val3796, i64 %val3796
store i64 %whc, i64* %whcPtr

%val3799 = load i64, i64* %whcPtr
%val3800 = mul i64 %val3799, 6
%val3801 = getelementptr i64, i64* null, i32 1
%zonesize3802 = mul i64 1, %val3800
%tzone3803 = load i8*, i8** %_impzPtr
%zone3804 = bitcast i8* %tzone3803 to %mzone*
%dat3805 = call i8* @llvm_zone_malloc(%mzone* %zone3804, i64 %zonesize3802)
call i8* @memset(i8* %dat3805, i32 0, i64 %zonesize3802)
%val3806 = bitcast i8* %dat3805 to i8*

; let value assignment
%data_s_25 = select i1 true, i8* %val3806, i8* %val3806
store i8* %data_s_25, i8** %data_s_25Ptr

; promote local stack var allocations
%tzone3977 = load i8*, i8** %_impzPtr
%zone3978 = bitcast i8* %tzone3977 to %mzone*
%ifptr3885 = alloca i64
%ifptr3886 = alloca i1
%ifptr3891 = alloca i1
%ifptr3896 = alloca i1
%ifptr3901 = alloca i1
%ifptr3906 = alloca i1
%ifptr3911 = alloca i1
%ifptr3860 = alloca i8*
%ifptr3846 = alloca i8*
%ifptr3832 = alloca i8*
; setup loop
store i32 0, i32* %iPtr
%val3828 = load i32, i32* %iPtr
%num3829 = add i32 6, %val3828
%comp3830 = icmp ult i32 6, 1
br i1 %comp3830, label %after3809, label %loop3809

loop3809:
; do set!
%val3810 = load i32, i32* %wptPtr
%val3811 = load i32, i32* %iPtr
%val3812 = load i32*, i32** %wpPtr
; pointer ref
%val3813 = getelementptr i32, i32* %val3812, i32 %val3811
%val3814 = load i32, i32* %val3813
%val3815 = add i32 %val3810, %val3814
store i32 %val3815, i32* %wptPtr
; do set!
%val3816 = load i32, i32* %hptPtr
%val3817 = load i32, i32* %iPtr
%val3818 = load i32*, i32** %hpPtr
; pointer ref
%val3819 = getelementptr i32, i32* %val3818, i32 %val3817
%val3820 = load i32, i32* %val3819
%val3821 = add i32 %val3816, %val3820
store i32 %val3821, i32* %hptPtr
; do set!
%val3822 = load i32, i32* %cptPtr
%val3823 = load i32, i32* %iPtr
%val3824 = load i32*, i32** %cpPtr
; pointer ref
%val3825 = getelementptr i32, i32* %val3824, i32 %val3823
%val3826 = load i32, i32* %val3825
%val3827 = add i32 %val3822, %val3826
store i32 %val3827, i32* %cptPtr
%loop_cnt3809 = load i32, i32* %iPtr
%next3809 = add i32 %loop_cnt3809, 1
store i32 %next3809, i32* %iPtr
%cmp3809 = icmp ult i32 %next3809, %num3829
br i1 %cmp3809, label %loop3809, label %after3809

after3809:
%val3833 = load i32, i32* %wptPtr
%val3834 = sdiv i32 %val3833, 6
%val3835 = load i32, i32* %wPtr
%cmp3836 = icmp ne i32 %val3834, %val3835
br i1 %cmp3836, label %then3832, label %else3832

then3832:
%var3837 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var3838 = bitcast [54 x i8]* @gsxtmgl-objects2254 to i8*

%val3839 = call i32 (i8*, ...) @printf(i8* %var3837, i8* %var3838)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%val3841 = load i32, i32* %wPtr
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val3841)
call fastcc void @print_return_adhoc_W3ZvaWRd()
; do set!
%null3844 = bitcast i8* null to i8*
store i8* %null3844, i8** %front_dataPtr
store i8* %null3844, i8** %ifptr3832
br label %ifcont3832

else3832:
br label %ifcont3832

ifcont3832:
%ifres3845 = load i8*, i8** %ifptr3832

%val3847 = load i32, i32* %hptPtr
%val3848 = sdiv i32 %val3847, 6
%val3849 = load i32, i32* %hPtr
%cmp3850 = icmp ne i32 %val3848, %val3849
br i1 %cmp3850, label %then3846, label %else3846

then3846:
%var3851 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var3852 = bitcast [55 x i8]* @gsxtmgl-objects2255 to i8*

%val3853 = call i32 (i8*, ...) @printf(i8* %var3851, i8* %var3852)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%val3855 = load i32, i32* %hPtr
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val3855)
call fastcc void @print_return_adhoc_W3ZvaWRd()
; do set!
%null3858 = bitcast i8* null to i8*
store i8* %null3858, i8** %front_dataPtr
store i8* %null3858, i8** %ifptr3846
br label %ifcont3846

else3846:
br label %ifcont3846

ifcont3846:
%ifres3859 = load i8*, i8** %ifptr3846

%val3861 = load i32, i32* %cptPtr
%val3862 = sdiv i32 %val3861, 6
%val3863 = load i32, i32* %cPtr
%cmp3864 = icmp ne i32 %val3862, %val3863
br i1 %cmp3864, label %then3860, label %else3860

then3860:
%var3865 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var3866 = bitcast [68 x i8]* @gsxtmgl-objects2256 to i8*

%val3867 = call i32 (i8*, ...) @printf(i8* %var3865, i8* %var3866)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%val3869 = load i32, i32* %cPtr
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val3869)
call fastcc void @print_return_adhoc_W3ZvaWRd()
; do set!
%null3872 = bitcast i8* null to i8*
store i8* %null3872, i8** %front_dataPtr
store i8* %null3872, i8** %ifptr3860
br label %ifcont3860

else3860:
br label %ifcont3860

ifcont3860:
%ifres3873 = load i8*, i8** %ifptr3860

%val3874 = load i32*, i32** %width_ptrPtr
%val3875 = load i32, i32* %wPtr
; set pointer
%val3876 = getelementptr i32, i32* %val3874, i64 0
store i32 %val3875, i32* %val3876
%val3877 = load i32*, i32** %height_ptrPtr
%val3878 = load i32, i32* %hPtr
; set pointer
%val3879 = getelementptr i32, i32* %val3877, i64 0
store i32 %val3878, i32* %val3879
%val3880 = load i32*, i32** %comp_ptrPtr
; set pointer
%val3881 = getelementptr i32, i32* %val3880, i64 0
store i32 4, i32* %val3881
%val3882 = load %Texture*, %Texture** %texPtr
%val3883 = load i32, i32* @GL_RGBA
; set tuple
%val3884 = getelementptr %Texture, %Texture* %val3882, i64 0, i32 1
store i32 %val3883, i32* %val3884
%val3887 = load i8*, i8** %front_dataPtr
%val3888 = icmp eq i8* %val3887, null
br i1 %val3888, label %then3886, label %else3886

then3886:
%val3889 = load i8*, i8** %front_dataPtr
%val3890 = icmp eq i8* %val3889, null
store i1 %val3890, i1* %ifptr3886
br label %ifcont3886

else3886:
%val3892 = load i8*, i8** %back_dataPtr
%val3893 = icmp eq i8* %val3892, null
br i1 %val3893, label %then3891, label %else3891

then3891:
%val3894 = load i8*, i8** %back_dataPtr
%val3895 = icmp eq i8* %val3894, null
store i1 %val3895, i1* %ifptr3891
br label %ifcont3891

else3891:
%val3897 = load i8*, i8** %top_dataPtr
%val3898 = icmp eq i8* %val3897, null
br i1 %val3898, label %then3896, label %else3896

then3896:
%val3899 = load i8*, i8** %top_dataPtr
%val3900 = icmp eq i8* %val3899, null
store i1 %val3900, i1* %ifptr3896
br label %ifcont3896

else3896:
%val3902 = load i8*, i8** %bottom_dataPtr
%val3903 = icmp eq i8* %val3902, null
br i1 %val3903, label %then3901, label %else3901

then3901:
%val3904 = load i8*, i8** %bottom_dataPtr
%val3905 = icmp eq i8* %val3904, null
store i1 %val3905, i1* %ifptr3901
br label %ifcont3901

else3901:
%val3907 = load i8*, i8** %left_dataPtr
%val3908 = icmp eq i8* %val3907, null
br i1 %val3908, label %then3906, label %else3906

then3906:
%val3909 = load i8*, i8** %left_dataPtr
%val3910 = icmp eq i8* %val3909, null
store i1 %val3910, i1* %ifptr3906
br label %ifcont3906

else3906:
%val3912 = load i8*, i8** %right_dataPtr
%val3913 = icmp eq i8* %val3912, null
br i1 %val3913, label %then3911, label %else3911

then3911:
%val3914 = load i8*, i8** %right_dataPtr
%val3915 = icmp eq i8* %val3914, null
store i1 %val3915, i1* %ifptr3911
br label %ifcont3911

else3911:
%res3916 = call ccc i1 @impc_false()
store i1 %res3916, i1* %ifptr3911
br label %ifcont3911

ifcont3911:
%ifres3917 = load i1, i1* %ifptr3911

store i1 %ifres3917, i1* %ifptr3906
br label %ifcont3906

ifcont3906:
%ifres3918 = load i1, i1* %ifptr3906

store i1 %ifres3918, i1* %ifptr3901
br label %ifcont3901

ifcont3901:
%ifres3919 = load i1, i1* %ifptr3901

store i1 %ifres3919, i1* %ifptr3896
br label %ifcont3896

ifcont3896:
%ifres3920 = load i1, i1* %ifptr3896

store i1 %ifres3920, i1* %ifptr3891
br label %ifcont3891

ifcont3891:
%ifres3921 = load i1, i1* %ifptr3891

store i1 %ifres3921, i1* %ifptr3886
br label %ifcont3886

ifcont3886:
%ifres3922 = load i1, i1* %ifptr3886

br i1 %ifres3922, label %then3885, label %else3885

then3885:
%var3923 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var3924 = bitcast [27 x i8]* @gsxtmgl-objects2257 to i8*

%val3925 = call i32 (i8*, ...) @printf(i8* %var3923, i8* %var3924)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%res3927 = call ccc i8* @stbi_failure_reason()
call fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %res3927)
call fastcc void @print_return_adhoc_W3ZvaWRd()
store i64 1, i64* %ifptr3885
br label %ifcont3885

else3885:
%val3930 = load i64, i64* %whcPtr
%val3931 = mul i64 %val3930, 0
%val3932 = load i8*, i8** %data_s_25Ptr
; pointer ref
%val3933 = getelementptr i8, i8* %val3932, i64 %val3931
%val3934 = load i8*, i8** %front_dataPtr
%val3935 = load i64, i64* %whcPtr
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val3933, i8* %val3934, i64 %val3935, i32 1, i1 0)
%val3937 = load i64, i64* %whcPtr
%val3938 = mul i64 %val3937, 1
%val3939 = load i8*, i8** %data_s_25Ptr
; pointer ref
%val3940 = getelementptr i8, i8* %val3939, i64 %val3938
%val3941 = load i8*, i8** %back_dataPtr
%val3942 = load i64, i64* %whcPtr
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val3940, i8* %val3941, i64 %val3942, i32 1, i1 0)
%val3944 = load i64, i64* %whcPtr
%val3945 = mul i64 %val3944, 2
%val3946 = load i8*, i8** %data_s_25Ptr
; pointer ref
%val3947 = getelementptr i8, i8* %val3946, i64 %val3945
%val3948 = load i8*, i8** %top_dataPtr
%val3949 = load i64, i64* %whcPtr
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val3947, i8* %val3948, i64 %val3949, i32 1, i1 0)
%val3951 = load i64, i64* %whcPtr
%val3952 = mul i64 %val3951, 3
%val3953 = load i8*, i8** %data_s_25Ptr
; pointer ref
%val3954 = getelementptr i8, i8* %val3953, i64 %val3952
%val3955 = load i8*, i8** %bottom_dataPtr
%val3956 = load i64, i64* %whcPtr
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val3954, i8* %val3955, i64 %val3956, i32 1, i1 0)
%val3958 = load i64, i64* %whcPtr
%val3959 = mul i64 %val3958, 4
%val3960 = load i8*, i8** %data_s_25Ptr
; pointer ref
%val3961 = getelementptr i8, i8* %val3960, i64 %val3959
%val3962 = load i8*, i8** %left_dataPtr
%val3963 = load i64, i64* %whcPtr
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val3961, i8* %val3962, i64 %val3963, i32 1, i1 0)
%val3965 = load i64, i64* %whcPtr
%val3966 = mul i64 %val3965, 5
%val3967 = load i8*, i8** %data_s_25Ptr
; pointer ref
%val3968 = getelementptr i8, i8* %val3967, i64 %val3966
%val3969 = load i8*, i8** %right_dataPtr
%val3970 = load i64, i64* %whcPtr
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val3968, i8* %val3969, i64 %val3970, i32 1, i1 0)
%val3972 = load %Texture*, %Texture** %texPtr
%val3973 = load i8*, i8** %data_s_25Ptr
; set tuple
%val3974 = getelementptr %Texture, %Texture* %val3972, i64 0, i32 4
store i8* %val3973, i8** %val3974
store i64 1, i64* %ifptr3885
br label %ifcont3885

ifcont3885:
%ifres3975 = load i64, i64* %ifptr3885

ret void
}
@gsxtmgl-objects2260 = hidden constant [165 x i8] c"load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}** @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3998 = load i8*, i8** %_impzPtr
%zone3999 = bitcast i8* %tzone3998 to %mzone*

; let assign value to symbol load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ
%dat_load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3999, i64 8)
%load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr = bitcast i8* %dat_load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ to { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}***
%tzone3979 = load i8*, i8** %_impzPtr
%zone3980 = bitcast i8* %tzone3979 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3980)
; malloc closure structure
%clsptr3981 = call i8* @llvm_zone_malloc(%mzone* %zone3980, i64 24)
%closure3982 = bitcast i8* %clsptr3981 to { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}*

; malloc environment structure
%envptr3983 = call i8* @llvm_zone_malloc(%mzone* %zone3980, i64 8)
%environment3984 = bitcast i8* %envptr3983 to {{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}***}*

; malloc closure address table
%addytable3985 = call %clsvar* @new_address_table()
%var3986 = bitcast [112 x i8]* @gsxtmgl-objects2258 to i8*
%var3987 = bitcast [107 x i8]* @gsxtmgl-objects2259 to i8*
%addytable3988 = call %clsvar* @add_address_table(%mzone* %zone3980, i8* %var3986, i32 0, i8* %var3987, i32 3, %clsvar* %addytable3985)
%address-table3989 = bitcast %clsvar* %addytable3988 to i8*

; insert table, function and environment into closure struct
%closure.table3992 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure3982, i32 0, i32 0
store i8* %address-table3989, i8** %closure.table3992
%closure.env3993 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure3982, i32 0, i32 1
store i8* %envptr3983, i8** %closure.env3993
%closure.func3994 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure3982, i32 0, i32 2
store void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)* @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ__3679, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)** %closure.func3994
%closure_size3995 = call i64 @llvm_zone_mark_size(%mzone* %zone3980)
call void @llvm_zone_ptr_set_size(i8* %clsptr3981, i64 %closure_size3995)
%wrapper_ptr3996 = call i8* @llvm_zone_malloc(%mzone* %zone3980, i64 8)
%closure_wrapper3997 = bitcast i8* %wrapper_ptr3996 to { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure3982, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_wrapper3997

; let value assignment
%load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_wrapper3997, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_wrapper3997
store { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}** %load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ, { i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}*** %load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ
%tmp_envptr3991 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}***}* %environment3984, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}*** %load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}**** %tmp_envptr3991


%val4000 = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}**, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}*** %load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr
ret {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}** %val4000
}


@load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}** @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%Texture* %arg_0,i32 %arg_1,%String* %arg_2,%String* %arg_3,%String* %arg_4,%String* %arg_5,%String* %arg_6,%String* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*,  void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1, %String* %arg_2, %String* %arg_3, %String* %arg_4, %String* %arg_5, %String* %arg_6, %String* %arg_7)
ret void
}


define dllexport ccc void @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_native(%Texture* %arg_0,i32 %arg_1,%String* %arg_2,%String* %arg_3,%String* %arg_4,%String* %arg_5,%String* %arg_6,%String* %arg_7) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*,  void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1, %String* %arg_2, %String* %arg_3, %String* %arg_4, %String* %arg_5, %String* %arg_6, %String* %arg_7)
ret void
}


define dllexport ccc i8*  @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4001 = bitcast [165 x i8]* @gsxtmgl-objects2260 to i8*
call i32 (i8*, ...) @printf(i8* %var4001)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4002 = bitcast [165 x i8]* @gsxtmgl-objects2260 to i8*
call i32 (i8*, ...) @printf(i8* %var4002)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4003 = bitcast [165 x i8]* @gsxtmgl-objects2260 to i8*
call i32 (i8*, ...) @printf(i8* %var4003)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4004 = bitcast [165 x i8]* @gsxtmgl-objects2260 to i8*
call i32 (i8*, ...) @printf(i8* %var4004)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to %String*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var4005 = bitcast [165 x i8]* @gsxtmgl-objects2260 to i8*
call i32 (i8*, ...) @printf(i8* %var4005)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to %String*
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_cptr(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var4006 = bitcast [165 x i8]* @gsxtmgl-objects2260 to i8*
call i32 (i8*, ...) @printf(i8* %var4006)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%ttv_5 = call ccc i8* @cptr_value(i8* %arg_5_val)
%arg_5 = bitcast i8* %ttv_5 to %String*
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_cptr(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var4007 = bitcast [165 x i8]* @gsxtmgl-objects2260 to i8*
call i32 (i8*, ...) @printf(i8* %var4007)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%ttv_6 = call ccc i8* @cptr_value(i8* %arg_6_val)
%arg_6 = bitcast i8* %ttv_6 to %String*
%arg_7_val = call ccc i8* @list_ref(i8* %_sc, i32 7,i8* %args)
%arg_7_rt_check = call i32 @is_cptr(i8* %arg_7_val)
%arg_7_bool = icmp ne i32 %arg_7_rt_check, 0
br i1 %arg_7_bool, label %arg_7_true, label %arg_7_false

arg_7_true:
br label %arg_7_continue

arg_7_false:
%var4008 = bitcast [165 x i8]* @gsxtmgl-objects2260 to i8*
call i32 (i8*, ...) @printf(i8* %var4008)
%arg_7_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_7_errret

arg_7_continue:
%ttv_7 = call ccc i8* @cptr_value(i8* %arg_7_val)
%arg_7 = bitcast i8* %ttv_7 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*,  void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1, %String* %arg_2, %String* %arg_3, %String* %arg_4, %String* %arg_5, %String* %arg_6, %String* %arg_7)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}*
%arg_p_0 = getelementptr {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}, {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}, {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}, {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
%arg_p_3 = getelementptr {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}, {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 3
%arg_3 = load %String*, %String** %arg_p_3
%arg_p_4 = getelementptr {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}, {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 4
%arg_4 = load %String*, %String** %arg_p_4
%arg_p_5 = getelementptr {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}, {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 5
%arg_5 = load %String*, %String** %arg_p_5
%arg_p_6 = getelementptr {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}, {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 6
%arg_6 = load %String*, %String** %arg_p_6
%arg_p_7 = getelementptr {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}, {%Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 7
%arg_7 = load %String*, %String** %arg_p_7
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @load_cube_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)*,  void (i8*, i8*, %Texture*, i32, %String*, %String*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1, %String* %arg_2, %String* %arg_3, %String* %arg_4, %String* %arg_5, %String* %arg_6, %String* %arg_7)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2261 = hidden constant [31 x i8] c"Unknown number of components: \00"
@gsxtmgl-objects2262 = hidden constant [55 x i8] c"create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd\00"
@gsxtmgl-objects2263 = hidden constant [57 x i8] c"{i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}**\00"
define dllexport fastcc void @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd__4009(i8* %_impz,i8* %_impenv, %Texture* %tex, i32 %width_s_26, i32 %height_s_27, i32 %comp) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4010 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}***}*
%create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJdPtr = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}**** %create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%width_s_26Ptr = alloca i32
store i32 %width_s_26, i32* %width_s_26Ptr
%height_s_27Ptr = alloca i32
store i32 %height_s_27, i32* %height_s_27Ptr
%compPtr = alloca i32
store i32 %comp, i32* %compPtr


%tzone4023 = load i8*, i8** %_impzPtr
%zone4024 = bitcast i8* %tzone4023 to %mzone*

; let assign value to symbol data_s_28
%data_s_28Ptr = alloca float*
%val4011 = load i32, i32* %width_s_26Ptr
%val4012 = load i32, i32* %height_s_27Ptr
%val4013 = mul i32 %val4011, %val4012
%val4014 = load i32, i32* %compPtr
%val4015 = mul i32 %val4013, %val4014
%tmp4016 = zext i32 %val4015 to i64
%val4017 = getelementptr i32, i32* null, i32 1
%zonesize4018 = mul i64 4, %tmp4016
%tzone4019 = load i8*, i8** %_impzPtr
%zone4020 = bitcast i8* %tzone4019 to %mzone*
%dat4021 = call i8* @llvm_zone_malloc(%mzone* %zone4020, i64 %zonesize4018)
call i8* @memset(i8* %dat4021, i32 0, i64 %zonesize4018)
%val4022 = bitcast i8* %dat4021 to float*

; let value assignment
%data_s_28 = select i1 true, float* %val4022, float* %val4022
store float* %data_s_28, float** %data_s_28Ptr

; promote local stack var allocations
%tzone4065 = load i8*, i8** %_impzPtr
%zone4066 = bitcast i8* %tzone4065 to %mzone*
%ifptr4025 = alloca i32
%ifptr4031 = alloca i32
%ifptr4037 = alloca i32
%val4026 = load i32, i32* %compPtr
%cmp4027 = icmp eq i32 %val4026, 4
br i1 %cmp4027, label %then4025, label %else4025

then4025:
%val4028 = load %Texture*, %Texture** %texPtr
%val4029 = load i32, i32* @GL_RGBA
; set tuple
%val4030 = getelementptr %Texture, %Texture* %val4028, i64 0, i32 1
store i32 %val4029, i32* %val4030
store i32 %val4029, i32* %ifptr4025
br label %ifcont4025

else4025:
%val4032 = load i32, i32* %compPtr
%cmp4033 = icmp eq i32 %val4032, 3
br i1 %cmp4033, label %then4031, label %else4031

then4031:
%val4034 = load %Texture*, %Texture** %texPtr
%val4035 = load i32, i32* @GL_RGB
; set tuple
%val4036 = getelementptr %Texture, %Texture* %val4034, i64 0, i32 1
store i32 %val4035, i32* %val4036
store i32 %val4035, i32* %ifptr4031
br label %ifcont4031

else4031:
%val4038 = load i32, i32* %compPtr
%cmp4039 = icmp eq i32 %val4038, 1
br i1 %cmp4039, label %then4037, label %else4037

then4037:
%val4040 = load %Texture*, %Texture** %texPtr
%val4041 = load i32, i32* @GL_DEPTH_COMPONENT
; set tuple
%val4042 = getelementptr %Texture, %Texture* %val4040, i64 0, i32 1
store i32 %val4041, i32* %val4042
store i32 %val4041, i32* %ifptr4037
br label %ifcont4037

else4037:
%var4043 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var4044 = bitcast [31 x i8]* @gsxtmgl-objects2261 to i8*

%val4045 = call i32 (i8*, ...) @printf(i8* %var4043, i8* %var4044)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%val4047 = load i32, i32* %compPtr
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val4047)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val4050 = trunc i64 1 to i32
store i32 %val4050, i32* %ifptr4037
br label %ifcont4037

ifcont4037:
%ifres4051 = load i32, i32* %ifptr4037

store i32 %ifres4051, i32* %ifptr4031
br label %ifcont4031

ifcont4031:
%ifres4052 = load i32, i32* %ifptr4031

store i32 %ifres4052, i32* %ifptr4025
br label %ifcont4025

ifcont4025:
%ifres4053 = load i32, i32* %ifptr4025

%val4054 = load %Texture*, %Texture** %texPtr
%val4055 = load i32, i32* %width_s_26Ptr
; set tuple
%val4056 = getelementptr %Texture, %Texture* %val4054, i64 0, i32 2
store i32 %val4055, i32* %val4056
%val4057 = load %Texture*, %Texture** %texPtr
%val4058 = load i32, i32* %height_s_27Ptr
; set tuple
%val4059 = getelementptr %Texture, %Texture* %val4057, i64 0, i32 3
store i32 %val4058, i32* %val4059
%val4060 = load %Texture*, %Texture** %texPtr
%val4061 = load float*, float** %data_s_28Ptr
%val4062 = bitcast float* %val4061 to i8*
; set tuple
%val4063 = getelementptr %Texture, %Texture* %val4060, i64 0, i32 4
store i8* %val4062, i8** %val4063
ret void
}
@gsxtmgl-objects2264 = hidden constant [108 x i8] c"create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}** @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4086 = load i8*, i8** %_impzPtr
%zone4087 = bitcast i8* %tzone4086 to %mzone*

; let assign value to symbol create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd
%dat_create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone4087, i64 8)
%create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJdPtr = bitcast i8* %dat_create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd to { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}***
%tzone4067 = load i8*, i8** %_impzPtr
%zone4068 = bitcast i8* %tzone4067 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4068)
; malloc closure structure
%clsptr4069 = call i8* @llvm_zone_malloc(%mzone* %zone4068, i64 24)
%closure4070 = bitcast i8* %clsptr4069 to { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}*

; malloc environment structure
%envptr4071 = call i8* @llvm_zone_malloc(%mzone* %zone4068, i64 8)
%environment4072 = bitcast i8* %envptr4071 to {{i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}***}*

; malloc closure address table
%addytable4073 = call %clsvar* @new_address_table()
%var4074 = bitcast [55 x i8]* @gsxtmgl-objects2262 to i8*
%var4075 = bitcast [57 x i8]* @gsxtmgl-objects2263 to i8*
%addytable4076 = call %clsvar* @add_address_table(%mzone* %zone4068, i8* %var4074, i32 0, i8* %var4075, i32 3, %clsvar* %addytable4073)
%address-table4077 = bitcast %clsvar* %addytable4076 to i8*

; insert table, function and environment into closure struct
%closure.table4080 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}* %closure4070, i32 0, i32 0
store i8* %address-table4077, i8** %closure.table4080
%closure.env4081 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}* %closure4070, i32 0, i32 1
store i8* %envptr4071, i8** %closure.env4081
%closure.func4082 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}* %closure4070, i32 0, i32 2
store void (i8*, i8*, %Texture*, i32, i32, i32)* @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd__4009, void (i8*, i8*, %Texture*, i32, i32, i32)** %closure.func4082
%closure_size4083 = call i64 @llvm_zone_mark_size(%mzone* %zone4068)
call void @llvm_zone_ptr_set_size(i8* %clsptr4069, i64 %closure_size4083)
%wrapper_ptr4084 = call i8* @llvm_zone_malloc(%mzone* %zone4068, i64 8)
%closure_wrapper4085 = bitcast i8* %wrapper_ptr4084 to { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}* %closure4070, { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}** %closure_wrapper4085

; let value assignment
%create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}** %closure_wrapper4085, { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}** %closure_wrapper4085
store { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}** %create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd, { i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}*** %create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd
%tmp_envptr4079 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}***}* %environment4072, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}*** %create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJdPtr, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}**** %tmp_envptr4079


%val4088 = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}*** %create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJdPtr
ret {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}** %val4088
}


@create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}** @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd(%Texture* %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32, i32, i32)*,  void (i8*, i8*, %Texture*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret void
}


define dllexport ccc void @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_native(%Texture* %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32, i32, i32)*,  void (i8*, i8*, %Texture*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret void
}


define dllexport ccc i8*  @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4089 = bitcast [108 x i8]* @gsxtmgl-objects2264 to i8*
call i32 (i8*, ...) @printf(i8* %var4089)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4090 = bitcast [108 x i8]* @gsxtmgl-objects2264 to i8*
call i32 (i8*, ...) @printf(i8* %var4090)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4091 = bitcast [108 x i8]* @gsxtmgl-objects2264 to i8*
call i32 (i8*, ...) @printf(i8* %var4091)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var4092 = bitcast [108 x i8]* @gsxtmgl-objects2264 to i8*
call i32 (i8*, ...) @printf(i8* %var4092)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32, i32, i32)*,  void (i8*, i8*, %Texture*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, i32, i32, i32}*
%arg_p_0 = getelementptr {%Texture*, i32, i32, i32}, {%Texture*, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, i32, i32, i32}, {%Texture*, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%Texture*, i32, i32, i32}, {%Texture*, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%Texture*, i32, i32, i32}, {%Texture*, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32, i32, i32)*,  void (i8*, i8*, %Texture*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2265 = hidden constant [48 x i8] c"write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0\00"
@gsxtmgl-objects2266 = hidden constant [56 x i8] c"{i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}**\00"
define dllexport fastcc void @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0__4093(i8* %_impz,i8* %_impenv, %Texture* %tex, %String* %filename, i1 %flip) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4094 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}***}*
%write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}***}* %impenv, i32 0, i32 0
%write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0Ptr = load {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}***, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}**** %write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0Ptr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%filenamePtr = alloca %String*
store %String* %filename, %String** %filenamePtr
%flipPtr = alloca i1
store i1 %flip, i1* %flipPtr

; promote local stack var allocations
%tzone4129 = load i8*, i8** %_impzPtr
%zone4130 = bitcast i8* %tzone4129 to %mzone*
%ifptr4095 = alloca i32

%tzone4101 = load i8*, i8** %_impzPtr
%zone4102 = bitcast i8* %tzone4101 to %mzone*

; let assign value to symbol comp
%compPtr = alloca i32
%val4096 = load %Texture*, %Texture** %texPtr
%res4097 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4096)
%val4098 = load i32, i32* @GL_RGB
%cmp4099 = icmp eq i32 %res4097, %val4098
br i1 %cmp4099, label %then4095, label %else4095

then4095:
store i32 3, i32* %ifptr4095
br label %ifcont4095

else4095:
store i32 4, i32* %ifptr4095
br label %ifcont4095

ifcont4095:
%ifres4100 = load i32, i32* %ifptr4095


; let value assignment
%comp = select i1 true, i32 %ifres4100, i32 %ifres4100
store i32 %comp, i32* %compPtr

%val4104 = load i1, i1* %flipPtr
br i1 %val4104, label %then4103, label %else4103

then4103:
%val4105 = load %Texture*, %Texture** %texPtr
%res4106 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4105)
%val4107 = load %Texture*, %Texture** %texPtr
%res4108 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4107)
%val4109 = load i32, i32* %compPtr
%val4110 = load %Texture*, %Texture** %texPtr
%res4111 = call fastcc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0(%Texture* %val4110)
call fastcc void @stbi_flip_vertically_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTgqXQ(i32 %res4106, i32 %res4108, i32 %val4109, i8* %res4111)
br label %ifcont4103

else4103:
br label %ifcont4103

ifcont4103:
%val4113 = load %String*, %String** %filenamePtr
%res4114 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val4113)
%val4115 = load %Texture*, %Texture** %texPtr
%res4116 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4115)
%val4117 = load %Texture*, %Texture** %texPtr
%res4118 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4117)
%val4119 = load i32, i32* %compPtr
%val4120 = load %Texture*, %Texture** %texPtr
%res4121 = call fastcc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0(%Texture* %val4120)
%val4122 = load %Texture*, %Texture** %texPtr
%res4123 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4122)
%val4124 = load i32, i32* %compPtr
%val4125 = mul i32 %res4123, %val4124
%val4126 = mul i32 %val4125, 1
%res4127 = call ccc i32 @stbi_write_png(i8* %res4114, i32 %res4116, i32 %res4118, i32 %val4119, i8* %res4121, i32 %val4126)
ret void
}
@gsxtmgl-objects2267 = hidden constant [101 x i8] c"write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}** @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4150 = load i8*, i8** %_impzPtr
%zone4151 = bitcast i8* %tzone4150 to %mzone*

; let assign value to symbol write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0
%dat_write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0 = call i8* @llvm_zone_malloc(%mzone* %zone4151, i64 8)
%write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0Ptr = bitcast i8* %dat_write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0 to { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}***
%tzone4131 = load i8*, i8** %_impzPtr
%zone4132 = bitcast i8* %tzone4131 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4132)
; malloc closure structure
%clsptr4133 = call i8* @llvm_zone_malloc(%mzone* %zone4132, i64 24)
%closure4134 = bitcast i8* %clsptr4133 to { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}*

; malloc environment structure
%envptr4135 = call i8* @llvm_zone_malloc(%mzone* %zone4132, i64 8)
%environment4136 = bitcast i8* %envptr4135 to {{i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}***}*

; malloc closure address table
%addytable4137 = call %clsvar* @new_address_table()
%var4138 = bitcast [48 x i8]* @gsxtmgl-objects2265 to i8*
%var4139 = bitcast [56 x i8]* @gsxtmgl-objects2266 to i8*
%addytable4140 = call %clsvar* @add_address_table(%mzone* %zone4132, i8* %var4138, i32 0, i8* %var4139, i32 3, %clsvar* %addytable4137)
%address-table4141 = bitcast %clsvar* %addytable4140 to i8*

; insert table, function and environment into closure struct
%closure.table4144 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}, { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}* %closure4134, i32 0, i32 0
store i8* %address-table4141, i8** %closure.table4144
%closure.env4145 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}, { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}* %closure4134, i32 0, i32 1
store i8* %envptr4135, i8** %closure.env4145
%closure.func4146 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}, { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}* %closure4134, i32 0, i32 2
store void (i8*, i8*, %Texture*, %String*, i1)* @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0__4093, void (i8*, i8*, %Texture*, %String*, i1)** %closure.func4146
%closure_size4147 = call i64 @llvm_zone_mark_size(%mzone* %zone4132)
call void @llvm_zone_ptr_set_size(i8* %clsptr4133, i64 %closure_size4147)
%wrapper_ptr4148 = call i8* @llvm_zone_malloc(%mzone* %zone4132, i64 8)
%closure_wrapper4149 = bitcast i8* %wrapper_ptr4148 to { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}* %closure4134, { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}** %closure_wrapper4149

; let value assignment
%write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}** %closure_wrapper4149, { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}** %closure_wrapper4149
store { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}** %write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0, { i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}*** %write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0Ptr

; add data to environment
; don't need to alloc for env var write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0
%tmp_envptr4143 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}***}* %environment4136, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}*** %write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0Ptr, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}**** %tmp_envptr4143


%val4152 = load {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}**, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}*** %write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0Ptr
ret {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}** %val4152
}


@write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_var = dllexport global [1 x i8*] [ i8* null ]

@write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}** @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0(%Texture* %arg_0,%String* %arg_1,i1 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, %String*, i1)*,  void (i8*, i8*, %Texture*, %String*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, %String* %arg_1, i1 %arg_2)
ret void
}


define dllexport ccc void @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_native(%Texture* %arg_0,%String* %arg_1,i1 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, %String*, i1)*,  void (i8*, i8*, %Texture*, %String*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, %String* %arg_1, i1 %arg_2)
ret void
}


define dllexport ccc i8*  @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4153 = bitcast [101 x i8]* @gsxtmgl-objects2267 to i8*
call i32 (i8*, ...) @printf(i8* %var4153)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4154 = bitcast [101 x i8]* @gsxtmgl-objects2267 to i8*
call i32 (i8*, ...) @printf(i8* %var4154)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4155 = bitcast [101 x i8]* @gsxtmgl-objects2267 to i8*
call i32 (i8*, ...) @printf(i8* %var4155)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i1  @i1value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, %String*, i1)*,  void (i8*, i8*, %Texture*, %String*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, %String* %arg_1, i1 %arg_2)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, %String*, i1}*
%arg_p_0 = getelementptr {%Texture*, %String*, i1}, {%Texture*, %String*, i1}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, %String*, i1}, {%Texture*, %String*, i1}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
%arg_p_2 = getelementptr {%Texture*, %String*, i1}, {%Texture*, %String*, i1}* %fstruct, i32 0, i32 2
%arg_2 = load i1, i1* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}, {i8*, i8*, void (i8*, i8*, %Texture*, %String*, i1)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, %String*, i1)*,  void (i8*, i8*, %Texture*, %String*, i1)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, %String* %arg_1, i1 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2268 = hidden constant [32 x i8] c"error binding texture cube data\00"
@gsxtmgl-objects2269 = hidden constant [23 x i8] c"could not update cube!\00"
@gsxtmgl-objects2270 = hidden constant [39 x i8] c"update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd\00"
define dllexport fastcc void @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd__4156(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4157 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*
%update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = load {i8*, i8*, void (i8*, i8*, %Texture*)*}***, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr

; promote local stack var allocations
%tzone4339 = load i8*, i8** %_impzPtr
%zone4340 = bitcast i8* %tzone4339 to %mzone*
%ifptr4307 = alloca i32
%ifptr4279 = alloca i32
%ifptr4251 = alloca i32
%ifptr4223 = alloca i32
%ifptr4195 = alloca i32
%ifptr4167 = alloca i32

%val4158 = load i32, i32* @GL_TEXTURE0
call fastcc void @glActiveTexture_adhoc_W3ZvaWQsaTMyXQ(i32 %val4158)
%val4160 = load i32, i32* @GL_TEXTURE_CUBE_MAP
%val4161 = load %Texture*, %Texture** %texPtr
%res4162 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4161)
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val4160, i32 %res4162)
%var4164 = bitcast [32 x i8]* @gsxtmgl-objects2268 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var4164)
%val4166 = load i32, i32* @GL_TEXTURE_CUBE_MAP_POSITIVE_Z
%val4168 = load %Texture*, %Texture** %texPtr
%res4169 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4168)
%val4170 = load i32, i32* @GL_BGRA
%cmp4171 = icmp eq i32 %res4169, %val4170
br i1 %cmp4171, label %then4167, label %else4167

then4167:
%val4172 = load i32, i32* @GL_RGBA
store i32 %val4172, i32* %ifptr4167
br label %ifcont4167

else4167:
%val4173 = load %Texture*, %Texture** %texPtr
%res4174 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4173)
store i32 %res4174, i32* %ifptr4167
br label %ifcont4167

ifcont4167:
%ifres4175 = load i32, i32* %ifptr4167

%val4176 = load %Texture*, %Texture** %texPtr
%res4177 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4176)
%val4178 = load %Texture*, %Texture** %texPtr
%res4179 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4178)
%val4180 = load %Texture*, %Texture** %texPtr
%res4181 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4180)
%val4182 = load i32, i32* @GL_UNSIGNED_BYTE
%val4183 = load %Texture*, %Texture** %texPtr
%res4184 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4183)
%val4185 = load %Texture*, %Texture** %texPtr
%res4186 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4185)
%val4187 = mul i32 %res4184, %res4186
%val4188 = mul i32 %val4187, 4
%val4189 = mul i32 %val4188, 0
%val4190 = load %Texture*, %Texture** %texPtr
%res4191 = call fastcc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0(%Texture* %val4190)
; pointer ref
%val4192 = getelementptr i8, i8* %res4191, i32 %val4189
call fastcc void @glTexImage2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %val4166, i32 0, i32 %ifres4175, i32 %res4177, i32 %res4179, i32 0, i32 %res4181, i32 %val4182, i8* %val4192)
%val4194 = load i32, i32* @GL_TEXTURE_CUBE_MAP_NEGATIVE_Z
%val4196 = load %Texture*, %Texture** %texPtr
%res4197 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4196)
%val4198 = load i32, i32* @GL_BGRA
%cmp4199 = icmp eq i32 %res4197, %val4198
br i1 %cmp4199, label %then4195, label %else4195

then4195:
%val4200 = load i32, i32* @GL_RGBA
store i32 %val4200, i32* %ifptr4195
br label %ifcont4195

else4195:
%val4201 = load %Texture*, %Texture** %texPtr
%res4202 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4201)
store i32 %res4202, i32* %ifptr4195
br label %ifcont4195

ifcont4195:
%ifres4203 = load i32, i32* %ifptr4195

%val4204 = load %Texture*, %Texture** %texPtr
%res4205 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4204)
%val4206 = load %Texture*, %Texture** %texPtr
%res4207 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4206)
%val4208 = load %Texture*, %Texture** %texPtr
%res4209 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4208)
%val4210 = load i32, i32* @GL_UNSIGNED_BYTE
%val4211 = load %Texture*, %Texture** %texPtr
%res4212 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4211)
%val4213 = load %Texture*, %Texture** %texPtr
%res4214 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4213)
%val4215 = mul i32 %res4212, %res4214
%val4216 = mul i32 %val4215, 4
%val4217 = mul i32 %val4216, 1
%val4218 = load %Texture*, %Texture** %texPtr
%res4219 = call fastcc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0(%Texture* %val4218)
; pointer ref
%val4220 = getelementptr i8, i8* %res4219, i32 %val4217
call fastcc void @glTexImage2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %val4194, i32 0, i32 %ifres4203, i32 %res4205, i32 %res4207, i32 0, i32 %res4209, i32 %val4210, i8* %val4220)
%val4222 = load i32, i32* @GL_TEXTURE_CUBE_MAP_POSITIVE_Y
%val4224 = load %Texture*, %Texture** %texPtr
%res4225 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4224)
%val4226 = load i32, i32* @GL_BGRA
%cmp4227 = icmp eq i32 %res4225, %val4226
br i1 %cmp4227, label %then4223, label %else4223

then4223:
%val4228 = load i32, i32* @GL_RGBA
store i32 %val4228, i32* %ifptr4223
br label %ifcont4223

else4223:
%val4229 = load %Texture*, %Texture** %texPtr
%res4230 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4229)
store i32 %res4230, i32* %ifptr4223
br label %ifcont4223

ifcont4223:
%ifres4231 = load i32, i32* %ifptr4223

%val4232 = load %Texture*, %Texture** %texPtr
%res4233 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4232)
%val4234 = load %Texture*, %Texture** %texPtr
%res4235 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4234)
%val4236 = load %Texture*, %Texture** %texPtr
%res4237 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4236)
%val4238 = load i32, i32* @GL_UNSIGNED_BYTE
%val4239 = load %Texture*, %Texture** %texPtr
%res4240 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4239)
%val4241 = load %Texture*, %Texture** %texPtr
%res4242 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4241)
%val4243 = mul i32 %res4240, %res4242
%val4244 = mul i32 %val4243, 4
%val4245 = mul i32 %val4244, 2
%val4246 = load %Texture*, %Texture** %texPtr
%res4247 = call fastcc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0(%Texture* %val4246)
; pointer ref
%val4248 = getelementptr i8, i8* %res4247, i32 %val4245
call fastcc void @glTexImage2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %val4222, i32 0, i32 %ifres4231, i32 %res4233, i32 %res4235, i32 0, i32 %res4237, i32 %val4238, i8* %val4248)
%val4250 = load i32, i32* @GL_TEXTURE_CUBE_MAP_NEGATIVE_Y
%val4252 = load %Texture*, %Texture** %texPtr
%res4253 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4252)
%val4254 = load i32, i32* @GL_BGRA
%cmp4255 = icmp eq i32 %res4253, %val4254
br i1 %cmp4255, label %then4251, label %else4251

then4251:
%val4256 = load i32, i32* @GL_RGBA
store i32 %val4256, i32* %ifptr4251
br label %ifcont4251

else4251:
%val4257 = load %Texture*, %Texture** %texPtr
%res4258 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4257)
store i32 %res4258, i32* %ifptr4251
br label %ifcont4251

ifcont4251:
%ifres4259 = load i32, i32* %ifptr4251

%val4260 = load %Texture*, %Texture** %texPtr
%res4261 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4260)
%val4262 = load %Texture*, %Texture** %texPtr
%res4263 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4262)
%val4264 = load %Texture*, %Texture** %texPtr
%res4265 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4264)
%val4266 = load i32, i32* @GL_UNSIGNED_BYTE
%val4267 = load %Texture*, %Texture** %texPtr
%res4268 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4267)
%val4269 = load %Texture*, %Texture** %texPtr
%res4270 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4269)
%val4271 = mul i32 %res4268, %res4270
%val4272 = mul i32 %val4271, 4
%val4273 = mul i32 %val4272, 3
%val4274 = load %Texture*, %Texture** %texPtr
%res4275 = call fastcc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0(%Texture* %val4274)
; pointer ref
%val4276 = getelementptr i8, i8* %res4275, i32 %val4273
call fastcc void @glTexImage2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %val4250, i32 0, i32 %ifres4259, i32 %res4261, i32 %res4263, i32 0, i32 %res4265, i32 %val4266, i8* %val4276)
%val4278 = load i32, i32* @GL_TEXTURE_CUBE_MAP_POSITIVE_X
%val4280 = load %Texture*, %Texture** %texPtr
%res4281 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4280)
%val4282 = load i32, i32* @GL_BGRA
%cmp4283 = icmp eq i32 %res4281, %val4282
br i1 %cmp4283, label %then4279, label %else4279

then4279:
%val4284 = load i32, i32* @GL_RGBA
store i32 %val4284, i32* %ifptr4279
br label %ifcont4279

else4279:
%val4285 = load %Texture*, %Texture** %texPtr
%res4286 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4285)
store i32 %res4286, i32* %ifptr4279
br label %ifcont4279

ifcont4279:
%ifres4287 = load i32, i32* %ifptr4279

%val4288 = load %Texture*, %Texture** %texPtr
%res4289 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4288)
%val4290 = load %Texture*, %Texture** %texPtr
%res4291 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4290)
%val4292 = load %Texture*, %Texture** %texPtr
%res4293 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4292)
%val4294 = load i32, i32* @GL_UNSIGNED_BYTE
%val4295 = load %Texture*, %Texture** %texPtr
%res4296 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4295)
%val4297 = load %Texture*, %Texture** %texPtr
%res4298 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4297)
%val4299 = mul i32 %res4296, %res4298
%val4300 = mul i32 %val4299, 4
%val4301 = mul i32 %val4300, 4
%val4302 = load %Texture*, %Texture** %texPtr
%res4303 = call fastcc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0(%Texture* %val4302)
; pointer ref
%val4304 = getelementptr i8, i8* %res4303, i32 %val4301
call fastcc void @glTexImage2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %val4278, i32 0, i32 %ifres4287, i32 %res4289, i32 %res4291, i32 0, i32 %res4293, i32 %val4294, i8* %val4304)
%val4306 = load i32, i32* @GL_TEXTURE_CUBE_MAP_NEGATIVE_X
%val4308 = load %Texture*, %Texture** %texPtr
%res4309 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4308)
%val4310 = load i32, i32* @GL_BGRA
%cmp4311 = icmp eq i32 %res4309, %val4310
br i1 %cmp4311, label %then4307, label %else4307

then4307:
%val4312 = load i32, i32* @GL_RGBA
store i32 %val4312, i32* %ifptr4307
br label %ifcont4307

else4307:
%val4313 = load %Texture*, %Texture** %texPtr
%res4314 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4313)
store i32 %res4314, i32* %ifptr4307
br label %ifcont4307

ifcont4307:
%ifres4315 = load i32, i32* %ifptr4307

%val4316 = load %Texture*, %Texture** %texPtr
%res4317 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4316)
%val4318 = load %Texture*, %Texture** %texPtr
%res4319 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4318)
%val4320 = load %Texture*, %Texture** %texPtr
%res4321 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4320)
%val4322 = load i32, i32* @GL_UNSIGNED_BYTE
%val4323 = load %Texture*, %Texture** %texPtr
%res4324 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4323)
%val4325 = load %Texture*, %Texture** %texPtr
%res4326 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4325)
%val4327 = mul i32 %res4324, %res4326
%val4328 = mul i32 %val4327, 4
%val4329 = mul i32 %val4328, 5
%val4330 = load %Texture*, %Texture** %texPtr
%res4331 = call fastcc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0(%Texture* %val4330)
; pointer ref
%val4332 = getelementptr i8, i8* %res4331, i32 %val4329
call fastcc void @glTexImage2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %val4306, i32 0, i32 %ifres4315, i32 %res4317, i32 %res4319, i32 0, i32 %res4321, i32 %val4322, i8* %val4332)
%val4334 = load i32, i32* @GL_TEXTURE_CUBE_MAP
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val4334, i32 0)
%var4336 = bitcast [23 x i8]* @gsxtmgl-objects2269 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var4336)
ret void
}
@gsxtmgl-objects2271 = hidden constant [92 x i8] c"update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4360 = load i8*, i8** %_impzPtr
%zone4361 = bitcast i8* %tzone4360 to %mzone*

; let assign value to symbol update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd
%dat_update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone4361, i64 8)
%update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = bitcast i8* %dat_update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd to { i8*, i8*, void (i8*, i8*, %Texture*)*}***
%tzone4341 = load i8*, i8** %_impzPtr
%zone4342 = bitcast i8* %tzone4341 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4342)
; malloc closure structure
%clsptr4343 = call i8* @llvm_zone_malloc(%mzone* %zone4342, i64 24)
%closure4344 = bitcast i8* %clsptr4343 to { i8*, i8*, void (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr4345 = call i8* @llvm_zone_malloc(%mzone* %zone4342, i64 8)
%environment4346 = bitcast i8* %envptr4345 to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable4347 = call %clsvar* @new_address_table()
%var4348 = bitcast [39 x i8]* @gsxtmgl-objects2270 to i8*
%var4349 = bitcast [42 x i8]* @gsxtmgl-objects2217 to i8*
%addytable4350 = call %clsvar* @add_address_table(%mzone* %zone4342, i8* %var4348, i32 0, i8* %var4349, i32 3, %clsvar* %addytable4347)
%address-table4351 = bitcast %clsvar* %addytable4350 to i8*

; insert table, function and environment into closure struct
%closure.table4354 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4344, i32 0, i32 0
store i8* %address-table4351, i8** %closure.table4354
%closure.env4355 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4344, i32 0, i32 1
store i8* %envptr4345, i8** %closure.env4355
%closure.func4356 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4344, i32 0, i32 2
store void (i8*, i8*, %Texture*)* @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd__4156, void (i8*, i8*, %Texture*)** %closure.func4356
%closure_size4357 = call i64 @llvm_zone_mark_size(%mzone* %zone4342)
call void @llvm_zone_ptr_set_size(i8* %clsptr4343, i64 %closure_size4357)
%wrapper_ptr4358 = call i8* @llvm_zone_malloc(%mzone* %zone4342, i64 8)
%closure_wrapper4359 = bitcast i8* %wrapper_ptr4358 to { i8*, i8*, void (i8*, i8*, %Texture*)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4344, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper4359

; let value assignment
%update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper4359, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper4359
store { i8*, i8*, void (i8*, i8*, %Texture*)*}** %update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd, { i8*, i8*, void (i8*, i8*, %Texture*)*}*** %update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd
%tmp_envptr4353 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %environment4346, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %tmp_envptr4353


%val4362 = load {i8*, i8*, void (i8*, i8*, %Texture*)*}**, {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr
ret {i8*, i8*, void (i8*, i8*, %Texture*)*}** %val4362
}


@update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc void @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc i8*  @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4363 = bitcast [92 x i8]* @gsxtmgl-objects2271 to i8*
call i32 (i8*, ...) @printf(i8* %var4363)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2272 = hidden constant [34 x i8] c"error setting tex cube parameters\00"
@gsxtmgl-objects2273 = hidden constant [41 x i8] c"bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd\00"
define dllexport fastcc i32 @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd__4364(i8* %_impz,i8* %_impenv, %Texture* %tex, i32 %active) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4365 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}*
%bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}* %impenv, i32 0, i32 0
%bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**** %bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%activePtr = alloca i32
store i32 %active, i32* %activePtr

; promote local stack var allocations
%tzone4423 = load i8*, i8** %_impzPtr
%zone4424 = bitcast i8* %tzone4423 to %mzone*
%ifptr4376 = alloca i64
%ifptr4377 = alloca i1
%ifptr4386 = alloca i1

%val4366 = load i32, i32* @GL_TEXTURE0
%val4367 = load i32, i32* %activePtr
%val4368 = add i32 %val4366, %val4367
call fastcc void @glActiveTexture_adhoc_W3ZvaWQsaTMyXQ(i32 %val4368)
%val4370 = load i32, i32* @GL_TEXTURE_CUBE_MAP
%val4371 = load %Texture*, %Texture** %texPtr
%res4372 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4371)
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val4370, i32 %res4372)
%var4374 = bitcast [32 x i8]* @gsxtmgl-objects2268 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var4374)
%val4378 = load %Texture*, %Texture** %texPtr
%res4379 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4378)
%val4380 = load i32, i32* @GL_RGBA
%cmp4381 = icmp eq i32 %res4379, %val4380
br i1 %cmp4381, label %then4377, label %else4377

then4377:
%val4382 = load %Texture*, %Texture** %texPtr
%res4383 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4382)
%val4384 = load i32, i32* @GL_RGBA
%cmp4385 = icmp eq i32 %res4383, %val4384
store i1 %cmp4385, i1* %ifptr4377
br label %ifcont4377

else4377:
%val4387 = load %Texture*, %Texture** %texPtr
%res4388 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4387)
%val4389 = load i32, i32* @GL_BGRA
%cmp4390 = icmp eq i32 %res4388, %val4389
br i1 %cmp4390, label %then4386, label %else4386

then4386:
%val4391 = load %Texture*, %Texture** %texPtr
%res4392 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4391)
%val4393 = load i32, i32* @GL_BGRA
%cmp4394 = icmp eq i32 %res4392, %val4393
store i1 %cmp4394, i1* %ifptr4386
br label %ifcont4386

else4386:
%res4395 = call ccc i1 @impc_false()
store i1 %res4395, i1* %ifptr4386
br label %ifcont4386

ifcont4386:
%ifres4396 = load i1, i1* %ifptr4386

store i1 %ifres4396, i1* %ifptr4377
br label %ifcont4377

ifcont4377:
%ifres4397 = load i1, i1* %ifptr4377

br i1 %ifres4397, label %then4376, label %else4376

then4376:
%val4398 = load i32, i32* @GL_TEXTURE_CUBE_MAP
%val4399 = load i32, i32* @GL_TEXTURE_WRAP_S
%val4400 = load i32, i32* @GL_CLAMP_TO_EDGE
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4398, i32 %val4399, i32 %val4400)
%val4402 = load i32, i32* @GL_TEXTURE_CUBE_MAP
%val4403 = load i32, i32* @GL_TEXTURE_WRAP_T
%val4404 = load i32, i32* @GL_CLAMP_TO_EDGE
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4402, i32 %val4403, i32 %val4404)
%val4406 = load i32, i32* @GL_TEXTURE_CUBE_MAP
%val4407 = load i32, i32* @GL_TEXTURE_WRAP_R
%val4408 = load i32, i32* @GL_CLAMP_TO_EDGE
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4406, i32 %val4407, i32 %val4408)
%val4410 = load i32, i32* @GL_TEXTURE_CUBE_MAP
%val4411 = load i32, i32* @GL_TEXTURE_MIN_FILTER
%val4412 = load i32, i32* @GL_LINEAR
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4410, i32 %val4411, i32 %val4412)
%val4414 = load i32, i32* @GL_TEXTURE_CUBE_MAP
%val4415 = load i32, i32* @GL_TEXTURE_MAG_FILTER
%val4416 = load i32, i32* @GL_LINEAR
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4414, i32 %val4415, i32 %val4416)
store i64 1, i64* %ifptr4376
br label %ifcont4376

else4376:
store i64 1, i64* %ifptr4376
br label %ifcont4376

ifcont4376:
%ifres4418 = load i64, i64* %ifptr4376

%var4419 = bitcast [34 x i8]* @gsxtmgl-objects2272 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var4419)
%val4421 = load %Texture*, %Texture** %texPtr
%res4422 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4421)
ret i32 %res4422
}
@gsxtmgl-objects2274 = hidden constant [94 x i8] c"bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4444 = load i8*, i8** %_impzPtr
%zone4445 = bitcast i8* %tzone4444 to %mzone*

; let assign value to symbol bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd
%dat_bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone4445, i64 8)
%bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr = bitcast i8* %dat_bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***
%tzone4425 = load i8*, i8** %_impzPtr
%zone4426 = bitcast i8* %tzone4425 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4426)
; malloc closure structure
%clsptr4427 = call i8* @llvm_zone_malloc(%mzone* %zone4426, i64 24)
%closure4428 = bitcast i8* %clsptr4427 to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*

; malloc environment structure
%envptr4429 = call i8* @llvm_zone_malloc(%mzone* %zone4426, i64 8)
%environment4430 = bitcast i8* %envptr4429 to {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}*

; malloc closure address table
%addytable4431 = call %clsvar* @new_address_table()
%var4432 = bitcast [41 x i8]* @gsxtmgl-objects2273 to i8*
%var4433 = bitcast [46 x i8]* @gsxtmgl-objects2228 to i8*
%addytable4434 = call %clsvar* @add_address_table(%mzone* %zone4426, i8* %var4432, i32 0, i8* %var4433, i32 3, %clsvar* %addytable4431)
%address-table4435 = bitcast %clsvar* %addytable4434 to i8*

; insert table, function and environment into closure struct
%closure.table4438 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure4428, i32 0, i32 0
store i8* %address-table4435, i8** %closure.table4438
%closure.env4439 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure4428, i32 0, i32 1
store i8* %envptr4429, i8** %closure.env4439
%closure.func4440 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure4428, i32 0, i32 2
store i32 (i8*, i8*, %Texture*, i32)* @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd__4364, i32 (i8*, i8*, %Texture*, i32)** %closure.func4440
%closure_size4441 = call i64 @llvm_zone_mark_size(%mzone* %zone4426)
call void @llvm_zone_ptr_set_size(i8* %clsptr4427, i64 %closure_size4441)
%wrapper_ptr4442 = call i8* @llvm_zone_malloc(%mzone* %zone4426, i64 8)
%closure_wrapper4443 = bitcast i8* %wrapper_ptr4442 to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
store { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure4428, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper4443

; let value assignment
%bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper4443, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper4443
store { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr

; add data to environment
; don't need to alloc for env var bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd
%tmp_envptr4437 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}* %environment4430, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**** %tmp_envptr4437


%val4446 = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr
ret {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %val4446
}


@bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_native(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4447 = bitcast [94 x i8]* @gsxtmgl-objects2274 to i8*
call i32 (i8*, ...) @printf(i8* %var4447)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4448 = bitcast [94 x i8]* @gsxtmgl-objects2274 to i8*
call i32 (i8*, ...) @printf(i8* %var4448)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, i32}*
%arg_p_0 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_cube_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2275 = hidden constant [24 x i8] c"couldn't update texture\00"
@gsxtmgl-objects2276 = hidden constant [34 x i8] c"update_adhoc_W3ZvaWQsVGV4dHVyZSpd\00"
define dllexport fastcc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd__4449(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4450 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*
%update_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%update_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = load {i8*, i8*, void (i8*, i8*, %Texture*)*}***, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %update_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr

; promote local stack var allocations
%tzone4482 = load i8*, i8** %_impzPtr
%zone4483 = bitcast i8* %tzone4482 to %mzone*
%ifptr4458 = alloca i32

%val4451 = load i32, i32* @GL_TEXTURE0
call fastcc void @glActiveTexture_adhoc_W3ZvaWQsaTMyXQ(i32 %val4451)
%val4453 = load i32, i32* @GL_TEXTURE_2D
%val4454 = load %Texture*, %Texture** %texPtr
%res4455 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4454)
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val4453, i32 %res4455)
%val4457 = load i32, i32* @GL_TEXTURE_2D
%val4459 = load %Texture*, %Texture** %texPtr
%res4460 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4459)
%val4461 = load i32, i32* @GL_BGRA
%cmp4462 = icmp eq i32 %res4460, %val4461
br i1 %cmp4462, label %then4458, label %else4458

then4458:
%val4463 = load i32, i32* @GL_RGBA
store i32 %val4463, i32* %ifptr4458
br label %ifcont4458

else4458:
%val4464 = load %Texture*, %Texture** %texPtr
%res4465 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4464)
store i32 %res4465, i32* %ifptr4458
br label %ifcont4458

ifcont4458:
%ifres4466 = load i32, i32* %ifptr4458

%val4467 = load %Texture*, %Texture** %texPtr
%res4468 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4467)
%val4469 = load %Texture*, %Texture** %texPtr
%res4470 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4469)
%val4471 = load %Texture*, %Texture** %texPtr
%res4472 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4471)
%val4473 = load i32, i32* @GL_UNSIGNED_BYTE
%val4474 = load %Texture*, %Texture** %texPtr
%res4475 = call fastcc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0(%Texture* %val4474)
call fastcc void @glTexImage2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %val4457, i32 0, i32 %ifres4466, i32 %res4468, i32 %res4470, i32 0, i32 %res4472, i32 %val4473, i8* %res4475)
%val4477 = load i32, i32* @GL_TEXTURE_2D
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val4477, i32 0)
%var4479 = bitcast [24 x i8]* @gsxtmgl-objects2275 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var4479)
ret void
}
@gsxtmgl-objects2277 = hidden constant [87 x i8] c"update_adhoc_W3ZvaWQsVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4503 = load i8*, i8** %_impzPtr
%zone4504 = bitcast i8* %tzone4503 to %mzone*

; let assign value to symbol update_adhoc_W3ZvaWQsVGV4dHVyZSpd
%dat_update_adhoc_W3ZvaWQsVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone4504, i64 8)
%update_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = bitcast i8* %dat_update_adhoc_W3ZvaWQsVGV4dHVyZSpd to { i8*, i8*, void (i8*, i8*, %Texture*)*}***
%tzone4484 = load i8*, i8** %_impzPtr
%zone4485 = bitcast i8* %tzone4484 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4485)
; malloc closure structure
%clsptr4486 = call i8* @llvm_zone_malloc(%mzone* %zone4485, i64 24)
%closure4487 = bitcast i8* %clsptr4486 to { i8*, i8*, void (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr4488 = call i8* @llvm_zone_malloc(%mzone* %zone4485, i64 8)
%environment4489 = bitcast i8* %envptr4488 to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable4490 = call %clsvar* @new_address_table()
%var4491 = bitcast [34 x i8]* @gsxtmgl-objects2276 to i8*
%var4492 = bitcast [42 x i8]* @gsxtmgl-objects2217 to i8*
%addytable4493 = call %clsvar* @add_address_table(%mzone* %zone4485, i8* %var4491, i32 0, i8* %var4492, i32 3, %clsvar* %addytable4490)
%address-table4494 = bitcast %clsvar* %addytable4493 to i8*

; insert table, function and environment into closure struct
%closure.table4497 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4487, i32 0, i32 0
store i8* %address-table4494, i8** %closure.table4497
%closure.env4498 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4487, i32 0, i32 1
store i8* %envptr4488, i8** %closure.env4498
%closure.func4499 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4487, i32 0, i32 2
store void (i8*, i8*, %Texture*)* @update_adhoc_W3ZvaWQsVGV4dHVyZSpd__4449, void (i8*, i8*, %Texture*)** %closure.func4499
%closure_size4500 = call i64 @llvm_zone_mark_size(%mzone* %zone4485)
call void @llvm_zone_ptr_set_size(i8* %clsptr4486, i64 %closure_size4500)
%wrapper_ptr4501 = call i8* @llvm_zone_malloc(%mzone* %zone4485, i64 8)
%closure_wrapper4502 = bitcast i8* %wrapper_ptr4501 to { i8*, i8*, void (i8*, i8*, %Texture*)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4487, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper4502

; let value assignment
%update_adhoc_W3ZvaWQsVGV4dHVyZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper4502, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper4502
store { i8*, i8*, void (i8*, i8*, %Texture*)*}** %update_adhoc_W3ZvaWQsVGV4dHVyZSpd, { i8*, i8*, void (i8*, i8*, %Texture*)*}*** %update_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var update_adhoc_W3ZvaWQsVGV4dHVyZSpd
%tmp_envptr4496 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %environment4489, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %update_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %tmp_envptr4496


%val4505 = load {i8*, i8*, void (i8*, i8*, %Texture*)*}**, {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %update_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr
ret {i8*, i8*, void (i8*, i8*, %Texture*)*}** %val4505
}


@update_adhoc_W3ZvaWQsVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@update_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc i8*  @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4506 = bitcast [87 x i8]* @gsxtmgl-objects2277 to i8*
call i32 (i8*, ...) @printf(i8* %var4506)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @update_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2278 = hidden constant [29 x i8] c"error setting tex parameters\00"
@gsxtmgl-objects2279 = hidden constant [36 x i8] c"bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd\00"
define dllexport fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd__4507(i8* %_impz,i8* %_impenv, %Texture* %tex, i32 %unit) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4508 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}*
%bind_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}* %impenv, i32 0, i32 0
%bind_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**** %bind_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%unitPtr = alloca i32
store i32 %unit, i32* %unitPtr

; promote local stack var allocations
%tzone4602 = load i8*, i8** %_impzPtr
%zone4603 = bitcast i8* %tzone4602 to %mzone*
%ifptr4517 = alloca i64
%ifptr4575 = alloca i64
%ifptr4518 = alloca i1
%ifptr4527 = alloca i1
%ifptr4536 = alloca i1
%ifptr4545 = alloca i1

%val4509 = load i32, i32* @GL_TEXTURE0
%val4510 = load i32, i32* %unitPtr
%val4511 = add i32 %val4509, %val4510
call fastcc void @glActiveTexture_adhoc_W3ZvaWQsaTMyXQ(i32 %val4511)
%val4513 = load i32, i32* @GL_TEXTURE_2D
%val4514 = load %Texture*, %Texture** %texPtr
%res4515 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4514)
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val4513, i32 %res4515)
%val4519 = load %Texture*, %Texture** %texPtr
%res4520 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4519)
%val4521 = load i32, i32* @GL_RGBA
%cmp4522 = icmp eq i32 %res4520, %val4521
br i1 %cmp4522, label %then4518, label %else4518

then4518:
%val4523 = load %Texture*, %Texture** %texPtr
%res4524 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4523)
%val4525 = load i32, i32* @GL_RGBA
%cmp4526 = icmp eq i32 %res4524, %val4525
store i1 %cmp4526, i1* %ifptr4518
br label %ifcont4518

else4518:
%val4528 = load %Texture*, %Texture** %texPtr
%res4529 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4528)
%val4530 = load i32, i32* @GL_RGB
%cmp4531 = icmp eq i32 %res4529, %val4530
br i1 %cmp4531, label %then4527, label %else4527

then4527:
%val4532 = load %Texture*, %Texture** %texPtr
%res4533 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4532)
%val4534 = load i32, i32* @GL_RGB
%cmp4535 = icmp eq i32 %res4533, %val4534
store i1 %cmp4535, i1* %ifptr4527
br label %ifcont4527

else4527:
%val4537 = load %Texture*, %Texture** %texPtr
%res4538 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4537)
%val4539 = load i32, i32* @GL_BGR
%cmp4540 = icmp eq i32 %res4538, %val4539
br i1 %cmp4540, label %then4536, label %else4536

then4536:
%val4541 = load %Texture*, %Texture** %texPtr
%res4542 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4541)
%val4543 = load i32, i32* @GL_BGR
%cmp4544 = icmp eq i32 %res4542, %val4543
store i1 %cmp4544, i1* %ifptr4536
br label %ifcont4536

else4536:
%val4546 = load %Texture*, %Texture** %texPtr
%res4547 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4546)
%val4548 = load i32, i32* @GL_BGRA
%cmp4549 = icmp eq i32 %res4547, %val4548
br i1 %cmp4549, label %then4545, label %else4545

then4545:
%val4550 = load %Texture*, %Texture** %texPtr
%res4551 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4550)
%val4552 = load i32, i32* @GL_BGRA
%cmp4553 = icmp eq i32 %res4551, %val4552
store i1 %cmp4553, i1* %ifptr4545
br label %ifcont4545

else4545:
%res4554 = call ccc i1 @impc_false()
store i1 %res4554, i1* %ifptr4545
br label %ifcont4545

ifcont4545:
%ifres4555 = load i1, i1* %ifptr4545

store i1 %ifres4555, i1* %ifptr4536
br label %ifcont4536

ifcont4536:
%ifres4556 = load i1, i1* %ifptr4536

store i1 %ifres4556, i1* %ifptr4527
br label %ifcont4527

ifcont4527:
%ifres4557 = load i1, i1* %ifptr4527

store i1 %ifres4557, i1* %ifptr4518
br label %ifcont4518

ifcont4518:
%ifres4558 = load i1, i1* %ifptr4518

br i1 %ifres4558, label %then4517, label %else4517

then4517:
%val4559 = load i32, i32* @GL_TEXTURE_2D
%val4560 = load i32, i32* @GL_TEXTURE_WRAP_S
%val4561 = load i32, i32* @GL_CLAMP_TO_EDGE
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4559, i32 %val4560, i32 %val4561)
%val4563 = load i32, i32* @GL_TEXTURE_2D
%val4564 = load i32, i32* @GL_TEXTURE_WRAP_T
%val4565 = load i32, i32* @GL_CLAMP_TO_EDGE
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4563, i32 %val4564, i32 %val4565)
%val4567 = load i32, i32* @GL_TEXTURE_2D
%val4568 = load i32, i32* @GL_TEXTURE_MIN_FILTER
%val4569 = load i32, i32* @GL_LINEAR
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4567, i32 %val4568, i32 %val4569)
%val4571 = load i32, i32* @GL_TEXTURE_2D
%val4572 = load i32, i32* @GL_TEXTURE_MAG_FILTER
%val4573 = load i32, i32* @GL_LINEAR
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4571, i32 %val4572, i32 %val4573)
store i64 1, i64* %ifptr4517
br label %ifcont4517

else4517:
%val4576 = load %Texture*, %Texture** %texPtr
%res4577 = call fastcc i32 @type_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4576)
%val4578 = load i32, i32* @GL_DEPTH_COMPONENT
%cmp4579 = icmp eq i32 %res4577, %val4578
br i1 %cmp4579, label %then4575, label %else4575

then4575:
%val4580 = load i32, i32* @GL_TEXTURE_2D
%val4581 = load i32, i32* @GL_TEXTURE_MAG_FILTER
%val4582 = load i32, i32* @GL_NEAREST
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4580, i32 %val4581, i32 %val4582)
%val4584 = load i32, i32* @GL_TEXTURE_2D
%val4585 = load i32, i32* @GL_TEXTURE_MIN_FILTER
%val4586 = load i32, i32* @GL_NEAREST
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4584, i32 %val4585, i32 %val4586)
%val4588 = load i32, i32* @GL_TEXTURE_2D
%val4589 = load i32, i32* @GL_TEXTURE_WRAP_S
%val4590 = load i32, i32* @GL_CLAMP_TO_EDGE
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4588, i32 %val4589, i32 %val4590)
%val4592 = load i32, i32* @GL_TEXTURE_2D
%val4593 = load i32, i32* @GL_TEXTURE_WRAP_T
%val4594 = load i32, i32* @GL_CLAMP_TO_EDGE
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4592, i32 %val4593, i32 %val4594)
store i64 1, i64* %ifptr4575
br label %ifcont4575

else4575:
store i64 1, i64* %ifptr4575
br label %ifcont4575

ifcont4575:
%ifres4596 = load i64, i64* %ifptr4575

store i64 %ifres4596, i64* %ifptr4517
br label %ifcont4517

ifcont4517:
%ifres4597 = load i64, i64* %ifptr4517

%var4598 = bitcast [29 x i8]* @gsxtmgl-objects2278 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var4598)
%val4600 = load %Texture*, %Texture** %texPtr
%res4601 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val4600)
ret i32 %res4601
}
@gsxtmgl-objects2280 = hidden constant [89 x i8] c"bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4623 = load i8*, i8** %_impzPtr
%zone4624 = bitcast i8* %tzone4623 to %mzone*

; let assign value to symbol bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd
%dat_bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone4624, i64 8)
%bind_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr = bitcast i8* %dat_bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***
%tzone4604 = load i8*, i8** %_impzPtr
%zone4605 = bitcast i8* %tzone4604 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4605)
; malloc closure structure
%clsptr4606 = call i8* @llvm_zone_malloc(%mzone* %zone4605, i64 24)
%closure4607 = bitcast i8* %clsptr4606 to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*

; malloc environment structure
%envptr4608 = call i8* @llvm_zone_malloc(%mzone* %zone4605, i64 8)
%environment4609 = bitcast i8* %envptr4608 to {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}*

; malloc closure address table
%addytable4610 = call %clsvar* @new_address_table()
%var4611 = bitcast [36 x i8]* @gsxtmgl-objects2279 to i8*
%var4612 = bitcast [46 x i8]* @gsxtmgl-objects2228 to i8*
%addytable4613 = call %clsvar* @add_address_table(%mzone* %zone4605, i8* %var4611, i32 0, i8* %var4612, i32 3, %clsvar* %addytable4610)
%address-table4614 = bitcast %clsvar* %addytable4613 to i8*

; insert table, function and environment into closure struct
%closure.table4617 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure4607, i32 0, i32 0
store i8* %address-table4614, i8** %closure.table4617
%closure.env4618 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure4607, i32 0, i32 1
store i8* %envptr4608, i8** %closure.env4618
%closure.func4619 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure4607, i32 0, i32 2
store i32 (i8*, i8*, %Texture*, i32)* @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd__4507, i32 (i8*, i8*, %Texture*, i32)** %closure.func4619
%closure_size4620 = call i64 @llvm_zone_mark_size(%mzone* %zone4605)
call void @llvm_zone_ptr_set_size(i8* %clsptr4606, i64 %closure_size4620)
%wrapper_ptr4621 = call i8* @llvm_zone_malloc(%mzone* %zone4605, i64 8)
%closure_wrapper4622 = bitcast i8* %wrapper_ptr4621 to { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
store { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure4607, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper4622

; let value assignment
%bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper4622, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_wrapper4622
store { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd, { i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %bind_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr

; add data to environment
; don't need to alloc for env var bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd
%tmp_envptr4616 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}***}* %environment4609, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %bind_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**** %tmp_envptr4616


%val4625 = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*** %bind_adhoc_W2kzMixUZXh0dXJlKixpMzJdPtr
ret {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %val4625
}


@bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_native(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4626 = bitcast [89 x i8]* @gsxtmgl-objects2280 to i8*
call i32 (i8*, ...) @printf(i8* %var4626)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4627 = bitcast [89 x i8]* @gsxtmgl-objects2280 to i8*
call i32 (i8*, ...) @printf(i8* %var4627)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, i32}*
%arg_p_0 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*, i32)*,  i32 (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2281 = hidden constant [31 x i8] c"bind_adhoc_W2kzMixUZXh0dXJlKl0\00"
define dllexport fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKl0__4628(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4629 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}*
%bind_adhoc_W2kzMixUZXh0dXJlKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%bind_adhoc_W2kzMixUZXh0dXJlKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}***, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**** %bind_adhoc_W2kzMixUZXh0dXJlKl0Ptr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr


%val4630 = load %Texture*, %Texture** %texPtr
%res4631 = call fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKixpMzJd(%Texture* %val4630, i32 0)
ret i32 %res4631
}
@gsxtmgl-objects2282 = hidden constant [84 x i8] c"bind_adhoc_W2kzMixUZXh0dXJlKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** @bind_adhoc_W2kzMixUZXh0dXJlKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4651 = load i8*, i8** %_impzPtr
%zone4652 = bitcast i8* %tzone4651 to %mzone*

; let assign value to symbol bind_adhoc_W2kzMixUZXh0dXJlKl0
%dat_bind_adhoc_W2kzMixUZXh0dXJlKl0 = call i8* @llvm_zone_malloc(%mzone* %zone4652, i64 8)
%bind_adhoc_W2kzMixUZXh0dXJlKl0Ptr = bitcast i8* %dat_bind_adhoc_W2kzMixUZXh0dXJlKl0 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}***
%tzone4632 = load i8*, i8** %_impzPtr
%zone4633 = bitcast i8* %tzone4632 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4633)
; malloc closure structure
%clsptr4634 = call i8* @llvm_zone_malloc(%mzone* %zone4633, i64 24)
%closure4635 = bitcast i8* %clsptr4634 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr4636 = call i8* @llvm_zone_malloc(%mzone* %zone4633, i64 8)
%environment4637 = bitcast i8* %envptr4636 to {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable4638 = call %clsvar* @new_address_table()
%var4639 = bitcast [31 x i8]* @gsxtmgl-objects2281 to i8*
%var4640 = bitcast [41 x i8]* @gsxtmgl-objects2223 to i8*
%addytable4641 = call %clsvar* @add_address_table(%mzone* %zone4633, i8* %var4639, i32 0, i8* %var4640, i32 3, %clsvar* %addytable4638)
%address-table4642 = bitcast %clsvar* %addytable4641 to i8*

; insert table, function and environment into closure struct
%closure.table4645 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure4635, i32 0, i32 0
store i8* %address-table4642, i8** %closure.table4645
%closure.env4646 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure4635, i32 0, i32 1
store i8* %envptr4636, i8** %closure.env4646
%closure.func4647 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Texture*)*}, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure4635, i32 0, i32 2
store i32 (i8*, i8*, %Texture*)* @bind_adhoc_W2kzMixUZXh0dXJlKl0__4628, i32 (i8*, i8*, %Texture*)** %closure.func4647
%closure_size4648 = call i64 @llvm_zone_mark_size(%mzone* %zone4633)
call void @llvm_zone_ptr_set_size(i8* %clsptr4634, i64 %closure_size4648)
%wrapper_ptr4649 = call i8* @llvm_zone_malloc(%mzone* %zone4633, i64 8)
%closure_wrapper4650 = bitcast i8* %wrapper_ptr4649 to { i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
store { i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure4635, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper4650

; let value assignment
%bind_adhoc_W2kzMixUZXh0dXJlKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper4650, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_wrapper4650
store { i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %bind_adhoc_W2kzMixUZXh0dXJlKl0, { i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %bind_adhoc_W2kzMixUZXh0dXJlKl0Ptr

; add data to environment
; don't need to alloc for env var bind_adhoc_W2kzMixUZXh0dXJlKl0
%tmp_envptr4644 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Texture*)*}***}* %environment4637, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %bind_adhoc_W2kzMixUZXh0dXJlKl0Ptr, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**** %tmp_envptr4644


%val4653 = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*** %bind_adhoc_W2kzMixUZXh0dXJlKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %val4653
}


@bind_adhoc_W2kzMixUZXh0dXJlKl0_var = dllexport global [1 x i8*] [ i8* null ]

@bind_adhoc_W2kzMixUZXh0dXJlKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @bind_adhoc_W2kzMixUZXh0dXJlKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** @bind_adhoc_W2kzMixUZXh0dXJlKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @bind_adhoc_W2kzMixUZXh0dXJlKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @bind_adhoc_W2kzMixUZXh0dXJlKl0_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @bind_adhoc_W2kzMixUZXh0dXJlKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4654 = bitcast [84 x i8]* @gsxtmgl-objects2282 to i8*
call i32 (i8*, ...) @printf(i8* %var4654)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @bind_adhoc_W2kzMixUZXh0dXJlKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixUZXh0dXJlKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Texture*)*}*, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Texture*)*}, {i8*, i8*, i32 (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Texture*)*,  i32 (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2283 = hidden constant [24 x i8] c"couldn't unbind texture\00"
@gsxtmgl-objects2284 = hidden constant [40 x i8] c"unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ\00"
@gsxtmgl-objects2285 = hidden constant [47 x i8] c"{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**\00"
define dllexport fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ__4655(i8* %_impz,i8* %_impenv, %Texture* %tex, i32 %unit) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4656 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***}*
%unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***}* %impenv, i32 0, i32 0
%unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr = load {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**** %unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%unitPtr = alloca i32
store i32 %unit, i32* %unitPtr


%val4657 = load i32, i32* @GL_TEXTURE0
%val4658 = load i32, i32* %unitPtr
%val4659 = add i32 %val4657, %val4658
call fastcc void @glActiveTexture_adhoc_W3ZvaWQsaTMyXQ(i32 %val4659)
%val4661 = load i32, i32* @GL_TEXTURE_2D
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val4661, i32 0)
%var4663 = bitcast [24 x i8]* @gsxtmgl-objects2283 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var4663)
ret void
}
@gsxtmgl-objects2286 = hidden constant [93 x i8] c"unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4685 = load i8*, i8** %_impzPtr
%zone4686 = bitcast i8* %tzone4685 to %mzone*

; let assign value to symbol unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ
%dat_unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone4686, i64 8)
%unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr = bitcast i8* %dat_unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ to { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***
%tzone4666 = load i8*, i8** %_impzPtr
%zone4667 = bitcast i8* %tzone4666 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4667)
; malloc closure structure
%clsptr4668 = call i8* @llvm_zone_malloc(%mzone* %zone4667, i64 24)
%closure4669 = bitcast i8* %clsptr4668 to { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*

; malloc environment structure
%envptr4670 = call i8* @llvm_zone_malloc(%mzone* %zone4667, i64 8)
%environment4671 = bitcast i8* %envptr4670 to {{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***}*

; malloc closure address table
%addytable4672 = call %clsvar* @new_address_table()
%var4673 = bitcast [40 x i8]* @gsxtmgl-objects2284 to i8*
%var4674 = bitcast [47 x i8]* @gsxtmgl-objects2285 to i8*
%addytable4675 = call %clsvar* @add_address_table(%mzone* %zone4667, i8* %var4673, i32 0, i8* %var4674, i32 3, %clsvar* %addytable4672)
%address-table4676 = bitcast %clsvar* %addytable4675 to i8*

; insert table, function and environment into closure struct
%closure.table4679 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure4669, i32 0, i32 0
store i8* %address-table4676, i8** %closure.table4679
%closure.env4680 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure4669, i32 0, i32 1
store i8* %envptr4670, i8** %closure.env4680
%closure.func4681 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure4669, i32 0, i32 2
store void (i8*, i8*, %Texture*, i32)* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ__4655, void (i8*, i8*, %Texture*, i32)** %closure.func4681
%closure_size4682 = call i64 @llvm_zone_mark_size(%mzone* %zone4667)
call void @llvm_zone_ptr_set_size(i8* %clsptr4668, i64 %closure_size4682)
%wrapper_ptr4683 = call i8* @llvm_zone_malloc(%mzone* %zone4667, i64 8)
%closure_wrapper4684 = bitcast i8* %wrapper_ptr4683 to { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure4669, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_wrapper4684

; let value assignment
%unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_wrapper4684, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_wrapper4684
store { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*** %unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr

; add data to environment
; don't need to alloc for env var unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ
%tmp_envptr4678 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***}* %environment4671, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*** %unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**** %tmp_envptr4678


%val4687 = load {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*** %unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr
ret {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %val4687
}


@unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32)*,  void (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_native(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32)*,  void (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc i8*  @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4688 = bitcast [93 x i8]* @gsxtmgl-objects2286 to i8*
call i32 (i8*, ...) @printf(i8* %var4688)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4689 = bitcast [93 x i8]* @gsxtmgl-objects2286 to i8*
call i32 (i8*, ...) @printf(i8* %var4689)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32)*,  void (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, i32}*
%arg_p_0 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32)*,  void (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2287 = hidden constant [34 x i8] c"unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd\00"
define dllexport fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd__4690(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4691 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*
%unbind_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%unbind_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = load {i8*, i8*, void (i8*, i8*, %Texture*)*}***, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %unbind_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr


%val4692 = load %Texture*, %Texture** %texPtr
call fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ(%Texture* %val4692, i32 0)
ret void
}
@gsxtmgl-objects2288 = hidden constant [87 x i8] c"unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4713 = load i8*, i8** %_impzPtr
%zone4714 = bitcast i8* %tzone4713 to %mzone*

; let assign value to symbol unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd
%dat_unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone4714, i64 8)
%unbind_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = bitcast i8* %dat_unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd to { i8*, i8*, void (i8*, i8*, %Texture*)*}***
%tzone4694 = load i8*, i8** %_impzPtr
%zone4695 = bitcast i8* %tzone4694 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4695)
; malloc closure structure
%clsptr4696 = call i8* @llvm_zone_malloc(%mzone* %zone4695, i64 24)
%closure4697 = bitcast i8* %clsptr4696 to { i8*, i8*, void (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr4698 = call i8* @llvm_zone_malloc(%mzone* %zone4695, i64 8)
%environment4699 = bitcast i8* %envptr4698 to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable4700 = call %clsvar* @new_address_table()
%var4701 = bitcast [34 x i8]* @gsxtmgl-objects2287 to i8*
%var4702 = bitcast [42 x i8]* @gsxtmgl-objects2217 to i8*
%addytable4703 = call %clsvar* @add_address_table(%mzone* %zone4695, i8* %var4701, i32 0, i8* %var4702, i32 3, %clsvar* %addytable4700)
%address-table4704 = bitcast %clsvar* %addytable4703 to i8*

; insert table, function and environment into closure struct
%closure.table4707 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4697, i32 0, i32 0
store i8* %address-table4704, i8** %closure.table4707
%closure.env4708 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4697, i32 0, i32 1
store i8* %envptr4698, i8** %closure.env4708
%closure.func4709 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4697, i32 0, i32 2
store void (i8*, i8*, %Texture*)* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd__4690, void (i8*, i8*, %Texture*)** %closure.func4709
%closure_size4710 = call i64 @llvm_zone_mark_size(%mzone* %zone4695)
call void @llvm_zone_ptr_set_size(i8* %clsptr4696, i64 %closure_size4710)
%wrapper_ptr4711 = call i8* @llvm_zone_malloc(%mzone* %zone4695, i64 8)
%closure_wrapper4712 = bitcast i8* %wrapper_ptr4711 to { i8*, i8*, void (i8*, i8*, %Texture*)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4697, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper4712

; let value assignment
%unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper4712, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper4712
store { i8*, i8*, void (i8*, i8*, %Texture*)*}** %unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd, { i8*, i8*, void (i8*, i8*, %Texture*)*}*** %unbind_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd
%tmp_envptr4706 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %environment4699, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %unbind_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %tmp_envptr4706


%val4715 = load {i8*, i8*, void (i8*, i8*, %Texture*)*}**, {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %unbind_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr
ret {i8*, i8*, void (i8*, i8*, %Texture*)*}** %val4715
}


@unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc i8*  @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4716 = bitcast [87 x i8]* @gsxtmgl-objects2288 to i8*
call i32 (i8*, ...) @printf(i8* %var4716)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2289 = hidden constant [45 x i8] c"unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ\00"
define dllexport fastcc void @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ__4717(i8* %_impz,i8* %_impenv, %Texture* %tex, i32 %active) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4718 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***}*
%unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***}* %impenv, i32 0, i32 0
%unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr = load {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**** %unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr
%activePtr = alloca i32
store i32 %active, i32* %activePtr


%val4719 = load i32, i32* @GL_TEXTURE0
%val4720 = load i32, i32* %activePtr
%val4721 = add i32 %val4719, %val4720
call fastcc void @glActiveTexture_adhoc_W3ZvaWQsaTMyXQ(i32 %val4721)
%val4723 = load i32, i32* @GL_TEXTURE_CUBE_MAP
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val4723, i32 0)
%var4725 = bitcast [24 x i8]* @gsxtmgl-objects2283 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var4725)
ret void
}
@gsxtmgl-objects2290 = hidden constant [98 x i8] c"unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4747 = load i8*, i8** %_impzPtr
%zone4748 = bitcast i8* %tzone4747 to %mzone*

; let assign value to symbol unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ
%dat_unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone4748, i64 8)
%unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr = bitcast i8* %dat_unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ to { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***
%tzone4728 = load i8*, i8** %_impzPtr
%zone4729 = bitcast i8* %tzone4728 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4729)
; malloc closure structure
%clsptr4730 = call i8* @llvm_zone_malloc(%mzone* %zone4729, i64 24)
%closure4731 = bitcast i8* %clsptr4730 to { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*

; malloc environment structure
%envptr4732 = call i8* @llvm_zone_malloc(%mzone* %zone4729, i64 8)
%environment4733 = bitcast i8* %envptr4732 to {{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***}*

; malloc closure address table
%addytable4734 = call %clsvar* @new_address_table()
%var4735 = bitcast [45 x i8]* @gsxtmgl-objects2289 to i8*
%var4736 = bitcast [47 x i8]* @gsxtmgl-objects2285 to i8*
%addytable4737 = call %clsvar* @add_address_table(%mzone* %zone4729, i8* %var4735, i32 0, i8* %var4736, i32 3, %clsvar* %addytable4734)
%address-table4738 = bitcast %clsvar* %addytable4737 to i8*

; insert table, function and environment into closure struct
%closure.table4741 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure4731, i32 0, i32 0
store i8* %address-table4738, i8** %closure.table4741
%closure.env4742 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure4731, i32 0, i32 1
store i8* %envptr4732, i8** %closure.env4742
%closure.func4743 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure4731, i32 0, i32 2
store void (i8*, i8*, %Texture*, i32)* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ__4717, void (i8*, i8*, %Texture*, i32)** %closure.func4743
%closure_size4744 = call i64 @llvm_zone_mark_size(%mzone* %zone4729)
call void @llvm_zone_ptr_set_size(i8* %clsptr4730, i64 %closure_size4744)
%wrapper_ptr4745 = call i8* @llvm_zone_malloc(%mzone* %zone4729, i64 8)
%closure_wrapper4746 = bitcast i8* %wrapper_ptr4745 to { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure4731, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_wrapper4746

; let value assignment
%unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_wrapper4746, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_wrapper4746
store { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ, { i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*** %unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr

; add data to environment
; don't need to alloc for env var unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ
%tmp_envptr4740 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*, i32)*}***}* %environment4733, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*** %unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**** %tmp_envptr4740


%val4749 = load {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*** %unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQPtr
ret {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %val4749
}


@unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32)*,  void (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc void @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_native(%Texture* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32)*,  void (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
ret void
}


define dllexport ccc i8*  @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4750 = bitcast [98 x i8]* @gsxtmgl-objects2290 to i8*
call i32 (i8*, ...) @printf(i8* %var4750)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4751 = bitcast [98 x i8]* @gsxtmgl-objects2290 to i8*
call i32 (i8*, ...) @printf(i8* %var4751)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32)*,  void (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, i32}*
%arg_p_0 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, i32}, {%Texture*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}*, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}, {i8*, i8*, void (i8*, i8*, %Texture*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*, i32)*,  void (i8*, i8*, %Texture*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2291 = hidden constant [39 x i8] c"unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd\00"
define dllexport fastcc void @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd__4752(i8* %_impz,i8* %_impenv, %Texture* %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4753 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*
%unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = load {i8*, i8*, void (i8*, i8*, %Texture*)*}***, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr_

; setup arguments
%texPtr = alloca %Texture*
store %Texture* %tex, %Texture** %texPtr


%val4754 = load %Texture*, %Texture** %texPtr
call fastcc void @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyXQ(%Texture* %val4754, i32 0)
ret void
}
@gsxtmgl-objects2292 = hidden constant [92 x i8] c"unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4775 = load i8*, i8** %_impzPtr
%zone4776 = bitcast i8* %tzone4775 to %mzone*

; let assign value to symbol unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd
%dat_unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone4776, i64 8)
%unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr = bitcast i8* %dat_unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd to { i8*, i8*, void (i8*, i8*, %Texture*)*}***
%tzone4756 = load i8*, i8** %_impzPtr
%zone4757 = bitcast i8* %tzone4756 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4757)
; malloc closure structure
%clsptr4758 = call i8* @llvm_zone_malloc(%mzone* %zone4757, i64 24)
%closure4759 = bitcast i8* %clsptr4758 to { i8*, i8*, void (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr4760 = call i8* @llvm_zone_malloc(%mzone* %zone4757, i64 8)
%environment4761 = bitcast i8* %envptr4760 to {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable4762 = call %clsvar* @new_address_table()
%var4763 = bitcast [39 x i8]* @gsxtmgl-objects2291 to i8*
%var4764 = bitcast [42 x i8]* @gsxtmgl-objects2217 to i8*
%addytable4765 = call %clsvar* @add_address_table(%mzone* %zone4757, i8* %var4763, i32 0, i8* %var4764, i32 3, %clsvar* %addytable4762)
%address-table4766 = bitcast %clsvar* %addytable4765 to i8*

; insert table, function and environment into closure struct
%closure.table4769 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4759, i32 0, i32 0
store i8* %address-table4766, i8** %closure.table4769
%closure.env4770 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4759, i32 0, i32 1
store i8* %envptr4760, i8** %closure.env4770
%closure.func4771 = getelementptr { i8*, i8*, void (i8*, i8*, %Texture*)*}, { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4759, i32 0, i32 2
store void (i8*, i8*, %Texture*)* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd__4752, void (i8*, i8*, %Texture*)** %closure.func4771
%closure_size4772 = call i64 @llvm_zone_mark_size(%mzone* %zone4757)
call void @llvm_zone_ptr_set_size(i8* %clsptr4758, i64 %closure_size4772)
%wrapper_ptr4773 = call i8* @llvm_zone_malloc(%mzone* %zone4757, i64 8)
%closure_wrapper4774 = bitcast i8* %wrapper_ptr4773 to { i8*, i8*, void (i8*, i8*, %Texture*)*}**
store { i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure4759, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper4774

; let value assignment
%unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper4774, { i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_wrapper4774
store { i8*, i8*, void (i8*, i8*, %Texture*)*}** %unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd, { i8*, i8*, void (i8*, i8*, %Texture*)*}*** %unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd
%tmp_envptr4768 = getelementptr {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, void (i8*, i8*, %Texture*)*}***}* %environment4761, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr, {i8*, i8*, void (i8*, i8*, %Texture*)*}**** %tmp_envptr4768


%val4777 = load {i8*, i8*, void (i8*, i8*, %Texture*)*}**, {i8*, i8*, void (i8*, i8*, %Texture*)*}*** %unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpdPtr
ret {i8*, i8*, void (i8*, i8*, %Texture*)*}** %val4777
}


@unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Texture*)*}** @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc void @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret void
}


define dllexport ccc i8*  @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4778 = bitcast [92 x i8]* @gsxtmgl-objects2292 to i8*
call i32 (i8*, ...) @printf(i8* %var4778)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_cube_adhoc_W3ZvaWQsVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Texture*)*}*, {i8*, i8*, void (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Texture*)*}, {i8*, i8*, void (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Texture*)*,  void (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2293 = hidden constant [23 x i8] c"Error creating Texture\00"
@gsxtmgl-objects2294 = hidden constant [23 x i8] c"Error deleting Texture\00"
@gsxtmgl-objects2295 = hidden constant [34 x i8] c"Texture_adhoc_W1RleHR1cmUqLGkzMl0\00"
@gsxtmgl-objects2296 = hidden constant [41 x i8] c"{i8*, i8*, %Texture* (i8*, i8*, i32)*}**\00"
@gsxtmgl-objects2297 = hidden constant [10 x i8] c"type_s_29\00"
@gsxtmgl-objects2298 = hidden constant [4 x i8] c"tex\00"
@gsxtmgl-objects2299 = hidden constant [10 x i8] c"%Texture*\00"
define dllexport fastcc void @Texture_adhoc_W1RleHR1cmUqLGkzMl0__4780(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4807 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}*
%Texture_adhoc_W1RleHR1cmUqLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 0
%Texture_adhoc_W1RleHR1cmUqLGkzMl0Ptr = load {i8*, i8*, %Texture* (i8*, i8*, i32)*}***, {i8*, i8*, %Texture* (i8*, i8*, i32)*}**** %Texture_adhoc_W1RleHR1cmUqLGkzMl0Ptr_
%type_s_29Ptr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 1
%type_s_29Ptr = load i32*, i32** %type_s_29Ptr_
%texPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 2
%texPtr = load %Texture**, %Texture*** %texPtr_
%fPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 3
%fPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %fPtr_
%hookPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 4
%hookPtr = load {i64,i8*,i8*}**, {i64,i8*,i8*}*** %hookPtr_
%hooksPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 5
%hooksPtr = load {i64,i8*,i8*}**, {i64,i8*,i8*}*** %hooksPtr_
%zonePtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %impenv, i32 0, i32 6
%zonePtr = load %mzone**, %mzone*** %zonePtr_

; setup arguments


%val4808 = load %Texture*, %Texture** %texPtr
; tuple ref
%val4809 = getelementptr %Texture, %Texture* %val4808, i64 0, i32 0
call fastcc void @glDeleteTextures_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val4809)
%var4811 = bitcast [23 x i8]* @gsxtmgl-objects2294 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var4811)
%val4813 = load %Texture*, %Texture** %texPtr
call fastcc void @free_image_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val4813)
ret void
}
define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMl0__4779(i8* %_impz,i8* %_impenv, i32 %type_s_29) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4781 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***}*
%Texture_adhoc_W1RleHR1cmUqLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%Texture_adhoc_W1RleHR1cmUqLGkzMl0Ptr = load {i8*, i8*, %Texture* (i8*, i8*, i32)*}***, {i8*, i8*, %Texture* (i8*, i8*, i32)*}**** %Texture_adhoc_W1RleHR1cmUqLGkzMl0Ptr_

; setup arguments
%dat_type_s_29 = call i8* @llvm_zone_malloc(%mzone* %zone4781, i64 4)
%type_s_29Ptr = bitcast i8* %dat_type_s_29 to i32*
store i32 %type_s_29, i32* %type_s_29Ptr


%tzone4785 = load i8*, i8** %_impzPtr
%zone4786 = bitcast i8* %tzone4785 to %mzone*

; let assign value to symbol tex
%dat_tex = call i8* @llvm_zone_malloc(%mzone* %zone4786, i64 8)
%texPtr = bitcast i8* %dat_tex to %Texture**
%val4782 = load i32, i32* %type_s_29Ptr
%null4783 = bitcast i8* null to i8*
%res4784 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 0, i32 %val4782, i32 0, i32 0, i8* %null4783)

; let value assignment
%tex = select i1 true, %Texture* %res4784, %Texture* %res4784
store %Texture* %tex, %Texture** %texPtr

%val4787 = load %Texture*, %Texture** %texPtr
; tuple ref
%val4788 = getelementptr %Texture, %Texture* %val4787, i64 0, i32 0
call fastcc void @glGenTextures_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val4788)
%var4790 = bitcast [23 x i8]* @gsxtmgl-objects2293 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var4790)
%tzone4793 = load i8*, i8** %_impzPtr
%zone4794 = bitcast i8* %tzone4793 to %mzone*

; let assign value to symbol zone
%dat_zone = call i8* @llvm_zone_malloc(%mzone* %zone4794, i64 8)
%zonePtr = bitcast i8* %dat_zone to %mzone**
%tzone4799 = load i8*, i8** %_impzPtr
%zone4800 = bitcast i8* %tzone4799 to %mzone*

; let assign value to symbol hooks
%dat_hooks = call i8* @llvm_zone_malloc(%mzone* %zone4800, i64 8)
%hooksPtr = bitcast i8* %dat_hooks to {i64,i8*,i8*}**
%tzone4805 = load i8*, i8** %_impzPtr
%zone4806 = bitcast i8* %tzone4805 to %mzone*

; let assign value to symbol hook
%dat_hook = call i8* @llvm_zone_malloc(%mzone* %zone4806, i64 8)
%hookPtr = bitcast i8* %dat_hook to {i64,i8*,i8*}**
%tzone4865 = load i8*, i8** %_impzPtr
%zone4866 = bitcast i8* %tzone4865 to %mzone*

; let assign value to symbol f
%dat_f = call i8* @llvm_zone_malloc(%mzone* %zone4866, i64 8)
%fPtr = bitcast i8* %dat_f to { i8*, i8*, void (i8*, i8*)*}***
%res4792 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%zone = select i1 true, %mzone* %res4792, %mzone* %res4792
store %mzone* %zone, %mzone** %zonePtr

%val4795 = load %mzone*, %mzone** %zonePtr
; tuple ref
%val4796 = getelementptr %mzone, %mzone* %val4795, i64 0, i32 4
%val4797 = load i8*, i8** %val4796
%val4798 = bitcast i8* %val4797 to {i64,i8*,i8*}*

; let value assignment
%hooks = select i1 true, {i64,i8*,i8*}* %val4798, {i64,i8*,i8*}* %val4798
store {i64,i8*,i8*}* %hooks, {i64,i8*,i8*}** %hooksPtr

%tzone4801 = load i8*, i8** %_impzPtr
%zone4802 = bitcast i8* %tzone4801 to %mzone*
%dat4803 = call i8* @llvm_zone_malloc(%mzone* %zone4802, i64 24)
call i8* @memset(i8* %dat4803, i32 0, i64 24)
%val4804 = bitcast i8* %dat4803 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val4804, {i64,i8*,i8*}* %val4804
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%tzone4816 = load i8*, i8** %_impzPtr
%zone4817 = bitcast i8* %tzone4816 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4817)
; malloc closure structure
%clsptr4818 = call i8* @llvm_zone_malloc(%mzone* %zone4817, i64 24)
%closure4819 = bitcast i8* %clsptr4818 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr4820 = call i8* @llvm_zone_malloc(%mzone* %zone4817, i64 56)
%environment4821 = bitcast i8* %envptr4820 to {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}*

; malloc closure address table
%addytable4822 = call %clsvar* @new_address_table()
%var4823 = bitcast [34 x i8]* @gsxtmgl-objects2295 to i8*
%var4824 = bitcast [41 x i8]* @gsxtmgl-objects2296 to i8*
%addytable4825 = call %clsvar* @add_address_table(%mzone* %zone4817, i8* %var4823, i32 0, i8* %var4824, i32 3, %clsvar* %addytable4822)
%var4826 = bitcast [10 x i8]* @gsxtmgl-objects2297 to i8*
%var4827 = bitcast [4 x i8]* @gsxtmgl-objects274 to i8*
%addytable4828 = call %clsvar* @add_address_table(%mzone* %zone4817, i8* %var4826, i32 8, i8* %var4827, i32 3, %clsvar* %addytable4825)
%var4829 = bitcast [4 x i8]* @gsxtmgl-objects2298 to i8*
%var4830 = bitcast [10 x i8]* @gsxtmgl-objects2299 to i8*
%addytable4831 = call %clsvar* @add_address_table(%mzone* %zone4817, i8* %var4829, i32 16, i8* %var4830, i32 3, %clsvar* %addytable4828)
%var4832 = bitcast [2 x i8]* @gsxtmgl-objects280 to i8*
%var4833 = bitcast [31 x i8]* @gsxtmgl-objects211 to i8*
%addytable4834 = call %clsvar* @add_address_table(%mzone* %zone4817, i8* %var4832, i32 24, i8* %var4833, i32 3, %clsvar* %addytable4831)
%var4835 = bitcast [5 x i8]* @gsxtmgl-objects281 to i8*
%var4836 = bitcast [15 x i8]* @gsxtmgl-objects282 to i8*
%addytable4837 = call %clsvar* @add_address_table(%mzone* %zone4817, i8* %var4835, i32 32, i8* %var4836, i32 3, %clsvar* %addytable4834)
%var4838 = bitcast [6 x i8]* @gsxtmgl-objects283 to i8*
%var4839 = bitcast [15 x i8]* @gsxtmgl-objects282 to i8*
%addytable4840 = call %clsvar* @add_address_table(%mzone* %zone4817, i8* %var4838, i32 40, i8* %var4839, i32 3, %clsvar* %addytable4837)
%var4841 = bitcast [5 x i8]* @gsxtmgl-objects284 to i8*
%var4842 = bitcast [8 x i8]* @gsxtmgl-objects285 to i8*
%addytable4843 = call %clsvar* @add_address_table(%mzone* %zone4817, i8* %var4841, i32 48, i8* %var4842, i32 3, %clsvar* %addytable4840)
%address-table4844 = bitcast %clsvar* %addytable4843 to i8*

; insert table, function and environment into closure struct
%closure.table4859 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure4819, i32 0, i32 0
store i8* %address-table4844, i8** %closure.table4859
%closure.env4860 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure4819, i32 0, i32 1
store i8* %envptr4820, i8** %closure.env4860
%closure.func4861 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure4819, i32 0, i32 2
store void (i8*, i8*)* @Texture_adhoc_W1RleHR1cmUqLGkzMl0__4780, void (i8*, i8*)** %closure.func4861
%closure_size4862 = call i64 @llvm_zone_mark_size(%mzone* %zone4817)
call void @llvm_zone_ptr_set_size(i8* %clsptr4818, i64 %closure_size4862)
%wrapper_ptr4863 = call i8* @llvm_zone_malloc(%mzone* %zone4817, i64 8)
%closure_wrapper4864 = bitcast i8* %wrapper_ptr4863 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure4819, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper4864

; let value assignment
%f = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper4864, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper4864
store { i8*, i8*, void (i8*, i8*)*}** %f, { i8*, i8*, void (i8*, i8*)*}*** %fPtr

; add data to environment
; don't need to alloc for env var Texture_adhoc_W1RleHR1cmUqLGkzMl0
%tmp_envptr4846 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment4821, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, i32)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMl0Ptr, {i8*, i8*, %Texture* (i8*, i8*, i32)*}**** %tmp_envptr4846

; don't need to alloc for env var type_s_29
%tmp_envptr4848 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment4821, i32 0, i32 1
store i32* %type_s_29Ptr, i32** %tmp_envptr4848

; don't need to alloc for env var tex
%tmp_envptr4850 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment4821, i32 0, i32 2
store %Texture** %texPtr, %Texture*** %tmp_envptr4850

; don't need to alloc for env var f
%tmp_envptr4852 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment4821, i32 0, i32 3
store {i8*, i8*, void (i8*, i8*)*}*** %fPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr4852

; don't need to alloc for env var hook
%tmp_envptr4854 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment4821, i32 0, i32 4
store {i64,i8*,i8*}** %hookPtr, {i64,i8*,i8*}*** %tmp_envptr4854

; don't need to alloc for env var hooks
%tmp_envptr4856 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment4821, i32 0, i32 5
store {i64,i8*,i8*}** %hooksPtr, {i64,i8*,i8*}*** %tmp_envptr4856

; don't need to alloc for env var zone
%tmp_envptr4858 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***, i32*, %Texture**, {i8*, i8*, void (i8*, i8*)*}***, {i64,i8*,i8*}**, {i64,i8*,i8*}**, %mzone**}* %environment4821, i32 0, i32 6
store %mzone** %zonePtr, %mzone*** %tmp_envptr4858


%val4867 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; set tuple
%val4868 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val4867, i64 0, i32 0
store i64 0, i64* %val4868
%val4869 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val4870 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val4871 = bitcast {i8*, i8*, void (i8*, i8*)*}** %val4870 to i8*
; set tuple
%val4872 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val4869, i64 0, i32 1
store i8* %val4871, i8** %val4872
%val4873 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val4874 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hooksPtr
%val4875 = bitcast {i64,i8*,i8*}* %val4874 to i8*
; set tuple
%val4876 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val4873, i64 0, i32 2
store i8* %val4875, i8** %val4876
%val4877 = load %mzone*, %mzone** %zonePtr
%val4878 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val4879 = bitcast {i64,i8*,i8*}* %val4878 to i8*
; set tuple
%val4880 = getelementptr %mzone, %mzone* %val4877, i64 0, i32 4
store i8* %val4879, i8** %val4880
%val4882 = load %Texture*, %Texture** %texPtr
ret %Texture* %val4882
}
@gsxtmgl-objects2300 = hidden constant [87 x i8] c"Texture_adhoc_W1RleHR1cmUqLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*, i32)*}** @Texture_adhoc_W1RleHR1cmUqLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4902 = load i8*, i8** %_impzPtr
%zone4903 = bitcast i8* %tzone4902 to %mzone*

; let assign value to symbol Texture_adhoc_W1RleHR1cmUqLGkzMl0
%dat_Texture_adhoc_W1RleHR1cmUqLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone4903, i64 8)
%Texture_adhoc_W1RleHR1cmUqLGkzMl0Ptr = bitcast i8* %dat_Texture_adhoc_W1RleHR1cmUqLGkzMl0 to { i8*, i8*, %Texture* (i8*, i8*, i32)*}***
%tzone4883 = load i8*, i8** %_impzPtr
%zone4884 = bitcast i8* %tzone4883 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4884)
; malloc closure structure
%clsptr4885 = call i8* @llvm_zone_malloc(%mzone* %zone4884, i64 24)
%closure4886 = bitcast i8* %clsptr4885 to { i8*, i8*, %Texture* (i8*, i8*, i32)*}*

; malloc environment structure
%envptr4887 = call i8* @llvm_zone_malloc(%mzone* %zone4884, i64 8)
%environment4888 = bitcast i8* %envptr4887 to {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable4889 = call %clsvar* @new_address_table()
%var4890 = bitcast [34 x i8]* @gsxtmgl-objects2295 to i8*
%var4891 = bitcast [41 x i8]* @gsxtmgl-objects2296 to i8*
%addytable4892 = call %clsvar* @add_address_table(%mzone* %zone4884, i8* %var4890, i32 0, i8* %var4891, i32 3, %clsvar* %addytable4889)
%address-table4893 = bitcast %clsvar* %addytable4892 to i8*

; insert table, function and environment into closure struct
%closure.table4896 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32)*}, { i8*, i8*, %Texture* (i8*, i8*, i32)*}* %closure4886, i32 0, i32 0
store i8* %address-table4893, i8** %closure.table4896
%closure.env4897 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32)*}, { i8*, i8*, %Texture* (i8*, i8*, i32)*}* %closure4886, i32 0, i32 1
store i8* %envptr4887, i8** %closure.env4897
%closure.func4898 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32)*}, { i8*, i8*, %Texture* (i8*, i8*, i32)*}* %closure4886, i32 0, i32 2
store %Texture* (i8*, i8*, i32)* @Texture_adhoc_W1RleHR1cmUqLGkzMl0__4779, %Texture* (i8*, i8*, i32)** %closure.func4898
%closure_size4899 = call i64 @llvm_zone_mark_size(%mzone* %zone4884)
call void @llvm_zone_ptr_set_size(i8* %clsptr4885, i64 %closure_size4899)
%wrapper_ptr4900 = call i8* @llvm_zone_malloc(%mzone* %zone4884, i64 8)
%closure_wrapper4901 = bitcast i8* %wrapper_ptr4900 to { i8*, i8*, %Texture* (i8*, i8*, i32)*}**
store { i8*, i8*, %Texture* (i8*, i8*, i32)*}* %closure4886, { i8*, i8*, %Texture* (i8*, i8*, i32)*}** %closure_wrapper4901

; let value assignment
%Texture_adhoc_W1RleHR1cmUqLGkzMl0 = select i1 true, { i8*, i8*, %Texture* (i8*, i8*, i32)*}** %closure_wrapper4901, { i8*, i8*, %Texture* (i8*, i8*, i32)*}** %closure_wrapper4901
store { i8*, i8*, %Texture* (i8*, i8*, i32)*}** %Texture_adhoc_W1RleHR1cmUqLGkzMl0, { i8*, i8*, %Texture* (i8*, i8*, i32)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var Texture_adhoc_W1RleHR1cmUqLGkzMl0
%tmp_envptr4895 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, i32)*}***}* %environment4888, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, i32)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMl0Ptr, {i8*, i8*, %Texture* (i8*, i8*, i32)*}**** %tmp_envptr4895


%val4904 = load {i8*, i8*, %Texture* (i8*, i8*, i32)*}**, {i8*, i8*, %Texture* (i8*, i8*, i32)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMl0Ptr
ret {i8*, i8*, %Texture* (i8*, i8*, i32)*}** %val4904
}


@Texture_adhoc_W1RleHR1cmUqLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_adhoc_W1RleHR1cmUqLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*, i32)*}** @Texture_adhoc_W1RleHR1cmUqLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_adhoc_W1RleHR1cmUqLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMl0(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32)*,  %Texture* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %Texture* %result
}


define dllexport ccc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMl0_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32)*,  %Texture* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %Texture* %result
}


define dllexport ccc i8*  @Texture_adhoc_W1RleHR1cmUqLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4905 = bitcast [87 x i8]* @gsxtmgl-objects2300 to i8*
call i32 (i8*, ...) @printf(i8* %var4905)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32)*,  %Texture* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32)*,  %Texture* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2301 = hidden constant [29 x i8] c"Texture_adhoc_W1RleHR1cmUqXQ\00"
@gsxtmgl-objects2302 = hidden constant [36 x i8] c"{i8*, i8*, %Texture* (i8*, i8*)*}**\00"
define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqXQ__4906(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4907 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*)*}***}*
%Texture_adhoc_W1RleHR1cmUqXQPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%Texture_adhoc_W1RleHR1cmUqXQPtr = load {i8*, i8*, %Texture* (i8*, i8*)*}***, {i8*, i8*, %Texture* (i8*, i8*)*}**** %Texture_adhoc_W1RleHR1cmUqXQPtr_

; setup arguments


%res4908 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMl0(i32 0)
ret %Texture* %res4908
}
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*)*}** @Texture_adhoc_W1RleHR1cmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4928 = load i8*, i8** %_impzPtr
%zone4929 = bitcast i8* %tzone4928 to %mzone*

; let assign value to symbol Texture_adhoc_W1RleHR1cmUqXQ
%dat_Texture_adhoc_W1RleHR1cmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone4929, i64 8)
%Texture_adhoc_W1RleHR1cmUqXQPtr = bitcast i8* %dat_Texture_adhoc_W1RleHR1cmUqXQ to { i8*, i8*, %Texture* (i8*, i8*)*}***
%tzone4909 = load i8*, i8** %_impzPtr
%zone4910 = bitcast i8* %tzone4909 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4910)
; malloc closure structure
%clsptr4911 = call i8* @llvm_zone_malloc(%mzone* %zone4910, i64 24)
%closure4912 = bitcast i8* %clsptr4911 to { i8*, i8*, %Texture* (i8*, i8*)*}*

; malloc environment structure
%envptr4913 = call i8* @llvm_zone_malloc(%mzone* %zone4910, i64 8)
%environment4914 = bitcast i8* %envptr4913 to {{i8*, i8*, %Texture* (i8*, i8*)*}***}*

; malloc closure address table
%addytable4915 = call %clsvar* @new_address_table()
%var4916 = bitcast [29 x i8]* @gsxtmgl-objects2301 to i8*
%var4917 = bitcast [36 x i8]* @gsxtmgl-objects2302 to i8*
%addytable4918 = call %clsvar* @add_address_table(%mzone* %zone4910, i8* %var4916, i32 0, i8* %var4917, i32 3, %clsvar* %addytable4915)
%address-table4919 = bitcast %clsvar* %addytable4918 to i8*

; insert table, function and environment into closure struct
%closure.table4922 = getelementptr { i8*, i8*, %Texture* (i8*, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*)*}* %closure4912, i32 0, i32 0
store i8* %address-table4919, i8** %closure.table4922
%closure.env4923 = getelementptr { i8*, i8*, %Texture* (i8*, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*)*}* %closure4912, i32 0, i32 1
store i8* %envptr4913, i8** %closure.env4923
%closure.func4924 = getelementptr { i8*, i8*, %Texture* (i8*, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*)*}* %closure4912, i32 0, i32 2
store %Texture* (i8*, i8*)* @Texture_adhoc_W1RleHR1cmUqXQ__4906, %Texture* (i8*, i8*)** %closure.func4924
%closure_size4925 = call i64 @llvm_zone_mark_size(%mzone* %zone4910)
call void @llvm_zone_ptr_set_size(i8* %clsptr4911, i64 %closure_size4925)
%wrapper_ptr4926 = call i8* @llvm_zone_malloc(%mzone* %zone4910, i64 8)
%closure_wrapper4927 = bitcast i8* %wrapper_ptr4926 to { i8*, i8*, %Texture* (i8*, i8*)*}**
store { i8*, i8*, %Texture* (i8*, i8*)*}* %closure4912, { i8*, i8*, %Texture* (i8*, i8*)*}** %closure_wrapper4927

; let value assignment
%Texture_adhoc_W1RleHR1cmUqXQ = select i1 true, { i8*, i8*, %Texture* (i8*, i8*)*}** %closure_wrapper4927, { i8*, i8*, %Texture* (i8*, i8*)*}** %closure_wrapper4927
store { i8*, i8*, %Texture* (i8*, i8*)*}** %Texture_adhoc_W1RleHR1cmUqXQ, { i8*, i8*, %Texture* (i8*, i8*)*}*** %Texture_adhoc_W1RleHR1cmUqXQPtr

; add data to environment
; don't need to alloc for env var Texture_adhoc_W1RleHR1cmUqXQ
%tmp_envptr4921 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*)*}***}* %environment4914, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*)*}*** %Texture_adhoc_W1RleHR1cmUqXQPtr, {i8*, i8*, %Texture* (i8*, i8*)*}**** %tmp_envptr4921


%val4930 = load {i8*, i8*, %Texture* (i8*, i8*)*}**, {i8*, i8*, %Texture* (i8*, i8*)*}*** %Texture_adhoc_W1RleHR1cmUqXQPtr
ret {i8*, i8*, %Texture* (i8*, i8*)*}** %val4930
}


@Texture_adhoc_W1RleHR1cmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_adhoc_W1RleHR1cmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*)*}** @Texture_adhoc_W1RleHR1cmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_adhoc_W1RleHR1cmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqXQ() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*)*,  %Texture* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee)
ret %Texture* %result
}


define dllexport ccc %Texture* @Texture_adhoc_W1RleHR1cmUqXQ_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*)*,  %Texture* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee)
ret %Texture* %result
}


define dllexport ccc i8*  @Texture_adhoc_W1RleHR1cmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*)*,  %Texture* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*)*,  %Texture* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2303 = hidden constant [45 x i8] c"Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ\00"
@gsxtmgl-objects2304 = hidden constant [51 x i8] c"{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}**\00"
define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ__4931(i8* %_impz,i8* %_impenv, i32 %width_s_30, i32 %height_s_31, i32 %comp) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4932 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}***}*
%Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQPtr = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}***, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}**** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQPtr_

; setup arguments
%width_s_30Ptr = alloca i32
store i32 %width_s_30, i32* %width_s_30Ptr
%height_s_31Ptr = alloca i32
store i32 %height_s_31, i32* %height_s_31Ptr
%compPtr = alloca i32
store i32 %comp, i32* %compPtr

; promote local stack var allocations
%tzone4957 = load i8*, i8** %_impzPtr
%zone4958 = bitcast i8* %tzone4957 to %mzone*
%ifptr4933 = alloca %Texture*
%ifptr4938 = alloca %Texture*

%tzone4947 = load i8*, i8** %_impzPtr
%zone4948 = bitcast i8* %tzone4947 to %mzone*

; let assign value to symbol tex
%texPtr = alloca %Texture*
%val4934 = load i32, i32* %compPtr
%cmp4935 = icmp eq i32 %val4934, 1
br i1 %cmp4935, label %then4933, label %else4933

then4933:
%val4936 = load i32, i32* @GL_DEPTH_COMPONENT
%res4937 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMl0(i32 %val4936)
store %Texture* %res4937, %Texture** %ifptr4933
br label %ifcont4933

else4933:
%val4939 = load i32, i32* %compPtr
%cmp4940 = icmp eq i32 %val4939, 3
br i1 %cmp4940, label %then4938, label %else4938

then4938:
%val4941 = load i32, i32* @GL_RGB
%res4942 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMl0(i32 %val4941)
store %Texture* %res4942, %Texture** %ifptr4938
br label %ifcont4938

else4938:
%val4943 = load i32, i32* @GL_RGBA
%res4944 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMl0(i32 %val4943)
store %Texture* %res4944, %Texture** %ifptr4938
br label %ifcont4938

ifcont4938:
%ifres4945 = load %Texture*, %Texture** %ifptr4938

store %Texture* %ifres4945, %Texture** %ifptr4933
br label %ifcont4933

ifcont4933:
%ifres4946 = load %Texture*, %Texture** %ifptr4933


; let value assignment
%tex = select i1 true, %Texture* %ifres4946, %Texture* %ifres4946
store %Texture* %tex, %Texture** %texPtr

%val4949 = load %Texture*, %Texture** %texPtr
%val4950 = load i32, i32* %width_s_30Ptr
%val4951 = load i32, i32* %height_s_31Ptr
%val4952 = load i32, i32* %compPtr
call fastcc void @create_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLGkzMixpMzJd(%Texture* %val4949, i32 %val4950, i32 %val4951, i32 %val4952)
%val4954 = load %Texture*, %Texture** %texPtr
call fastcc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val4954)
%val4956 = load %Texture*, %Texture** %texPtr
ret %Texture* %val4956
}
@gsxtmgl-objects2305 = hidden constant [98 x i8] c"Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}** @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4978 = load i8*, i8** %_impzPtr
%zone4979 = bitcast i8* %tzone4978 to %mzone*

; let assign value to symbol Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ
%dat_Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone4979, i64 8)
%Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQPtr = bitcast i8* %dat_Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}***
%tzone4959 = load i8*, i8** %_impzPtr
%zone4960 = bitcast i8* %tzone4959 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4960)
; malloc closure structure
%clsptr4961 = call i8* @llvm_zone_malloc(%mzone* %zone4960, i64 24)
%closure4962 = bitcast i8* %clsptr4961 to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}*

; malloc environment structure
%envptr4963 = call i8* @llvm_zone_malloc(%mzone* %zone4960, i64 8)
%environment4964 = bitcast i8* %envptr4963 to {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}***}*

; malloc closure address table
%addytable4965 = call %clsvar* @new_address_table()
%var4966 = bitcast [45 x i8]* @gsxtmgl-objects2303 to i8*
%var4967 = bitcast [51 x i8]* @gsxtmgl-objects2304 to i8*
%addytable4968 = call %clsvar* @add_address_table(%mzone* %zone4960, i8* %var4966, i32 0, i8* %var4967, i32 3, %clsvar* %addytable4965)
%address-table4969 = bitcast %clsvar* %addytable4968 to i8*

; insert table, function and environment into closure struct
%closure.table4972 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}* %closure4962, i32 0, i32 0
store i8* %address-table4969, i8** %closure.table4972
%closure.env4973 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}* %closure4962, i32 0, i32 1
store i8* %envptr4963, i8** %closure.env4973
%closure.func4974 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}* %closure4962, i32 0, i32 2
store %Texture* (i8*, i8*, i32, i32, i32)* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ__4931, %Texture* (i8*, i8*, i32, i32, i32)** %closure.func4974
%closure_size4975 = call i64 @llvm_zone_mark_size(%mzone* %zone4960)
call void @llvm_zone_ptr_set_size(i8* %clsptr4961, i64 %closure_size4975)
%wrapper_ptr4976 = call i8* @llvm_zone_malloc(%mzone* %zone4960, i64 8)
%closure_wrapper4977 = bitcast i8* %wrapper_ptr4976 to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}**
store { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}* %closure4962, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}** %closure_wrapper4977

; let value assignment
%Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ = select i1 true, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}** %closure_wrapper4977, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}** %closure_wrapper4977
store { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ
%tmp_envptr4971 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}***}* %environment4964, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQPtr, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}**** %tmp_envptr4971


%val4980 = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}**, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQPtr
ret {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}** %val4980
}


@Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}** @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ(i32 %arg_0,i32 %arg_1,i32 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32)*,  %Texture* (i8*, i8*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2)
ret %Texture* %result
}


define dllexport ccc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_native(i32 %arg_0,i32 %arg_1,i32 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32)*,  %Texture* (i8*, i8*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2)
ret %Texture* %result
}


define dllexport ccc i8*  @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4981 = bitcast [98 x i8]* @gsxtmgl-objects2305 to i8*
call i32 (i8*, ...) @printf(i8* %var4981)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4982 = bitcast [98 x i8]* @gsxtmgl-objects2305 to i8*
call i32 (i8*, ...) @printf(i8* %var4982)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4983 = bitcast [98 x i8]* @gsxtmgl-objects2305 to i8*
call i32 (i8*, ...) @printf(i8* %var4983)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32)*,  %Texture* (i8*, i8*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32}, {i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32}, {i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32}, {i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32)*,  %Texture* (i8*, i8*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2306 = hidden constant [45 x i8] c"Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ\00"
@gsxtmgl-objects2307 = hidden constant [51 x i8] c"{i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}**\00"
define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ__4984(i8* %_impz,i8* %_impenv, %String* %filename, i32 %flipped) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4985 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}***}*
%Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}***}* %impenv, i32 0, i32 0
%Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQPtr = load {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}***, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}**** %Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQPtr_

; setup arguments
%filenamePtr = alloca %String*
store %String* %filename, %String** %filenamePtr
%flippedPtr = alloca i32
store i32 %flipped, i32* %flippedPtr


%tzone4987 = load i8*, i8** %_impzPtr
%zone4988 = bitcast i8* %tzone4987 to %mzone*

; let assign value to symbol tex
%texPtr = alloca %Texture*
%res4986 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqXQ()

; let value assignment
%tex = select i1 true, %Texture* %res4986, %Texture* %res4986
store %Texture* %tex, %Texture** %texPtr

%val4989 = load %Texture*, %Texture** %texPtr
%val4990 = load i32, i32* %flippedPtr
%val4991 = load %String*, %String** %filenamePtr
call fastcc void @load_data_adhoc_W3ZvaWQsVGV4dHVyZSosaTMyLFN0cmluZypd(%Texture* %val4989, i32 %val4990, %String* %val4991)
%val4993 = load %Texture*, %Texture** %texPtr
call fastcc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val4993)
%val4995 = load %Texture*, %Texture** %texPtr
ret %Texture* %val4995
}
@gsxtmgl-objects2308 = hidden constant [98 x i8] c"Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}** @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5015 = load i8*, i8** %_impzPtr
%zone5016 = bitcast i8* %tzone5015 to %mzone*

; let assign value to symbol Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ
%dat_Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone5016, i64 8)
%Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQPtr = bitcast i8* %dat_Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ to { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}***
%tzone4996 = load i8*, i8** %_impzPtr
%zone4997 = bitcast i8* %tzone4996 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4997)
; malloc closure structure
%clsptr4998 = call i8* @llvm_zone_malloc(%mzone* %zone4997, i64 24)
%closure4999 = bitcast i8* %clsptr4998 to { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}*

; malloc environment structure
%envptr5000 = call i8* @llvm_zone_malloc(%mzone* %zone4997, i64 8)
%environment5001 = bitcast i8* %envptr5000 to {{i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}***}*

; malloc closure address table
%addytable5002 = call %clsvar* @new_address_table()
%var5003 = bitcast [45 x i8]* @gsxtmgl-objects2306 to i8*
%var5004 = bitcast [51 x i8]* @gsxtmgl-objects2307 to i8*
%addytable5005 = call %clsvar* @add_address_table(%mzone* %zone4997, i8* %var5003, i32 0, i8* %var5004, i32 3, %clsvar* %addytable5002)
%address-table5006 = bitcast %clsvar* %addytable5005 to i8*

; insert table, function and environment into closure struct
%closure.table5009 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}, { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}* %closure4999, i32 0, i32 0
store i8* %address-table5006, i8** %closure.table5009
%closure.env5010 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}, { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}* %closure4999, i32 0, i32 1
store i8* %envptr5000, i8** %closure.env5010
%closure.func5011 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}, { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}* %closure4999, i32 0, i32 2
store %Texture* (i8*, i8*, %String*, i32)* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ__4984, %Texture* (i8*, i8*, %String*, i32)** %closure.func5011
%closure_size5012 = call i64 @llvm_zone_mark_size(%mzone* %zone4997)
call void @llvm_zone_ptr_set_size(i8* %clsptr4998, i64 %closure_size5012)
%wrapper_ptr5013 = call i8* @llvm_zone_malloc(%mzone* %zone4997, i64 8)
%closure_wrapper5014 = bitcast i8* %wrapper_ptr5013 to { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}**
store { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}* %closure4999, { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}** %closure_wrapper5014

; let value assignment
%Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ = select i1 true, { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}** %closure_wrapper5014, { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}** %closure_wrapper5014
store { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}** %Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ, { i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}*** %Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQPtr

; add data to environment
; don't need to alloc for env var Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ
%tmp_envptr5008 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}***}* %environment5001, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}*** %Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQPtr, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}**** %tmp_envptr5008


%val5017 = load {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}**, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}*** %Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQPtr
ret {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}** %val5017
}


@Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}** @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ(%String* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}*, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %String*, i32)*,  %Texture* (i8*, i8*, %String*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1)
ret %Texture* %result
}


define dllexport ccc %Texture* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_native(%String* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}*, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %String*, i32)*,  %Texture* (i8*, i8*, %String*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1)
ret %Texture* %result
}


define dllexport ccc i8*  @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5018 = bitcast [98 x i8]* @gsxtmgl-objects2308 to i8*
call i32 (i8*, ...) @printf(i8* %var5018)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5019 = bitcast [98 x i8]* @gsxtmgl-objects2308 to i8*
call i32 (i8*, ...) @printf(i8* %var5019)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}*, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %String*, i32)*,  %Texture* (i8*, i8*, %String*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i32}*
%arg_p_0 = getelementptr {%String*, i32}, {%String*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i32}, {%String*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}*, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %String*, i32)*,  %Texture* (i8*, i8*, %String*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2309 = hidden constant [39 x i8] c"Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd\00"
@gsxtmgl-objects2310 = hidden constant [46 x i8] c"{i8*, i8*, %Texture* (i8*, i8*, %String*)*}**\00"
define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd__5020(i8* %_impz,i8* %_impenv, %String* %filename) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5021 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, %String*)*}***}*
%Texture_adhoc_W1RleHR1cmUqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, %String*)*}***}* %impenv, i32 0, i32 0
%Texture_adhoc_W1RleHR1cmUqLFN0cmluZypdPtr = load {i8*, i8*, %Texture* (i8*, i8*, %String*)*}***, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}**** %Texture_adhoc_W1RleHR1cmUqLFN0cmluZypdPtr_

; setup arguments
%filenamePtr = alloca %String*
store %String* %filename, %String** %filenamePtr


%tzone5024 = load i8*, i8** %_impzPtr
%zone5025 = bitcast i8* %tzone5024 to %mzone*

; let assign value to symbol tex
%texPtr = alloca %Texture*
%val5022 = load %String*, %String** %filenamePtr
%res5023 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZyosaTMyXQ(%String* %val5022, i32 1)

; let value assignment
%tex = select i1 true, %Texture* %res5023, %Texture* %res5023
store %Texture* %tex, %Texture** %texPtr

%val5026 = load %Texture*, %Texture** %texPtr
ret %Texture* %val5026
}
@gsxtmgl-objects2311 = hidden constant [92 x i8] c"Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*, %String*)*}** @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5046 = load i8*, i8** %_impzPtr
%zone5047 = bitcast i8* %tzone5046 to %mzone*

; let assign value to symbol Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd
%dat_Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone5047, i64 8)
%Texture_adhoc_W1RleHR1cmUqLFN0cmluZypdPtr = bitcast i8* %dat_Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd to { i8*, i8*, %Texture* (i8*, i8*, %String*)*}***
%tzone5027 = load i8*, i8** %_impzPtr
%zone5028 = bitcast i8* %tzone5027 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5028)
; malloc closure structure
%clsptr5029 = call i8* @llvm_zone_malloc(%mzone* %zone5028, i64 24)
%closure5030 = bitcast i8* %clsptr5029 to { i8*, i8*, %Texture* (i8*, i8*, %String*)*}*

; malloc environment structure
%envptr5031 = call i8* @llvm_zone_malloc(%mzone* %zone5028, i64 8)
%environment5032 = bitcast i8* %envptr5031 to {{i8*, i8*, %Texture* (i8*, i8*, %String*)*}***}*

; malloc closure address table
%addytable5033 = call %clsvar* @new_address_table()
%var5034 = bitcast [39 x i8]* @gsxtmgl-objects2309 to i8*
%var5035 = bitcast [46 x i8]* @gsxtmgl-objects2310 to i8*
%addytable5036 = call %clsvar* @add_address_table(%mzone* %zone5028, i8* %var5034, i32 0, i8* %var5035, i32 3, %clsvar* %addytable5033)
%address-table5037 = bitcast %clsvar* %addytable5036 to i8*

; insert table, function and environment into closure struct
%closure.table5040 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %String*)*}, { i8*, i8*, %Texture* (i8*, i8*, %String*)*}* %closure5030, i32 0, i32 0
store i8* %address-table5037, i8** %closure.table5040
%closure.env5041 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %String*)*}, { i8*, i8*, %Texture* (i8*, i8*, %String*)*}* %closure5030, i32 0, i32 1
store i8* %envptr5031, i8** %closure.env5041
%closure.func5042 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %String*)*}, { i8*, i8*, %Texture* (i8*, i8*, %String*)*}* %closure5030, i32 0, i32 2
store %Texture* (i8*, i8*, %String*)* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd__5020, %Texture* (i8*, i8*, %String*)** %closure.func5042
%closure_size5043 = call i64 @llvm_zone_mark_size(%mzone* %zone5028)
call void @llvm_zone_ptr_set_size(i8* %clsptr5029, i64 %closure_size5043)
%wrapper_ptr5044 = call i8* @llvm_zone_malloc(%mzone* %zone5028, i64 8)
%closure_wrapper5045 = bitcast i8* %wrapper_ptr5044 to { i8*, i8*, %Texture* (i8*, i8*, %String*)*}**
store { i8*, i8*, %Texture* (i8*, i8*, %String*)*}* %closure5030, { i8*, i8*, %Texture* (i8*, i8*, %String*)*}** %closure_wrapper5045

; let value assignment
%Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd = select i1 true, { i8*, i8*, %Texture* (i8*, i8*, %String*)*}** %closure_wrapper5045, { i8*, i8*, %Texture* (i8*, i8*, %String*)*}** %closure_wrapper5045
store { i8*, i8*, %Texture* (i8*, i8*, %String*)*}** %Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd, { i8*, i8*, %Texture* (i8*, i8*, %String*)*}*** %Texture_adhoc_W1RleHR1cmUqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd
%tmp_envptr5039 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, %String*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, %String*)*}***}* %environment5032, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, %String*)*}*** %Texture_adhoc_W1RleHR1cmUqLFN0cmluZypdPtr, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}**** %tmp_envptr5039


%val5048 = load {i8*, i8*, %Texture* (i8*, i8*, %String*)*}**, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}*** %Texture_adhoc_W1RleHR1cmUqLFN0cmluZypdPtr
ret {i8*, i8*, %Texture* (i8*, i8*, %String*)*}** %val5048
}


@Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*, %String*)*}** @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %String*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %String*)*,  %Texture* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %Texture* %result
}


define dllexport ccc %Texture* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_native(%String* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %String*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %String*)*,  %Texture* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
ret %Texture* %result
}


define dllexport ccc i8*  @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5049 = bitcast [92 x i8]* @gsxtmgl-objects2311 to i8*
call i32 (i8*, ...) @printf(i8* %var5049)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %String*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %String*)*,  %Texture* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*}*
%arg_p_0 = getelementptr {%String*}, {%String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %String*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %String*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %String*)*}, {i8*, i8*, %Texture* (i8*, i8*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %String*)*,  %Texture* (i8*, i8*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %String* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2312 = hidden constant [50 x i8] c"Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0\00"
@gsxtmgl-objects2313 = hidden constant [56 x i8] c"{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}**\00"
define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0__5050(i8* %_impz,i8* %_impenv, i32 %width_s_32, i32 %height_s_33, i32 %comp, i8* %data_s_34) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5051 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}***}*
%Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}***}* %impenv, i32 0, i32 0
%Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0Ptr = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}***, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}**** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0Ptr_

; setup arguments
%width_s_32Ptr = alloca i32
store i32 %width_s_32, i32* %width_s_32Ptr
%height_s_33Ptr = alloca i32
store i32 %height_s_33, i32* %height_s_33Ptr
%compPtr = alloca i32
store i32 %comp, i32* %compPtr
%data_s_34Ptr = alloca i8*
store i8* %data_s_34, i8** %data_s_34Ptr

; promote local stack var allocations
%tzone5081 = load i8*, i8** %_impzPtr
%zone5082 = bitcast i8* %tzone5081 to %mzone*
%ifptr5052 = alloca %Texture*
%ifptr5057 = alloca %Texture*

%tzone5066 = load i8*, i8** %_impzPtr
%zone5067 = bitcast i8* %tzone5066 to %mzone*

; let assign value to symbol tex
%texPtr = alloca %Texture*
%val5053 = load i32, i32* %compPtr
%cmp5054 = icmp eq i32 %val5053, 1
br i1 %cmp5054, label %then5052, label %else5052

then5052:
%val5055 = load i32, i32* @GL_DEPTH_COMPONENT
%res5056 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMl0(i32 %val5055)
store %Texture* %res5056, %Texture** %ifptr5052
br label %ifcont5052

else5052:
%val5058 = load i32, i32* %compPtr
%cmp5059 = icmp eq i32 %val5058, 3
br i1 %cmp5059, label %then5057, label %else5057

then5057:
%val5060 = load i32, i32* @GL_RGB
%res5061 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMl0(i32 %val5060)
store %Texture* %res5061, %Texture** %ifptr5057
br label %ifcont5057

else5057:
%val5062 = load i32, i32* @GL_RGBA
%res5063 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMl0(i32 %val5062)
store %Texture* %res5063, %Texture** %ifptr5057
br label %ifcont5057

ifcont5057:
%ifres5064 = load %Texture*, %Texture** %ifptr5057

store %Texture* %ifres5064, %Texture** %ifptr5052
br label %ifcont5052

ifcont5052:
%ifres5065 = load %Texture*, %Texture** %ifptr5052


; let value assignment
%tex = select i1 true, %Texture* %ifres5065, %Texture* %ifres5065
store %Texture* %tex, %Texture** %texPtr

%val5068 = load %Texture*, %Texture** %texPtr
%val5069 = load i32, i32* %width_s_32Ptr
; set tuple
%val5070 = getelementptr %Texture, %Texture* %val5068, i64 0, i32 2
store i32 %val5069, i32* %val5070
%val5071 = load %Texture*, %Texture** %texPtr
%val5072 = load i32, i32* %height_s_33Ptr
; set tuple
%val5073 = getelementptr %Texture, %Texture* %val5071, i64 0, i32 3
store i32 %val5072, i32* %val5073
%val5074 = load %Texture*, %Texture** %texPtr
%val5075 = load i8*, i8** %data_s_34Ptr
%val5076 = bitcast i8* %val5075 to i8*
; set tuple
%val5077 = getelementptr %Texture, %Texture* %val5074, i64 0, i32 4
store i8* %val5076, i8** %val5077
%val5078 = load %Texture*, %Texture** %texPtr
call fastcc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val5078)
%val5080 = load %Texture*, %Texture** %texPtr
ret %Texture* %val5080
}
@gsxtmgl-objects2314 = hidden constant [103 x i8] c"Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}** @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5102 = load i8*, i8** %_impzPtr
%zone5103 = bitcast i8* %tzone5102 to %mzone*

; let assign value to symbol Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0
%dat_Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone5103, i64 8)
%Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0Ptr = bitcast i8* %dat_Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0 to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}***
%tzone5083 = load i8*, i8** %_impzPtr
%zone5084 = bitcast i8* %tzone5083 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5084)
; malloc closure structure
%clsptr5085 = call i8* @llvm_zone_malloc(%mzone* %zone5084, i64 24)
%closure5086 = bitcast i8* %clsptr5085 to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}*

; malloc environment structure
%envptr5087 = call i8* @llvm_zone_malloc(%mzone* %zone5084, i64 8)
%environment5088 = bitcast i8* %envptr5087 to {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}***}*

; malloc closure address table
%addytable5089 = call %clsvar* @new_address_table()
%var5090 = bitcast [50 x i8]* @gsxtmgl-objects2312 to i8*
%var5091 = bitcast [56 x i8]* @gsxtmgl-objects2313 to i8*
%addytable5092 = call %clsvar* @add_address_table(%mzone* %zone5084, i8* %var5090, i32 0, i8* %var5091, i32 3, %clsvar* %addytable5089)
%address-table5093 = bitcast %clsvar* %addytable5092 to i8*

; insert table, function and environment into closure struct
%closure.table5096 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}* %closure5086, i32 0, i32 0
store i8* %address-table5093, i8** %closure.table5096
%closure.env5097 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}* %closure5086, i32 0, i32 1
store i8* %envptr5087, i8** %closure.env5097
%closure.func5098 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}* %closure5086, i32 0, i32 2
store %Texture* (i8*, i8*, i32, i32, i32, i8*)* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0__5050, %Texture* (i8*, i8*, i32, i32, i32, i8*)** %closure.func5098
%closure_size5099 = call i64 @llvm_zone_mark_size(%mzone* %zone5084)
call void @llvm_zone_ptr_set_size(i8* %clsptr5085, i64 %closure_size5099)
%wrapper_ptr5100 = call i8* @llvm_zone_malloc(%mzone* %zone5084, i64 8)
%closure_wrapper5101 = bitcast i8* %wrapper_ptr5100 to { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}**
store { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}* %closure5086, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}** %closure_wrapper5101

; let value assignment
%Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0 = select i1 true, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}** %closure_wrapper5101, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}** %closure_wrapper5101
store { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0, { i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0
%tmp_envptr5095 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}***}* %environment5088, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0Ptr, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}**** %tmp_envptr5095


%val5104 = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}**, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}*** %Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0Ptr
ret {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}** %val5104
}


@Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}** @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0(i32 %arg_0,i32 %arg_1,i32 %arg_2,i8* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i8* %arg_3)
ret %Texture* %result
}


define dllexport ccc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i8* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i8* %arg_3)
ret %Texture* %result
}


define dllexport ccc i8*  @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5105 = bitcast [103 x i8]* @gsxtmgl-objects2314 to i8*
call i32 (i8*, ...) @printf(i8* %var5105)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5106 = bitcast [103 x i8]* @gsxtmgl-objects2314 to i8*
call i32 (i8*, ...) @printf(i8* %var5106)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5107 = bitcast [103 x i8]* @gsxtmgl-objects2314 to i8*
call i32 (i8*, ...) @printf(i8* %var5107)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr_or_str(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var5108 = bitcast [103 x i8]* @gsxtmgl-objects2314 to i8*
call i32 (i8*, ...) @printf(i8* %var5108)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i8*  @cptr_value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i8* %arg_3)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i8*}*
%arg_p_0 = getelementptr {i32, i32, i32, i8*}, {i32, i32, i32, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i8*}, {i32, i32, i32, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i8*}, {i32, i32, i32, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i8*}, {i32, i32, i32, i8*}* %fstruct, i32 0, i32 3
%arg_3 = load i8*, i8** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}*, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}, {i8*, i8*, %Texture* (i8*, i8*, i32, i32, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, i32, i32, i32, i8*)*,  %Texture* (i8*, i8*, i32, i32, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i8* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%Shader = type {i32,i32}
@gsxtmgl-objects2315 = hidden constant [37 x i8] c"Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0\00"
@gsxtmgl-objects2316 = hidden constant [45 x i8] c"{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**\00"
define dllexport fastcc %Shader* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0__5109(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5110 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}*
%Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**** %Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr


%tzone5115 = load i8*, i8** %_impzPtr
%zone5116 = bitcast i8* %tzone5115 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Shader*
%tzone5111 = load i8*, i8** %_impzPtr
%zone5112 = bitcast i8* %tzone5111 to %mzone*
%dat5113 = call i8* @llvm_zone_malloc(%mzone* %zone5112, i64 8)
call i8* @memset(i8* %dat5113, i32 0, i64 8)
%val5114 = bitcast i8* %dat5113 to %Shader*

; let value assignment
%obj = select i1 true, %Shader* %val5114, %Shader* %val5114
store %Shader* %obj, %Shader** %objPtr

%val5117 = load %Shader*, %Shader** %objPtr
%val5118 = load i32, i32* %arg_0Ptr
; set tuple
%val5119 = getelementptr %Shader, %Shader* %val5117, i64 0, i32 0
store i32 %val5118, i32* %val5119
%val5120 = load %Shader*, %Shader** %objPtr
%val5121 = load i32, i32* %arg_1Ptr
; set tuple
%val5122 = getelementptr %Shader, %Shader* %val5120, i64 0, i32 1
store i32 %val5121, i32* %val5122
%val5123 = load %Shader*, %Shader** %objPtr
ret %Shader* %val5123
}
@gsxtmgl-objects2317 = hidden constant [90 x i8] c"Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5143 = load i8*, i8** %_impzPtr
%zone5144 = bitcast i8* %tzone5143 to %mzone*

; let assign value to symbol Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0
%dat_Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone5144, i64 8)
%Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr = bitcast i8* %dat_Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***
%tzone5124 = load i8*, i8** %_impzPtr
%zone5125 = bitcast i8* %tzone5124 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5125)
; malloc closure structure
%clsptr5126 = call i8* @llvm_zone_malloc(%mzone* %zone5125, i64 24)
%closure5127 = bitcast i8* %clsptr5126 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr5128 = call i8* @llvm_zone_malloc(%mzone* %zone5125, i64 8)
%environment5129 = bitcast i8* %envptr5128 to {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable5130 = call %clsvar* @new_address_table()
%var5131 = bitcast [37 x i8]* @gsxtmgl-objects2315 to i8*
%var5132 = bitcast [45 x i8]* @gsxtmgl-objects2316 to i8*
%addytable5133 = call %clsvar* @add_address_table(%mzone* %zone5125, i8* %var5131, i32 0, i8* %var5132, i32 3, %clsvar* %addytable5130)
%address-table5134 = bitcast %clsvar* %addytable5133 to i8*

; insert table, function and environment into closure struct
%closure.table5137 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure5127, i32 0, i32 0
store i8* %address-table5134, i8** %closure.table5137
%closure.env5138 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure5127, i32 0, i32 1
store i8* %envptr5128, i8** %closure.env5138
%closure.func5139 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure5127, i32 0, i32 2
store %Shader* (i8*, i8*, i32, i32)* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0__5109, %Shader* (i8*, i8*, i32, i32)** %closure.func5139
%closure_size5140 = call i64 @llvm_zone_mark_size(%mzone* %zone5125)
call void @llvm_zone_ptr_set_size(i8* %clsptr5126, i64 %closure_size5140)
%wrapper_ptr5141 = call i8* @llvm_zone_malloc(%mzone* %zone5125, i64 8)
%closure_wrapper5142 = bitcast i8* %wrapper_ptr5141 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure5127, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper5142

; let value assignment
%Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0 = select i1 true, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper5142, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper5142
store { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0
%tmp_envptr5136 = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}* %environment5129, i32 0, i32 0
store {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**** %tmp_envptr5136


%val5145 = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr
ret {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %val5145
}


@Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc %Shader* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc i8*  @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5146 = bitcast [90 x i8]* @gsxtmgl-objects2317 to i8*
call i32 (i8*, ...) @printf(i8* %var5146)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5147 = bitcast [90 x i8]* @gsxtmgl-objects2317 to i8*
call i32 (i8*, ...) @printf(i8* %var5147)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast %Shader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2318 = hidden constant [39 x i8] c"Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0\00"
define dllexport fastcc %Shader* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0__5148(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5149 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}*
%Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**** %Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr


%tzone5154 = load i8*, i8** %_impzPtr
%zone5155 = bitcast i8* %tzone5154 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Shader*
%tzone5150 = load i8*, i8** %_impzPtr
%zone5151 = bitcast i8* %tzone5150 to %mzone*
%dat5152 = call i8* @llvm_zone_malloc(%mzone* %zone5151, i64 8)
call i8* @memset(i8* %dat5152, i32 0, i64 8)
%val5153 = bitcast i8* %dat5152 to %Shader*

; let value assignment
%obj = select i1 true, %Shader* %val5153, %Shader* %val5153
store %Shader* %obj, %Shader** %objPtr

%val5156 = load %Shader*, %Shader** %objPtr
%val5157 = load i32, i32* %arg_0Ptr
; set tuple
%val5158 = getelementptr %Shader, %Shader* %val5156, i64 0, i32 0
store i32 %val5157, i32* %val5158
%val5159 = load %Shader*, %Shader** %objPtr
%val5160 = load i32, i32* %arg_1Ptr
; set tuple
%val5161 = getelementptr %Shader, %Shader* %val5159, i64 0, i32 1
store i32 %val5160, i32* %val5161
%val5162 = load %Shader*, %Shader** %objPtr
ret %Shader* %val5162
}
@gsxtmgl-objects2319 = hidden constant [92 x i8] c"Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5182 = load i8*, i8** %_impzPtr
%zone5183 = bitcast i8* %tzone5182 to %mzone*

; let assign value to symbol Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0
%dat_Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone5183, i64 8)
%Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr = bitcast i8* %dat_Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***
%tzone5163 = load i8*, i8** %_impzPtr
%zone5164 = bitcast i8* %tzone5163 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5164)
; malloc closure structure
%clsptr5165 = call i8* @llvm_zone_malloc(%mzone* %zone5164, i64 24)
%closure5166 = bitcast i8* %clsptr5165 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr5167 = call i8* @llvm_zone_malloc(%mzone* %zone5164, i64 8)
%environment5168 = bitcast i8* %envptr5167 to {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable5169 = call %clsvar* @new_address_table()
%var5170 = bitcast [39 x i8]* @gsxtmgl-objects2318 to i8*
%var5171 = bitcast [45 x i8]* @gsxtmgl-objects2316 to i8*
%addytable5172 = call %clsvar* @add_address_table(%mzone* %zone5164, i8* %var5170, i32 0, i8* %var5171, i32 3, %clsvar* %addytable5169)
%address-table5173 = bitcast %clsvar* %addytable5172 to i8*

; insert table, function and environment into closure struct
%closure.table5176 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure5166, i32 0, i32 0
store i8* %address-table5173, i8** %closure.table5176
%closure.env5177 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure5166, i32 0, i32 1
store i8* %envptr5167, i8** %closure.env5177
%closure.func5178 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure5166, i32 0, i32 2
store %Shader* (i8*, i8*, i32, i32)* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0__5148, %Shader* (i8*, i8*, i32, i32)** %closure.func5178
%closure_size5179 = call i64 @llvm_zone_mark_size(%mzone* %zone5164)
call void @llvm_zone_ptr_set_size(i8* %clsptr5165, i64 %closure_size5179)
%wrapper_ptr5180 = call i8* @llvm_zone_malloc(%mzone* %zone5164, i64 8)
%closure_wrapper5181 = bitcast i8* %wrapper_ptr5180 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure5166, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper5181

; let value assignment
%Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0 = select i1 true, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper5181, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper5181
store { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0
%tmp_envptr5175 = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}* %environment5168, i32 0, i32 0
store {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**** %tmp_envptr5175


%val5184 = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr
ret {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %val5184
}


@Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc %Shader* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc i8*  @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5185 = bitcast [92 x i8]* @gsxtmgl-objects2319 to i8*
call i32 (i8*, ...) @printf(i8* %var5185)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5186 = bitcast [92 x i8]* @gsxtmgl-objects2319 to i8*
call i32 (i8*, ...) @printf(i8* %var5186)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast %Shader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2320 = hidden constant [39 x i8] c"Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0\00"
define dllexport fastcc %Shader* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0__5187(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5188 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}*
%Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**** %Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr


%tzone5191 = load i8*, i8** %_impzPtr
%zone5192 = bitcast i8* %tzone5191 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Shader*
%dat5189 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat5189, i32 0, i64 8)
%val5190 = bitcast i8* %dat5189 to %Shader*

; let value assignment
%obj = select i1 true, %Shader* %val5190, %Shader* %val5190
store %Shader* %obj, %Shader** %objPtr

%val5193 = load %Shader*, %Shader** %objPtr
%val5194 = load i32, i32* %arg_0Ptr
; set tuple
%val5195 = getelementptr %Shader, %Shader* %val5193, i64 0, i32 0
store i32 %val5194, i32* %val5195
%val5196 = load %Shader*, %Shader** %objPtr
%val5197 = load i32, i32* %arg_1Ptr
; set tuple
%val5198 = getelementptr %Shader, %Shader* %val5196, i64 0, i32 1
store i32 %val5197, i32* %val5198
%val5199 = load %Shader*, %Shader** %objPtr
ret %Shader* %val5199
}
@gsxtmgl-objects2321 = hidden constant [92 x i8] c"Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5219 = load i8*, i8** %_impzPtr
%zone5220 = bitcast i8* %tzone5219 to %mzone*

; let assign value to symbol Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0
%dat_Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone5220, i64 8)
%Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr = bitcast i8* %dat_Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***
%tzone5200 = load i8*, i8** %_impzPtr
%zone5201 = bitcast i8* %tzone5200 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5201)
; malloc closure structure
%clsptr5202 = call i8* @llvm_zone_malloc(%mzone* %zone5201, i64 24)
%closure5203 = bitcast i8* %clsptr5202 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr5204 = call i8* @llvm_zone_malloc(%mzone* %zone5201, i64 8)
%environment5205 = bitcast i8* %envptr5204 to {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable5206 = call %clsvar* @new_address_table()
%var5207 = bitcast [39 x i8]* @gsxtmgl-objects2320 to i8*
%var5208 = bitcast [45 x i8]* @gsxtmgl-objects2316 to i8*
%addytable5209 = call %clsvar* @add_address_table(%mzone* %zone5201, i8* %var5207, i32 0, i8* %var5208, i32 3, %clsvar* %addytable5206)
%address-table5210 = bitcast %clsvar* %addytable5209 to i8*

; insert table, function and environment into closure struct
%closure.table5213 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure5203, i32 0, i32 0
store i8* %address-table5210, i8** %closure.table5213
%closure.env5214 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure5203, i32 0, i32 1
store i8* %envptr5204, i8** %closure.env5214
%closure.func5215 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure5203, i32 0, i32 2
store %Shader* (i8*, i8*, i32, i32)* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0__5187, %Shader* (i8*, i8*, i32, i32)** %closure.func5215
%closure_size5216 = call i64 @llvm_zone_mark_size(%mzone* %zone5201)
call void @llvm_zone_ptr_set_size(i8* %clsptr5202, i64 %closure_size5216)
%wrapper_ptr5217 = call i8* @llvm_zone_malloc(%mzone* %zone5201, i64 8)
%closure_wrapper5218 = bitcast i8* %wrapper_ptr5217 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure5203, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper5218

; let value assignment
%Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0 = select i1 true, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper5218, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper5218
store { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0
%tmp_envptr5212 = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}* %environment5205, i32 0, i32 0
store {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**** %tmp_envptr5212


%val5221 = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr
ret {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %val5221
}


@Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc %Shader* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc i8*  @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5222 = bitcast [92 x i8]* @gsxtmgl-objects2321 to i8*
call i32 (i8*, ...) @printf(i8* %var5222)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5223 = bitcast [92 x i8]* @gsxtmgl-objects2321 to i8*
call i32 (i8*, ...) @printf(i8* %var5223)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast %Shader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2322 = hidden constant [40 x i8] c"Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ\00"
@gsxtmgl-objects2323 = hidden constant [44 x i8] c"{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**\00"
define dllexport fastcc %Shader @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ__5224(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5225 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***}*
%Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr = load {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**** %Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr


%tzone5227 = load i8*, i8** %_impzPtr
%zone5228 = bitcast i8* %tzone5227 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Shader*
%dat5226 = alloca %Shader, align 16

; let value assignment
%obj = select i1 true, %Shader* %dat5226, %Shader* %dat5226
store %Shader* %obj, %Shader** %objPtr

%val5229 = load %Shader*, %Shader** %objPtr
%val5230 = load i32, i32* %arg_0Ptr
; set tuple
%val5231 = getelementptr %Shader, %Shader* %val5229, i64 0, i32 0
store i32 %val5230, i32* %val5231
%val5232 = load %Shader*, %Shader** %objPtr
%val5233 = load i32, i32* %arg_1Ptr
; set tuple
%val5234 = getelementptr %Shader, %Shader* %val5232, i64 0, i32 1
store i32 %val5233, i32* %val5234
%val5235 = load %Shader*, %Shader** %objPtr
; pointer ref
%val5236 = getelementptr %Shader, %Shader* %val5235, i64 0
%val5237 = load %Shader, %Shader* %val5236
ret %Shader %val5237
}
@gsxtmgl-objects2324 = hidden constant [93 x i8] c"Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5257 = load i8*, i8** %_impzPtr
%zone5258 = bitcast i8* %tzone5257 to %mzone*

; let assign value to symbol Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ
%dat_Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone5258, i64 8)
%Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr = bitcast i8* %dat_Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ to { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***
%tzone5238 = load i8*, i8** %_impzPtr
%zone5239 = bitcast i8* %tzone5238 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5239)
; malloc closure structure
%clsptr5240 = call i8* @llvm_zone_malloc(%mzone* %zone5239, i64 24)
%closure5241 = bitcast i8* %clsptr5240 to { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr5242 = call i8* @llvm_zone_malloc(%mzone* %zone5239, i64 8)
%environment5243 = bitcast i8* %envptr5242 to {{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable5244 = call %clsvar* @new_address_table()
%var5245 = bitcast [40 x i8]* @gsxtmgl-objects2322 to i8*
%var5246 = bitcast [44 x i8]* @gsxtmgl-objects2323 to i8*
%addytable5247 = call %clsvar* @add_address_table(%mzone* %zone5239, i8* %var5245, i32 0, i8* %var5246, i32 3, %clsvar* %addytable5244)
%address-table5248 = bitcast %clsvar* %addytable5247 to i8*

; insert table, function and environment into closure struct
%closure.table5251 = getelementptr { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure5241, i32 0, i32 0
store i8* %address-table5248, i8** %closure.table5251
%closure.env5252 = getelementptr { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure5241, i32 0, i32 1
store i8* %envptr5242, i8** %closure.env5252
%closure.func5253 = getelementptr { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure5241, i32 0, i32 2
store %Shader (i8*, i8*, i32, i32)* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ__5224, %Shader (i8*, i8*, i32, i32)** %closure.func5253
%closure_size5254 = call i64 @llvm_zone_mark_size(%mzone* %zone5239)
call void @llvm_zone_ptr_set_size(i8* %clsptr5240, i64 %closure_size5254)
%wrapper_ptr5255 = call i8* @llvm_zone_malloc(%mzone* %zone5239, i64 8)
%closure_wrapper5256 = bitcast i8* %wrapper_ptr5255 to { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**
store { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure5241, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure_wrapper5256

; let value assignment
%Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ = select i1 true, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure_wrapper5256, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure_wrapper5256
store { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*** %Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ
%tmp_envptr5250 = getelementptr {{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***}* %environment5243, i32 0, i32 0
store {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*** %Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**** %tmp_envptr5250


%val5259 = load {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*** %Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr
ret {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %val5259
}


@Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader (i8*, i8*, i32, i32)*,  %Shader (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader %result
}


define dllexport ccc %Shader @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader (i8*, i8*, i32, i32)*,  %Shader (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader %result
}


define dllexport ccc void @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader (i8*, i8*, i32, i32)*,  %Shader (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2325 = hidden constant [36 x i8] c"hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0\00"
@gsxtmgl-objects2326 = hidden constant [45 x i8] c"{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**\00"
define dllexport fastcc %Shader* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0__5262(i8* %_impz,i8* %_impenv, %Shader* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5263 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***}*
%hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr_ = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**** %hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr_

; setup arguments
%xPtr = alloca %Shader*
store %Shader* %x, %Shader** %xPtr


%tzone5266 = load i8*, i8** %_impzPtr
%zone5267 = bitcast i8* %tzone5266 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Shader*
%dat5264 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat5264, i32 0, i64 8)
%val5265 = bitcast i8* %dat5264 to %Shader*

; let value assignment
%obj = select i1 true, %Shader* %val5265, %Shader* %val5265
store %Shader* %obj, %Shader** %objPtr

%val5268 = load %Shader*, %Shader** %objPtr
%val5269 = load %Shader*, %Shader** %xPtr
; tuple ref
%val5270 = getelementptr %Shader, %Shader* %val5269, i64 0, i32 0
%val5271 = load i32, i32* %val5270
; set tuple
%val5272 = getelementptr %Shader, %Shader* %val5268, i64 0, i32 0
store i32 %val5271, i32* %val5272
%val5273 = load %Shader*, %Shader** %objPtr
%val5274 = load %Shader*, %Shader** %xPtr
; tuple ref
%val5275 = getelementptr %Shader, %Shader* %val5274, i64 0, i32 1
%val5276 = load i32, i32* %val5275
; set tuple
%val5277 = getelementptr %Shader, %Shader* %val5273, i64 0, i32 1
store i32 %val5276, i32* %val5277
%val5278 = load %Shader*, %Shader** %objPtr
ret %Shader* %val5278
}
@gsxtmgl-objects2327 = hidden constant [89 x i8] c"hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5298 = load i8*, i8** %_impzPtr
%zone5299 = bitcast i8* %tzone5298 to %mzone*

; let assign value to symbol hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0
%dat_hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0 = call i8* @llvm_zone_malloc(%mzone* %zone5299, i64 8)
%hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0 to { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***
%tzone5279 = load i8*, i8** %_impzPtr
%zone5280 = bitcast i8* %tzone5279 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5280)
; malloc closure structure
%clsptr5281 = call i8* @llvm_zone_malloc(%mzone* %zone5280, i64 24)
%closure5282 = bitcast i8* %clsptr5281 to { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*

; malloc environment structure
%envptr5283 = call i8* @llvm_zone_malloc(%mzone* %zone5280, i64 8)
%environment5284 = bitcast i8* %envptr5283 to {{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***}*

; malloc closure address table
%addytable5285 = call %clsvar* @new_address_table()
%var5286 = bitcast [36 x i8]* @gsxtmgl-objects2325 to i8*
%var5287 = bitcast [45 x i8]* @gsxtmgl-objects2326 to i8*
%addytable5288 = call %clsvar* @add_address_table(%mzone* %zone5280, i8* %var5286, i32 0, i8* %var5287, i32 3, %clsvar* %addytable5285)
%address-table5289 = bitcast %clsvar* %addytable5288 to i8*

; insert table, function and environment into closure struct
%closure.table5292 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure5282, i32 0, i32 0
store i8* %address-table5289, i8** %closure.table5292
%closure.env5293 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure5282, i32 0, i32 1
store i8* %envptr5283, i8** %closure.env5293
%closure.func5294 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure5282, i32 0, i32 2
store %Shader* (i8*, i8*, %Shader*)* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0__5262, %Shader* (i8*, i8*, %Shader*)** %closure.func5294
%closure_size5295 = call i64 @llvm_zone_mark_size(%mzone* %zone5280)
call void @llvm_zone_ptr_set_size(i8* %clsptr5281, i64 %closure_size5295)
%wrapper_ptr5296 = call i8* @llvm_zone_malloc(%mzone* %zone5280, i64 8)
%closure_wrapper5297 = bitcast i8* %wrapper_ptr5296 to { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**
store { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure5282, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_wrapper5297

; let value assignment
%hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0 = select i1 true, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_wrapper5297, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_wrapper5297
store { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*** %hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0
%tmp_envptr5291 = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***}* %environment5284, i32 0, i32 0
store {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*** %hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**** %tmp_envptr5291


%val5300 = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*** %hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr
ret {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %val5300
}


@hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*)*,  %Shader* (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret %Shader* %result
}


define dllexport ccc %Shader* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_native(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*)*,  %Shader* (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret %Shader* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5301 = bitcast [89 x i8]* @gsxtmgl-objects2327 to i8*
call i32 (i8*, ...) @printf(i8* %var5301)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*)*,  %Shader* (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%tmpres = bitcast %Shader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*}*
%arg_p_0 = getelementptr {%Shader*}, {%Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*)*,  %Shader* (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2328 = hidden constant [32 x i8] c"hfree_adhoc_W3ZvaWQsU2hhZGVyKl0\00"
@gsxtmgl-objects2329 = hidden constant [41 x i8] c"{i8*, i8*, void (i8*, i8*, %Shader*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0__5302(i8* %_impz,i8* %_impenv, %Shader* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5303 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}*
%hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr = load {i8*, i8*, void (i8*, i8*, %Shader*)*}***, {i8*, i8*, void (i8*, i8*, %Shader*)*}**** %hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr_

; setup arguments
%xPtr = alloca %Shader*
store %Shader* %x, %Shader** %xPtr


%val5304 = load %Shader*, %Shader** %xPtr
%val5305 = bitcast %Shader* %val5304 to i8*
call ccc void @free(i8* %val5305)
ret void
}
@gsxtmgl-objects2330 = hidden constant [85 x i8] c"hfree_adhoc_W3ZvaWQsU2hhZGVyKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Shader*)*}** @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5327 = load i8*, i8** %_impzPtr
%zone5328 = bitcast i8* %tzone5327 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU2hhZGVyKl0
%dat_hfree_adhoc_W3ZvaWQsU2hhZGVyKl0 = call i8* @llvm_zone_malloc(%mzone* %zone5328, i64 8)
%hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU2hhZGVyKl0 to { i8*, i8*, void (i8*, i8*, %Shader*)*}***
%tzone5308 = load i8*, i8** %_impzPtr
%zone5309 = bitcast i8* %tzone5308 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5309)
; malloc closure structure
%clsptr5310 = call i8* @llvm_zone_malloc(%mzone* %zone5309, i64 24)
%closure5311 = bitcast i8* %clsptr5310 to { i8*, i8*, void (i8*, i8*, %Shader*)*}*

; malloc environment structure
%envptr5312 = call i8* @llvm_zone_malloc(%mzone* %zone5309, i64 8)
%environment5313 = bitcast i8* %envptr5312 to {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}*

; malloc closure address table
%addytable5314 = call %clsvar* @new_address_table()
%var5315 = bitcast [32 x i8]* @gsxtmgl-objects2328 to i8*
%var5316 = bitcast [41 x i8]* @gsxtmgl-objects2329 to i8*
%addytable5317 = call %clsvar* @add_address_table(%mzone* %zone5309, i8* %var5315, i32 0, i8* %var5316, i32 3, %clsvar* %addytable5314)
%address-table5318 = bitcast %clsvar* %addytable5317 to i8*

; insert table, function and environment into closure struct
%closure.table5321 = getelementptr { i8*, i8*, void (i8*, i8*, %Shader*)*}, { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure5311, i32 0, i32 0
store i8* %address-table5318, i8** %closure.table5321
%closure.env5322 = getelementptr { i8*, i8*, void (i8*, i8*, %Shader*)*}, { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure5311, i32 0, i32 1
store i8* %envptr5312, i8** %closure.env5322
%closure.func5323 = getelementptr { i8*, i8*, void (i8*, i8*, %Shader*)*}, { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure5311, i32 0, i32 2
store void (i8*, i8*, %Shader*)* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0__5302, void (i8*, i8*, %Shader*)** %closure.func5323
%closure_size5324 = call i64 @llvm_zone_mark_size(%mzone* %zone5309)
call void @llvm_zone_ptr_set_size(i8* %clsptr5310, i64 %closure_size5324)
%wrapper_ptr5325 = call i8* @llvm_zone_malloc(%mzone* %zone5309, i64 8)
%closure_wrapper5326 = bitcast i8* %wrapper_ptr5325 to { i8*, i8*, void (i8*, i8*, %Shader*)*}**
store { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure5311, { i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_wrapper5326

; let value assignment
%hfree_adhoc_W3ZvaWQsU2hhZGVyKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_wrapper5326, { i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_wrapper5326
store { i8*, i8*, void (i8*, i8*, %Shader*)*}** %hfree_adhoc_W3ZvaWQsU2hhZGVyKl0, { i8*, i8*, void (i8*, i8*, %Shader*)*}*** %hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU2hhZGVyKl0
%tmp_envptr5320 = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %environment5313, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Shader*)*}*** %hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr, {i8*, i8*, void (i8*, i8*, %Shader*)*}**** %tmp_envptr5320


%val5329 = load {i8*, i8*, void (i8*, i8*, %Shader*)*}**, {i8*, i8*, void (i8*, i8*, %Shader*)*}*** %hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %Shader*)*}** %val5329
}


@hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Shader*)*}** @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_native(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5330 = bitcast [85 x i8]* @gsxtmgl-objects2330 to i8*
call i32 (i8*, ...) @printf(i8* %var5330)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*}*
%arg_p_0 = getelementptr {%Shader*}, {%Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2331 = hidden constant [55 x i8] c"zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmgl-objects2332 = hidden constant [63 x i8] c"{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %Shader* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ__5331(i8* %_impz,i8* %_impenv, %Shader* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5332 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %Shader*
store %Shader* %x, %Shader** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val5334 = load %mzone*, %mzone** %fromzPtr
%val5335 = load %Shader*, %Shader** %xPtr
%val5336 = bitcast %Shader* %val5335 to i8*
%res5337 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val5334, i8* %val5336)
br i1 %res5337, label %then5333, label %else5333

then5333:
%val5338 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val5338)
%zone_ptr5339 = bitcast %mzone* %val5338 to i8*
store i8* %zone_ptr5339, i8** %_impzPtr
%tzone5345 = load i8*, i8** %_impzPtr
%zone5346 = bitcast i8* %tzone5345 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Shader*
%tzone5341 = load i8*, i8** %_impzPtr
%zone5342 = bitcast i8* %tzone5341 to %mzone*
%dat5343 = call i8* @llvm_zone_malloc(%mzone* %zone5342, i64 8)
call i8* @memset(i8* %dat5343, i32 0, i64 8)
%val5344 = bitcast i8* %dat5343 to %Shader*

; let value assignment
%obj = select i1 true, %Shader* %val5344, %Shader* %val5344
store %Shader* %obj, %Shader** %objPtr

%val5347 = load %Shader*, %Shader** %objPtr
%val5348 = load %Shader*, %Shader** %xPtr
; tuple ref
%val5349 = getelementptr %Shader, %Shader* %val5348, i64 0, i32 0
%val5350 = load i32, i32* %val5349
; set tuple
%val5351 = getelementptr %Shader, %Shader* %val5347, i64 0, i32 0
store i32 %val5350, i32* %val5351
%val5352 = load %Shader*, %Shader** %objPtr
%val5353 = load %Shader*, %Shader** %xPtr
; tuple ref
%val5354 = getelementptr %Shader, %Shader* %val5353, i64 0, i32 1
%val5355 = load i32, i32* %val5354
; set tuple
%val5356 = getelementptr %Shader, %Shader* %val5352, i64 0, i32 1
store i32 %val5355, i32* %val5356
%oldzone5357 = call %mzone* @llvm_pop_zone_stack()
%newzone5358 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr5359 = bitcast %mzone* %newzone5358 to i8*
store i8* %zone_ptr5359, i8** %_impzPtr
%val5360 = load %Shader*, %Shader** %objPtr
ret %Shader* %val5360

else5333:
%val5361 = load %Shader*, %Shader** %xPtr
ret %Shader* %val5361
}
@gsxtmgl-objects2333 = hidden constant [108 x i8] c"zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5381 = load i8*, i8** %_impzPtr
%zone5382 = bitcast i8* %tzone5381 to %mzone*

; let assign value to symbol zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone5382, i64 8)
%zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***
%tzone5362 = load i8*, i8** %_impzPtr
%zone5363 = bitcast i8* %tzone5362 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5363)
; malloc closure structure
%clsptr5364 = call i8* @llvm_zone_malloc(%mzone* %zone5363, i64 24)
%closure5365 = bitcast i8* %clsptr5364 to { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr5366 = call i8* @llvm_zone_malloc(%mzone* %zone5363, i64 8)
%environment5367 = bitcast i8* %envptr5366 to {{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable5368 = call %clsvar* @new_address_table()
%var5369 = bitcast [55 x i8]* @gsxtmgl-objects2331 to i8*
%var5370 = bitcast [63 x i8]* @gsxtmgl-objects2332 to i8*
%addytable5371 = call %clsvar* @add_address_table(%mzone* %zone5363, i8* %var5369, i32 0, i8* %var5370, i32 3, %clsvar* %addytable5368)
%address-table5372 = bitcast %clsvar* %addytable5371 to i8*

; insert table, function and environment into closure struct
%closure.table5375 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure5365, i32 0, i32 0
store i8* %address-table5372, i8** %closure.table5375
%closure.env5376 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure5365, i32 0, i32 1
store i8* %envptr5366, i8** %closure.env5376
%closure.func5377 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure5365, i32 0, i32 2
store %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ__5331, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)** %closure.func5377
%closure_size5378 = call i64 @llvm_zone_mark_size(%mzone* %zone5363)
call void @llvm_zone_ptr_set_size(i8* %clsptr5364, i64 %closure_size5378)
%wrapper_ptr5379 = call i8* @llvm_zone_malloc(%mzone* %zone5363, i64 8)
%closure_wrapper5380 = bitcast i8* %wrapper_ptr5379 to { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**
store { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure5365, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_wrapper5380

; let value assignment
%zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_wrapper5380, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_wrapper5380
store { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ
%tmp_envptr5374 = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***}* %environment5367, i32 0, i32 0
store {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**** %tmp_envptr5374


%val5383 = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %val5383
}


@zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ(%Shader* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*,  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Shader* %result
}


define dllexport ccc %Shader* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_native(%Shader* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*,  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Shader* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5384 = bitcast [108 x i8]* @gsxtmgl-objects2333 to i8*
call i32 (i8*, ...) @printf(i8* %var5384)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5385 = bitcast [108 x i8]* @gsxtmgl-objects2333 to i8*
call i32 (i8*, ...) @printf(i8* %var5385)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5386 = bitcast [108 x i8]* @gsxtmgl-objects2333 to i8*
call i32 (i8*, ...) @printf(i8* %var5386)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*,  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %Shader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%Shader*, %mzone*, %mzone*}, {%Shader*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
%arg_p_1 = getelementptr {%Shader*, %mzone*, %mzone*}, {%Shader*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%Shader*, %mzone*, %mzone*}, {%Shader*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*,  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2334 = hidden constant [28 x i8] c"id_adhoc_W2kzMixTaGFkZXIqXQ\00"
@gsxtmgl-objects2335 = hidden constant [40 x i8] c"{i8*, i8*, i32 (i8*, i8*, %Shader*)*}**\00"
define dllexport fastcc i32 @id_adhoc_W2kzMixTaGFkZXIqXQ__5387(i8* %_impz,i8* %_impenv, %Shader* %shader) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5388 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}*
%id_adhoc_W2kzMixTaGFkZXIqXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 0
%id_adhoc_W2kzMixTaGFkZXIqXQPtr = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}***, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**** %id_adhoc_W2kzMixTaGFkZXIqXQPtr_

; setup arguments
%shaderPtr = alloca %Shader*
store %Shader* %shader, %Shader** %shaderPtr


%val5389 = load %Shader*, %Shader** %shaderPtr
; tuple ref
%val5390 = getelementptr %Shader, %Shader* %val5389, i64 0, i32 0
%val5391 = load i32, i32* %val5390
ret i32 %val5391
}
@gsxtmgl-objects2336 = hidden constant [81 x i8] c"id_adhoc_W2kzMixTaGFkZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** @id_adhoc_W2kzMixTaGFkZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5411 = load i8*, i8** %_impzPtr
%zone5412 = bitcast i8* %tzone5411 to %mzone*

; let assign value to symbol id_adhoc_W2kzMixTaGFkZXIqXQ
%dat_id_adhoc_W2kzMixTaGFkZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone5412, i64 8)
%id_adhoc_W2kzMixTaGFkZXIqXQPtr = bitcast i8* %dat_id_adhoc_W2kzMixTaGFkZXIqXQ to { i8*, i8*, i32 (i8*, i8*, %Shader*)*}***
%tzone5392 = load i8*, i8** %_impzPtr
%zone5393 = bitcast i8* %tzone5392 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5393)
; malloc closure structure
%clsptr5394 = call i8* @llvm_zone_malloc(%mzone* %zone5393, i64 24)
%closure5395 = bitcast i8* %clsptr5394 to { i8*, i8*, i32 (i8*, i8*, %Shader*)*}*

; malloc environment structure
%envptr5396 = call i8* @llvm_zone_malloc(%mzone* %zone5393, i64 8)
%environment5397 = bitcast i8* %envptr5396 to {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}*

; malloc closure address table
%addytable5398 = call %clsvar* @new_address_table()
%var5399 = bitcast [28 x i8]* @gsxtmgl-objects2334 to i8*
%var5400 = bitcast [40 x i8]* @gsxtmgl-objects2335 to i8*
%addytable5401 = call %clsvar* @add_address_table(%mzone* %zone5393, i8* %var5399, i32 0, i8* %var5400, i32 3, %clsvar* %addytable5398)
%address-table5402 = bitcast %clsvar* %addytable5401 to i8*

; insert table, function and environment into closure struct
%closure.table5405 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure5395, i32 0, i32 0
store i8* %address-table5402, i8** %closure.table5405
%closure.env5406 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure5395, i32 0, i32 1
store i8* %envptr5396, i8** %closure.env5406
%closure.func5407 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure5395, i32 0, i32 2
store i32 (i8*, i8*, %Shader*)* @id_adhoc_W2kzMixTaGFkZXIqXQ__5387, i32 (i8*, i8*, %Shader*)** %closure.func5407
%closure_size5408 = call i64 @llvm_zone_mark_size(%mzone* %zone5393)
call void @llvm_zone_ptr_set_size(i8* %clsptr5394, i64 %closure_size5408)
%wrapper_ptr5409 = call i8* @llvm_zone_malloc(%mzone* %zone5393, i64 8)
%closure_wrapper5410 = bitcast i8* %wrapper_ptr5409 to { i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
store { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure5395, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_wrapper5410

; let value assignment
%id_adhoc_W2kzMixTaGFkZXIqXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_wrapper5410, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_wrapper5410
store { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %id_adhoc_W2kzMixTaGFkZXIqXQ, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}*** %id_adhoc_W2kzMixTaGFkZXIqXQPtr

; add data to environment
; don't need to alloc for env var id_adhoc_W2kzMixTaGFkZXIqXQ
%tmp_envptr5404 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}* %environment5397, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*** %id_adhoc_W2kzMixTaGFkZXIqXQPtr, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**** %tmp_envptr5404


%val5413 = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*** %id_adhoc_W2kzMixTaGFkZXIqXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %val5413
}


@id_adhoc_W2kzMixTaGFkZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@id_adhoc_W2kzMixTaGFkZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @id_adhoc_W2kzMixTaGFkZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** @id_adhoc_W2kzMixTaGFkZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @id_adhoc_W2kzMixTaGFkZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @id_adhoc_W2kzMixTaGFkZXIqXQ_native(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @id_adhoc_W2kzMixTaGFkZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5414 = bitcast [81 x i8]* @gsxtmgl-objects2336 to i8*
call i32 (i8*, ...) @printf(i8* %var5414)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @id_adhoc_W2kzMixTaGFkZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*}*
%arg_p_0 = getelementptr {%Shader*}, {%Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2337 = hidden constant [30 x i8] c"type_adhoc_W2kzMixTaGFkZXIqXQ\00"
define dllexport fastcc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ__5415(i8* %_impz,i8* %_impenv, %Shader* %shader) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5416 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}*
%type_adhoc_W2kzMixTaGFkZXIqXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 0
%type_adhoc_W2kzMixTaGFkZXIqXQPtr = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}***, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**** %type_adhoc_W2kzMixTaGFkZXIqXQPtr_

; setup arguments
%shaderPtr = alloca %Shader*
store %Shader* %shader, %Shader** %shaderPtr


%val5417 = load %Shader*, %Shader** %shaderPtr
; tuple ref
%val5418 = getelementptr %Shader, %Shader* %val5417, i64 0, i32 1
%val5419 = load i32, i32* %val5418
ret i32 %val5419
}
@gsxtmgl-objects2338 = hidden constant [83 x i8] c"type_adhoc_W2kzMixTaGFkZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** @type_adhoc_W2kzMixTaGFkZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5439 = load i8*, i8** %_impzPtr
%zone5440 = bitcast i8* %tzone5439 to %mzone*

; let assign value to symbol type_adhoc_W2kzMixTaGFkZXIqXQ
%dat_type_adhoc_W2kzMixTaGFkZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone5440, i64 8)
%type_adhoc_W2kzMixTaGFkZXIqXQPtr = bitcast i8* %dat_type_adhoc_W2kzMixTaGFkZXIqXQ to { i8*, i8*, i32 (i8*, i8*, %Shader*)*}***
%tzone5420 = load i8*, i8** %_impzPtr
%zone5421 = bitcast i8* %tzone5420 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5421)
; malloc closure structure
%clsptr5422 = call i8* @llvm_zone_malloc(%mzone* %zone5421, i64 24)
%closure5423 = bitcast i8* %clsptr5422 to { i8*, i8*, i32 (i8*, i8*, %Shader*)*}*

; malloc environment structure
%envptr5424 = call i8* @llvm_zone_malloc(%mzone* %zone5421, i64 8)
%environment5425 = bitcast i8* %envptr5424 to {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}*

; malloc closure address table
%addytable5426 = call %clsvar* @new_address_table()
%var5427 = bitcast [30 x i8]* @gsxtmgl-objects2337 to i8*
%var5428 = bitcast [40 x i8]* @gsxtmgl-objects2335 to i8*
%addytable5429 = call %clsvar* @add_address_table(%mzone* %zone5421, i8* %var5427, i32 0, i8* %var5428, i32 3, %clsvar* %addytable5426)
%address-table5430 = bitcast %clsvar* %addytable5429 to i8*

; insert table, function and environment into closure struct
%closure.table5433 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure5423, i32 0, i32 0
store i8* %address-table5430, i8** %closure.table5433
%closure.env5434 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure5423, i32 0, i32 1
store i8* %envptr5424, i8** %closure.env5434
%closure.func5435 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure5423, i32 0, i32 2
store i32 (i8*, i8*, %Shader*)* @type_adhoc_W2kzMixTaGFkZXIqXQ__5415, i32 (i8*, i8*, %Shader*)** %closure.func5435
%closure_size5436 = call i64 @llvm_zone_mark_size(%mzone* %zone5421)
call void @llvm_zone_ptr_set_size(i8* %clsptr5422, i64 %closure_size5436)
%wrapper_ptr5437 = call i8* @llvm_zone_malloc(%mzone* %zone5421, i64 8)
%closure_wrapper5438 = bitcast i8* %wrapper_ptr5437 to { i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
store { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure5423, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_wrapper5438

; let value assignment
%type_adhoc_W2kzMixTaGFkZXIqXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_wrapper5438, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_wrapper5438
store { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %type_adhoc_W2kzMixTaGFkZXIqXQ, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}*** %type_adhoc_W2kzMixTaGFkZXIqXQPtr

; add data to environment
; don't need to alloc for env var type_adhoc_W2kzMixTaGFkZXIqXQ
%tmp_envptr5432 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}* %environment5425, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*** %type_adhoc_W2kzMixTaGFkZXIqXQPtr, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**** %tmp_envptr5432


%val5441 = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*** %type_adhoc_W2kzMixTaGFkZXIqXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %val5441
}


@type_adhoc_W2kzMixTaGFkZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@type_adhoc_W2kzMixTaGFkZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @type_adhoc_W2kzMixTaGFkZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixTaGFkZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** @type_adhoc_W2kzMixTaGFkZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @type_adhoc_W2kzMixTaGFkZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @type_adhoc_W2kzMixTaGFkZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ_native(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @type_adhoc_W2kzMixTaGFkZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5442 = bitcast [83 x i8]* @gsxtmgl-objects2338 to i8*
call i32 (i8*, ...) @printf(i8* %var5442)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @type_adhoc_W2kzMixTaGFkZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*}*
%arg_p_0 = getelementptr {%Shader*}, {%Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @type_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2339 = hidden constant [13 x i8] c"NULL SHADER!\00"
@gsxtmgl-objects2340 = hidden constant [14 x i8] c"%sShader: %s
\00"
@gsxtmgl-objects2341 = hidden constant [5 x i8] c"Vert\00"
@gsxtmgl-objects2342 = hidden constant [5 x i8] c"Frag\00"
@gsxtmgl-objects2343 = hidden constant [5 x i8] c"Geom\00"
@gsxtmgl-objects2344 = hidden constant [1 x i8] c"\00"
@gsxtmgl-objects2345 = hidden constant [3 x i8] c"OK\00"
@gsxtmgl-objects2346 = hidden constant [32 x i8] c"print_adhoc_W3ZvaWQsU2hhZGVyKl0\00"
@gsxtmgl-objects2347 = hidden constant [7 x i8] c"logbuf\00"
@gsxtmgl-objects2348 = hidden constant [4 x i8] c"i8*\00"
@gsxtmgl-objects2349 = hidden constant [15 x i8] c"max_log_length\00"
@gsxtmgl-objects2350 = hidden constant [15 x i8] c"_anon_lambda_2\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU2hhZGVyKl0__5443(i8* %_impz,i8* %_impenv, %Shader* %shader) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5456 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}*
%print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr = load {i8*, i8*, void (i8*, i8*, %Shader*)*}***, {i8*, i8*, void (i8*, i8*, %Shader*)*}**** %print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr_
%logbufPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 1
%logbufPtr = load i8**, i8*** %logbufPtr_
%max_log_lengthPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 2
%max_log_lengthPtr = load i32*, i32** %max_log_lengthPtr_
%_anon_lambda_2Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 3
%_anon_lambda_2Ptr = load {i8*, i8*, void (i8*, i8*, %Shader*)*}***, {i8*, i8*, void (i8*, i8*, %Shader*)*}**** %_anon_lambda_2Ptr_

; setup arguments
%shaderPtr = alloca %Shader*
store %Shader* %shader, %Shader** %shaderPtr


%val5458 = load %Shader*, %Shader** %shaderPtr
%val5459 = icmp eq %Shader* %val5458, null
br i1 %val5459, label %then5457, label %else5457

then5457:
%var5460 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var5461 = bitcast [13 x i8]* @gsxtmgl-objects2339 to i8*

%val5462 = call i32 (i8*, ...) @printf(i8* %var5460, i8* %var5461)
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret void

else5457:
%tzone5466 = load i8*, i8** %_impzPtr
%zone5467 = bitcast i8* %tzone5466 to %mzone*

; let assign value to symbol len_ptr
%len_ptrPtr = alloca i32*
%dat5465 = alloca i32, i64 1, align 16

; let value assignment
%len_ptr = select i1 true, i32* %dat5465, i32* %dat5465
store i32* %len_ptr, i32** %len_ptrPtr

; promote local stack var allocations
%tzone5513 = load i8*, i8** %_impzPtr
%zone5514 = bitcast i8* %tzone5513 to %mzone*
%ifptr5506 = alloca i64
%ifptr5497 = alloca i8*
%ifptr5475 = alloca i8*
%ifptr5481 = alloca i8*
%ifptr5487 = alloca i8*
%val5468 = load %Shader*, %Shader** %shaderPtr
%res5469 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val5468)
%val5470 = load i32, i32* %max_log_lengthPtr
%val5471 = load i32*, i32** %len_ptrPtr
%val5472 = load i8*, i8** %logbufPtr
call fastcc void @glGetShaderInfoLog_adhoc_W3ZvaWQsaTMyLGkzMixpMzIqLGk4Kl0(i32 %res5469, i32 %val5470, i32* %val5471, i8* %val5472)
%var5474 = bitcast [14 x i8]* @gsxtmgl-objects2340 to i8*
%val5476 = load %Shader*, %Shader** %shaderPtr
%res5477 = call fastcc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val5476)
%val5478 = load i32, i32* @GL_VERTEX_SHADER
%cmp5479 = icmp eq i32 %res5477, %val5478
br i1 %cmp5479, label %then5475, label %else5475

then5475:
%var5480 = bitcast [5 x i8]* @gsxtmgl-objects2341 to i8*
store i8* %var5480, i8** %ifptr5475
br label %ifcont5475

else5475:
%val5482 = load %Shader*, %Shader** %shaderPtr
%res5483 = call fastcc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val5482)
%val5484 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp5485 = icmp eq i32 %res5483, %val5484
br i1 %cmp5485, label %then5481, label %else5481

then5481:
%var5486 = bitcast [5 x i8]* @gsxtmgl-objects2342 to i8*
store i8* %var5486, i8** %ifptr5481
br label %ifcont5481

else5481:
%val5488 = load %Shader*, %Shader** %shaderPtr
%res5489 = call fastcc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val5488)
%val5490 = load i32, i32* @GL_GEOMETRY_SHADER
%cmp5491 = icmp eq i32 %res5489, %val5490
br i1 %cmp5491, label %then5487, label %else5487

then5487:
%var5492 = bitcast [5 x i8]* @gsxtmgl-objects2343 to i8*
store i8* %var5492, i8** %ifptr5487
br label %ifcont5487

else5487:
%var5493 = bitcast [1 x i8]* @gsxtmgl-objects2344 to i8*
store i8* %var5493, i8** %ifptr5487
br label %ifcont5487

ifcont5487:
%ifres5494 = load i8*, i8** %ifptr5487

store i8* %ifres5494, i8** %ifptr5481
br label %ifcont5481

ifcont5481:
%ifres5495 = load i8*, i8** %ifptr5481

store i8* %ifres5495, i8** %ifptr5475
br label %ifcont5475

ifcont5475:
%ifres5496 = load i8*, i8** %ifptr5475

%val5498 = load i32*, i32** %len_ptrPtr
; pointer ref
%val5499 = getelementptr i32, i32* %val5498, i64 0
%val5500 = load i32, i32* %val5499
%cmp5501 = icmp eq i32 %val5500, 0
br i1 %cmp5501, label %then5497, label %else5497

then5497:
%var5502 = bitcast [3 x i8]* @gsxtmgl-objects2345 to i8*
store i8* %var5502, i8** %ifptr5497
br label %ifcont5497

else5497:
%val5503 = load i8*, i8** %logbufPtr
store i8* %val5503, i8** %ifptr5497
br label %ifcont5497

ifcont5497:
%ifres5504 = load i8*, i8** %ifptr5497


%val5505 = call i32 (i8*, ...) @printf(i8* %var5474, i8* %ifres5496, i8* %ifres5504)
%val5507 = load i32*, i32** %len_ptrPtr
; pointer ref
%val5508 = getelementptr i32, i32* %val5507, i64 0
%val5509 = load i32, i32* %val5508
%cmp5510 = icmp eq i32 %val5509, 0
br i1 %cmp5510, label %then5506, label %else5506

then5506:
store i64 0, i64* %ifptr5506
br label %ifcont5506

else5506:
store i64 1, i64* %ifptr5506
br label %ifcont5506

ifcont5506:
%ifres5511 = load i64, i64* %ifptr5506

ret void
}
@gsxtmgl-objects2351 = hidden constant [85 x i8] c"print_adhoc_W3ZvaWQsU2hhZGVyKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Shader*)*}** @print_adhoc_W3ZvaWQsU2hhZGVyKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5552 = load i8*, i8** %_impzPtr
%zone5553 = bitcast i8* %tzone5552 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU2hhZGVyKl0
%dat_print_adhoc_W3ZvaWQsU2hhZGVyKl0 = call i8* @llvm_zone_malloc(%mzone* %zone5553, i64 8)
%print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU2hhZGVyKl0 to {i8*, i8*, void (i8*, i8*, %Shader*)*}***
%tzone5444 = load i8*, i8** %_impzPtr
%zone5445 = bitcast i8* %tzone5444 to %mzone*

; let assign value to symbol max_log_length
%dat_max_log_length = call i8* @llvm_zone_malloc(%mzone* %zone5445, i64 4)
%max_log_lengthPtr = bitcast i8* %dat_max_log_length to i32*
%tzone5454 = load i8*, i8** %_impzPtr
%zone5455 = bitcast i8* %tzone5454 to %mzone*

; let assign value to symbol logbuf
%dat_logbuf = call i8* @llvm_zone_malloc(%mzone* %zone5455, i64 8)
%logbufPtr = bitcast i8* %dat_logbuf to i8**

; let value assignment
%max_log_length = select i1 true, i32 4096, i32 4096
store i32 %max_log_length, i32* %max_log_lengthPtr

%val5446 = load i32, i32* %max_log_lengthPtr
%tmp5447 = zext i32 %val5446 to i64
%val5448 = getelementptr i32, i32* null, i32 1
%zonesize5449 = mul i64 1, %tmp5447
%tzone5450 = load i8*, i8** %_impzPtr
%zone5451 = bitcast i8* %tzone5450 to %mzone*
%dat5452 = call i8* @llvm_zone_malloc(%mzone* %zone5451, i64 %zonesize5449)
call i8* @memset(i8* %dat5452, i32 0, i64 %zonesize5449)
%val5453 = bitcast i8* %dat5452 to i8*

; let value assignment
%logbuf = select i1 true, i8* %val5453, i8* %val5453
store i8* %logbuf, i8** %logbufPtr

%tzone5549 = load i8*, i8** %_impzPtr
%zone5550 = bitcast i8* %tzone5549 to %mzone*

; let assign value to symbol _anon_lambda_2
%dat__anon_lambda_2 = call i8* @llvm_zone_malloc(%mzone* %zone5550, i64 8)
%_anon_lambda_2Ptr = bitcast i8* %dat__anon_lambda_2 to { i8*, i8*, void (i8*, i8*, %Shader*)*}***
%tzone5515 = load i8*, i8** %_impzPtr
%zone5516 = bitcast i8* %tzone5515 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5516)
; malloc closure structure
%clsptr5517 = call i8* @llvm_zone_malloc(%mzone* %zone5516, i64 24)
%closure5518 = bitcast i8* %clsptr5517 to { i8*, i8*, void (i8*, i8*, %Shader*)*}*

; malloc environment structure
%envptr5519 = call i8* @llvm_zone_malloc(%mzone* %zone5516, i64 32)
%environment5520 = bitcast i8* %envptr5519 to {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}*

; malloc closure address table
%addytable5521 = call %clsvar* @new_address_table()
%var5522 = bitcast [32 x i8]* @gsxtmgl-objects2346 to i8*
%var5523 = bitcast [41 x i8]* @gsxtmgl-objects2329 to i8*
%addytable5524 = call %clsvar* @add_address_table(%mzone* %zone5516, i8* %var5522, i32 0, i8* %var5523, i32 3, %clsvar* %addytable5521)
%var5525 = bitcast [7 x i8]* @gsxtmgl-objects2347 to i8*
%var5526 = bitcast [4 x i8]* @gsxtmgl-objects2348 to i8*
%addytable5527 = call %clsvar* @add_address_table(%mzone* %zone5516, i8* %var5525, i32 8, i8* %var5526, i32 3, %clsvar* %addytable5524)
%var5528 = bitcast [15 x i8]* @gsxtmgl-objects2349 to i8*
%var5529 = bitcast [4 x i8]* @gsxtmgl-objects274 to i8*
%addytable5530 = call %clsvar* @add_address_table(%mzone* %zone5516, i8* %var5528, i32 16, i8* %var5529, i32 3, %clsvar* %addytable5527)
%var5531 = bitcast [15 x i8]* @gsxtmgl-objects2350 to i8*
%var5532 = bitcast [41 x i8]* @gsxtmgl-objects2329 to i8*
%addytable5533 = call %clsvar* @add_address_table(%mzone* %zone5516, i8* %var5531, i32 24, i8* %var5532, i32 3, %clsvar* %addytable5530)
%address-table5534 = bitcast %clsvar* %addytable5533 to i8*

; insert table, function and environment into closure struct
%closure.table5543 = getelementptr { i8*, i8*, void (i8*, i8*, %Shader*)*}, { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure5518, i32 0, i32 0
store i8* %address-table5534, i8** %closure.table5543
%closure.env5544 = getelementptr { i8*, i8*, void (i8*, i8*, %Shader*)*}, { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure5518, i32 0, i32 1
store i8* %envptr5519, i8** %closure.env5544
%closure.func5545 = getelementptr { i8*, i8*, void (i8*, i8*, %Shader*)*}, { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure5518, i32 0, i32 2
store void (i8*, i8*, %Shader*)* @print_adhoc_W3ZvaWQsU2hhZGVyKl0__5443, void (i8*, i8*, %Shader*)** %closure.func5545
%closure_size5546 = call i64 @llvm_zone_mark_size(%mzone* %zone5516)
call void @llvm_zone_ptr_set_size(i8* %clsptr5517, i64 %closure_size5546)
%wrapper_ptr5547 = call i8* @llvm_zone_malloc(%mzone* %zone5516, i64 8)
%closure_wrapper5548 = bitcast i8* %wrapper_ptr5547 to { i8*, i8*, void (i8*, i8*, %Shader*)*}**
store { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure5518, { i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_wrapper5548

; let value assignment
%_anon_lambda_2 = select i1 true, { i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_wrapper5548, { i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_wrapper5548
store { i8*, i8*, void (i8*, i8*, %Shader*)*}** %_anon_lambda_2, { i8*, i8*, void (i8*, i8*, %Shader*)*}*** %_anon_lambda_2Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU2hhZGVyKl0
%tmp_envptr5536 = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %environment5520, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Shader*)*}*** %print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr, {i8*, i8*, void (i8*, i8*, %Shader*)*}**** %tmp_envptr5536

; don't need to alloc for env var logbuf
%tmp_envptr5538 = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %environment5520, i32 0, i32 1
store i8** %logbufPtr, i8*** %tmp_envptr5538

; don't need to alloc for env var max_log_length
%tmp_envptr5540 = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %environment5520, i32 0, i32 2
store i32* %max_log_lengthPtr, i32** %tmp_envptr5540

; don't need to alloc for env var _anon_lambda_2
%tmp_envptr5542 = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %environment5520, i32 0, i32 3
store {i8*, i8*, void (i8*, i8*, %Shader*)*}*** %_anon_lambda_2Ptr, {i8*, i8*, void (i8*, i8*, %Shader*)*}**** %tmp_envptr5542


%val5551 = load {i8*, i8*, void (i8*, i8*, %Shader*)*}**, {i8*, i8*, void (i8*, i8*, %Shader*)*}*** %_anon_lambda_2Ptr

; let value assignment
%print_adhoc_W3ZvaWQsU2hhZGVyKl0 = select i1 true, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %val5551, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %val5551
store {i8*, i8*, void (i8*, i8*, %Shader*)*}** %print_adhoc_W3ZvaWQsU2hhZGVyKl0, {i8*, i8*, void (i8*, i8*, %Shader*)*}*** %print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr

%val5554 = load {i8*, i8*, void (i8*, i8*, %Shader*)*}**, {i8*, i8*, void (i8*, i8*, %Shader*)*}*** %print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %Shader*)*}** %val5554
}


@print_adhoc_W3ZvaWQsU2hhZGVyKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU2hhZGVyKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU2hhZGVyKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Shader*)*}** @print_adhoc_W3ZvaWQsU2hhZGVyKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU2hhZGVyKl0(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU2hhZGVyKl0_native(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU2hhZGVyKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5555 = bitcast [85 x i8]* @gsxtmgl-objects2351 to i8*
call i32 (i8*, ...) @printf(i8* %var5555)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU2hhZGVyKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*}*
%arg_p_0 = getelementptr {%Shader*}, {%Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2352 = hidden constant [93 x i8] c"Error: shader type must be one of GL_VERTEX_SHADER, GL_FRAGMENT_SHADER or GL_GEOMETRY_SHADER\00"
@gsxtmgl-objects2353 = hidden constant [8 x i8] c"Shader:\00"
@gsxtmgl-objects2354 = hidden constant [23 x i8] c"Error compiling shader\00"
@gsxtmgl-objects2355 = hidden constant [42 x i8] c"Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd\00"
@gsxtmgl-objects2356 = hidden constant [50 x i8] c"{i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}**\00"
define dllexport fastcc %Shader* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd__5556(i8* %_impz,i8* %_impenv, %String* %source, i32 %type_s_35) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5557 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}***}*
%Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJdPtr_ = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}***}* %impenv, i32 0, i32 0
%Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJdPtr = load {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}***, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}**** %Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJdPtr_

; setup arguments
%sourcePtr = alloca %String*
store %String* %source, %String** %sourcePtr
%type_s_35Ptr = alloca i32
store i32 %type_s_35, i32* %type_s_35Ptr

; promote local stack var allocations
%tzone5626 = load i8*, i8** %_impzPtr
%zone5627 = bitcast i8* %tzone5626 to %mzone*
%ifptr5559 = alloca i1
%ifptr5560 = alloca i1
%ifptr5567 = alloca i1
%ifptr5574 = alloca i1

%val5561 = load i32, i32* %type_s_35Ptr
%val5562 = load i32, i32* @GL_VERTEX_SHADER
%cmp5563 = icmp eq i32 %val5561, %val5562
br i1 %cmp5563, label %then5560, label %else5560

then5560:
%val5564 = load i32, i32* %type_s_35Ptr
%val5565 = load i32, i32* @GL_VERTEX_SHADER
%cmp5566 = icmp eq i32 %val5564, %val5565
store i1 %cmp5566, i1* %ifptr5560
br label %ifcont5560

else5560:
%val5568 = load i32, i32* %type_s_35Ptr
%val5569 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp5570 = icmp eq i32 %val5568, %val5569
br i1 %cmp5570, label %then5567, label %else5567

then5567:
%val5571 = load i32, i32* %type_s_35Ptr
%val5572 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp5573 = icmp eq i32 %val5571, %val5572
store i1 %cmp5573, i1* %ifptr5567
br label %ifcont5567

else5567:
%val5575 = load i32, i32* %type_s_35Ptr
%val5576 = load i32, i32* @GL_GEOMETRY_SHADER
%cmp5577 = icmp eq i32 %val5575, %val5576
br i1 %cmp5577, label %then5574, label %else5574

then5574:
%val5578 = load i32, i32* %type_s_35Ptr
%val5579 = load i32, i32* @GL_GEOMETRY_SHADER
%cmp5580 = icmp eq i32 %val5578, %val5579
store i1 %cmp5580, i1* %ifptr5574
br label %ifcont5574

else5574:
%res5581 = call ccc i1 @impc_false()
store i1 %res5581, i1* %ifptr5574
br label %ifcont5574

ifcont5574:
%ifres5582 = load i1, i1* %ifptr5574

store i1 %ifres5582, i1* %ifptr5567
br label %ifcont5567

ifcont5567:
%ifres5583 = load i1, i1* %ifptr5567

store i1 %ifres5583, i1* %ifptr5560
br label %ifcont5560

ifcont5560:
%ifres5584 = load i1, i1* %ifptr5560

br i1 %ifres5584, label %then5559, label %else5559

then5559:
%res5585 = call ccc i1 @impc_false()
store i1 %res5585, i1* %ifptr5559
br label %ifcont5559

else5559:
%res5586 = call ccc i1 @impc_true()
store i1 %res5586, i1* %ifptr5559
br label %ifcont5559

ifcont5559:
%ifres5587 = load i1, i1* %ifptr5559

br i1 %ifres5587, label %then5558, label %else5558

then5558:
%var5588 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var5589 = bitcast [93 x i8]* @gsxtmgl-objects2352 to i8*

%val5590 = call i32 (i8*, ...) @printf(i8* %var5588, i8* %var5589)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%null5592 = bitcast i8* null to %Shader*
ret %Shader* %null5592

else5558:
%tzone5595 = load i8*, i8** %_impzPtr
%zone5596 = bitcast i8* %tzone5595 to %mzone*

; let assign value to symbol shader_id
%shader_idPtr = alloca i32
%tzone5598 = load i8*, i8** %_impzPtr
%zone5599 = bitcast i8* %tzone5598 to %mzone*

; let assign value to symbol source_ptr
%source_ptrPtr = alloca i8**
%tzone5603 = load i8*, i8** %_impzPtr
%zone5604 = bitcast i8* %tzone5603 to %mzone*

; let assign value to symbol shader
%shaderPtr = alloca %Shader*
%val5593 = load i32, i32* %type_s_35Ptr
%res5594 = call fastcc i32 @glCreateShader_adhoc_W2kzMixpMzJd(i32 %val5593)

; let value assignment
%shader_id = select i1 true, i32 %res5594, i32 %res5594
store i32 %shader_id, i32* %shader_idPtr

%dat5597 = alloca i8*, align 16

; let value assignment
%source_ptr = select i1 true, i8** %dat5597, i8** %dat5597
store i8** %source_ptr, i8*** %source_ptrPtr

%val5600 = load i32, i32* %shader_idPtr
%val5601 = load i32, i32* %type_s_35Ptr
%res5602 = call fastcc %Shader* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0(i32 %val5600, i32 %val5601)

; let value assignment
%shader = select i1 true, %Shader* %res5602, %Shader* %res5602
store %Shader* %shader, %Shader** %shaderPtr

%val5605 = load i8**, i8*** %source_ptrPtr
%val5606 = load %String*, %String** %sourcePtr
%res5607 = call fastcc i8* @cstring_adhoc_W2k4KixTdHJpbmcqXQ(%String* %val5606)
; set pointer
%val5608 = getelementptr i8*, i8** %val5605, i64 0
store i8* %res5607, i8** %val5608
%val5609 = load i32, i32* %shader_idPtr
%val5610 = load i8**, i8*** %source_ptrPtr
%null5611 = bitcast i8* null to i8*
%val5612 = bitcast i8* %null5611 to i32*
call fastcc void @glShaderSource_adhoc_W3ZvaWQsaTMyLGkzMixpOCoqLGkzMipd(i32 %val5609, i32 1, i8** %val5610, i32* %val5612)
%val5614 = load i32, i32* %shader_idPtr
call fastcc void @glCompileShader_adhoc_W3ZvaWQsaTMyXQ(i32 %val5614)
%var5616 = bitcast [8 x i8]* @gsxtmgl-objects2353 to i8*
%res5617 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var5616)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res5617)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%val5620 = load %Shader*, %Shader** %shaderPtr
call fastcc void @print_adhoc_W3ZvaWQsU2hhZGVyKl0(%Shader* %val5620)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%var5623 = bitcast [23 x i8]* @gsxtmgl-objects2354 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var5623)
%val5625 = load %Shader*, %Shader** %shaderPtr
ret %Shader* %val5625
}
@gsxtmgl-objects2357 = hidden constant [95 x i8] c"Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}** @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5647 = load i8*, i8** %_impzPtr
%zone5648 = bitcast i8* %tzone5647 to %mzone*

; let assign value to symbol Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd
%dat_Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone5648, i64 8)
%Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJdPtr = bitcast i8* %dat_Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd to { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}***
%tzone5628 = load i8*, i8** %_impzPtr
%zone5629 = bitcast i8* %tzone5628 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5629)
; malloc closure structure
%clsptr5630 = call i8* @llvm_zone_malloc(%mzone* %zone5629, i64 24)
%closure5631 = bitcast i8* %clsptr5630 to { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}*

; malloc environment structure
%envptr5632 = call i8* @llvm_zone_malloc(%mzone* %zone5629, i64 8)
%environment5633 = bitcast i8* %envptr5632 to {{i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}***}*

; malloc closure address table
%addytable5634 = call %clsvar* @new_address_table()
%var5635 = bitcast [42 x i8]* @gsxtmgl-objects2355 to i8*
%var5636 = bitcast [50 x i8]* @gsxtmgl-objects2356 to i8*
%addytable5637 = call %clsvar* @add_address_table(%mzone* %zone5629, i8* %var5635, i32 0, i8* %var5636, i32 3, %clsvar* %addytable5634)
%address-table5638 = bitcast %clsvar* %addytable5637 to i8*

; insert table, function and environment into closure struct
%closure.table5641 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}* %closure5631, i32 0, i32 0
store i8* %address-table5638, i8** %closure.table5641
%closure.env5642 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}* %closure5631, i32 0, i32 1
store i8* %envptr5632, i8** %closure.env5642
%closure.func5643 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}* %closure5631, i32 0, i32 2
store %Shader* (i8*, i8*, %String*, i32)* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd__5556, %Shader* (i8*, i8*, %String*, i32)** %closure.func5643
%closure_size5644 = call i64 @llvm_zone_mark_size(%mzone* %zone5629)
call void @llvm_zone_ptr_set_size(i8* %clsptr5630, i64 %closure_size5644)
%wrapper_ptr5645 = call i8* @llvm_zone_malloc(%mzone* %zone5629, i64 8)
%closure_wrapper5646 = bitcast i8* %wrapper_ptr5645 to { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}**
store { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}* %closure5631, { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}** %closure_wrapper5646

; let value assignment
%Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd = select i1 true, { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}** %closure_wrapper5646, { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}** %closure_wrapper5646
store { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}** %Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd, { i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}*** %Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJdPtr

; add data to environment
; don't need to alloc for env var Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd
%tmp_envptr5640 = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}***}* %environment5633, i32 0, i32 0
store {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}*** %Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJdPtr, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}**** %tmp_envptr5640


%val5649 = load {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}**, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}*** %Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJdPtr
ret {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}** %val5649
}


@Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}** @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd(%String* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %String*, i32)*,  %Shader* (i8*, i8*, %String*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc %Shader* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_native(%String* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %String*, i32)*,  %Shader* (i8*, i8*, %String*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc i8*  @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5650 = bitcast [95 x i8]* @gsxtmgl-objects2357 to i8*
call i32 (i8*, ...) @printf(i8* %var5650)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5651 = bitcast [95 x i8]* @gsxtmgl-objects2357 to i8*
call i32 (i8*, ...) @printf(i8* %var5651)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %String*, i32)*,  %Shader* (i8*, i8*, %String*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1)
%tmpres = bitcast %Shader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, i32}*
%arg_p_0 = getelementptr {%String*, i32}, {%String*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, i32}, {%String*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, %String*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %String*, i32)*,  %Shader* (i8*, i8*, %String*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %String* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%ShaderProgram = type {i32,%Shader*,%Shader*,%Shader*,%String*}
@gsxtmgl-objects2358 = hidden constant [91 x i8] c"ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ\00"
@gsxtmgl-objects2359 = hidden constant [87 x i8] c"{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**\00"
define dllexport fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ__5652(i8* %_impz,i8* %_impenv, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5653 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}*
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca %Shader*
store %Shader* %arg_1, %Shader** %arg_1Ptr
%arg_2Ptr = alloca %Shader*
store %Shader* %arg_2, %Shader** %arg_2Ptr
%arg_3Ptr = alloca %Shader*
store %Shader* %arg_3, %Shader** %arg_3Ptr
%arg_4Ptr = alloca %String*
store %String* %arg_4, %String** %arg_4Ptr


%tzone5658 = load i8*, i8** %_impzPtr
%zone5659 = bitcast i8* %tzone5658 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %ShaderProgram*
%tzone5654 = load i8*, i8** %_impzPtr
%zone5655 = bitcast i8* %tzone5654 to %mzone*
%dat5656 = call i8* @llvm_zone_malloc(%mzone* %zone5655, i64 40)
call i8* @memset(i8* %dat5656, i32 0, i64 40)
%val5657 = bitcast i8* %dat5656 to %ShaderProgram*

; let value assignment
%obj = select i1 true, %ShaderProgram* %val5657, %ShaderProgram* %val5657
store %ShaderProgram* %obj, %ShaderProgram** %objPtr

%val5660 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5661 = load i32, i32* %arg_0Ptr
; set tuple
%val5662 = getelementptr %ShaderProgram, %ShaderProgram* %val5660, i64 0, i32 0
store i32 %val5661, i32* %val5662
%val5663 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5664 = load %Shader*, %Shader** %arg_1Ptr
; set tuple
%val5665 = getelementptr %ShaderProgram, %ShaderProgram* %val5663, i64 0, i32 1
store %Shader* %val5664, %Shader** %val5665
%val5666 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5667 = load %Shader*, %Shader** %arg_2Ptr
; set tuple
%val5668 = getelementptr %ShaderProgram, %ShaderProgram* %val5666, i64 0, i32 2
store %Shader* %val5667, %Shader** %val5668
%val5669 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5670 = load %Shader*, %Shader** %arg_3Ptr
; set tuple
%val5671 = getelementptr %ShaderProgram, %ShaderProgram* %val5669, i64 0, i32 3
store %Shader* %val5670, %Shader** %val5671
%val5672 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5673 = load %String*, %String** %arg_4Ptr
; set tuple
%val5674 = getelementptr %ShaderProgram, %ShaderProgram* %val5672, i64 0, i32 4
store %String* %val5673, %String** %val5674
%val5675 = load %ShaderProgram*, %ShaderProgram** %objPtr
ret %ShaderProgram* %val5675
}
@gsxtmgl-objects2360 = hidden constant [144 x i8] c"ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5695 = load i8*, i8** %_impzPtr
%zone5696 = bitcast i8* %tzone5695 to %mzone*

; let assign value to symbol ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ
%dat_ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone5696, i64 8)
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr = bitcast i8* %dat_ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ to { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***
%tzone5676 = load i8*, i8** %_impzPtr
%zone5677 = bitcast i8* %tzone5676 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5677)
; malloc closure structure
%clsptr5678 = call i8* @llvm_zone_malloc(%mzone* %zone5677, i64 24)
%closure5679 = bitcast i8* %clsptr5678 to { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*

; malloc environment structure
%envptr5680 = call i8* @llvm_zone_malloc(%mzone* %zone5677, i64 8)
%environment5681 = bitcast i8* %envptr5680 to {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}*

; malloc closure address table
%addytable5682 = call %clsvar* @new_address_table()
%var5683 = bitcast [91 x i8]* @gsxtmgl-objects2358 to i8*
%var5684 = bitcast [87 x i8]* @gsxtmgl-objects2359 to i8*
%addytable5685 = call %clsvar* @add_address_table(%mzone* %zone5677, i8* %var5683, i32 0, i8* %var5684, i32 3, %clsvar* %addytable5682)
%address-table5686 = bitcast %clsvar* %addytable5685 to i8*

; insert table, function and environment into closure struct
%closure.table5689 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5679, i32 0, i32 0
store i8* %address-table5686, i8** %closure.table5689
%closure.env5690 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5679, i32 0, i32 1
store i8* %envptr5680, i8** %closure.env5690
%closure.func5691 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5679, i32 0, i32 2
store %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ__5652, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %closure.func5691
%closure_size5692 = call i64 @llvm_zone_mark_size(%mzone* %zone5677)
call void @llvm_zone_ptr_set_size(i8* %clsptr5678, i64 %closure_size5692)
%wrapper_ptr5693 = call i8* @llvm_zone_malloc(%mzone* %zone5677, i64 8)
%closure_wrapper5694 = bitcast i8* %wrapper_ptr5693 to { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
store { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5679, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_wrapper5694

; let value assignment
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ = select i1 true, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_wrapper5694, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_wrapper5694
store { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ
%tmp_envptr5688 = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}* %environment5681, i32 0, i32 0
store {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**** %tmp_envptr5688


%val5697 = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr
ret {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %val5697
}


@ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ(i32 %arg_0,%Shader* %arg_1,%Shader* %arg_2,%Shader* %arg_3,%String* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
ret %ShaderProgram* %result
}


define dllexport ccc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_native(i32 %arg_0,%Shader* %arg_1,%Shader* %arg_2,%Shader* %arg_3,%String* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
ret %ShaderProgram* %result
}


define dllexport ccc i8*  @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5698 = bitcast [144 x i8]* @gsxtmgl-objects2360 to i8*
call i32 (i8*, ...) @printf(i8* %var5698)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5699 = bitcast [144 x i8]* @gsxtmgl-objects2360 to i8*
call i32 (i8*, ...) @printf(i8* %var5699)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Shader*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5700 = bitcast [144 x i8]* @gsxtmgl-objects2360 to i8*
call i32 (i8*, ...) @printf(i8* %var5700)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Shader*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var5701 = bitcast [144 x i8]* @gsxtmgl-objects2360 to i8*
call i32 (i8*, ...) @printf(i8* %var5701)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to %Shader*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var5702 = bitcast [144 x i8]* @gsxtmgl-objects2360 to i8*
call i32 (i8*, ...) @printf(i8* %var5702)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
%tmpres = bitcast %ShaderProgram* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Shader*, %Shader*, %Shader*, %String*}*
%arg_p_0 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %Shader*, %Shader** %arg_p_1
%arg_p_2 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %Shader*, %Shader** %arg_p_2
%arg_p_3 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 3
%arg_3 = load %Shader*, %Shader** %arg_p_3
%arg_p_4 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 4
%arg_4 = load %String*, %String** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2361 = hidden constant [93 x i8] c"ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ\00"
define dllexport fastcc %ShaderProgram* @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ__5703(i8* %_impz,i8* %_impenv, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5704 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}*
%ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**** %ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca %Shader*
store %Shader* %arg_1, %Shader** %arg_1Ptr
%arg_2Ptr = alloca %Shader*
store %Shader* %arg_2, %Shader** %arg_2Ptr
%arg_3Ptr = alloca %Shader*
store %Shader* %arg_3, %Shader** %arg_3Ptr
%arg_4Ptr = alloca %String*
store %String* %arg_4, %String** %arg_4Ptr


%tzone5709 = load i8*, i8** %_impzPtr
%zone5710 = bitcast i8* %tzone5709 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %ShaderProgram*
%tzone5705 = load i8*, i8** %_impzPtr
%zone5706 = bitcast i8* %tzone5705 to %mzone*
%dat5707 = call i8* @llvm_zone_malloc(%mzone* %zone5706, i64 40)
call i8* @memset(i8* %dat5707, i32 0, i64 40)
%val5708 = bitcast i8* %dat5707 to %ShaderProgram*

; let value assignment
%obj = select i1 true, %ShaderProgram* %val5708, %ShaderProgram* %val5708
store %ShaderProgram* %obj, %ShaderProgram** %objPtr

%val5711 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5712 = load i32, i32* %arg_0Ptr
; set tuple
%val5713 = getelementptr %ShaderProgram, %ShaderProgram* %val5711, i64 0, i32 0
store i32 %val5712, i32* %val5713
%val5714 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5715 = load %Shader*, %Shader** %arg_1Ptr
; set tuple
%val5716 = getelementptr %ShaderProgram, %ShaderProgram* %val5714, i64 0, i32 1
store %Shader* %val5715, %Shader** %val5716
%val5717 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5718 = load %Shader*, %Shader** %arg_2Ptr
; set tuple
%val5719 = getelementptr %ShaderProgram, %ShaderProgram* %val5717, i64 0, i32 2
store %Shader* %val5718, %Shader** %val5719
%val5720 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5721 = load %Shader*, %Shader** %arg_3Ptr
; set tuple
%val5722 = getelementptr %ShaderProgram, %ShaderProgram* %val5720, i64 0, i32 3
store %Shader* %val5721, %Shader** %val5722
%val5723 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5724 = load %String*, %String** %arg_4Ptr
; set tuple
%val5725 = getelementptr %ShaderProgram, %ShaderProgram* %val5723, i64 0, i32 4
store %String* %val5724, %String** %val5725
%val5726 = load %ShaderProgram*, %ShaderProgram** %objPtr
ret %ShaderProgram* %val5726
}
@gsxtmgl-objects2362 = hidden constant [146 x i8] c"ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5746 = load i8*, i8** %_impzPtr
%zone5747 = bitcast i8* %tzone5746 to %mzone*

; let assign value to symbol ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ
%dat_ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone5747, i64 8)
%ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr = bitcast i8* %dat_ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ to { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***
%tzone5727 = load i8*, i8** %_impzPtr
%zone5728 = bitcast i8* %tzone5727 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5728)
; malloc closure structure
%clsptr5729 = call i8* @llvm_zone_malloc(%mzone* %zone5728, i64 24)
%closure5730 = bitcast i8* %clsptr5729 to { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*

; malloc environment structure
%envptr5731 = call i8* @llvm_zone_malloc(%mzone* %zone5728, i64 8)
%environment5732 = bitcast i8* %envptr5731 to {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}*

; malloc closure address table
%addytable5733 = call %clsvar* @new_address_table()
%var5734 = bitcast [93 x i8]* @gsxtmgl-objects2361 to i8*
%var5735 = bitcast [87 x i8]* @gsxtmgl-objects2359 to i8*
%addytable5736 = call %clsvar* @add_address_table(%mzone* %zone5728, i8* %var5734, i32 0, i8* %var5735, i32 3, %clsvar* %addytable5733)
%address-table5737 = bitcast %clsvar* %addytable5736 to i8*

; insert table, function and environment into closure struct
%closure.table5740 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5730, i32 0, i32 0
store i8* %address-table5737, i8** %closure.table5740
%closure.env5741 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5730, i32 0, i32 1
store i8* %envptr5731, i8** %closure.env5741
%closure.func5742 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5730, i32 0, i32 2
store %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)* @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ__5703, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %closure.func5742
%closure_size5743 = call i64 @llvm_zone_mark_size(%mzone* %zone5728)
call void @llvm_zone_ptr_set_size(i8* %clsptr5729, i64 %closure_size5743)
%wrapper_ptr5744 = call i8* @llvm_zone_malloc(%mzone* %zone5728, i64 8)
%closure_wrapper5745 = bitcast i8* %wrapper_ptr5744 to { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
store { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5730, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_wrapper5745

; let value assignment
%ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ = select i1 true, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_wrapper5745, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_wrapper5745
store { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*** %ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ
%tmp_envptr5739 = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}* %environment5732, i32 0, i32 0
store {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*** %ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**** %tmp_envptr5739


%val5748 = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*** %ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr
ret {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %val5748
}


@ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %ShaderProgram* @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ(i32 %arg_0,%Shader* %arg_1,%Shader* %arg_2,%Shader* %arg_3,%String* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
ret %ShaderProgram* %result
}


define dllexport ccc %ShaderProgram* @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_native(i32 %arg_0,%Shader* %arg_1,%Shader* %arg_2,%Shader* %arg_3,%String* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
ret %ShaderProgram* %result
}


define dllexport ccc i8*  @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5749 = bitcast [146 x i8]* @gsxtmgl-objects2362 to i8*
call i32 (i8*, ...) @printf(i8* %var5749)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5750 = bitcast [146 x i8]* @gsxtmgl-objects2362 to i8*
call i32 (i8*, ...) @printf(i8* %var5750)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Shader*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5751 = bitcast [146 x i8]* @gsxtmgl-objects2362 to i8*
call i32 (i8*, ...) @printf(i8* %var5751)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Shader*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var5752 = bitcast [146 x i8]* @gsxtmgl-objects2362 to i8*
call i32 (i8*, ...) @printf(i8* %var5752)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to %Shader*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var5753 = bitcast [146 x i8]* @gsxtmgl-objects2362 to i8*
call i32 (i8*, ...) @printf(i8* %var5753)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
%tmpres = bitcast %ShaderProgram* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Shader*, %Shader*, %Shader*, %String*}*
%arg_p_0 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %Shader*, %Shader** %arg_p_1
%arg_p_2 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %Shader*, %Shader** %arg_p_2
%arg_p_3 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 3
%arg_3 = load %Shader*, %Shader** %arg_p_3
%arg_p_4 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 4
%arg_4 = load %String*, %String** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_z_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2363 = hidden constant [93 x i8] c"ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ\00"
define dllexport fastcc %ShaderProgram* @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ__5754(i8* %_impz,i8* %_impenv, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5755 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}*
%ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**** %ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca %Shader*
store %Shader* %arg_1, %Shader** %arg_1Ptr
%arg_2Ptr = alloca %Shader*
store %Shader* %arg_2, %Shader** %arg_2Ptr
%arg_3Ptr = alloca %Shader*
store %Shader* %arg_3, %Shader** %arg_3Ptr
%arg_4Ptr = alloca %String*
store %String* %arg_4, %String** %arg_4Ptr


%tzone5758 = load i8*, i8** %_impzPtr
%zone5759 = bitcast i8* %tzone5758 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %ShaderProgram*
%dat5756 = call i8* @malloc(i64 40)
call i8* @memset(i8* %dat5756, i32 0, i64 40)
%val5757 = bitcast i8* %dat5756 to %ShaderProgram*

; let value assignment
%obj = select i1 true, %ShaderProgram* %val5757, %ShaderProgram* %val5757
store %ShaderProgram* %obj, %ShaderProgram** %objPtr

%val5760 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5761 = load i32, i32* %arg_0Ptr
; set tuple
%val5762 = getelementptr %ShaderProgram, %ShaderProgram* %val5760, i64 0, i32 0
store i32 %val5761, i32* %val5762
%val5763 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5764 = load %Shader*, %Shader** %arg_1Ptr
; set tuple
%val5765 = getelementptr %ShaderProgram, %ShaderProgram* %val5763, i64 0, i32 1
store %Shader* %val5764, %Shader** %val5765
%val5766 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5767 = load %Shader*, %Shader** %arg_2Ptr
; set tuple
%val5768 = getelementptr %ShaderProgram, %ShaderProgram* %val5766, i64 0, i32 2
store %Shader* %val5767, %Shader** %val5768
%val5769 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5770 = load %Shader*, %Shader** %arg_3Ptr
; set tuple
%val5771 = getelementptr %ShaderProgram, %ShaderProgram* %val5769, i64 0, i32 3
store %Shader* %val5770, %Shader** %val5771
%val5772 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5773 = load %String*, %String** %arg_4Ptr
; set tuple
%val5774 = getelementptr %ShaderProgram, %ShaderProgram* %val5772, i64 0, i32 4
store %String* %val5773, %String** %val5774
%val5775 = load %ShaderProgram*, %ShaderProgram** %objPtr
ret %ShaderProgram* %val5775
}
@gsxtmgl-objects2364 = hidden constant [146 x i8] c"ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5795 = load i8*, i8** %_impzPtr
%zone5796 = bitcast i8* %tzone5795 to %mzone*

; let assign value to symbol ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ
%dat_ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone5796, i64 8)
%ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr = bitcast i8* %dat_ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ to { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***
%tzone5776 = load i8*, i8** %_impzPtr
%zone5777 = bitcast i8* %tzone5776 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5777)
; malloc closure structure
%clsptr5778 = call i8* @llvm_zone_malloc(%mzone* %zone5777, i64 24)
%closure5779 = bitcast i8* %clsptr5778 to { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*

; malloc environment structure
%envptr5780 = call i8* @llvm_zone_malloc(%mzone* %zone5777, i64 8)
%environment5781 = bitcast i8* %envptr5780 to {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}*

; malloc closure address table
%addytable5782 = call %clsvar* @new_address_table()
%var5783 = bitcast [93 x i8]* @gsxtmgl-objects2363 to i8*
%var5784 = bitcast [87 x i8]* @gsxtmgl-objects2359 to i8*
%addytable5785 = call %clsvar* @add_address_table(%mzone* %zone5777, i8* %var5783, i32 0, i8* %var5784, i32 3, %clsvar* %addytable5782)
%address-table5786 = bitcast %clsvar* %addytable5785 to i8*

; insert table, function and environment into closure struct
%closure.table5789 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5779, i32 0, i32 0
store i8* %address-table5786, i8** %closure.table5789
%closure.env5790 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5779, i32 0, i32 1
store i8* %envptr5780, i8** %closure.env5790
%closure.func5791 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5779, i32 0, i32 2
store %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)* @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ__5754, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %closure.func5791
%closure_size5792 = call i64 @llvm_zone_mark_size(%mzone* %zone5777)
call void @llvm_zone_ptr_set_size(i8* %clsptr5778, i64 %closure_size5792)
%wrapper_ptr5793 = call i8* @llvm_zone_malloc(%mzone* %zone5777, i64 8)
%closure_wrapper5794 = bitcast i8* %wrapper_ptr5793 to { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
store { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5779, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_wrapper5794

; let value assignment
%ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ = select i1 true, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_wrapper5794, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_wrapper5794
store { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ, { i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*** %ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ
%tmp_envptr5788 = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}* %environment5781, i32 0, i32 0
store {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*** %ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**** %tmp_envptr5788


%val5797 = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*** %ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQPtr
ret {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %val5797
}


@ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %ShaderProgram* @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ(i32 %arg_0,%Shader* %arg_1,%Shader* %arg_2,%Shader* %arg_3,%String* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
ret %ShaderProgram* %result
}


define dllexport ccc %ShaderProgram* @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_native(i32 %arg_0,%Shader* %arg_1,%Shader* %arg_2,%Shader* %arg_3,%String* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
ret %ShaderProgram* %result
}


define dllexport ccc i8*  @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5798 = bitcast [146 x i8]* @gsxtmgl-objects2364 to i8*
call i32 (i8*, ...) @printf(i8* %var5798)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var5799 = bitcast [146 x i8]* @gsxtmgl-objects2364 to i8*
call i32 (i8*, ...) @printf(i8* %var5799)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Shader*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var5800 = bitcast [146 x i8]* @gsxtmgl-objects2364 to i8*
call i32 (i8*, ...) @printf(i8* %var5800)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Shader*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var5801 = bitcast [146 x i8]* @gsxtmgl-objects2364 to i8*
call i32 (i8*, ...) @printf(i8* %var5801)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to %Shader*
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_cptr(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var5802 = bitcast [146 x i8]* @gsxtmgl-objects2364 to i8*
call i32 (i8*, ...) @printf(i8* %var5802)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%ttv_4 = call ccc i8* @cptr_value(i8* %arg_4_val)
%arg_4 = bitcast i8* %ttv_4 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
%tmpres = bitcast %ShaderProgram* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Shader*, %Shader*, %Shader*, %String*}*
%arg_p_0 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %Shader*, %Shader** %arg_p_1
%arg_p_2 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %Shader*, %Shader** %arg_p_2
%arg_p_3 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 3
%arg_3 = load %Shader*, %Shader** %arg_p_3
%arg_p_4 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 4
%arg_4 = load %String*, %String** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_h_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram* (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2365 = hidden constant [93 x i8] c"ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd\00"
@gsxtmgl-objects2366 = hidden constant [86 x i8] c"{i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**\00"
define dllexport fastcc %ShaderProgram @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd__5803(i8* %_impz,i8* %_impenv, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5804 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}*
%ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}, {{i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypdPtr = load {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***, {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**** %ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca %Shader*
store %Shader* %arg_1, %Shader** %arg_1Ptr
%arg_2Ptr = alloca %Shader*
store %Shader* %arg_2, %Shader** %arg_2Ptr
%arg_3Ptr = alloca %Shader*
store %Shader* %arg_3, %Shader** %arg_3Ptr
%arg_4Ptr = alloca %String*
store %String* %arg_4, %String** %arg_4Ptr


%tzone5806 = load i8*, i8** %_impzPtr
%zone5807 = bitcast i8* %tzone5806 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %ShaderProgram*
%dat5805 = alloca %ShaderProgram, align 16

; let value assignment
%obj = select i1 true, %ShaderProgram* %dat5805, %ShaderProgram* %dat5805
store %ShaderProgram* %obj, %ShaderProgram** %objPtr

%val5808 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5809 = load i32, i32* %arg_0Ptr
; set tuple
%val5810 = getelementptr %ShaderProgram, %ShaderProgram* %val5808, i64 0, i32 0
store i32 %val5809, i32* %val5810
%val5811 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5812 = load %Shader*, %Shader** %arg_1Ptr
; set tuple
%val5813 = getelementptr %ShaderProgram, %ShaderProgram* %val5811, i64 0, i32 1
store %Shader* %val5812, %Shader** %val5813
%val5814 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5815 = load %Shader*, %Shader** %arg_2Ptr
; set tuple
%val5816 = getelementptr %ShaderProgram, %ShaderProgram* %val5814, i64 0, i32 2
store %Shader* %val5815, %Shader** %val5816
%val5817 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5818 = load %Shader*, %Shader** %arg_3Ptr
; set tuple
%val5819 = getelementptr %ShaderProgram, %ShaderProgram* %val5817, i64 0, i32 3
store %Shader* %val5818, %Shader** %val5819
%val5820 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5821 = load %String*, %String** %arg_4Ptr
; set tuple
%val5822 = getelementptr %ShaderProgram, %ShaderProgram* %val5820, i64 0, i32 4
store %String* %val5821, %String** %val5822
%val5823 = load %ShaderProgram*, %ShaderProgram** %objPtr
; pointer ref
%val5824 = getelementptr %ShaderProgram, %ShaderProgram* %val5823, i64 0
%val5825 = load %ShaderProgram, %ShaderProgram* %val5824
ret %ShaderProgram %val5825
}
@gsxtmgl-objects2367 = hidden constant [146 x i8] c"ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5845 = load i8*, i8** %_impzPtr
%zone5846 = bitcast i8* %tzone5845 to %mzone*

; let assign value to symbol ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd
%dat_ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone5846, i64 8)
%ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypdPtr = bitcast i8* %dat_ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd to { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***
%tzone5826 = load i8*, i8** %_impzPtr
%zone5827 = bitcast i8* %tzone5826 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5827)
; malloc closure structure
%clsptr5828 = call i8* @llvm_zone_malloc(%mzone* %zone5827, i64 24)
%closure5829 = bitcast i8* %clsptr5828 to { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*

; malloc environment structure
%envptr5830 = call i8* @llvm_zone_malloc(%mzone* %zone5827, i64 8)
%environment5831 = bitcast i8* %envptr5830 to {{i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}*

; malloc closure address table
%addytable5832 = call %clsvar* @new_address_table()
%var5833 = bitcast [93 x i8]* @gsxtmgl-objects2365 to i8*
%var5834 = bitcast [86 x i8]* @gsxtmgl-objects2366 to i8*
%addytable5835 = call %clsvar* @add_address_table(%mzone* %zone5827, i8* %var5833, i32 0, i8* %var5834, i32 3, %clsvar* %addytable5832)
%address-table5836 = bitcast %clsvar* %addytable5835 to i8*

; insert table, function and environment into closure struct
%closure.table5839 = getelementptr { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5829, i32 0, i32 0
store i8* %address-table5836, i8** %closure.table5839
%closure.env5840 = getelementptr { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5829, i32 0, i32 1
store i8* %envptr5830, i8** %closure.env5840
%closure.func5841 = getelementptr { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5829, i32 0, i32 2
store %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)* @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd__5803, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %closure.func5841
%closure_size5842 = call i64 @llvm_zone_mark_size(%mzone* %zone5827)
call void @llvm_zone_ptr_set_size(i8* %clsptr5828, i64 %closure_size5842)
%wrapper_ptr5843 = call i8* @llvm_zone_malloc(%mzone* %zone5827, i64 8)
%closure_wrapper5844 = bitcast i8* %wrapper_ptr5843 to { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
store { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure5829, { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_wrapper5844

; let value assignment
%ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd = select i1 true, { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_wrapper5844, { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_wrapper5844
store { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd, { i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*** %ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd
%tmp_envptr5838 = getelementptr {{i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}, {{i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}***}* %environment5831, i32 0, i32 0
store {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*** %ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypdPtr, {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**** %tmp_envptr5838


%val5847 = load {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**, {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*** %ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypdPtr
ret {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %val5847
}


@ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %ShaderProgram @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd(i32 %arg_0,%Shader* %arg_1,%Shader* %arg_2,%Shader* %arg_3,%String* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
ret %ShaderProgram %result
}


define dllexport ccc %ShaderProgram @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_native(i32 %arg_0,%Shader* %arg_1,%Shader* %arg_2,%Shader* %arg_3,%String* %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
ret %ShaderProgram %result
}


define dllexport ccc void @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Shader*, %Shader*, %Shader*, %String*}*
%arg_p_0 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %Shader*, %Shader** %arg_p_1
%arg_p_2 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %Shader*, %Shader** %arg_p_2
%arg_p_3 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 3
%arg_3 = load %Shader*, %Shader** %arg_p_3
%arg_p_4 = getelementptr {i32, %Shader*, %Shader*, %Shader*, %String*}, {i32, %Shader*, %Shader*, %Shader*, %String*}* %fstruct, i32 0, i32 4
%arg_4 = load %String*, %String** %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_val_adhoc_W1NoYWRlclByb2dyYW0saTMyLFNoYWRlciosU2hhZGVyKixTaGFkZXIqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}*, {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}, {i8*, i8*, %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)*,  %ShaderProgram (i8*, i8*, i32, %Shader*, %Shader*, %Shader*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3, %String* %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2368 = hidden constant [55 x i8] c"hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ\00"
@gsxtmgl-objects2369 = hidden constant [59 x i8] c"{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}**\00"
define dllexport fastcc %ShaderProgram* @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ__5853(i8* %_impz,i8* %_impenv, %ShaderProgram* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5854 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}***}*
%hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQPtr_ = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQPtr = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}***, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}**** %hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQPtr_

; setup arguments
%xPtr = alloca %ShaderProgram*
store %ShaderProgram* %x, %ShaderProgram** %xPtr


%tzone5857 = load i8*, i8** %_impzPtr
%zone5858 = bitcast i8* %tzone5857 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %ShaderProgram*
%dat5855 = call i8* @malloc(i64 40)
call i8* @memset(i8* %dat5855, i32 0, i64 40)
%val5856 = bitcast i8* %dat5855 to %ShaderProgram*

; let value assignment
%obj = select i1 true, %ShaderProgram* %val5856, %ShaderProgram* %val5856
store %ShaderProgram* %obj, %ShaderProgram** %objPtr

; promote local stack var allocations
%tzone5929 = load i8*, i8** %_impzPtr
%zone5930 = bitcast i8* %tzone5929 to %mzone*
%ifptr5912 = alloca %String*
%ifptr5913 = alloca i1
%ifptr5896 = alloca %Shader*
%ifptr5897 = alloca i1
%ifptr5880 = alloca %Shader*
%ifptr5881 = alloca i1
%ifptr5864 = alloca %Shader*
%ifptr5865 = alloca i1
%val5859 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5860 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5861 = getelementptr %ShaderProgram, %ShaderProgram* %val5860, i64 0, i32 0
%val5862 = load i32, i32* %val5861
; set tuple
%val5863 = getelementptr %ShaderProgram, %ShaderProgram* %val5859, i64 0, i32 0
store i32 %val5862, i32* %val5863
%val5866 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5867 = getelementptr %ShaderProgram, %ShaderProgram* %val5866, i64 0, i32 1
%val5868 = load %Shader*, %Shader** %val5867
%val5869 = icmp eq %Shader* %val5868, null
br i1 %val5869, label %then5865, label %else5865

then5865:
%res5870 = call ccc i1 @impc_false()
store i1 %res5870, i1* %ifptr5865
br label %ifcont5865

else5865:
%res5871 = call ccc i1 @impc_true()
store i1 %res5871, i1* %ifptr5865
br label %ifcont5865

ifcont5865:
%ifres5872 = load i1, i1* %ifptr5865

br i1 %ifres5872, label %then5864, label %else5864

then5864:
%val5873 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5874 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5875 = getelementptr %ShaderProgram, %ShaderProgram* %val5874, i64 0, i32 1
%val5876 = load %Shader*, %Shader** %val5875
%res5877 = call fastcc %Shader* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0(%Shader* %val5876)
; set tuple
%val5878 = getelementptr %ShaderProgram, %ShaderProgram* %val5873, i64 0, i32 1
store %Shader* %res5877, %Shader** %val5878
store %Shader* %res5877, %Shader** %ifptr5864
br label %ifcont5864

else5864:
br label %ifcont5864

ifcont5864:
%ifres5879 = load %Shader*, %Shader** %ifptr5864

%val5882 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5883 = getelementptr %ShaderProgram, %ShaderProgram* %val5882, i64 0, i32 2
%val5884 = load %Shader*, %Shader** %val5883
%val5885 = icmp eq %Shader* %val5884, null
br i1 %val5885, label %then5881, label %else5881

then5881:
%res5886 = call ccc i1 @impc_false()
store i1 %res5886, i1* %ifptr5881
br label %ifcont5881

else5881:
%res5887 = call ccc i1 @impc_true()
store i1 %res5887, i1* %ifptr5881
br label %ifcont5881

ifcont5881:
%ifres5888 = load i1, i1* %ifptr5881

br i1 %ifres5888, label %then5880, label %else5880

then5880:
%val5889 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5890 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5891 = getelementptr %ShaderProgram, %ShaderProgram* %val5890, i64 0, i32 2
%val5892 = load %Shader*, %Shader** %val5891
%res5893 = call fastcc %Shader* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0(%Shader* %val5892)
; set tuple
%val5894 = getelementptr %ShaderProgram, %ShaderProgram* %val5889, i64 0, i32 2
store %Shader* %res5893, %Shader** %val5894
store %Shader* %res5893, %Shader** %ifptr5880
br label %ifcont5880

else5880:
br label %ifcont5880

ifcont5880:
%ifres5895 = load %Shader*, %Shader** %ifptr5880

%val5898 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5899 = getelementptr %ShaderProgram, %ShaderProgram* %val5898, i64 0, i32 3
%val5900 = load %Shader*, %Shader** %val5899
%val5901 = icmp eq %Shader* %val5900, null
br i1 %val5901, label %then5897, label %else5897

then5897:
%res5902 = call ccc i1 @impc_false()
store i1 %res5902, i1* %ifptr5897
br label %ifcont5897

else5897:
%res5903 = call ccc i1 @impc_true()
store i1 %res5903, i1* %ifptr5897
br label %ifcont5897

ifcont5897:
%ifres5904 = load i1, i1* %ifptr5897

br i1 %ifres5904, label %then5896, label %else5896

then5896:
%val5905 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5906 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5907 = getelementptr %ShaderProgram, %ShaderProgram* %val5906, i64 0, i32 3
%val5908 = load %Shader*, %Shader** %val5907
%res5909 = call fastcc %Shader* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0(%Shader* %val5908)
; set tuple
%val5910 = getelementptr %ShaderProgram, %ShaderProgram* %val5905, i64 0, i32 3
store %Shader* %res5909, %Shader** %val5910
store %Shader* %res5909, %Shader** %ifptr5896
br label %ifcont5896

else5896:
br label %ifcont5896

ifcont5896:
%ifres5911 = load %Shader*, %Shader** %ifptr5896

%val5914 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5915 = getelementptr %ShaderProgram, %ShaderProgram* %val5914, i64 0, i32 4
%val5916 = load %String*, %String** %val5915
%val5917 = icmp eq %String* %val5916, null
br i1 %val5917, label %then5913, label %else5913

then5913:
%res5918 = call ccc i1 @impc_false()
store i1 %res5918, i1* %ifptr5913
br label %ifcont5913

else5913:
%res5919 = call ccc i1 @impc_true()
store i1 %res5919, i1* %ifptr5913
br label %ifcont5913

ifcont5913:
%ifres5920 = load i1, i1* %ifptr5913

br i1 %ifres5920, label %then5912, label %else5912

then5912:
%val5921 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val5922 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5923 = getelementptr %ShaderProgram, %ShaderProgram* %val5922, i64 0, i32 4
%val5924 = load %String*, %String** %val5923
%res5925 = call fastcc %String* @hcopy_adhoc_W1N0cmluZyosU3RyaW5nKl0(%String* %val5924)
; set tuple
%val5926 = getelementptr %ShaderProgram, %ShaderProgram* %val5921, i64 0, i32 4
store %String* %res5925, %String** %val5926
store %String* %res5925, %String** %ifptr5912
br label %ifcont5912

else5912:
br label %ifcont5912

ifcont5912:
%ifres5927 = load %String*, %String** %ifptr5912

%val5928 = load %ShaderProgram*, %ShaderProgram** %objPtr
ret %ShaderProgram* %val5928
}
@gsxtmgl-objects2370 = hidden constant [108 x i8] c"hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}** @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone5950 = load i8*, i8** %_impzPtr
%zone5951 = bitcast i8* %tzone5950 to %mzone*

; let assign value to symbol hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ
%dat_hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ = call i8* @llvm_zone_malloc(%mzone* %zone5951, i64 8)
%hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQPtr = bitcast i8* %dat_hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ to { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}***
%tzone5931 = load i8*, i8** %_impzPtr
%zone5932 = bitcast i8* %tzone5931 to %mzone*
call void @llvm_zone_mark(%mzone* %zone5932)
; malloc closure structure
%clsptr5933 = call i8* @llvm_zone_malloc(%mzone* %zone5932, i64 24)
%closure5934 = bitcast i8* %clsptr5933 to { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}*

; malloc environment structure
%envptr5935 = call i8* @llvm_zone_malloc(%mzone* %zone5932, i64 8)
%environment5936 = bitcast i8* %envptr5935 to {{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}***}*

; malloc closure address table
%addytable5937 = call %clsvar* @new_address_table()
%var5938 = bitcast [55 x i8]* @gsxtmgl-objects2368 to i8*
%var5939 = bitcast [59 x i8]* @gsxtmgl-objects2369 to i8*
%addytable5940 = call %clsvar* @add_address_table(%mzone* %zone5932, i8* %var5938, i32 0, i8* %var5939, i32 3, %clsvar* %addytable5937)
%address-table5941 = bitcast %clsvar* %addytable5940 to i8*

; insert table, function and environment into closure struct
%closure.table5944 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}* %closure5934, i32 0, i32 0
store i8* %address-table5941, i8** %closure.table5944
%closure.env5945 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}* %closure5934, i32 0, i32 1
store i8* %envptr5935, i8** %closure.env5945
%closure.func5946 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}* %closure5934, i32 0, i32 2
store %ShaderProgram* (i8*, i8*, %ShaderProgram*)* @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ__5853, %ShaderProgram* (i8*, i8*, %ShaderProgram*)** %closure.func5946
%closure_size5947 = call i64 @llvm_zone_mark_size(%mzone* %zone5932)
call void @llvm_zone_ptr_set_size(i8* %clsptr5933, i64 %closure_size5947)
%wrapper_ptr5948 = call i8* @llvm_zone_malloc(%mzone* %zone5932, i64 8)
%closure_wrapper5949 = bitcast i8* %wrapper_ptr5948 to { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}**
store { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}* %closure5934, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper5949

; let value assignment
%hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ = select i1 true, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper5949, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper5949
store { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}** %hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}*** %hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQPtr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ
%tmp_envptr5943 = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}***}* %environment5936, i32 0, i32 0
store {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}*** %hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQPtr, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}**** %tmp_envptr5943


%val5952 = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}**, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}*** %hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQPtr
ret {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}** %val5952
}


@hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}** @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %ShaderProgram* @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %ShaderProgram*)*,  %ShaderProgram* (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret %ShaderProgram* %result
}


define dllexport ccc %ShaderProgram* @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_native(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %ShaderProgram*)*,  %ShaderProgram* (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret %ShaderProgram* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var5953 = bitcast [108 x i8]* @gsxtmgl-objects2370 to i8*
call i32 (i8*, ...) @printf(i8* %var5953)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %ShaderProgram*)*,  %ShaderProgram* (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%tmpres = bitcast %ShaderProgram* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*}*
%arg_p_0 = getelementptr {%ShaderProgram*}, {%ShaderProgram*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %ShaderProgram*)*,  %ShaderProgram* (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2371 = hidden constant [41 x i8] c"hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd\00"
@gsxtmgl-objects2372 = hidden constant [48 x i8] c"{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__5954(i8* %_impz,i8* %_impenv, %ShaderProgram* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone5955 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*
%hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_

; setup arguments
%xPtr = alloca %ShaderProgram*
store %ShaderProgram* %x, %ShaderProgram** %xPtr

; promote local stack var allocations
%tzone6012 = load i8*, i8** %_impzPtr
%zone6013 = bitcast i8* %tzone6012 to %mzone*
%ifptr5996 = alloca i1
%ifptr5983 = alloca i1
%ifptr5970 = alloca i1
%ifptr5957 = alloca i1

%val5958 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5959 = getelementptr %ShaderProgram, %ShaderProgram* %val5958, i64 0, i32 1
%val5960 = load %Shader*, %Shader** %val5959
%val5961 = icmp eq %Shader* %val5960, null
br i1 %val5961, label %then5957, label %else5957

then5957:
%res5962 = call ccc i1 @impc_false()
store i1 %res5962, i1* %ifptr5957
br label %ifcont5957

else5957:
%res5963 = call ccc i1 @impc_true()
store i1 %res5963, i1* %ifptr5957
br label %ifcont5957

ifcont5957:
%ifres5964 = load i1, i1* %ifptr5957

br i1 %ifres5964, label %then5956, label %else5956

then5956:
%val5965 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5966 = getelementptr %ShaderProgram, %ShaderProgram* %val5965, i64 0, i32 1
%val5967 = load %Shader*, %Shader** %val5966
call fastcc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0(%Shader* %val5967)
br label %ifcont5956

else5956:
br label %ifcont5956

ifcont5956:
%val5971 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5972 = getelementptr %ShaderProgram, %ShaderProgram* %val5971, i64 0, i32 2
%val5973 = load %Shader*, %Shader** %val5972
%val5974 = icmp eq %Shader* %val5973, null
br i1 %val5974, label %then5970, label %else5970

then5970:
%res5975 = call ccc i1 @impc_false()
store i1 %res5975, i1* %ifptr5970
br label %ifcont5970

else5970:
%res5976 = call ccc i1 @impc_true()
store i1 %res5976, i1* %ifptr5970
br label %ifcont5970

ifcont5970:
%ifres5977 = load i1, i1* %ifptr5970

br i1 %ifres5977, label %then5969, label %else5969

then5969:
%val5978 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5979 = getelementptr %ShaderProgram, %ShaderProgram* %val5978, i64 0, i32 2
%val5980 = load %Shader*, %Shader** %val5979
call fastcc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0(%Shader* %val5980)
br label %ifcont5969

else5969:
br label %ifcont5969

ifcont5969:
%val5984 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5985 = getelementptr %ShaderProgram, %ShaderProgram* %val5984, i64 0, i32 3
%val5986 = load %Shader*, %Shader** %val5985
%val5987 = icmp eq %Shader* %val5986, null
br i1 %val5987, label %then5983, label %else5983

then5983:
%res5988 = call ccc i1 @impc_false()
store i1 %res5988, i1* %ifptr5983
br label %ifcont5983

else5983:
%res5989 = call ccc i1 @impc_true()
store i1 %res5989, i1* %ifptr5983
br label %ifcont5983

ifcont5983:
%ifres5990 = load i1, i1* %ifptr5983

br i1 %ifres5990, label %then5982, label %else5982

then5982:
%val5991 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5992 = getelementptr %ShaderProgram, %ShaderProgram* %val5991, i64 0, i32 3
%val5993 = load %Shader*, %Shader** %val5992
call fastcc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0(%Shader* %val5993)
br label %ifcont5982

else5982:
br label %ifcont5982

ifcont5982:
%val5997 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val5998 = getelementptr %ShaderProgram, %ShaderProgram* %val5997, i64 0, i32 4
%val5999 = load %String*, %String** %val5998
%val6000 = icmp eq %String* %val5999, null
br i1 %val6000, label %then5996, label %else5996

then5996:
%res6001 = call ccc i1 @impc_false()
store i1 %res6001, i1* %ifptr5996
br label %ifcont5996

else5996:
%res6002 = call ccc i1 @impc_true()
store i1 %res6002, i1* %ifptr5996
br label %ifcont5996

ifcont5996:
%ifres6003 = load i1, i1* %ifptr5996

br i1 %ifres6003, label %then5995, label %else5995

then5995:
%val6004 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val6005 = getelementptr %ShaderProgram, %ShaderProgram* %val6004, i64 0, i32 4
%val6006 = load %String*, %String** %val6005
call fastcc void @hfree_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %val6006)
br label %ifcont5995

else5995:
br label %ifcont5995

ifcont5995:
%val6008 = load %ShaderProgram*, %ShaderProgram** %xPtr
%val6009 = bitcast %ShaderProgram* %val6008 to i8*
call ccc void @free(i8* %val6009)
ret void
}
@gsxtmgl-objects2373 = hidden constant [94 x i8] c"hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6033 = load i8*, i8** %_impzPtr
%zone6034 = bitcast i8* %tzone6033 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%dat_hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = call i8* @llvm_zone_malloc(%mzone* %zone6034, i64 8)
%hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***
%tzone6014 = load i8*, i8** %_impzPtr
%zone6015 = bitcast i8* %tzone6014 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6015)
; malloc closure structure
%clsptr6016 = call i8* @llvm_zone_malloc(%mzone* %zone6015, i64 24)
%closure6017 = bitcast i8* %clsptr6016 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*

; malloc environment structure
%envptr6018 = call i8* @llvm_zone_malloc(%mzone* %zone6015, i64 8)
%environment6019 = bitcast i8* %envptr6018 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*

; malloc closure address table
%addytable6020 = call %clsvar* @new_address_table()
%var6021 = bitcast [41 x i8]* @gsxtmgl-objects2371 to i8*
%var6022 = bitcast [48 x i8]* @gsxtmgl-objects2372 to i8*
%addytable6023 = call %clsvar* @add_address_table(%mzone* %zone6015, i8* %var6021, i32 0, i8* %var6022, i32 3, %clsvar* %addytable6020)
%address-table6024 = bitcast %clsvar* %addytable6023 to i8*

; insert table, function and environment into closure struct
%closure.table6027 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6017, i32 0, i32 0
store i8* %address-table6024, i8** %closure.table6027
%closure.env6028 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6017, i32 0, i32 1
store i8* %envptr6018, i8** %closure.env6028
%closure.func6029 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6017, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*)* @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__5954, void (i8*, i8*, %ShaderProgram*)** %closure.func6029
%closure_size6030 = call i64 @llvm_zone_mark_size(%mzone* %zone6015)
call void @llvm_zone_ptr_set_size(i8* %clsptr6016, i64 %closure_size6030)
%wrapper_ptr6031 = call i8* @llvm_zone_malloc(%mzone* %zone6015, i64 8)
%closure_wrapper6032 = bitcast i8* %wrapper_ptr6031 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6017, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6032

; let value assignment
%hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6032, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6032
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%tmp_envptr6026 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %environment6019, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %tmp_envptr6026


%val6035 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %val6035
}


@hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_native(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6036 = bitcast [94 x i8]* @gsxtmgl-objects2373 to i8*
call i32 (i8*, ...) @printf(i8* %var6036)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*}*
%arg_p_0 = getelementptr {%ShaderProgram*}, {%ShaderProgram*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2374 = hidden constant [73 x i8] c"zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd\00"
@gsxtmgl-objects2375 = hidden constant [77 x i8] c"{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %ShaderProgram* @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd__6037(i8* %_impz,i8* %_impenv, %ShaderProgram* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6038 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpdPtr_ = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpdPtr = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}***, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpdPtr_

; setup arguments
%xPtr = alloca %ShaderProgram*
store %ShaderProgram* %x, %ShaderProgram** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val6040 = load %mzone*, %mzone** %fromzPtr
%val6041 = load %ShaderProgram*, %ShaderProgram** %xPtr
%val6042 = bitcast %ShaderProgram* %val6041 to i8*
%res6043 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val6040, i8* %val6042)
br i1 %res6043, label %then6039, label %else6039

then6039:
%val6044 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val6044)
%zone_ptr6045 = bitcast %mzone* %val6044 to i8*
store i8* %zone_ptr6045, i8** %_impzPtr
%tzone6051 = load i8*, i8** %_impzPtr
%zone6052 = bitcast i8* %tzone6051 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %ShaderProgram*
%tzone6047 = load i8*, i8** %_impzPtr
%zone6048 = bitcast i8* %tzone6047 to %mzone*
%dat6049 = call i8* @llvm_zone_malloc(%mzone* %zone6048, i64 40)
call i8* @memset(i8* %dat6049, i32 0, i64 40)
%val6050 = bitcast i8* %dat6049 to %ShaderProgram*

; let value assignment
%obj = select i1 true, %ShaderProgram* %val6050, %ShaderProgram* %val6050
store %ShaderProgram* %obj, %ShaderProgram** %objPtr

; promote local stack var allocations
%tzone6134 = load i8*, i8** %_impzPtr
%zone6135 = bitcast i8* %tzone6134 to %mzone*
%ifptr6112 = alloca %String*
%ifptr6113 = alloca i1
%ifptr6094 = alloca %Shader*
%ifptr6095 = alloca i1
%ifptr6076 = alloca %Shader*
%ifptr6077 = alloca i1
%ifptr6058 = alloca %Shader*
%ifptr6059 = alloca i1
%val6053 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val6054 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val6055 = getelementptr %ShaderProgram, %ShaderProgram* %val6054, i64 0, i32 0
%val6056 = load i32, i32* %val6055
; set tuple
%val6057 = getelementptr %ShaderProgram, %ShaderProgram* %val6053, i64 0, i32 0
store i32 %val6056, i32* %val6057
%val6060 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val6061 = getelementptr %ShaderProgram, %ShaderProgram* %val6060, i64 0, i32 1
%val6062 = load %Shader*, %Shader** %val6061
%val6063 = icmp eq %Shader* %val6062, null
br i1 %val6063, label %then6059, label %else6059

then6059:
%res6064 = call ccc i1 @impc_false()
store i1 %res6064, i1* %ifptr6059
br label %ifcont6059

else6059:
%res6065 = call ccc i1 @impc_true()
store i1 %res6065, i1* %ifptr6059
br label %ifcont6059

ifcont6059:
%ifres6066 = load i1, i1* %ifptr6059

br i1 %ifres6066, label %then6058, label %else6058

then6058:
%val6067 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val6068 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val6069 = getelementptr %ShaderProgram, %ShaderProgram* %val6068, i64 0, i32 1
%val6070 = load %Shader*, %Shader** %val6069
%val6071 = load %mzone*, %mzone** %fromzPtr
%val6072 = load %mzone*, %mzone** %tozPtr
%res6073 = call fastcc %Shader* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ(%Shader* %val6070, %mzone* %val6071, %mzone* %val6072)
; set tuple
%val6074 = getelementptr %ShaderProgram, %ShaderProgram* %val6067, i64 0, i32 1
store %Shader* %res6073, %Shader** %val6074
store %Shader* %res6073, %Shader** %ifptr6058
br label %ifcont6058

else6058:
br label %ifcont6058

ifcont6058:
%ifres6075 = load %Shader*, %Shader** %ifptr6058

%val6078 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val6079 = getelementptr %ShaderProgram, %ShaderProgram* %val6078, i64 0, i32 2
%val6080 = load %Shader*, %Shader** %val6079
%val6081 = icmp eq %Shader* %val6080, null
br i1 %val6081, label %then6077, label %else6077

then6077:
%res6082 = call ccc i1 @impc_false()
store i1 %res6082, i1* %ifptr6077
br label %ifcont6077

else6077:
%res6083 = call ccc i1 @impc_true()
store i1 %res6083, i1* %ifptr6077
br label %ifcont6077

ifcont6077:
%ifres6084 = load i1, i1* %ifptr6077

br i1 %ifres6084, label %then6076, label %else6076

then6076:
%val6085 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val6086 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val6087 = getelementptr %ShaderProgram, %ShaderProgram* %val6086, i64 0, i32 2
%val6088 = load %Shader*, %Shader** %val6087
%val6089 = load %mzone*, %mzone** %fromzPtr
%val6090 = load %mzone*, %mzone** %tozPtr
%res6091 = call fastcc %Shader* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ(%Shader* %val6088, %mzone* %val6089, %mzone* %val6090)
; set tuple
%val6092 = getelementptr %ShaderProgram, %ShaderProgram* %val6085, i64 0, i32 2
store %Shader* %res6091, %Shader** %val6092
store %Shader* %res6091, %Shader** %ifptr6076
br label %ifcont6076

else6076:
br label %ifcont6076

ifcont6076:
%ifres6093 = load %Shader*, %Shader** %ifptr6076

%val6096 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val6097 = getelementptr %ShaderProgram, %ShaderProgram* %val6096, i64 0, i32 3
%val6098 = load %Shader*, %Shader** %val6097
%val6099 = icmp eq %Shader* %val6098, null
br i1 %val6099, label %then6095, label %else6095

then6095:
%res6100 = call ccc i1 @impc_false()
store i1 %res6100, i1* %ifptr6095
br label %ifcont6095

else6095:
%res6101 = call ccc i1 @impc_true()
store i1 %res6101, i1* %ifptr6095
br label %ifcont6095

ifcont6095:
%ifres6102 = load i1, i1* %ifptr6095

br i1 %ifres6102, label %then6094, label %else6094

then6094:
%val6103 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val6104 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val6105 = getelementptr %ShaderProgram, %ShaderProgram* %val6104, i64 0, i32 3
%val6106 = load %Shader*, %Shader** %val6105
%val6107 = load %mzone*, %mzone** %fromzPtr
%val6108 = load %mzone*, %mzone** %tozPtr
%res6109 = call fastcc %Shader* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ(%Shader* %val6106, %mzone* %val6107, %mzone* %val6108)
; set tuple
%val6110 = getelementptr %ShaderProgram, %ShaderProgram* %val6103, i64 0, i32 3
store %Shader* %res6109, %Shader** %val6110
store %Shader* %res6109, %Shader** %ifptr6094
br label %ifcont6094

else6094:
br label %ifcont6094

ifcont6094:
%ifres6111 = load %Shader*, %Shader** %ifptr6094

%val6114 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val6115 = getelementptr %ShaderProgram, %ShaderProgram* %val6114, i64 0, i32 4
%val6116 = load %String*, %String** %val6115
%val6117 = icmp eq %String* %val6116, null
br i1 %val6117, label %then6113, label %else6113

then6113:
%res6118 = call ccc i1 @impc_false()
store i1 %res6118, i1* %ifptr6113
br label %ifcont6113

else6113:
%res6119 = call ccc i1 @impc_true()
store i1 %res6119, i1* %ifptr6113
br label %ifcont6113

ifcont6113:
%ifres6120 = load i1, i1* %ifptr6113

br i1 %ifres6120, label %then6112, label %else6112

then6112:
%val6121 = load %ShaderProgram*, %ShaderProgram** %objPtr
%val6122 = load %ShaderProgram*, %ShaderProgram** %xPtr
; tuple ref
%val6123 = getelementptr %ShaderProgram, %ShaderProgram* %val6122, i64 0, i32 4
%val6124 = load %String*, %String** %val6123
%val6125 = load %mzone*, %mzone** %fromzPtr
%val6126 = load %mzone*, %mzone** %tozPtr
%res6127 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val6124, %mzone* %val6125, %mzone* %val6126)
; set tuple
%val6128 = getelementptr %ShaderProgram, %ShaderProgram* %val6121, i64 0, i32 4
store %String* %res6127, %String** %val6128
store %String* %res6127, %String** %ifptr6112
br label %ifcont6112

else6112:
br label %ifcont6112

ifcont6112:
%ifres6129 = load %String*, %String** %ifptr6112

%oldzone6130 = call %mzone* @llvm_pop_zone_stack()
%newzone6131 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr6132 = bitcast %mzone* %newzone6131 to i8*
store i8* %zone_ptr6132, i8** %_impzPtr
%val6133 = load %ShaderProgram*, %ShaderProgram** %objPtr
ret %ShaderProgram* %val6133

else6039:
%val6136 = load %ShaderProgram*, %ShaderProgram** %xPtr
ret %ShaderProgram* %val6136
}
@gsxtmgl-objects2376 = hidden constant [126 x i8] c"zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6156 = load i8*, i8** %_impzPtr
%zone6157 = bitcast i8* %tzone6156 to %mzone*

; let assign value to symbol zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd
%dat_zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd = call i8* @llvm_zone_malloc(%mzone* %zone6157, i64 8)
%zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpdPtr = bitcast i8* %dat_zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd to { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}***
%tzone6137 = load i8*, i8** %_impzPtr
%zone6138 = bitcast i8* %tzone6137 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6138)
; malloc closure structure
%clsptr6139 = call i8* @llvm_zone_malloc(%mzone* %zone6138, i64 24)
%closure6140 = bitcast i8* %clsptr6139 to { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr6141 = call i8* @llvm_zone_malloc(%mzone* %zone6138, i64 8)
%environment6142 = bitcast i8* %envptr6141 to {{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable6143 = call %clsvar* @new_address_table()
%var6144 = bitcast [73 x i8]* @gsxtmgl-objects2374 to i8*
%var6145 = bitcast [77 x i8]* @gsxtmgl-objects2375 to i8*
%addytable6146 = call %clsvar* @add_address_table(%mzone* %zone6138, i8* %var6144, i32 0, i8* %var6145, i32 3, %clsvar* %addytable6143)
%address-table6147 = bitcast %clsvar* %addytable6146 to i8*

; insert table, function and environment into closure struct
%closure.table6150 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}* %closure6140, i32 0, i32 0
store i8* %address-table6147, i8** %closure.table6150
%closure.env6151 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}* %closure6140, i32 0, i32 1
store i8* %envptr6141, i8** %closure.env6151
%closure.func6152 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}* %closure6140, i32 0, i32 2
store %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)* @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd__6037, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)** %closure.func6152
%closure_size6153 = call i64 @llvm_zone_mark_size(%mzone* %zone6138)
call void @llvm_zone_ptr_set_size(i8* %clsptr6139, i64 %closure_size6153)
%wrapper_ptr6154 = call i8* @llvm_zone_malloc(%mzone* %zone6138, i64 8)
%closure_wrapper6155 = bitcast i8* %wrapper_ptr6154 to { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}**
store { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}* %closure6140, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}** %closure_wrapper6155

; let value assignment
%zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd = select i1 true, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}** %closure_wrapper6155, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}** %closure_wrapper6155
store { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd, { i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpdPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd
%tmp_envptr6149 = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}***}* %environment6142, i32 0, i32 0
store {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpdPtr, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}**** %tmp_envptr6149


%val6158 = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}**, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpdPtr
ret {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}** %val6158
}


@zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %ShaderProgram* @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd(%ShaderProgram* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*,  %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %ShaderProgram* %result
}


define dllexport ccc %ShaderProgram* @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_native(%ShaderProgram* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*,  %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %ShaderProgram* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6159 = bitcast [126 x i8]* @gsxtmgl-objects2376 to i8*
call i32 (i8*, ...) @printf(i8* %var6159)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6160 = bitcast [126 x i8]* @gsxtmgl-objects2376 to i8*
call i32 (i8*, ...) @printf(i8* %var6160)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6161 = bitcast [126 x i8]* @gsxtmgl-objects2376 to i8*
call i32 (i8*, ...) @printf(i8* %var6161)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*,  %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %ShaderProgram* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%ShaderProgram*, %mzone*, %mzone*}, {%ShaderProgram*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
%arg_p_1 = getelementptr {%ShaderProgram*, %mzone*, %mzone*}, {%ShaderProgram*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%ShaderProgram*, %mzone*, %mzone*}, {%ShaderProgram*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlclByb2dyYW0qLFNoYWRlclByb2dyYW0qLG16b25lKixtem9uZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)*,  %ShaderProgram* (i8*, i8*, %ShaderProgram*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2377 = hidden constant [37 x i8] c"id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0\00"
@gsxtmgl-objects2378 = hidden constant [47 x i8] c"{i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}**\00"
define dllexport fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0__6162(i8* %_impz,i8* %_impenv, %ShaderProgram* %program) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6163 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}***}*
%id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 0
%id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}***, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}**** %id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0Ptr_

; setup arguments
%programPtr = alloca %ShaderProgram*
store %ShaderProgram* %program, %ShaderProgram** %programPtr


%val6165 = load %ShaderProgram*, %ShaderProgram** %programPtr
%val6166 = icmp eq %ShaderProgram* %val6165, null
br i1 %val6166, label %then6164, label %else6164

then6164:
ret i32 -1

else6164:
%val6167 = load %ShaderProgram*, %ShaderProgram** %programPtr
; tuple ref
%val6168 = getelementptr %ShaderProgram, %ShaderProgram* %val6167, i64 0, i32 0
%val6169 = load i32, i32* %val6168
ret i32 %val6169
}
@gsxtmgl-objects2379 = hidden constant [90 x i8] c"id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}** @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6189 = load i8*, i8** %_impzPtr
%zone6190 = bitcast i8* %tzone6189 to %mzone*

; let assign value to symbol id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0
%dat_id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0 = call i8* @llvm_zone_malloc(%mzone* %zone6190, i64 8)
%id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0Ptr = bitcast i8* %dat_id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0 to { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}***
%tzone6170 = load i8*, i8** %_impzPtr
%zone6171 = bitcast i8* %tzone6170 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6171)
; malloc closure structure
%clsptr6172 = call i8* @llvm_zone_malloc(%mzone* %zone6171, i64 24)
%closure6173 = bitcast i8* %clsptr6172 to { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}*

; malloc environment structure
%envptr6174 = call i8* @llvm_zone_malloc(%mzone* %zone6171, i64 8)
%environment6175 = bitcast i8* %envptr6174 to {{i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}***}*

; malloc closure address table
%addytable6176 = call %clsvar* @new_address_table()
%var6177 = bitcast [37 x i8]* @gsxtmgl-objects2377 to i8*
%var6178 = bitcast [47 x i8]* @gsxtmgl-objects2378 to i8*
%addytable6179 = call %clsvar* @add_address_table(%mzone* %zone6171, i8* %var6177, i32 0, i8* %var6178, i32 3, %clsvar* %addytable6176)
%address-table6180 = bitcast %clsvar* %addytable6179 to i8*

; insert table, function and environment into closure struct
%closure.table6183 = getelementptr { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}* %closure6173, i32 0, i32 0
store i8* %address-table6180, i8** %closure.table6183
%closure.env6184 = getelementptr { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}* %closure6173, i32 0, i32 1
store i8* %envptr6174, i8** %closure.env6184
%closure.func6185 = getelementptr { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}* %closure6173, i32 0, i32 2
store i32 (i8*, i8*, %ShaderProgram*)* @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0__6162, i32 (i8*, i8*, %ShaderProgram*)** %closure.func6185
%closure_size6186 = call i64 @llvm_zone_mark_size(%mzone* %zone6171)
call void @llvm_zone_ptr_set_size(i8* %clsptr6172, i64 %closure_size6186)
%wrapper_ptr6187 = call i8* @llvm_zone_malloc(%mzone* %zone6171, i64 8)
%closure_wrapper6188 = bitcast i8* %wrapper_ptr6187 to { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}**
store { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}* %closure6173, { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6188

; let value assignment
%id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6188, { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6188
store { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}** %id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0, { i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}*** %id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0Ptr

; add data to environment
; don't need to alloc for env var id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0
%tmp_envptr6182 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}***}* %environment6175, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}*** %id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0Ptr, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}**** %tmp_envptr6182


%val6191 = load {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}**, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}*** %id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}** %val6191
}


@id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_var = dllexport global [1 x i8*] [ i8* null ]

@id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}** @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %ShaderProgram*)*,  i32 (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_native(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %ShaderProgram*)*,  i32 (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6192 = bitcast [90 x i8]* @gsxtmgl-objects2379 to i8*
call i32 (i8*, ...) @printf(i8* %var6192)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %ShaderProgram*)*,  i32 (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*}*
%arg_p_0 = getelementptr {%ShaderProgram*}, {%ShaderProgram*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, i32 (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %ShaderProgram*)*,  i32 (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2380 = hidden constant [14 x i8] c"NULL PROGRAM!\00"
@gsxtmgl-objects2381 = hidden constant [44 x i8] c"name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd\00"
@gsxtmgl-objects2382 = hidden constant [52 x i8] c"{i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}**\00"
define dllexport fastcc %String* @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd__6193(i8* %_impz,i8* %_impenv, %ShaderProgram* %program) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6194 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}***}*
%name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpdPtr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 0
%name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpdPtr = load {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}***, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}**** %name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpdPtr_

; setup arguments
%programPtr = alloca %ShaderProgram*
store %ShaderProgram* %program, %ShaderProgram** %programPtr


%val6196 = load %ShaderProgram*, %ShaderProgram** %programPtr
%val6197 = icmp eq %ShaderProgram* %val6196, null
br i1 %val6197, label %then6195, label %else6195

then6195:
%var6198 = bitcast [14 x i8]* @gsxtmgl-objects2380 to i8*
%res6199 = call fastcc %String* @Str_adhoc_W1N0cmluZyosaTgqXQ(i8* %var6198)
ret %String* %res6199

else6195:
%val6200 = load %ShaderProgram*, %ShaderProgram** %programPtr
; tuple ref
%val6201 = getelementptr %ShaderProgram, %ShaderProgram* %val6200, i64 0, i32 4
%val6202 = load %String*, %String** %val6201
ret %String* %val6202
}
@gsxtmgl-objects2383 = hidden constant [97 x i8] c"name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}** @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6222 = load i8*, i8** %_impzPtr
%zone6223 = bitcast i8* %tzone6222 to %mzone*

; let assign value to symbol name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd
%dat_name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd = call i8* @llvm_zone_malloc(%mzone* %zone6223, i64 8)
%name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpdPtr = bitcast i8* %dat_name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd to { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}***
%tzone6203 = load i8*, i8** %_impzPtr
%zone6204 = bitcast i8* %tzone6203 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6204)
; malloc closure structure
%clsptr6205 = call i8* @llvm_zone_malloc(%mzone* %zone6204, i64 24)
%closure6206 = bitcast i8* %clsptr6205 to { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}*

; malloc environment structure
%envptr6207 = call i8* @llvm_zone_malloc(%mzone* %zone6204, i64 8)
%environment6208 = bitcast i8* %envptr6207 to {{i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}***}*

; malloc closure address table
%addytable6209 = call %clsvar* @new_address_table()
%var6210 = bitcast [44 x i8]* @gsxtmgl-objects2381 to i8*
%var6211 = bitcast [52 x i8]* @gsxtmgl-objects2382 to i8*
%addytable6212 = call %clsvar* @add_address_table(%mzone* %zone6204, i8* %var6210, i32 0, i8* %var6211, i32 3, %clsvar* %addytable6209)
%address-table6213 = bitcast %clsvar* %addytable6212 to i8*

; insert table, function and environment into closure struct
%closure.table6216 = getelementptr { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}* %closure6206, i32 0, i32 0
store i8* %address-table6213, i8** %closure.table6216
%closure.env6217 = getelementptr { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}* %closure6206, i32 0, i32 1
store i8* %envptr6207, i8** %closure.env6217
%closure.func6218 = getelementptr { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}* %closure6206, i32 0, i32 2
store %String* (i8*, i8*, %ShaderProgram*)* @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd__6193, %String* (i8*, i8*, %ShaderProgram*)** %closure.func6218
%closure_size6219 = call i64 @llvm_zone_mark_size(%mzone* %zone6204)
call void @llvm_zone_ptr_set_size(i8* %clsptr6205, i64 %closure_size6219)
%wrapper_ptr6220 = call i8* @llvm_zone_malloc(%mzone* %zone6204, i64 8)
%closure_wrapper6221 = bitcast i8* %wrapper_ptr6220 to { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}**
store { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}* %closure6206, { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6221

; let value assignment
%name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd = select i1 true, { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6221, { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6221
store { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}** %name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd, { i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}*** %name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpdPtr

; add data to environment
; don't need to alloc for env var name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd
%tmp_envptr6215 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}***}* %environment6208, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}*** %name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpdPtr, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}**** %tmp_envptr6215


%val6224 = load {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}**, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}*** %name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpdPtr
ret {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}** %val6224
}


@name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_var = dllexport global [1 x i8*] [ i8* null ]

@name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}** @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %ShaderProgram*)*,  %String* (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_native(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %ShaderProgram*)*,  %String* (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6225 = bitcast [97 x i8]* @gsxtmgl-objects2383 to i8*
call i32 (i8*, ...) @printf(i8* %var6225)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %ShaderProgram*)*,  %String* (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*}*
%arg_p_0 = getelementptr {%ShaderProgram*}, {%ShaderProgram*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @name_adhoc_W1N0cmluZyosU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, %String* (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %ShaderProgram*)*,  %String* (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2384 = hidden constant [21 x i8] c"NULL SHADER PROGRAM!\00"
@gsxtmgl-objects2385 = hidden constant [16 x i8] c"ShaderProgram: \00"
@gsxtmgl-objects2386 = hidden constant [41 x i8] c"print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd\00"
@gsxtmgl-objects2387 = hidden constant [15 x i8] c"_anon_lambda_3\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__6226(i8* %_impz,i8* %_impenv, %ShaderProgram* %program) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6239 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*
%print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_
%logbufPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 1
%logbufPtr = load i8**, i8*** %logbufPtr_
%max_log_lengthPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 2
%max_log_lengthPtr = load i32*, i32** %max_log_lengthPtr_
%_anon_lambda_3Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 3
%_anon_lambda_3Ptr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %_anon_lambda_3Ptr_

; setup arguments
%programPtr = alloca %ShaderProgram*
store %ShaderProgram* %program, %ShaderProgram** %programPtr


%val6241 = load %ShaderProgram*, %ShaderProgram** %programPtr
%val6242 = icmp eq %ShaderProgram* %val6241, null
br i1 %val6242, label %then6240, label %else6240

then6240:
%var6243 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var6244 = bitcast [21 x i8]* @gsxtmgl-objects2384 to i8*

%val6245 = call i32 (i8*, ...) @printf(i8* %var6243, i8* %var6244)
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret void

else6240:
%tzone6249 = load i8*, i8** %_impzPtr
%zone6250 = bitcast i8* %tzone6249 to %mzone*

; let assign value to symbol len_ptr
%len_ptrPtr = alloca i32*
%dat6248 = alloca i32, i64 1, align 16

; let value assignment
%len_ptr = select i1 true, i32* %dat6248, i32* %dat6248
store i32* %len_ptr, i32** %len_ptrPtr

; promote local stack var allocations
%tzone6283 = load i8*, i8** %_impzPtr
%zone6284 = bitcast i8* %tzone6283 to %mzone*
%ifptr6276 = alloca i64
%ifptr6267 = alloca i8*
%val6251 = load %ShaderProgram*, %ShaderProgram** %programPtr
%res6252 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6251)
%val6253 = load i32, i32* %max_log_lengthPtr
%val6254 = load i32*, i32** %len_ptrPtr
%val6255 = load i8*, i8** %logbufPtr
call fastcc void @glGetProgramInfoLog_adhoc_W3ZvaWQsaTMyLGkzMixpMzIqLGk4Kl0(i32 %res6252, i32 %val6253, i32* %val6254, i8* %val6255)
%var6257 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var6258 = bitcast [16 x i8]* @gsxtmgl-objects2385 to i8*

%val6259 = call i32 (i8*, ...) @printf(i8* %var6257, i8* %var6258)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%val6261 = load %ShaderProgram*, %ShaderProgram** %programPtr
; tuple ref
%val6262 = getelementptr %ShaderProgram, %ShaderProgram* %val6261, i64 0, i32 4
%val6263 = load %String*, %String** %val6262
call fastcc void @print_adhoc_W3ZvaWQsU3RyaW5nKl0(%String* %val6263)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%var6266 = bitcast [4 x i8]* @gsxtmgl-objects25 to i8*
%val6268 = load i32*, i32** %len_ptrPtr
; pointer ref
%val6269 = getelementptr i32, i32* %val6268, i64 0
%val6270 = load i32, i32* %val6269
%cmp6271 = icmp eq i32 %val6270, 0
br i1 %cmp6271, label %then6267, label %else6267

then6267:
%var6272 = bitcast [3 x i8]* @gsxtmgl-objects2345 to i8*
store i8* %var6272, i8** %ifptr6267
br label %ifcont6267

else6267:
%val6273 = load i8*, i8** %logbufPtr
store i8* %val6273, i8** %ifptr6267
br label %ifcont6267

ifcont6267:
%ifres6274 = load i8*, i8** %ifptr6267


%val6275 = call i32 (i8*, ...) @printf(i8* %var6266, i8* %ifres6274)
%val6277 = load i32*, i32** %len_ptrPtr
; pointer ref
%val6278 = getelementptr i32, i32* %val6277, i64 0
%val6279 = load i32, i32* %val6278
%cmp6280 = icmp eq i32 %val6279, 0
br i1 %cmp6280, label %then6276, label %else6276

then6276:
store i64 0, i64* %ifptr6276
br label %ifcont6276

else6276:
store i64 1, i64* %ifptr6276
br label %ifcont6276

ifcont6276:
%ifres6281 = load i64, i64* %ifptr6276

ret void
}
@gsxtmgl-objects2388 = hidden constant [94 x i8] c"print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6322 = load i8*, i8** %_impzPtr
%zone6323 = bitcast i8* %tzone6322 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%dat_print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = call i8* @llvm_zone_malloc(%mzone* %zone6323, i64 8)
%print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***
%tzone6227 = load i8*, i8** %_impzPtr
%zone6228 = bitcast i8* %tzone6227 to %mzone*

; let assign value to symbol max_log_length
%dat_max_log_length = call i8* @llvm_zone_malloc(%mzone* %zone6228, i64 4)
%max_log_lengthPtr = bitcast i8* %dat_max_log_length to i32*
%tzone6237 = load i8*, i8** %_impzPtr
%zone6238 = bitcast i8* %tzone6237 to %mzone*

; let assign value to symbol logbuf
%dat_logbuf = call i8* @llvm_zone_malloc(%mzone* %zone6238, i64 8)
%logbufPtr = bitcast i8* %dat_logbuf to i8**

; let value assignment
%max_log_length = select i1 true, i32 4096, i32 4096
store i32 %max_log_length, i32* %max_log_lengthPtr

%val6229 = load i32, i32* %max_log_lengthPtr
%tmp6230 = zext i32 %val6229 to i64
%val6231 = getelementptr i32, i32* null, i32 1
%zonesize6232 = mul i64 1, %tmp6230
%tzone6233 = load i8*, i8** %_impzPtr
%zone6234 = bitcast i8* %tzone6233 to %mzone*
%dat6235 = call i8* @llvm_zone_malloc(%mzone* %zone6234, i64 %zonesize6232)
call i8* @memset(i8* %dat6235, i32 0, i64 %zonesize6232)
%val6236 = bitcast i8* %dat6235 to i8*

; let value assignment
%logbuf = select i1 true, i8* %val6236, i8* %val6236
store i8* %logbuf, i8** %logbufPtr

%tzone6319 = load i8*, i8** %_impzPtr
%zone6320 = bitcast i8* %tzone6319 to %mzone*

; let assign value to symbol _anon_lambda_3
%dat__anon_lambda_3 = call i8* @llvm_zone_malloc(%mzone* %zone6320, i64 8)
%_anon_lambda_3Ptr = bitcast i8* %dat__anon_lambda_3 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***
%tzone6285 = load i8*, i8** %_impzPtr
%zone6286 = bitcast i8* %tzone6285 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6286)
; malloc closure structure
%clsptr6287 = call i8* @llvm_zone_malloc(%mzone* %zone6286, i64 24)
%closure6288 = bitcast i8* %clsptr6287 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*

; malloc environment structure
%envptr6289 = call i8* @llvm_zone_malloc(%mzone* %zone6286, i64 32)
%environment6290 = bitcast i8* %envptr6289 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*

; malloc closure address table
%addytable6291 = call %clsvar* @new_address_table()
%var6292 = bitcast [41 x i8]* @gsxtmgl-objects2386 to i8*
%var6293 = bitcast [48 x i8]* @gsxtmgl-objects2372 to i8*
%addytable6294 = call %clsvar* @add_address_table(%mzone* %zone6286, i8* %var6292, i32 0, i8* %var6293, i32 3, %clsvar* %addytable6291)
%var6295 = bitcast [7 x i8]* @gsxtmgl-objects2347 to i8*
%var6296 = bitcast [4 x i8]* @gsxtmgl-objects2348 to i8*
%addytable6297 = call %clsvar* @add_address_table(%mzone* %zone6286, i8* %var6295, i32 8, i8* %var6296, i32 3, %clsvar* %addytable6294)
%var6298 = bitcast [15 x i8]* @gsxtmgl-objects2349 to i8*
%var6299 = bitcast [4 x i8]* @gsxtmgl-objects274 to i8*
%addytable6300 = call %clsvar* @add_address_table(%mzone* %zone6286, i8* %var6298, i32 16, i8* %var6299, i32 3, %clsvar* %addytable6297)
%var6301 = bitcast [15 x i8]* @gsxtmgl-objects2387 to i8*
%var6302 = bitcast [48 x i8]* @gsxtmgl-objects2372 to i8*
%addytable6303 = call %clsvar* @add_address_table(%mzone* %zone6286, i8* %var6301, i32 24, i8* %var6302, i32 3, %clsvar* %addytable6300)
%address-table6304 = bitcast %clsvar* %addytable6303 to i8*

; insert table, function and environment into closure struct
%closure.table6313 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6288, i32 0, i32 0
store i8* %address-table6304, i8** %closure.table6313
%closure.env6314 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6288, i32 0, i32 1
store i8* %envptr6289, i8** %closure.env6314
%closure.func6315 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6288, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*)* @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__6226, void (i8*, i8*, %ShaderProgram*)** %closure.func6315
%closure_size6316 = call i64 @llvm_zone_mark_size(%mzone* %zone6286)
call void @llvm_zone_ptr_set_size(i8* %clsptr6287, i64 %closure_size6316)
%wrapper_ptr6317 = call i8* @llvm_zone_malloc(%mzone* %zone6286, i64 8)
%closure_wrapper6318 = bitcast i8* %wrapper_ptr6317 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6288, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6318

; let value assignment
%_anon_lambda_3 = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6318, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6318
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %_anon_lambda_3, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %_anon_lambda_3Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%tmp_envptr6306 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %environment6290, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %tmp_envptr6306

; don't need to alloc for env var logbuf
%tmp_envptr6308 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %environment6290, i32 0, i32 1
store i8** %logbufPtr, i8*** %tmp_envptr6308

; don't need to alloc for env var max_log_length
%tmp_envptr6310 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %environment6290, i32 0, i32 2
store i32* %max_log_lengthPtr, i32** %tmp_envptr6310

; don't need to alloc for env var _anon_lambda_3
%tmp_envptr6312 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, i8**, i32*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %environment6290, i32 0, i32 3
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %_anon_lambda_3Ptr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %tmp_envptr6312


%val6321 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %_anon_lambda_3Ptr

; let value assignment
%print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = select i1 true, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %val6321, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %val6321
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr

%val6324 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %val6324
}


@print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_native(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6325 = bitcast [94 x i8]* @gsxtmgl-objects2388 to i8*
call i32 (i8*, ...) @printf(i8* %var6325)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*}*
%arg_p_0 = getelementptr {%ShaderProgram*}, {%ShaderProgram*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2389 = hidden constant [62 x i8] c"Error: input shader types must be vert and frag respectively.\00"
@gsxtmgl-objects2390 = hidden constant [29 x i8] c"Error making shader program!\00"
@gsxtmgl-objects2391 = hidden constant [15 x i8] c"ShaderProgram:\00"
@gsxtmgl-objects2392 = hidden constant [75 x i8] c"ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ\00"
@gsxtmgl-objects2393 = hidden constant [72 x i8] c"{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}**\00"
define dllexport fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ__6326(i8* %_impz,i8* %_impenv, %String* %name_s_36, %Shader* %vert, %Shader* %frag) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6327 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}***}*
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQPtr_ = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQPtr = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}***, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}**** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQPtr_

; setup arguments
%name_s_36Ptr = alloca %String*
store %String* %name_s_36, %String** %name_s_36Ptr
%vertPtr = alloca %Shader*
store %Shader* %vert, %Shader** %vertPtr
%fragPtr = alloca %Shader*
store %Shader* %frag, %Shader** %fragPtr

; promote local stack var allocations
%tzone6387 = load i8*, i8** %_impzPtr
%zone6388 = bitcast i8* %tzone6387 to %mzone*
%ifptr6329 = alloca i1
%ifptr6330 = alloca i1
%ifptr6335 = alloca i1

%val6331 = load %Shader*, %Shader** %vertPtr
%res6332 = call fastcc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val6331)
%val6333 = load i32, i32* @GL_VERTEX_SHADER
%cmp6334 = icmp eq i32 %res6332, %val6333
br i1 %cmp6334, label %then6330, label %else6330

then6330:
%val6336 = load %Shader*, %Shader** %fragPtr
%res6337 = call fastcc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val6336)
%val6338 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp6339 = icmp eq i32 %res6337, %val6338
br i1 %cmp6339, label %then6335, label %else6335

then6335:
%val6340 = load %Shader*, %Shader** %fragPtr
%res6341 = call fastcc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val6340)
%val6342 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp6343 = icmp eq i32 %res6341, %val6342
store i1 %cmp6343, i1* %ifptr6335
br label %ifcont6335

else6335:
%res6344 = call ccc i1 @impc_false()
store i1 %res6344, i1* %ifptr6335
br label %ifcont6335

ifcont6335:
%ifres6345 = load i1, i1* %ifptr6335

store i1 %ifres6345, i1* %ifptr6330
br label %ifcont6330

else6330:
%res6346 = call ccc i1 @impc_false()
store i1 %res6346, i1* %ifptr6330
br label %ifcont6330

ifcont6330:
%ifres6347 = load i1, i1* %ifptr6330

br i1 %ifres6347, label %then6329, label %else6329

then6329:
%res6348 = call ccc i1 @impc_false()
store i1 %res6348, i1* %ifptr6329
br label %ifcont6329

else6329:
%res6349 = call ccc i1 @impc_true()
store i1 %res6349, i1* %ifptr6329
br label %ifcont6329

ifcont6329:
%ifres6350 = load i1, i1* %ifptr6329

br i1 %ifres6350, label %then6328, label %else6328

then6328:
%var6351 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var6352 = bitcast [62 x i8]* @gsxtmgl-objects2389 to i8*

%val6353 = call i32 (i8*, ...) @printf(i8* %var6351, i8* %var6352)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%null6355 = bitcast i8* null to %ShaderProgram*
ret %ShaderProgram* %null6355

else6328:
%tzone6362 = load i8*, i8** %_impzPtr
%zone6363 = bitcast i8* %tzone6362 to %mzone*

; let assign value to symbol program
%programPtr = alloca %ShaderProgram*
%res6356 = call fastcc i32 @glCreateProgram_adhoc_W2kzMl0()
%val6357 = load %Shader*, %Shader** %vertPtr
%val6358 = load %Shader*, %Shader** %fragPtr
%null6359 = bitcast i8* null to %Shader*
%val6360 = load %String*, %String** %name_s_36Ptr
%res6361 = call fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ(i32 %res6356, %Shader* %val6357, %Shader* %val6358, %Shader* %null6359, %String* %val6360)

; let value assignment
%program = select i1 true, %ShaderProgram* %res6361, %ShaderProgram* %res6361
store %ShaderProgram* %program, %ShaderProgram** %programPtr

%val6364 = load %ShaderProgram*, %ShaderProgram** %programPtr
%res6365 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6364)
%val6366 = load %Shader*, %Shader** %vertPtr
%res6367 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val6366)
call fastcc void @glAttachShader_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res6365, i32 %res6367)
%val6369 = load %ShaderProgram*, %ShaderProgram** %programPtr
%res6370 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6369)
%val6371 = load %Shader*, %Shader** %fragPtr
%res6372 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val6371)
call fastcc void @glAttachShader_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res6370, i32 %res6372)
%val6374 = load %ShaderProgram*, %ShaderProgram** %programPtr
%res6375 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6374)
call fastcc void @glLinkProgram_adhoc_W3ZvaWQsaTMyXQ(i32 %res6375)
%var6377 = bitcast [29 x i8]* @gsxtmgl-objects2390 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var6377)
%var6379 = bitcast [15 x i8]* @gsxtmgl-objects2391 to i8*
%res6380 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var6379)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res6380)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%val6383 = load %ShaderProgram*, %ShaderProgram** %programPtr
call fastcc void @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val6383)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val6386 = load %ShaderProgram*, %ShaderProgram** %programPtr
ret %ShaderProgram* %val6386
}
@gsxtmgl-objects2394 = hidden constant [128 x i8] c"ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}** @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6408 = load i8*, i8** %_impzPtr
%zone6409 = bitcast i8* %tzone6408 to %mzone*

; let assign value to symbol ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ
%dat_ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone6409, i64 8)
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQPtr = bitcast i8* %dat_ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ to { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}***
%tzone6389 = load i8*, i8** %_impzPtr
%zone6390 = bitcast i8* %tzone6389 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6390)
; malloc closure structure
%clsptr6391 = call i8* @llvm_zone_malloc(%mzone* %zone6390, i64 24)
%closure6392 = bitcast i8* %clsptr6391 to { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}*

; malloc environment structure
%envptr6393 = call i8* @llvm_zone_malloc(%mzone* %zone6390, i64 8)
%environment6394 = bitcast i8* %envptr6393 to {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}***}*

; malloc closure address table
%addytable6395 = call %clsvar* @new_address_table()
%var6396 = bitcast [75 x i8]* @gsxtmgl-objects2392 to i8*
%var6397 = bitcast [72 x i8]* @gsxtmgl-objects2393 to i8*
%addytable6398 = call %clsvar* @add_address_table(%mzone* %zone6390, i8* %var6396, i32 0, i8* %var6397, i32 3, %clsvar* %addytable6395)
%address-table6399 = bitcast %clsvar* %addytable6398 to i8*

; insert table, function and environment into closure struct
%closure.table6402 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}* %closure6392, i32 0, i32 0
store i8* %address-table6399, i8** %closure.table6402
%closure.env6403 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}* %closure6392, i32 0, i32 1
store i8* %envptr6393, i8** %closure.env6403
%closure.func6404 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}* %closure6392, i32 0, i32 2
store %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ__6326, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)** %closure.func6404
%closure_size6405 = call i64 @llvm_zone_mark_size(%mzone* %zone6390)
call void @llvm_zone_ptr_set_size(i8* %clsptr6391, i64 %closure_size6405)
%wrapper_ptr6406 = call i8* @llvm_zone_malloc(%mzone* %zone6390, i64 8)
%closure_wrapper6407 = bitcast i8* %wrapper_ptr6406 to { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}**
store { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}* %closure6392, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}** %closure_wrapper6407

; let value assignment
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ = select i1 true, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}** %closure_wrapper6407, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}** %closure_wrapper6407
store { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQPtr

; add data to environment
; don't need to alloc for env var ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ
%tmp_envptr6401 = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}***}* %environment6394, i32 0, i32 0
store {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQPtr, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}**** %tmp_envptr6401


%val6410 = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}**, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQPtr
ret {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}** %val6410
}


@ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}** @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ(%String* %arg_0,%Shader* %arg_1,%Shader* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*,  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %Shader* %arg_1, %Shader* %arg_2)
ret %ShaderProgram* %result
}


define dllexport ccc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_native(%String* %arg_0,%Shader* %arg_1,%Shader* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*,  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %Shader* %arg_1, %Shader* %arg_2)
ret %ShaderProgram* %result
}


define dllexport ccc i8*  @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6411 = bitcast [128 x i8]* @gsxtmgl-objects2394 to i8*
call i32 (i8*, ...) @printf(i8* %var6411)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6412 = bitcast [128 x i8]* @gsxtmgl-objects2394 to i8*
call i32 (i8*, ...) @printf(i8* %var6412)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Shader*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6413 = bitcast [128 x i8]* @gsxtmgl-objects2394 to i8*
call i32 (i8*, ...) @printf(i8* %var6413)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*,  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %Shader* %arg_1, %Shader* %arg_2)
%tmpres = bitcast %ShaderProgram* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %Shader*, %Shader*}*
%arg_p_0 = getelementptr {%String*, %Shader*, %Shader*}, {%String*, %Shader*, %Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %Shader*, %Shader*}, {%String*, %Shader*, %Shader*}* %fstruct, i32 0, i32 1
%arg_1 = load %Shader*, %Shader** %arg_p_1
%arg_p_2 = getelementptr {%String*, %Shader*, %Shader*}, {%String*, %Shader*, %Shader*}* %fstruct, i32 0, i32 2
%arg_2 = load %Shader*, %Shader** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)*,  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %Shader* %arg_1, %Shader* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2395 = hidden constant [68 x i8] c"Error: input shader types must be vert, geom and frag respectively.\00"
@gsxtmgl-objects2396 = hidden constant [85 x i8] c"ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd\00"
@gsxtmgl-objects2397 = hidden constant [82 x i8] c"{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}**\00"
define dllexport fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd__6414(i8* %_impz,i8* %_impenv, %String* %name_s_37, %Shader* %vert, %Shader* %geom, %Shader* %frag) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6415 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}***}*
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipdPtr_ = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipdPtr = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}***, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}**** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipdPtr_

; setup arguments
%name_s_37Ptr = alloca %String*
store %String* %name_s_37, %String** %name_s_37Ptr
%vertPtr = alloca %Shader*
store %Shader* %vert, %Shader** %vertPtr
%geomPtr = alloca %Shader*
store %Shader* %geom, %Shader** %geomPtr
%fragPtr = alloca %Shader*
store %Shader* %frag, %Shader** %fragPtr

; promote local stack var allocations
%tzone6487 = load i8*, i8** %_impzPtr
%zone6488 = bitcast i8* %tzone6487 to %mzone*
%ifptr6417 = alloca i1
%ifptr6418 = alloca i1
%ifptr6423 = alloca i1
%ifptr6428 = alloca i1

%val6419 = load %Shader*, %Shader** %vertPtr
%res6420 = call fastcc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val6419)
%val6421 = load i32, i32* @GL_VERTEX_SHADER
%cmp6422 = icmp eq i32 %res6420, %val6421
br i1 %cmp6422, label %then6418, label %else6418

then6418:
%val6424 = load %Shader*, %Shader** %geomPtr
%res6425 = call fastcc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val6424)
%val6426 = load i32, i32* @GL_GEOMETRY_SHADER
%cmp6427 = icmp eq i32 %res6425, %val6426
br i1 %cmp6427, label %then6423, label %else6423

then6423:
%val6429 = load %Shader*, %Shader** %fragPtr
%res6430 = call fastcc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val6429)
%val6431 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp6432 = icmp eq i32 %res6430, %val6431
br i1 %cmp6432, label %then6428, label %else6428

then6428:
%val6433 = load %Shader*, %Shader** %fragPtr
%res6434 = call fastcc i32 @type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val6433)
%val6435 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp6436 = icmp eq i32 %res6434, %val6435
store i1 %cmp6436, i1* %ifptr6428
br label %ifcont6428

else6428:
%res6437 = call ccc i1 @impc_false()
store i1 %res6437, i1* %ifptr6428
br label %ifcont6428

ifcont6428:
%ifres6438 = load i1, i1* %ifptr6428

store i1 %ifres6438, i1* %ifptr6423
br label %ifcont6423

else6423:
%res6439 = call ccc i1 @impc_false()
store i1 %res6439, i1* %ifptr6423
br label %ifcont6423

ifcont6423:
%ifres6440 = load i1, i1* %ifptr6423

store i1 %ifres6440, i1* %ifptr6418
br label %ifcont6418

else6418:
%res6441 = call ccc i1 @impc_false()
store i1 %res6441, i1* %ifptr6418
br label %ifcont6418

ifcont6418:
%ifres6442 = load i1, i1* %ifptr6418

br i1 %ifres6442, label %then6417, label %else6417

then6417:
%res6443 = call ccc i1 @impc_false()
store i1 %res6443, i1* %ifptr6417
br label %ifcont6417

else6417:
%res6444 = call ccc i1 @impc_true()
store i1 %res6444, i1* %ifptr6417
br label %ifcont6417

ifcont6417:
%ifres6445 = load i1, i1* %ifptr6417

br i1 %ifres6445, label %then6416, label %else6416

then6416:
%var6446 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var6447 = bitcast [68 x i8]* @gsxtmgl-objects2395 to i8*

%val6448 = call i32 (i8*, ...) @printf(i8* %var6446, i8* %var6447)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%null6450 = bitcast i8* null to %ShaderProgram*
ret %ShaderProgram* %null6450

else6416:
%tzone6457 = load i8*, i8** %_impzPtr
%zone6458 = bitcast i8* %tzone6457 to %mzone*

; let assign value to symbol program
%programPtr = alloca %ShaderProgram*
%res6451 = call fastcc i32 @glCreateProgram_adhoc_W2kzMl0()
%val6452 = load %Shader*, %Shader** %vertPtr
%val6453 = load %Shader*, %Shader** %fragPtr
%val6454 = load %Shader*, %Shader** %geomPtr
%val6455 = load %String*, %String** %name_s_37Ptr
%res6456 = call fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLGkzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKixTdHJpbmcqXQ(i32 %res6451, %Shader* %val6452, %Shader* %val6453, %Shader* %val6454, %String* %val6455)

; let value assignment
%program = select i1 true, %ShaderProgram* %res6456, %ShaderProgram* %res6456
store %ShaderProgram* %program, %ShaderProgram** %programPtr

%val6459 = load %ShaderProgram*, %ShaderProgram** %programPtr
%res6460 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6459)
%val6461 = load %Shader*, %Shader** %vertPtr
%res6462 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val6461)
call fastcc void @glAttachShader_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res6460, i32 %res6462)
%val6464 = load %ShaderProgram*, %ShaderProgram** %programPtr
%res6465 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6464)
%val6466 = load %Shader*, %Shader** %geomPtr
%res6467 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val6466)
call fastcc void @glAttachShader_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res6465, i32 %res6467)
%val6469 = load %ShaderProgram*, %ShaderProgram** %programPtr
%res6470 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6469)
%val6471 = load %Shader*, %Shader** %fragPtr
%res6472 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val6471)
call fastcc void @glAttachShader_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %res6470, i32 %res6472)
%val6474 = load %ShaderProgram*, %ShaderProgram** %programPtr
%res6475 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6474)
call fastcc void @glLinkProgram_adhoc_W3ZvaWQsaTMyXQ(i32 %res6475)
%var6477 = bitcast [29 x i8]* @gsxtmgl-objects2390 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var6477)
%var6479 = bitcast [15 x i8]* @gsxtmgl-objects2391 to i8*
%res6480 = call fastcc %Symbol* @Symbol_adhoc_W1N5bWJvbCosaTgqXQ(i8* %var6479)
call fastcc void @print_adhoc_W3ZvaWQsU3ltYm9sKl0(%Symbol* %res6480)
call fastcc void @print_space_adhoc_W3ZvaWRd()
%val6483 = load %ShaderProgram*, %ShaderProgram** %programPtr
call fastcc void @print_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %val6483)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%val6486 = load %ShaderProgram*, %ShaderProgram** %programPtr
ret %ShaderProgram* %val6486
}
@gsxtmgl-objects2398 = hidden constant [138 x i8] c"ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}** @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6508 = load i8*, i8** %_impzPtr
%zone6509 = bitcast i8* %tzone6508 to %mzone*

; let assign value to symbol ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd
%dat_ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd = call i8* @llvm_zone_malloc(%mzone* %zone6509, i64 8)
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipdPtr = bitcast i8* %dat_ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd to { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}***
%tzone6489 = load i8*, i8** %_impzPtr
%zone6490 = bitcast i8* %tzone6489 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6490)
; malloc closure structure
%clsptr6491 = call i8* @llvm_zone_malloc(%mzone* %zone6490, i64 24)
%closure6492 = bitcast i8* %clsptr6491 to { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}*

; malloc environment structure
%envptr6493 = call i8* @llvm_zone_malloc(%mzone* %zone6490, i64 8)
%environment6494 = bitcast i8* %envptr6493 to {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}***}*

; malloc closure address table
%addytable6495 = call %clsvar* @new_address_table()
%var6496 = bitcast [85 x i8]* @gsxtmgl-objects2396 to i8*
%var6497 = bitcast [82 x i8]* @gsxtmgl-objects2397 to i8*
%addytable6498 = call %clsvar* @add_address_table(%mzone* %zone6490, i8* %var6496, i32 0, i8* %var6497, i32 3, %clsvar* %addytable6495)
%address-table6499 = bitcast %clsvar* %addytable6498 to i8*

; insert table, function and environment into closure struct
%closure.table6502 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}* %closure6492, i32 0, i32 0
store i8* %address-table6499, i8** %closure.table6502
%closure.env6503 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}* %closure6492, i32 0, i32 1
store i8* %envptr6493, i8** %closure.env6503
%closure.func6504 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}* %closure6492, i32 0, i32 2
store %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd__6414, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)** %closure.func6504
%closure_size6505 = call i64 @llvm_zone_mark_size(%mzone* %zone6490)
call void @llvm_zone_ptr_set_size(i8* %clsptr6491, i64 %closure_size6505)
%wrapper_ptr6506 = call i8* @llvm_zone_malloc(%mzone* %zone6490, i64 8)
%closure_wrapper6507 = bitcast i8* %wrapper_ptr6506 to { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}**
store { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}* %closure6492, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}** %closure_wrapper6507

; let value assignment
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd = select i1 true, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}** %closure_wrapper6507, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}** %closure_wrapper6507
store { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipdPtr

; add data to environment
; don't need to alloc for env var ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd
%tmp_envptr6501 = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}***}* %environment6494, i32 0, i32 0
store {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipdPtr, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}**** %tmp_envptr6501


%val6510 = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}**, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipdPtr
ret {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}** %val6510
}


@ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}** @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd(%String* %arg_0,%Shader* %arg_1,%Shader* %arg_2,%Shader* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*,  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3)
ret %ShaderProgram* %result
}


define dllexport ccc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_native(%String* %arg_0,%Shader* %arg_1,%Shader* %arg_2,%Shader* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*,  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3)
ret %ShaderProgram* %result
}


define dllexport ccc i8*  @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6511 = bitcast [138 x i8]* @gsxtmgl-objects2398 to i8*
call i32 (i8*, ...) @printf(i8* %var6511)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6512 = bitcast [138 x i8]* @gsxtmgl-objects2398 to i8*
call i32 (i8*, ...) @printf(i8* %var6512)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Shader*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6513 = bitcast [138 x i8]* @gsxtmgl-objects2398 to i8*
call i32 (i8*, ...) @printf(i8* %var6513)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Shader*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var6514 = bitcast [138 x i8]* @gsxtmgl-objects2398 to i8*
call i32 (i8*, ...) @printf(i8* %var6514)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*,  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3)
%tmpres = bitcast %ShaderProgram* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %Shader*, %Shader*, %Shader*}*
%arg_p_0 = getelementptr {%String*, %Shader*, %Shader*, %Shader*}, {%String*, %Shader*, %Shader*, %Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %Shader*, %Shader*, %Shader*}, {%String*, %Shader*, %Shader*, %Shader*}* %fstruct, i32 0, i32 1
%arg_1 = load %Shader*, %Shader** %arg_p_1
%arg_p_2 = getelementptr {%String*, %Shader*, %Shader*, %Shader*}, {%String*, %Shader*, %Shader*, %Shader*}* %fstruct, i32 0, i32 2
%arg_2 = load %Shader*, %Shader** %arg_p_2
%arg_p_3 = getelementptr {%String*, %Shader*, %Shader*, %Shader*}, {%String*, %Shader*, %Shader*, %Shader*}* %fstruct, i32 0, i32 3
%arg_3 = load %Shader*, %Shader** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)*,  %ShaderProgram* (i8*, i8*, %String*, %Shader*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %Shader* %arg_1, %Shader* %arg_2, %Shader* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2399 = hidden constant [24 x i8] c"Error compiling Shaders\00"
@gsxtmgl-objects2400 = hidden constant [75 x i8] c"ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ\00"
@gsxtmgl-objects2401 = hidden constant [72 x i8] c"{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}**\00"
define dllexport fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ__6515(i8* %_impz,i8* %_impenv, %String* %name_s_38, %String* %vsource, %String* %fsource) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6516 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}***}*
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}***, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}**** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr_

; setup arguments
%name_s_38Ptr = alloca %String*
store %String* %name_s_38, %String** %name_s_38Ptr
%vsourcePtr = alloca %String*
store %String* %vsource, %String** %vsourcePtr
%fsourcePtr = alloca %String*
store %String* %fsource, %String** %fsourcePtr


%tzone6520 = load i8*, i8** %_impzPtr
%zone6521 = bitcast i8* %tzone6520 to %mzone*

; let assign value to symbol vert
%vertPtr = alloca %Shader*
%tzone6525 = load i8*, i8** %_impzPtr
%zone6526 = bitcast i8* %tzone6525 to %mzone*

; let assign value to symbol frag
%fragPtr = alloca %Shader*
%val6517 = load %String*, %String** %vsourcePtr
%val6518 = load i32, i32* @GL_VERTEX_SHADER
%res6519 = call fastcc %Shader* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd(%String* %val6517, i32 %val6518)

; let value assignment
%vert = select i1 true, %Shader* %res6519, %Shader* %res6519
store %Shader* %vert, %Shader** %vertPtr

%val6522 = load %String*, %String** %fsourcePtr
%val6523 = load i32, i32* @GL_FRAGMENT_SHADER
%res6524 = call fastcc %Shader* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd(%String* %val6522, i32 %val6523)

; let value assignment
%frag = select i1 true, %Shader* %res6524, %Shader* %res6524
store %Shader* %frag, %Shader** %fragPtr

; promote local stack var allocations
%tzone6548 = load i8*, i8** %_impzPtr
%zone6549 = bitcast i8* %tzone6548 to %mzone*
%ifptr6530 = alloca i1
%ifptr6535 = alloca i1
%var6527 = bitcast [24 x i8]* @gsxtmgl-objects2399 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var6527)
%val6531 = load %Shader*, %Shader** %vertPtr
%val6532 = icmp eq %Shader* %val6531, null
br i1 %val6532, label %then6530, label %else6530

then6530:
%val6533 = load %Shader*, %Shader** %vertPtr
%val6534 = icmp eq %Shader* %val6533, null
store i1 %val6534, i1* %ifptr6530
br label %ifcont6530

else6530:
%val6536 = load %Shader*, %Shader** %fragPtr
%val6537 = icmp eq %Shader* %val6536, null
br i1 %val6537, label %then6535, label %else6535

then6535:
%val6538 = load %Shader*, %Shader** %fragPtr
%val6539 = icmp eq %Shader* %val6538, null
store i1 %val6539, i1* %ifptr6535
br label %ifcont6535

else6535:
%res6540 = call ccc i1 @impc_false()
store i1 %res6540, i1* %ifptr6535
br label %ifcont6535

ifcont6535:
%ifres6541 = load i1, i1* %ifptr6535

store i1 %ifres6541, i1* %ifptr6530
br label %ifcont6530

ifcont6530:
%ifres6542 = load i1, i1* %ifptr6530

br i1 %ifres6542, label %then6529, label %else6529

then6529:
%null6543 = bitcast i8* null to %ShaderProgram*
ret %ShaderProgram* %null6543

else6529:
%val6544 = load %String*, %String** %name_s_38Ptr
%val6545 = load %Shader*, %Shader** %vertPtr
%val6546 = load %Shader*, %Shader** %fragPtr
%res6547 = call fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqXQ(%String* %val6544, %Shader* %val6545, %Shader* %val6546)
ret %ShaderProgram* %res6547
}
@gsxtmgl-objects2402 = hidden constant [128 x i8] c"ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}** @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6569 = load i8*, i8** %_impzPtr
%zone6570 = bitcast i8* %tzone6569 to %mzone*

; let assign value to symbol ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ
%dat_ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone6570, i64 8)
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr = bitcast i8* %dat_ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ to { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}***
%tzone6550 = load i8*, i8** %_impzPtr
%zone6551 = bitcast i8* %tzone6550 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6551)
; malloc closure structure
%clsptr6552 = call i8* @llvm_zone_malloc(%mzone* %zone6551, i64 24)
%closure6553 = bitcast i8* %clsptr6552 to { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}*

; malloc environment structure
%envptr6554 = call i8* @llvm_zone_malloc(%mzone* %zone6551, i64 8)
%environment6555 = bitcast i8* %envptr6554 to {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}***}*

; malloc closure address table
%addytable6556 = call %clsvar* @new_address_table()
%var6557 = bitcast [75 x i8]* @gsxtmgl-objects2400 to i8*
%var6558 = bitcast [72 x i8]* @gsxtmgl-objects2401 to i8*
%addytable6559 = call %clsvar* @add_address_table(%mzone* %zone6551, i8* %var6557, i32 0, i8* %var6558, i32 3, %clsvar* %addytable6556)
%address-table6560 = bitcast %clsvar* %addytable6559 to i8*

; insert table, function and environment into closure struct
%closure.table6563 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}* %closure6553, i32 0, i32 0
store i8* %address-table6560, i8** %closure.table6563
%closure.env6564 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}* %closure6553, i32 0, i32 1
store i8* %envptr6554, i8** %closure.env6564
%closure.func6565 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}* %closure6553, i32 0, i32 2
store %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ__6515, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)** %closure.func6565
%closure_size6566 = call i64 @llvm_zone_mark_size(%mzone* %zone6551)
call void @llvm_zone_ptr_set_size(i8* %clsptr6552, i64 %closure_size6566)
%wrapper_ptr6567 = call i8* @llvm_zone_malloc(%mzone* %zone6551, i64 8)
%closure_wrapper6568 = bitcast i8* %wrapper_ptr6567 to { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}**
store { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}* %closure6553, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper6568

; let value assignment
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ = select i1 true, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper6568, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}** %closure_wrapper6568
store { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ
%tmp_envptr6562 = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}***}* %environment6555, i32 0, i32 0
store {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}**** %tmp_envptr6562


%val6571 = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}**, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQPtr
ret {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}** %val6571
}


@ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}** @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %arg_0,%String* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*,  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
ret %ShaderProgram* %result
}


define dllexport ccc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_native(%String* %arg_0,%String* %arg_1,%String* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*,  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
ret %ShaderProgram* %result
}


define dllexport ccc i8*  @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6572 = bitcast [128 x i8]* @gsxtmgl-objects2402 to i8*
call i32 (i8*, ...) @printf(i8* %var6572)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6573 = bitcast [128 x i8]* @gsxtmgl-objects2402 to i8*
call i32 (i8*, ...) @printf(i8* %var6573)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6574 = bitcast [128 x i8]* @gsxtmgl-objects2402 to i8*
call i32 (i8*, ...) @printf(i8* %var6574)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*,  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
%tmpres = bitcast %ShaderProgram* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
%arg_p_2 = getelementptr {%String*, %String*, %String*}, {%String*, %String*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)*,  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2403 = hidden constant [85 x i8] c"ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd\00"
@gsxtmgl-objects2404 = hidden constant [82 x i8] c"{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}**\00"
define dllexport fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd__6575(i8* %_impz,i8* %_impenv, %String* %name_s_39, %String* %vsource, %String* %gsource, %String* %fsource) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6576 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}***}*
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr_ = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}***, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}**** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr_

; setup arguments
%name_s_39Ptr = alloca %String*
store %String* %name_s_39, %String** %name_s_39Ptr
%vsourcePtr = alloca %String*
store %String* %vsource, %String** %vsourcePtr
%gsourcePtr = alloca %String*
store %String* %gsource, %String** %gsourcePtr
%fsourcePtr = alloca %String*
store %String* %fsource, %String** %fsourcePtr


%tzone6580 = load i8*, i8** %_impzPtr
%zone6581 = bitcast i8* %tzone6580 to %mzone*

; let assign value to symbol vert
%vertPtr = alloca %Shader*
%tzone6585 = load i8*, i8** %_impzPtr
%zone6586 = bitcast i8* %tzone6585 to %mzone*

; let assign value to symbol geom
%geomPtr = alloca %Shader*
%tzone6590 = load i8*, i8** %_impzPtr
%zone6591 = bitcast i8* %tzone6590 to %mzone*

; let assign value to symbol frag
%fragPtr = alloca %Shader*
%val6577 = load %String*, %String** %vsourcePtr
%val6578 = load i32, i32* @GL_VERTEX_SHADER
%res6579 = call fastcc %Shader* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd(%String* %val6577, i32 %val6578)

; let value assignment
%vert = select i1 true, %Shader* %res6579, %Shader* %res6579
store %Shader* %vert, %Shader** %vertPtr

%val6582 = load %String*, %String** %gsourcePtr
%val6583 = load i32, i32* @GL_GEOMETRY_SHADER
%res6584 = call fastcc %Shader* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd(%String* %val6582, i32 %val6583)

; let value assignment
%geom = select i1 true, %Shader* %res6584, %Shader* %res6584
store %Shader* %geom, %Shader** %geomPtr

%val6587 = load %String*, %String** %fsourcePtr
%val6588 = load i32, i32* @GL_FRAGMENT_SHADER
%res6589 = call fastcc %Shader* @Shader_adhoc_W1NoYWRlciosU3RyaW5nKixpMzJd(%String* %val6587, i32 %val6588)

; let value assignment
%frag = select i1 true, %Shader* %res6589, %Shader* %res6589
store %Shader* %frag, %Shader** %fragPtr

; promote local stack var allocations
%tzone6620 = load i8*, i8** %_impzPtr
%zone6621 = bitcast i8* %tzone6620 to %mzone*
%ifptr6595 = alloca i1
%ifptr6600 = alloca i1
%ifptr6605 = alloca i1
%var6592 = bitcast [24 x i8]* @gsxtmgl-objects2399 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var6592)
%val6596 = load %Shader*, %Shader** %vertPtr
%val6597 = icmp eq %Shader* %val6596, null
br i1 %val6597, label %then6595, label %else6595

then6595:
%val6598 = load %Shader*, %Shader** %vertPtr
%val6599 = icmp eq %Shader* %val6598, null
store i1 %val6599, i1* %ifptr6595
br label %ifcont6595

else6595:
%val6601 = load %Shader*, %Shader** %geomPtr
%val6602 = icmp eq %Shader* %val6601, null
br i1 %val6602, label %then6600, label %else6600

then6600:
%val6603 = load %Shader*, %Shader** %geomPtr
%val6604 = icmp eq %Shader* %val6603, null
store i1 %val6604, i1* %ifptr6600
br label %ifcont6600

else6600:
%val6606 = load %Shader*, %Shader** %fragPtr
%val6607 = icmp eq %Shader* %val6606, null
br i1 %val6607, label %then6605, label %else6605

then6605:
%val6608 = load %Shader*, %Shader** %fragPtr
%val6609 = icmp eq %Shader* %val6608, null
store i1 %val6609, i1* %ifptr6605
br label %ifcont6605

else6605:
%res6610 = call ccc i1 @impc_false()
store i1 %res6610, i1* %ifptr6605
br label %ifcont6605

ifcont6605:
%ifres6611 = load i1, i1* %ifptr6605

store i1 %ifres6611, i1* %ifptr6600
br label %ifcont6600

ifcont6600:
%ifres6612 = load i1, i1* %ifptr6600

store i1 %ifres6612, i1* %ifptr6595
br label %ifcont6595

ifcont6595:
%ifres6613 = load i1, i1* %ifptr6595

br i1 %ifres6613, label %then6594, label %else6594

then6594:
%null6614 = bitcast i8* null to %ShaderProgram*
ret %ShaderProgram* %null6614

else6594:
%val6615 = load %String*, %String** %name_s_39Ptr
%val6616 = load %Shader*, %Shader** %vertPtr
%val6617 = load %Shader*, %Shader** %geomPtr
%val6618 = load %Shader*, %Shader** %fragPtr
%res6619 = call fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU2hhZGVyKixTaGFkZXIqLFNoYWRlcipd(%String* %val6615, %Shader* %val6616, %Shader* %val6617, %Shader* %val6618)
ret %ShaderProgram* %res6619
}
@gsxtmgl-objects2405 = hidden constant [138 x i8] c"ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}** @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6641 = load i8*, i8** %_impzPtr
%zone6642 = bitcast i8* %tzone6641 to %mzone*

; let assign value to symbol ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd
%dat_ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd = call i8* @llvm_zone_malloc(%mzone* %zone6642, i64 8)
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr = bitcast i8* %dat_ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd to { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}***
%tzone6622 = load i8*, i8** %_impzPtr
%zone6623 = bitcast i8* %tzone6622 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6623)
; malloc closure structure
%clsptr6624 = call i8* @llvm_zone_malloc(%mzone* %zone6623, i64 24)
%closure6625 = bitcast i8* %clsptr6624 to { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}*

; malloc environment structure
%envptr6626 = call i8* @llvm_zone_malloc(%mzone* %zone6623, i64 8)
%environment6627 = bitcast i8* %envptr6626 to {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}***}*

; malloc closure address table
%addytable6628 = call %clsvar* @new_address_table()
%var6629 = bitcast [85 x i8]* @gsxtmgl-objects2403 to i8*
%var6630 = bitcast [82 x i8]* @gsxtmgl-objects2404 to i8*
%addytable6631 = call %clsvar* @add_address_table(%mzone* %zone6623, i8* %var6629, i32 0, i8* %var6630, i32 3, %clsvar* %addytable6628)
%address-table6632 = bitcast %clsvar* %addytable6631 to i8*

; insert table, function and environment into closure struct
%closure.table6635 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}* %closure6625, i32 0, i32 0
store i8* %address-table6632, i8** %closure.table6635
%closure.env6636 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}* %closure6625, i32 0, i32 1
store i8* %envptr6626, i8** %closure.env6636
%closure.func6637 = getelementptr { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}* %closure6625, i32 0, i32 2
store %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd__6575, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)** %closure.func6637
%closure_size6638 = call i64 @llvm_zone_mark_size(%mzone* %zone6623)
call void @llvm_zone_ptr_set_size(i8* %clsptr6624, i64 %closure_size6638)
%wrapper_ptr6639 = call i8* @llvm_zone_malloc(%mzone* %zone6623, i64 8)
%closure_wrapper6640 = bitcast i8* %wrapper_ptr6639 to { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}**
store { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}* %closure6625, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}** %closure_wrapper6640

; let value assignment
%ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd = select i1 true, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}** %closure_wrapper6640, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}** %closure_wrapper6640
store { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd, { i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr

; add data to environment
; don't need to alloc for env var ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd
%tmp_envptr6634 = getelementptr {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}***}, {{i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}***}* %environment6627, i32 0, i32 0
store {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}**** %tmp_envptr6634


%val6643 = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}**, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}*** %ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypdPtr
ret {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}** %val6643
}


@ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}** @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd(%String* %arg_0,%String* %arg_1,%String* %arg_2,%String* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*,  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2, %String* %arg_3)
ret %ShaderProgram* %result
}


define dllexport ccc %ShaderProgram* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_native(%String* %arg_0,%String* %arg_1,%String* %arg_2,%String* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*,  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2, %String* %arg_3)
ret %ShaderProgram* %result
}


define dllexport ccc i8*  @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6644 = bitcast [138 x i8]* @gsxtmgl-objects2405 to i8*
call i32 (i8*, ...) @printf(i8* %var6644)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %String*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6645 = bitcast [138 x i8]* @gsxtmgl-objects2405 to i8*
call i32 (i8*, ...) @printf(i8* %var6645)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6646 = bitcast [138 x i8]* @gsxtmgl-objects2405 to i8*
call i32 (i8*, ...) @printf(i8* %var6646)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %String*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var6647 = bitcast [138 x i8]* @gsxtmgl-objects2405 to i8*
call i32 (i8*, ...) @printf(i8* %var6647)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%ttv_3 = call ccc i8* @cptr_value(i8* %arg_3_val)
%arg_3 = bitcast i8* %ttv_3 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*,  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2, %String* %arg_3)
%tmpres = bitcast %ShaderProgram* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%String*, %String*, %String*, %String*}*
%arg_p_0 = getelementptr {%String*, %String*, %String*, %String*}, {%String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %String*, %String** %arg_p_0
%arg_p_1 = getelementptr {%String*, %String*, %String*, %String*}, {%String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
%arg_p_2 = getelementptr {%String*, %String*, %String*, %String*}, {%String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 2
%arg_2 = load %String*, %String** %arg_p_2
%arg_p_3 = getelementptr {%String*, %String*, %String*, %String*}, {%String*, %String*, %String*, %String*}* %fstruct, i32 0, i32 3
%arg_3 = load %String*, %String** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_adhoc_W1NoYWRlclByb2dyYW0qLFN0cmluZyosU3RyaW5nKixTdHJpbmcqLFN0cmluZypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}**
%closure = load {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}*, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}, {i8*, i8*, %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*}* %closure, i32 0, i32 1
%ff = load  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)*,  %ShaderProgram* (i8*, i8*, %String*, %String*, %String*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %ShaderProgram* %ff(i8* %_impz, i8* %ee, %String* %arg_0, %String* %arg_1, %String* %arg_2, %String* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2406 = hidden constant [41 x i8] c"start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd\00"
define dllexport fastcc void @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__6648(i8* %_impz,i8* %_impenv, %ShaderProgram* %prog) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6649 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*
%start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 0
%start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_

; setup arguments
%progPtr = alloca %ShaderProgram*
store %ShaderProgram* %prog, %ShaderProgram** %progPtr


call fastcc void @glUseProgram_adhoc_W3ZvaWQsaTMyXQ(i32 0)
%val6651 = load %ShaderProgram*, %ShaderProgram** %progPtr
%res6652 = call fastcc i32 @id_adhoc_W2kzMixTaGFkZXJQcm9ncmFtKl0(%ShaderProgram* %val6651)
call fastcc void @glUseProgram_adhoc_W3ZvaWQsaTMyXQ(i32 %res6652)
ret void
}
@gsxtmgl-objects2407 = hidden constant [94 x i8] c"start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6673 = load i8*, i8** %_impzPtr
%zone6674 = bitcast i8* %tzone6673 to %mzone*

; let assign value to symbol start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%dat_start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = call i8* @llvm_zone_malloc(%mzone* %zone6674, i64 8)
%start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = bitcast i8* %dat_start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***
%tzone6654 = load i8*, i8** %_impzPtr
%zone6655 = bitcast i8* %tzone6654 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6655)
; malloc closure structure
%clsptr6656 = call i8* @llvm_zone_malloc(%mzone* %zone6655, i64 24)
%closure6657 = bitcast i8* %clsptr6656 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*

; malloc environment structure
%envptr6658 = call i8* @llvm_zone_malloc(%mzone* %zone6655, i64 8)
%environment6659 = bitcast i8* %envptr6658 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*

; malloc closure address table
%addytable6660 = call %clsvar* @new_address_table()
%var6661 = bitcast [41 x i8]* @gsxtmgl-objects2406 to i8*
%var6662 = bitcast [48 x i8]* @gsxtmgl-objects2372 to i8*
%addytable6663 = call %clsvar* @add_address_table(%mzone* %zone6655, i8* %var6661, i32 0, i8* %var6662, i32 3, %clsvar* %addytable6660)
%address-table6664 = bitcast %clsvar* %addytable6663 to i8*

; insert table, function and environment into closure struct
%closure.table6667 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6657, i32 0, i32 0
store i8* %address-table6664, i8** %closure.table6667
%closure.env6668 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6657, i32 0, i32 1
store i8* %envptr6658, i8** %closure.env6668
%closure.func6669 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6657, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*)* @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__6648, void (i8*, i8*, %ShaderProgram*)** %closure.func6669
%closure_size6670 = call i64 @llvm_zone_mark_size(%mzone* %zone6655)
call void @llvm_zone_ptr_set_size(i8* %clsptr6656, i64 %closure_size6670)
%wrapper_ptr6671 = call i8* @llvm_zone_malloc(%mzone* %zone6655, i64 8)
%closure_wrapper6672 = bitcast i8* %wrapper_ptr6671 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6657, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6672

; let value assignment
%start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6672, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6672
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr

; add data to environment
; don't need to alloc for env var start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%tmp_envptr6666 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %environment6659, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %tmp_envptr6666


%val6675 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %val6675
}


@start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var = dllexport global [1 x i8*] [ i8* null ]

@start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc void @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_native(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc i8*  @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6676 = bitcast [94 x i8]* @gsxtmgl-objects2407 to i8*
call i32 (i8*, ...) @printf(i8* %var6676)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*}*
%arg_p_0 = getelementptr {%ShaderProgram*}, {%ShaderProgram*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @start_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2408 = hidden constant [40 x i8] c"stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd\00"
define dllexport fastcc void @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__6677(i8* %_impz,i8* %_impenv, %ShaderProgram* %prog) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6678 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*
%stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %impenv, i32 0, i32 0
%stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr_

; setup arguments
%progPtr = alloca %ShaderProgram*
store %ShaderProgram* %prog, %ShaderProgram** %progPtr


call fastcc void @glUseProgram_adhoc_W3ZvaWQsaTMyXQ(i32 0)
ret void
}
@gsxtmgl-objects2409 = hidden constant [93 x i8] c"stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6699 = load i8*, i8** %_impzPtr
%zone6700 = bitcast i8* %tzone6699 to %mzone*

; let assign value to symbol stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%dat_stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = call i8* @llvm_zone_malloc(%mzone* %zone6700, i64 8)
%stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr = bitcast i8* %dat_stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***
%tzone6680 = load i8*, i8** %_impzPtr
%zone6681 = bitcast i8* %tzone6680 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6681)
; malloc closure structure
%clsptr6682 = call i8* @llvm_zone_malloc(%mzone* %zone6681, i64 24)
%closure6683 = bitcast i8* %clsptr6682 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*

; malloc environment structure
%envptr6684 = call i8* @llvm_zone_malloc(%mzone* %zone6681, i64 8)
%environment6685 = bitcast i8* %envptr6684 to {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}*

; malloc closure address table
%addytable6686 = call %clsvar* @new_address_table()
%var6687 = bitcast [40 x i8]* @gsxtmgl-objects2408 to i8*
%var6688 = bitcast [48 x i8]* @gsxtmgl-objects2372 to i8*
%addytable6689 = call %clsvar* @add_address_table(%mzone* %zone6681, i8* %var6687, i32 0, i8* %var6688, i32 3, %clsvar* %addytable6686)
%address-table6690 = bitcast %clsvar* %addytable6689 to i8*

; insert table, function and environment into closure struct
%closure.table6693 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6683, i32 0, i32 0
store i8* %address-table6690, i8** %closure.table6693
%closure.env6694 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6683, i32 0, i32 1
store i8* %envptr6684, i8** %closure.env6694
%closure.func6695 = getelementptr { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6683, i32 0, i32 2
store void (i8*, i8*, %ShaderProgram*)* @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd__6677, void (i8*, i8*, %ShaderProgram*)** %closure.func6695
%closure_size6696 = call i64 @llvm_zone_mark_size(%mzone* %zone6681)
call void @llvm_zone_ptr_set_size(i8* %clsptr6682, i64 %closure_size6696)
%wrapper_ptr6697 = call i8* @llvm_zone_malloc(%mzone* %zone6681, i64 8)
%closure_wrapper6698 = bitcast i8* %wrapper_ptr6697 to { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure6683, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6698

; let value assignment
%stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd = select i1 true, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6698, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_wrapper6698
store { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd, { i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr

; add data to environment
; don't need to alloc for env var stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd
%tmp_envptr6692 = getelementptr {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}, {{i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}***}* %environment6685, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**** %tmp_envptr6692


%val6701 = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*** %stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpdPtr
ret {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %val6701
}


@stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var = dllexport global [1 x i8*] [ i8* null ]

@stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc void @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_native(%ShaderProgram* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
ret void
}


define dllexport ccc i8*  @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6702 = bitcast [93 x i8]* @gsxtmgl-objects2409 to i8*
call i32 (i8*, ...) @printf(i8* %var6702)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %ShaderProgram*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%ShaderProgram*}*
%arg_p_0 = getelementptr {%ShaderProgram*}, {%ShaderProgram*}* %fstruct, i32 0, i32 0
%arg_0 = load %ShaderProgram*, %ShaderProgram** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @stop_adhoc_W3ZvaWQsU2hhZGVyUHJvZ3JhbSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}*, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}, {i8*, i8*, void (i8*, i8*, %ShaderProgram*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %ShaderProgram*)*,  void (i8*, i8*, %ShaderProgram*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %ShaderProgram* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%FBO = type {i32,%Texture*,%Texture*,i32,i32}
@gsxtmgl-objects2410 = hidden constant [59 x i8] c"FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd\00"
@gsxtmgl-objects2411 = hidden constant [69 x i8] c"{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**\00"
define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd__6703(i8* %_impz,i8* %_impenv, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6704 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}*
%FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}* %impenv, i32 0, i32 0
%FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**** %FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca %Texture*
store %Texture* %arg_1, %Texture** %arg_1Ptr
%arg_2Ptr = alloca %Texture*
store %Texture* %arg_2, %Texture** %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr


%tzone6709 = load i8*, i8** %_impzPtr
%zone6710 = bitcast i8* %tzone6709 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %FBO*
%tzone6705 = load i8*, i8** %_impzPtr
%zone6706 = bitcast i8* %tzone6705 to %mzone*
%dat6707 = call i8* @llvm_zone_malloc(%mzone* %zone6706, i64 32)
call i8* @memset(i8* %dat6707, i32 0, i64 32)
%val6708 = bitcast i8* %dat6707 to %FBO*

; let value assignment
%obj = select i1 true, %FBO* %val6708, %FBO* %val6708
store %FBO* %obj, %FBO** %objPtr

%val6711 = load %FBO*, %FBO** %objPtr
%val6712 = load i32, i32* %arg_0Ptr
; set tuple
%val6713 = getelementptr %FBO, %FBO* %val6711, i64 0, i32 0
store i32 %val6712, i32* %val6713
%val6714 = load %FBO*, %FBO** %objPtr
%val6715 = load %Texture*, %Texture** %arg_1Ptr
; set tuple
%val6716 = getelementptr %FBO, %FBO* %val6714, i64 0, i32 1
store %Texture* %val6715, %Texture** %val6716
%val6717 = load %FBO*, %FBO** %objPtr
%val6718 = load %Texture*, %Texture** %arg_2Ptr
; set tuple
%val6719 = getelementptr %FBO, %FBO* %val6717, i64 0, i32 2
store %Texture* %val6718, %Texture** %val6719
%val6720 = load %FBO*, %FBO** %objPtr
%val6721 = load i32, i32* %arg_3Ptr
; set tuple
%val6722 = getelementptr %FBO, %FBO* %val6720, i64 0, i32 3
store i32 %val6721, i32* %val6722
%val6723 = load %FBO*, %FBO** %objPtr
%val6724 = load i32, i32* %arg_4Ptr
; set tuple
%val6725 = getelementptr %FBO, %FBO* %val6723, i64 0, i32 4
store i32 %val6724, i32* %val6725
%val6726 = load %FBO*, %FBO** %objPtr
ret %FBO* %val6726
}
@gsxtmgl-objects2412 = hidden constant [112 x i8] c"FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6746 = load i8*, i8** %_impzPtr
%zone6747 = bitcast i8* %tzone6746 to %mzone*

; let assign value to symbol FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd
%dat_FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone6747, i64 8)
%FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr = bitcast i8* %dat_FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd to { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***
%tzone6727 = load i8*, i8** %_impzPtr
%zone6728 = bitcast i8* %tzone6727 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6728)
; malloc closure structure
%clsptr6729 = call i8* @llvm_zone_malloc(%mzone* %zone6728, i64 24)
%closure6730 = bitcast i8* %clsptr6729 to { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*

; malloc environment structure
%envptr6731 = call i8* @llvm_zone_malloc(%mzone* %zone6728, i64 8)
%environment6732 = bitcast i8* %envptr6731 to {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}*

; malloc closure address table
%addytable6733 = call %clsvar* @new_address_table()
%var6734 = bitcast [59 x i8]* @gsxtmgl-objects2410 to i8*
%var6735 = bitcast [69 x i8]* @gsxtmgl-objects2411 to i8*
%addytable6736 = call %clsvar* @add_address_table(%mzone* %zone6728, i8* %var6734, i32 0, i8* %var6735, i32 3, %clsvar* %addytable6733)
%address-table6737 = bitcast %clsvar* %addytable6736 to i8*

; insert table, function and environment into closure struct
%closure.table6740 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6730, i32 0, i32 0
store i8* %address-table6737, i8** %closure.table6740
%closure.env6741 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6730, i32 0, i32 1
store i8* %envptr6731, i8** %closure.env6741
%closure.func6742 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6730, i32 0, i32 2
store %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd__6703, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %closure.func6742
%closure_size6743 = call i64 @llvm_zone_mark_size(%mzone* %zone6728)
call void @llvm_zone_ptr_set_size(i8* %clsptr6729, i64 %closure_size6743)
%wrapper_ptr6744 = call i8* @llvm_zone_malloc(%mzone* %zone6728, i64 8)
%closure_wrapper6745 = bitcast i8* %wrapper_ptr6744 to { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
store { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6730, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_wrapper6745

; let value assignment
%FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_wrapper6745, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_wrapper6745
store { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*** %FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd
%tmp_envptr6739 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}* %environment6732, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*** %FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**** %tmp_envptr6739


%val6748 = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*** %FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr
ret {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %val6748
}


@FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd(i32 %arg_0,%Texture* %arg_1,%Texture* %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_native(i32 %arg_0,%Texture* %arg_1,%Texture* %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6749 = bitcast [112 x i8]* @gsxtmgl-objects2412 to i8*
call i32 (i8*, ...) @printf(i8* %var6749)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6750 = bitcast [112 x i8]* @gsxtmgl-objects2412 to i8*
call i32 (i8*, ...) @printf(i8* %var6750)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6751 = bitcast [112 x i8]* @gsxtmgl-objects2412 to i8*
call i32 (i8*, ...) @printf(i8* %var6751)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Texture*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var6752 = bitcast [112 x i8]* @gsxtmgl-objects2412 to i8*
call i32 (i8*, ...) @printf(i8* %var6752)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var6753 = bitcast [112 x i8]* @gsxtmgl-objects2412 to i8*
call i32 (i8*, ...) @printf(i8* %var6753)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Texture*, %Texture*, i32, i32}*
%arg_p_0 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load %Texture*, %Texture** %arg_p_2
%arg_p_3 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2413 = hidden constant [61 x i8] c"FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd\00"
define dllexport fastcc %FBO* @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd__6754(i8* %_impz,i8* %_impenv, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6755 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}*
%FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}* %impenv, i32 0, i32 0
%FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**** %FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca %Texture*
store %Texture* %arg_1, %Texture** %arg_1Ptr
%arg_2Ptr = alloca %Texture*
store %Texture* %arg_2, %Texture** %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr


%tzone6760 = load i8*, i8** %_impzPtr
%zone6761 = bitcast i8* %tzone6760 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %FBO*
%tzone6756 = load i8*, i8** %_impzPtr
%zone6757 = bitcast i8* %tzone6756 to %mzone*
%dat6758 = call i8* @llvm_zone_malloc(%mzone* %zone6757, i64 32)
call i8* @memset(i8* %dat6758, i32 0, i64 32)
%val6759 = bitcast i8* %dat6758 to %FBO*

; let value assignment
%obj = select i1 true, %FBO* %val6759, %FBO* %val6759
store %FBO* %obj, %FBO** %objPtr

%val6762 = load %FBO*, %FBO** %objPtr
%val6763 = load i32, i32* %arg_0Ptr
; set tuple
%val6764 = getelementptr %FBO, %FBO* %val6762, i64 0, i32 0
store i32 %val6763, i32* %val6764
%val6765 = load %FBO*, %FBO** %objPtr
%val6766 = load %Texture*, %Texture** %arg_1Ptr
; set tuple
%val6767 = getelementptr %FBO, %FBO* %val6765, i64 0, i32 1
store %Texture* %val6766, %Texture** %val6767
%val6768 = load %FBO*, %FBO** %objPtr
%val6769 = load %Texture*, %Texture** %arg_2Ptr
; set tuple
%val6770 = getelementptr %FBO, %FBO* %val6768, i64 0, i32 2
store %Texture* %val6769, %Texture** %val6770
%val6771 = load %FBO*, %FBO** %objPtr
%val6772 = load i32, i32* %arg_3Ptr
; set tuple
%val6773 = getelementptr %FBO, %FBO* %val6771, i64 0, i32 3
store i32 %val6772, i32* %val6773
%val6774 = load %FBO*, %FBO** %objPtr
%val6775 = load i32, i32* %arg_4Ptr
; set tuple
%val6776 = getelementptr %FBO, %FBO* %val6774, i64 0, i32 4
store i32 %val6775, i32* %val6776
%val6777 = load %FBO*, %FBO** %objPtr
ret %FBO* %val6777
}
@gsxtmgl-objects2414 = hidden constant [114 x i8] c"FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6797 = load i8*, i8** %_impzPtr
%zone6798 = bitcast i8* %tzone6797 to %mzone*

; let assign value to symbol FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd
%dat_FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone6798, i64 8)
%FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr = bitcast i8* %dat_FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd to { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***
%tzone6778 = load i8*, i8** %_impzPtr
%zone6779 = bitcast i8* %tzone6778 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6779)
; malloc closure structure
%clsptr6780 = call i8* @llvm_zone_malloc(%mzone* %zone6779, i64 24)
%closure6781 = bitcast i8* %clsptr6780 to { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*

; malloc environment structure
%envptr6782 = call i8* @llvm_zone_malloc(%mzone* %zone6779, i64 8)
%environment6783 = bitcast i8* %envptr6782 to {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}*

; malloc closure address table
%addytable6784 = call %clsvar* @new_address_table()
%var6785 = bitcast [61 x i8]* @gsxtmgl-objects2413 to i8*
%var6786 = bitcast [69 x i8]* @gsxtmgl-objects2411 to i8*
%addytable6787 = call %clsvar* @add_address_table(%mzone* %zone6779, i8* %var6785, i32 0, i8* %var6786, i32 3, %clsvar* %addytable6784)
%address-table6788 = bitcast %clsvar* %addytable6787 to i8*

; insert table, function and environment into closure struct
%closure.table6791 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6781, i32 0, i32 0
store i8* %address-table6788, i8** %closure.table6791
%closure.env6792 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6781, i32 0, i32 1
store i8* %envptr6782, i8** %closure.env6792
%closure.func6793 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6781, i32 0, i32 2
store %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)* @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd__6754, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %closure.func6793
%closure_size6794 = call i64 @llvm_zone_mark_size(%mzone* %zone6779)
call void @llvm_zone_ptr_set_size(i8* %clsptr6780, i64 %closure_size6794)
%wrapper_ptr6795 = call i8* @llvm_zone_malloc(%mzone* %zone6779, i64 8)
%closure_wrapper6796 = bitcast i8* %wrapper_ptr6795 to { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
store { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6781, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_wrapper6796

; let value assignment
%FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_wrapper6796, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_wrapper6796
store { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*** %FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd
%tmp_envptr6790 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}* %environment6783, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*** %FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**** %tmp_envptr6790


%val6799 = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*** %FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr
ret {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %val6799
}


@FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd(i32 %arg_0,%Texture* %arg_1,%Texture* %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_native(i32 %arg_0,%Texture* %arg_1,%Texture* %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6800 = bitcast [114 x i8]* @gsxtmgl-objects2414 to i8*
call i32 (i8*, ...) @printf(i8* %var6800)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6801 = bitcast [114 x i8]* @gsxtmgl-objects2414 to i8*
call i32 (i8*, ...) @printf(i8* %var6801)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6802 = bitcast [114 x i8]* @gsxtmgl-objects2414 to i8*
call i32 (i8*, ...) @printf(i8* %var6802)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Texture*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var6803 = bitcast [114 x i8]* @gsxtmgl-objects2414 to i8*
call i32 (i8*, ...) @printf(i8* %var6803)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var6804 = bitcast [114 x i8]* @gsxtmgl-objects2414 to i8*
call i32 (i8*, ...) @printf(i8* %var6804)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Texture*, %Texture*, i32, i32}*
%arg_p_0 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load %Texture*, %Texture** %arg_p_2
%arg_p_3 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2415 = hidden constant [61 x i8] c"FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd\00"
define dllexport fastcc %FBO* @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd__6805(i8* %_impz,i8* %_impenv, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6806 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}*
%FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}* %impenv, i32 0, i32 0
%FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**** %FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca %Texture*
store %Texture* %arg_1, %Texture** %arg_1Ptr
%arg_2Ptr = alloca %Texture*
store %Texture* %arg_2, %Texture** %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr


%tzone6809 = load i8*, i8** %_impzPtr
%zone6810 = bitcast i8* %tzone6809 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %FBO*
%dat6807 = call i8* @malloc(i64 32)
call i8* @memset(i8* %dat6807, i32 0, i64 32)
%val6808 = bitcast i8* %dat6807 to %FBO*

; let value assignment
%obj = select i1 true, %FBO* %val6808, %FBO* %val6808
store %FBO* %obj, %FBO** %objPtr

%val6811 = load %FBO*, %FBO** %objPtr
%val6812 = load i32, i32* %arg_0Ptr
; set tuple
%val6813 = getelementptr %FBO, %FBO* %val6811, i64 0, i32 0
store i32 %val6812, i32* %val6813
%val6814 = load %FBO*, %FBO** %objPtr
%val6815 = load %Texture*, %Texture** %arg_1Ptr
; set tuple
%val6816 = getelementptr %FBO, %FBO* %val6814, i64 0, i32 1
store %Texture* %val6815, %Texture** %val6816
%val6817 = load %FBO*, %FBO** %objPtr
%val6818 = load %Texture*, %Texture** %arg_2Ptr
; set tuple
%val6819 = getelementptr %FBO, %FBO* %val6817, i64 0, i32 2
store %Texture* %val6818, %Texture** %val6819
%val6820 = load %FBO*, %FBO** %objPtr
%val6821 = load i32, i32* %arg_3Ptr
; set tuple
%val6822 = getelementptr %FBO, %FBO* %val6820, i64 0, i32 3
store i32 %val6821, i32* %val6822
%val6823 = load %FBO*, %FBO** %objPtr
%val6824 = load i32, i32* %arg_4Ptr
; set tuple
%val6825 = getelementptr %FBO, %FBO* %val6823, i64 0, i32 4
store i32 %val6824, i32* %val6825
%val6826 = load %FBO*, %FBO** %objPtr
ret %FBO* %val6826
}
@gsxtmgl-objects2416 = hidden constant [114 x i8] c"FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6846 = load i8*, i8** %_impzPtr
%zone6847 = bitcast i8* %tzone6846 to %mzone*

; let assign value to symbol FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd
%dat_FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone6847, i64 8)
%FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr = bitcast i8* %dat_FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd to { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***
%tzone6827 = load i8*, i8** %_impzPtr
%zone6828 = bitcast i8* %tzone6827 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6828)
; malloc closure structure
%clsptr6829 = call i8* @llvm_zone_malloc(%mzone* %zone6828, i64 24)
%closure6830 = bitcast i8* %clsptr6829 to { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*

; malloc environment structure
%envptr6831 = call i8* @llvm_zone_malloc(%mzone* %zone6828, i64 8)
%environment6832 = bitcast i8* %envptr6831 to {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}*

; malloc closure address table
%addytable6833 = call %clsvar* @new_address_table()
%var6834 = bitcast [61 x i8]* @gsxtmgl-objects2415 to i8*
%var6835 = bitcast [69 x i8]* @gsxtmgl-objects2411 to i8*
%addytable6836 = call %clsvar* @add_address_table(%mzone* %zone6828, i8* %var6834, i32 0, i8* %var6835, i32 3, %clsvar* %addytable6833)
%address-table6837 = bitcast %clsvar* %addytable6836 to i8*

; insert table, function and environment into closure struct
%closure.table6840 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6830, i32 0, i32 0
store i8* %address-table6837, i8** %closure.table6840
%closure.env6841 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6830, i32 0, i32 1
store i8* %envptr6831, i8** %closure.env6841
%closure.func6842 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6830, i32 0, i32 2
store %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)* @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd__6805, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %closure.func6842
%closure_size6843 = call i64 @llvm_zone_mark_size(%mzone* %zone6828)
call void @llvm_zone_ptr_set_size(i8* %clsptr6829, i64 %closure_size6843)
%wrapper_ptr6844 = call i8* @llvm_zone_malloc(%mzone* %zone6828, i64 8)
%closure_wrapper6845 = bitcast i8* %wrapper_ptr6844 to { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
store { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6830, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_wrapper6845

; let value assignment
%FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_wrapper6845, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_wrapper6845
store { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd, { i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*** %FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd
%tmp_envptr6839 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}* %environment6832, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*** %FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**** %tmp_envptr6839


%val6848 = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*** %FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJdPtr
ret {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %val6848
}


@FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd(i32 %arg_0,%Texture* %arg_1,%Texture* %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_native(i32 %arg_0,%Texture* %arg_1,%Texture* %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6849 = bitcast [114 x i8]* @gsxtmgl-objects2416 to i8*
call i32 (i8*, ...) @printf(i8* %var6849)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var6850 = bitcast [114 x i8]* @gsxtmgl-objects2416 to i8*
call i32 (i8*, ...) @printf(i8* %var6850)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var6851 = bitcast [114 x i8]* @gsxtmgl-objects2416 to i8*
call i32 (i8*, ...) @printf(i8* %var6851)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Texture*
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var6852 = bitcast [114 x i8]* @gsxtmgl-objects2416 to i8*
call i32 (i8*, ...) @printf(i8* %var6852)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var6853 = bitcast [114 x i8]* @gsxtmgl-objects2416 to i8*
call i32 (i8*, ...) @printf(i8* %var6853)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Texture*, %Texture*, i32, i32}*
%arg_p_0 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load %Texture*, %Texture** %arg_p_2
%arg_p_3 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO* (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2417 = hidden constant [62 x i8] c"FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0\00"
@gsxtmgl-objects2418 = hidden constant [68 x i8] c"{i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**\00"
define dllexport fastcc %FBO @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0__6854(i8* %_impz,i8* %_impenv, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6855 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}*
%FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}, {{i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}* %impenv, i32 0, i32 0
%FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0Ptr = load {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***, {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**** %FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca %Texture*
store %Texture* %arg_1, %Texture** %arg_1Ptr
%arg_2Ptr = alloca %Texture*
store %Texture* %arg_2, %Texture** %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr


%tzone6857 = load i8*, i8** %_impzPtr
%zone6858 = bitcast i8* %tzone6857 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %FBO*
%dat6856 = alloca %FBO, align 16

; let value assignment
%obj = select i1 true, %FBO* %dat6856, %FBO* %dat6856
store %FBO* %obj, %FBO** %objPtr

%val6859 = load %FBO*, %FBO** %objPtr
%val6860 = load i32, i32* %arg_0Ptr
; set tuple
%val6861 = getelementptr %FBO, %FBO* %val6859, i64 0, i32 0
store i32 %val6860, i32* %val6861
%val6862 = load %FBO*, %FBO** %objPtr
%val6863 = load %Texture*, %Texture** %arg_1Ptr
; set tuple
%val6864 = getelementptr %FBO, %FBO* %val6862, i64 0, i32 1
store %Texture* %val6863, %Texture** %val6864
%val6865 = load %FBO*, %FBO** %objPtr
%val6866 = load %Texture*, %Texture** %arg_2Ptr
; set tuple
%val6867 = getelementptr %FBO, %FBO* %val6865, i64 0, i32 2
store %Texture* %val6866, %Texture** %val6867
%val6868 = load %FBO*, %FBO** %objPtr
%val6869 = load i32, i32* %arg_3Ptr
; set tuple
%val6870 = getelementptr %FBO, %FBO* %val6868, i64 0, i32 3
store i32 %val6869, i32* %val6870
%val6871 = load %FBO*, %FBO** %objPtr
%val6872 = load i32, i32* %arg_4Ptr
; set tuple
%val6873 = getelementptr %FBO, %FBO* %val6871, i64 0, i32 4
store i32 %val6872, i32* %val6873
%val6874 = load %FBO*, %FBO** %objPtr
; pointer ref
%val6875 = getelementptr %FBO, %FBO* %val6874, i64 0
%val6876 = load %FBO, %FBO* %val6875
ret %FBO %val6876
}
@gsxtmgl-objects2419 = hidden constant [115 x i8] c"FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6896 = load i8*, i8** %_impzPtr
%zone6897 = bitcast i8* %tzone6896 to %mzone*

; let assign value to symbol FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0
%dat_FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone6897, i64 8)
%FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0Ptr = bitcast i8* %dat_FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0 to { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***
%tzone6877 = load i8*, i8** %_impzPtr
%zone6878 = bitcast i8* %tzone6877 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6878)
; malloc closure structure
%clsptr6879 = call i8* @llvm_zone_malloc(%mzone* %zone6878, i64 24)
%closure6880 = bitcast i8* %clsptr6879 to { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*

; malloc environment structure
%envptr6881 = call i8* @llvm_zone_malloc(%mzone* %zone6878, i64 8)
%environment6882 = bitcast i8* %envptr6881 to {{i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}*

; malloc closure address table
%addytable6883 = call %clsvar* @new_address_table()
%var6884 = bitcast [62 x i8]* @gsxtmgl-objects2417 to i8*
%var6885 = bitcast [68 x i8]* @gsxtmgl-objects2418 to i8*
%addytable6886 = call %clsvar* @add_address_table(%mzone* %zone6878, i8* %var6884, i32 0, i8* %var6885, i32 3, %clsvar* %addytable6883)
%address-table6887 = bitcast %clsvar* %addytable6886 to i8*

; insert table, function and environment into closure struct
%closure.table6890 = getelementptr { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6880, i32 0, i32 0
store i8* %address-table6887, i8** %closure.table6890
%closure.env6891 = getelementptr { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6880, i32 0, i32 1
store i8* %envptr6881, i8** %closure.env6891
%closure.func6892 = getelementptr { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6880, i32 0, i32 2
store %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)* @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0__6854, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %closure.func6892
%closure_size6893 = call i64 @llvm_zone_mark_size(%mzone* %zone6878)
call void @llvm_zone_ptr_set_size(i8* %clsptr6879, i64 %closure_size6893)
%wrapper_ptr6894 = call i8* @llvm_zone_malloc(%mzone* %zone6878, i64 8)
%closure_wrapper6895 = bitcast i8* %wrapper_ptr6894 to { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
store { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure6880, { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_wrapper6895

; let value assignment
%FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0 = select i1 true, { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_wrapper6895, { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_wrapper6895
store { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0, { i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*** %FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0
%tmp_envptr6889 = getelementptr {{i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}, {{i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}***}* %environment6882, i32 0, i32 0
store {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*** %FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0Ptr, {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**** %tmp_envptr6889


%val6898 = load {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**, {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*** %FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0Ptr
ret {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %val6898
}


@FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0(i32 %arg_0,%Texture* %arg_1,%Texture* %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO %result
}


define dllexport ccc %FBO @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_native(i32 %arg_0,%Texture* %arg_1,%Texture* %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO %result
}


define dllexport ccc void @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, %Texture*, %Texture*, i32, i32}*
%arg_p_0 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
%arg_p_2 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load %Texture*, %Texture** %arg_p_2
%arg_p_3 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, %Texture*, %Texture*, i32, i32}, {i32, %Texture*, %Texture*, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_val_adhoc_W0ZCTyxpMzIsVGV4dHVyZSosVGV4dHVyZSosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}*, {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}, {i8*, i8*, %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)*,  %FBO (i8*, i8*, i32, %Texture*, %Texture*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO %ff(i8* %_impz, i8* %ee, i32 %arg_0, %Texture* %arg_1, %Texture* %arg_2, i32 %arg_3, i32 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2420 = hidden constant [28 x i8] c"hcopy_adhoc_W0ZCTyosRkJPKl0\00"
@gsxtmgl-objects2421 = hidden constant [39 x i8] c"{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**\00"
define dllexport fastcc %FBO* @hcopy_adhoc_W0ZCTyosRkJPKl0__6904(i8* %_impz,i8* %_impenv, %FBO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6905 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***}*
%hcopy_adhoc_W0ZCTyosRkJPKl0Ptr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W0ZCTyosRkJPKl0Ptr = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**** %hcopy_adhoc_W0ZCTyosRkJPKl0Ptr_

; setup arguments
%xPtr = alloca %FBO*
store %FBO* %x, %FBO** %xPtr


%tzone6908 = load i8*, i8** %_impzPtr
%zone6909 = bitcast i8* %tzone6908 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %FBO*
%dat6906 = call i8* @malloc(i64 32)
call i8* @memset(i8* %dat6906, i32 0, i64 32)
%val6907 = bitcast i8* %dat6906 to %FBO*

; let value assignment
%obj = select i1 true, %FBO* %val6907, %FBO* %val6907
store %FBO* %obj, %FBO** %objPtr

; promote local stack var allocations
%tzone6958 = load i8*, i8** %_impzPtr
%zone6959 = bitcast i8* %tzone6958 to %mzone*
%ifptr6931 = alloca %Texture*
%ifptr6932 = alloca i1
%ifptr6915 = alloca %Texture*
%ifptr6916 = alloca i1
%val6910 = load %FBO*, %FBO** %objPtr
%val6911 = load %FBO*, %FBO** %xPtr
; tuple ref
%val6912 = getelementptr %FBO, %FBO* %val6911, i64 0, i32 0
%val6913 = load i32, i32* %val6912
; set tuple
%val6914 = getelementptr %FBO, %FBO* %val6910, i64 0, i32 0
store i32 %val6913, i32* %val6914
%val6917 = load %FBO*, %FBO** %xPtr
; tuple ref
%val6918 = getelementptr %FBO, %FBO* %val6917, i64 0, i32 1
%val6919 = load %Texture*, %Texture** %val6918
%val6920 = icmp eq %Texture* %val6919, null
br i1 %val6920, label %then6916, label %else6916

then6916:
%res6921 = call ccc i1 @impc_false()
store i1 %res6921, i1* %ifptr6916
br label %ifcont6916

else6916:
%res6922 = call ccc i1 @impc_true()
store i1 %res6922, i1* %ifptr6916
br label %ifcont6916

ifcont6916:
%ifres6923 = load i1, i1* %ifptr6916

br i1 %ifres6923, label %then6915, label %else6915

then6915:
%val6924 = load %FBO*, %FBO** %objPtr
%val6925 = load %FBO*, %FBO** %xPtr
; tuple ref
%val6926 = getelementptr %FBO, %FBO* %val6925, i64 0, i32 1
%val6927 = load %Texture*, %Texture** %val6926
%res6928 = call fastcc %Texture* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ(%Texture* %val6927)
; set tuple
%val6929 = getelementptr %FBO, %FBO* %val6924, i64 0, i32 1
store %Texture* %res6928, %Texture** %val6929
store %Texture* %res6928, %Texture** %ifptr6915
br label %ifcont6915

else6915:
br label %ifcont6915

ifcont6915:
%ifres6930 = load %Texture*, %Texture** %ifptr6915

%val6933 = load %FBO*, %FBO** %xPtr
; tuple ref
%val6934 = getelementptr %FBO, %FBO* %val6933, i64 0, i32 2
%val6935 = load %Texture*, %Texture** %val6934
%val6936 = icmp eq %Texture* %val6935, null
br i1 %val6936, label %then6932, label %else6932

then6932:
%res6937 = call ccc i1 @impc_false()
store i1 %res6937, i1* %ifptr6932
br label %ifcont6932

else6932:
%res6938 = call ccc i1 @impc_true()
store i1 %res6938, i1* %ifptr6932
br label %ifcont6932

ifcont6932:
%ifres6939 = load i1, i1* %ifptr6932

br i1 %ifres6939, label %then6931, label %else6931

then6931:
%val6940 = load %FBO*, %FBO** %objPtr
%val6941 = load %FBO*, %FBO** %xPtr
; tuple ref
%val6942 = getelementptr %FBO, %FBO* %val6941, i64 0, i32 2
%val6943 = load %Texture*, %Texture** %val6942
%res6944 = call fastcc %Texture* @hcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqXQ(%Texture* %val6943)
; set tuple
%val6945 = getelementptr %FBO, %FBO* %val6940, i64 0, i32 2
store %Texture* %res6944, %Texture** %val6945
store %Texture* %res6944, %Texture** %ifptr6931
br label %ifcont6931

else6931:
br label %ifcont6931

ifcont6931:
%ifres6946 = load %Texture*, %Texture** %ifptr6931

%val6947 = load %FBO*, %FBO** %objPtr
%val6948 = load %FBO*, %FBO** %xPtr
; tuple ref
%val6949 = getelementptr %FBO, %FBO* %val6948, i64 0, i32 3
%val6950 = load i32, i32* %val6949
; set tuple
%val6951 = getelementptr %FBO, %FBO* %val6947, i64 0, i32 3
store i32 %val6950, i32* %val6951
%val6952 = load %FBO*, %FBO** %objPtr
%val6953 = load %FBO*, %FBO** %xPtr
; tuple ref
%val6954 = getelementptr %FBO, %FBO* %val6953, i64 0, i32 4
%val6955 = load i32, i32* %val6954
; set tuple
%val6956 = getelementptr %FBO, %FBO* %val6952, i64 0, i32 4
store i32 %val6955, i32* %val6956
%val6957 = load %FBO*, %FBO** %objPtr
ret %FBO* %val6957
}
@gsxtmgl-objects2422 = hidden constant [81 x i8] c"hcopy_adhoc_W0ZCTyosRkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** @hcopy_adhoc_W0ZCTyosRkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone6979 = load i8*, i8** %_impzPtr
%zone6980 = bitcast i8* %tzone6979 to %mzone*

; let assign value to symbol hcopy_adhoc_W0ZCTyosRkJPKl0
%dat_hcopy_adhoc_W0ZCTyosRkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone6980, i64 8)
%hcopy_adhoc_W0ZCTyosRkJPKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W0ZCTyosRkJPKl0 to { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***
%tzone6960 = load i8*, i8** %_impzPtr
%zone6961 = bitcast i8* %tzone6960 to %mzone*
call void @llvm_zone_mark(%mzone* %zone6961)
; malloc closure structure
%clsptr6962 = call i8* @llvm_zone_malloc(%mzone* %zone6961, i64 24)
%closure6963 = bitcast i8* %clsptr6962 to { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr6964 = call i8* @llvm_zone_malloc(%mzone* %zone6961, i64 8)
%environment6965 = bitcast i8* %envptr6964 to {{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable6966 = call %clsvar* @new_address_table()
%var6967 = bitcast [28 x i8]* @gsxtmgl-objects2420 to i8*
%var6968 = bitcast [39 x i8]* @gsxtmgl-objects2421 to i8*
%addytable6969 = call %clsvar* @add_address_table(%mzone* %zone6961, i8* %var6967, i32 0, i8* %var6968, i32 3, %clsvar* %addytable6966)
%address-table6970 = bitcast %clsvar* %addytable6969 to i8*

; insert table, function and environment into closure struct
%closure.table6973 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure6963, i32 0, i32 0
store i8* %address-table6970, i8** %closure.table6973
%closure.env6974 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure6963, i32 0, i32 1
store i8* %envptr6964, i8** %closure.env6974
%closure.func6975 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure6963, i32 0, i32 2
store %FBO* (i8*, i8*, %FBO*)* @hcopy_adhoc_W0ZCTyosRkJPKl0__6904, %FBO* (i8*, i8*, %FBO*)** %closure.func6975
%closure_size6976 = call i64 @llvm_zone_mark_size(%mzone* %zone6961)
call void @llvm_zone_ptr_set_size(i8* %clsptr6962, i64 %closure_size6976)
%wrapper_ptr6977 = call i8* @llvm_zone_malloc(%mzone* %zone6961, i64 8)
%closure_wrapper6978 = bitcast i8* %wrapper_ptr6977 to { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**
store { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure6963, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_wrapper6978

; let value assignment
%hcopy_adhoc_W0ZCTyosRkJPKl0 = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_wrapper6978, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_wrapper6978
store { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %hcopy_adhoc_W0ZCTyosRkJPKl0, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*** %hcopy_adhoc_W0ZCTyosRkJPKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W0ZCTyosRkJPKl0
%tmp_envptr6972 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***}* %environment6965, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*** %hcopy_adhoc_W0ZCTyosRkJPKl0Ptr, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**** %tmp_envptr6972


%val6981 = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*** %hcopy_adhoc_W0ZCTyosRkJPKl0Ptr
ret {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %val6981
}


@hcopy_adhoc_W0ZCTyosRkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W0ZCTyosRkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W0ZCTyosRkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** @hcopy_adhoc_W0ZCTyosRkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W0ZCTyosRkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @hcopy_adhoc_W0ZCTyosRkJPKl0(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*)*,  %FBO* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret %FBO* %result
}


define dllexport ccc %FBO* @hcopy_adhoc_W0ZCTyosRkJPKl0_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*)*,  %FBO* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret %FBO* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W0ZCTyosRkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var6982 = bitcast [81 x i8]* @gsxtmgl-objects2422 to i8*
call i32 (i8*, ...) @printf(i8* %var6982)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*)*,  %FBO* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W0ZCTyosRkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*)*,  %FBO* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2423 = hidden constant [28 x i8] c"hfree_adhoc_W3ZvaWQsRkJPKl0\00"
@gsxtmgl-objects2424 = hidden constant [38 x i8] c"{i8*, i8*, void (i8*, i8*, %FBO*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsRkJPKl0__6983(i8* %_impz,i8* %_impenv, %FBO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone6984 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}*
%hfree_adhoc_W3ZvaWQsRkJPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsRkJPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %FBO*)*}***, {i8*, i8*, void (i8*, i8*, %FBO*)*}**** %hfree_adhoc_W3ZvaWQsRkJPKl0Ptr_

; setup arguments
%xPtr = alloca %FBO*
store %FBO* %x, %FBO** %xPtr

; promote local stack var allocations
%tzone7015 = load i8*, i8** %_impzPtr
%zone7016 = bitcast i8* %tzone7015 to %mzone*
%ifptr6999 = alloca i1
%ifptr6986 = alloca i1

%val6987 = load %FBO*, %FBO** %xPtr
; tuple ref
%val6988 = getelementptr %FBO, %FBO* %val6987, i64 0, i32 1
%val6989 = load %Texture*, %Texture** %val6988
%val6990 = icmp eq %Texture* %val6989, null
br i1 %val6990, label %then6986, label %else6986

then6986:
%res6991 = call ccc i1 @impc_false()
store i1 %res6991, i1* %ifptr6986
br label %ifcont6986

else6986:
%res6992 = call ccc i1 @impc_true()
store i1 %res6992, i1* %ifptr6986
br label %ifcont6986

ifcont6986:
%ifres6993 = load i1, i1* %ifptr6986

br i1 %ifres6993, label %then6985, label %else6985

then6985:
%val6994 = load %FBO*, %FBO** %xPtr
; tuple ref
%val6995 = getelementptr %FBO, %FBO* %val6994, i64 0, i32 1
%val6996 = load %Texture*, %Texture** %val6995
call fastcc void @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val6996)
br label %ifcont6985

else6985:
br label %ifcont6985

ifcont6985:
%val7000 = load %FBO*, %FBO** %xPtr
; tuple ref
%val7001 = getelementptr %FBO, %FBO* %val7000, i64 0, i32 2
%val7002 = load %Texture*, %Texture** %val7001
%val7003 = icmp eq %Texture* %val7002, null
br i1 %val7003, label %then6999, label %else6999

then6999:
%res7004 = call ccc i1 @impc_false()
store i1 %res7004, i1* %ifptr6999
br label %ifcont6999

else6999:
%res7005 = call ccc i1 @impc_true()
store i1 %res7005, i1* %ifptr6999
br label %ifcont6999

ifcont6999:
%ifres7006 = load i1, i1* %ifptr6999

br i1 %ifres7006, label %then6998, label %else6998

then6998:
%val7007 = load %FBO*, %FBO** %xPtr
; tuple ref
%val7008 = getelementptr %FBO, %FBO* %val7007, i64 0, i32 2
%val7009 = load %Texture*, %Texture** %val7008
call fastcc void @hfree_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val7009)
br label %ifcont6998

else6998:
br label %ifcont6998

ifcont6998:
%val7011 = load %FBO*, %FBO** %xPtr
%val7012 = bitcast %FBO* %val7011 to i8*
call ccc void @free(i8* %val7012)
ret void
}
@gsxtmgl-objects2425 = hidden constant [81 x i8] c"hfree_adhoc_W3ZvaWQsRkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %FBO*)*}** @hfree_adhoc_W3ZvaWQsRkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7036 = load i8*, i8** %_impzPtr
%zone7037 = bitcast i8* %tzone7036 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsRkJPKl0
%dat_hfree_adhoc_W3ZvaWQsRkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone7037, i64 8)
%hfree_adhoc_W3ZvaWQsRkJPKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsRkJPKl0 to { i8*, i8*, void (i8*, i8*, %FBO*)*}***
%tzone7017 = load i8*, i8** %_impzPtr
%zone7018 = bitcast i8* %tzone7017 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7018)
; malloc closure structure
%clsptr7019 = call i8* @llvm_zone_malloc(%mzone* %zone7018, i64 24)
%closure7020 = bitcast i8* %clsptr7019 to { i8*, i8*, void (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr7021 = call i8* @llvm_zone_malloc(%mzone* %zone7018, i64 8)
%environment7022 = bitcast i8* %envptr7021 to {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable7023 = call %clsvar* @new_address_table()
%var7024 = bitcast [28 x i8]* @gsxtmgl-objects2423 to i8*
%var7025 = bitcast [38 x i8]* @gsxtmgl-objects2424 to i8*
%addytable7026 = call %clsvar* @add_address_table(%mzone* %zone7018, i8* %var7024, i32 0, i8* %var7025, i32 3, %clsvar* %addytable7023)
%address-table7027 = bitcast %clsvar* %addytable7026 to i8*

; insert table, function and environment into closure struct
%closure.table7030 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*)*}, { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure7020, i32 0, i32 0
store i8* %address-table7027, i8** %closure.table7030
%closure.env7031 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*)*}, { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure7020, i32 0, i32 1
store i8* %envptr7021, i8** %closure.env7031
%closure.func7032 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*)*}, { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure7020, i32 0, i32 2
store void (i8*, i8*, %FBO*)* @hfree_adhoc_W3ZvaWQsRkJPKl0__6983, void (i8*, i8*, %FBO*)** %closure.func7032
%closure_size7033 = call i64 @llvm_zone_mark_size(%mzone* %zone7018)
call void @llvm_zone_ptr_set_size(i8* %clsptr7019, i64 %closure_size7033)
%wrapper_ptr7034 = call i8* @llvm_zone_malloc(%mzone* %zone7018, i64 8)
%closure_wrapper7035 = bitcast i8* %wrapper_ptr7034 to { i8*, i8*, void (i8*, i8*, %FBO*)*}**
store { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure7020, { i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_wrapper7035

; let value assignment
%hfree_adhoc_W3ZvaWQsRkJPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_wrapper7035, { i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_wrapper7035
store { i8*, i8*, void (i8*, i8*, %FBO*)*}** %hfree_adhoc_W3ZvaWQsRkJPKl0, { i8*, i8*, void (i8*, i8*, %FBO*)*}*** %hfree_adhoc_W3ZvaWQsRkJPKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsRkJPKl0
%tmp_envptr7029 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}* %environment7022, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %FBO*)*}*** %hfree_adhoc_W3ZvaWQsRkJPKl0Ptr, {i8*, i8*, void (i8*, i8*, %FBO*)*}**** %tmp_envptr7029


%val7038 = load {i8*, i8*, void (i8*, i8*, %FBO*)*}**, {i8*, i8*, void (i8*, i8*, %FBO*)*}*** %hfree_adhoc_W3ZvaWQsRkJPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %FBO*)*}** %val7038
}


@hfree_adhoc_W3ZvaWQsRkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsRkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsRkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %FBO*)*}** @hfree_adhoc_W3ZvaWQsRkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsRkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsRkJPKl0(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsRkJPKl0_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsRkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7039 = bitcast [81 x i8]* @gsxtmgl-objects2425 to i8*
call i32 (i8*, ...) @printf(i8* %var7039)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsRkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2426 = hidden constant [47 x i8] c"zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmgl-objects2427 = hidden constant [57 x i8] c"{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %FBO* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ__7040(i8* %_impz,i8* %_impenv, %FBO* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7041 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %FBO*
store %FBO* %x, %FBO** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val7043 = load %mzone*, %mzone** %fromzPtr
%val7044 = load %FBO*, %FBO** %xPtr
%val7045 = bitcast %FBO* %val7044 to i8*
%res7046 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val7043, i8* %val7045)
br i1 %res7046, label %then7042, label %else7042

then7042:
%val7047 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val7047)
%zone_ptr7048 = bitcast %mzone* %val7047 to i8*
store i8* %zone_ptr7048, i8** %_impzPtr
%tzone7054 = load i8*, i8** %_impzPtr
%zone7055 = bitcast i8* %tzone7054 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %FBO*
%tzone7050 = load i8*, i8** %_impzPtr
%zone7051 = bitcast i8* %tzone7050 to %mzone*
%dat7052 = call i8* @llvm_zone_malloc(%mzone* %zone7051, i64 32)
call i8* @memset(i8* %dat7052, i32 0, i64 32)
%val7053 = bitcast i8* %dat7052 to %FBO*

; let value assignment
%obj = select i1 true, %FBO* %val7053, %FBO* %val7053
store %FBO* %obj, %FBO** %objPtr

; promote local stack var allocations
%tzone7111 = load i8*, i8** %_impzPtr
%zone7112 = bitcast i8* %tzone7111 to %mzone*
%ifptr7079 = alloca %Texture*
%ifptr7080 = alloca i1
%ifptr7061 = alloca %Texture*
%ifptr7062 = alloca i1
%val7056 = load %FBO*, %FBO** %objPtr
%val7057 = load %FBO*, %FBO** %xPtr
; tuple ref
%val7058 = getelementptr %FBO, %FBO* %val7057, i64 0, i32 0
%val7059 = load i32, i32* %val7058
; set tuple
%val7060 = getelementptr %FBO, %FBO* %val7056, i64 0, i32 0
store i32 %val7059, i32* %val7060
%val7063 = load %FBO*, %FBO** %xPtr
; tuple ref
%val7064 = getelementptr %FBO, %FBO* %val7063, i64 0, i32 1
%val7065 = load %Texture*, %Texture** %val7064
%val7066 = icmp eq %Texture* %val7065, null
br i1 %val7066, label %then7062, label %else7062

then7062:
%res7067 = call ccc i1 @impc_false()
store i1 %res7067, i1* %ifptr7062
br label %ifcont7062

else7062:
%res7068 = call ccc i1 @impc_true()
store i1 %res7068, i1* %ifptr7062
br label %ifcont7062

ifcont7062:
%ifres7069 = load i1, i1* %ifptr7062

br i1 %ifres7069, label %then7061, label %else7061

then7061:
%val7070 = load %FBO*, %FBO** %objPtr
%val7071 = load %FBO*, %FBO** %xPtr
; tuple ref
%val7072 = getelementptr %FBO, %FBO* %val7071, i64 0, i32 1
%val7073 = load %Texture*, %Texture** %val7072
%val7074 = load %mzone*, %mzone** %fromzPtr
%val7075 = load %mzone*, %mzone** %tozPtr
%res7076 = call fastcc %Texture* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd(%Texture* %val7073, %mzone* %val7074, %mzone* %val7075)
; set tuple
%val7077 = getelementptr %FBO, %FBO* %val7070, i64 0, i32 1
store %Texture* %res7076, %Texture** %val7077
store %Texture* %res7076, %Texture** %ifptr7061
br label %ifcont7061

else7061:
br label %ifcont7061

ifcont7061:
%ifres7078 = load %Texture*, %Texture** %ifptr7061

%val7081 = load %FBO*, %FBO** %xPtr
; tuple ref
%val7082 = getelementptr %FBO, %FBO* %val7081, i64 0, i32 2
%val7083 = load %Texture*, %Texture** %val7082
%val7084 = icmp eq %Texture* %val7083, null
br i1 %val7084, label %then7080, label %else7080

then7080:
%res7085 = call ccc i1 @impc_false()
store i1 %res7085, i1* %ifptr7080
br label %ifcont7080

else7080:
%res7086 = call ccc i1 @impc_true()
store i1 %res7086, i1* %ifptr7080
br label %ifcont7080

ifcont7080:
%ifres7087 = load i1, i1* %ifptr7080

br i1 %ifres7087, label %then7079, label %else7079

then7079:
%val7088 = load %FBO*, %FBO** %objPtr
%val7089 = load %FBO*, %FBO** %xPtr
; tuple ref
%val7090 = getelementptr %FBO, %FBO* %val7089, i64 0, i32 2
%val7091 = load %Texture*, %Texture** %val7090
%val7092 = load %mzone*, %mzone** %fromzPtr
%val7093 = load %mzone*, %mzone** %tozPtr
%res7094 = call fastcc %Texture* @zcopy_adhoc_W1RleHR1cmUqLFRleHR1cmUqLG16b25lKixtem9uZSpd(%Texture* %val7091, %mzone* %val7092, %mzone* %val7093)
; set tuple
%val7095 = getelementptr %FBO, %FBO* %val7088, i64 0, i32 2
store %Texture* %res7094, %Texture** %val7095
store %Texture* %res7094, %Texture** %ifptr7079
br label %ifcont7079

else7079:
br label %ifcont7079

ifcont7079:
%ifres7096 = load %Texture*, %Texture** %ifptr7079

%val7097 = load %FBO*, %FBO** %objPtr
%val7098 = load %FBO*, %FBO** %xPtr
; tuple ref
%val7099 = getelementptr %FBO, %FBO* %val7098, i64 0, i32 3
%val7100 = load i32, i32* %val7099
; set tuple
%val7101 = getelementptr %FBO, %FBO* %val7097, i64 0, i32 3
store i32 %val7100, i32* %val7101
%val7102 = load %FBO*, %FBO** %objPtr
%val7103 = load %FBO*, %FBO** %xPtr
; tuple ref
%val7104 = getelementptr %FBO, %FBO* %val7103, i64 0, i32 4
%val7105 = load i32, i32* %val7104
; set tuple
%val7106 = getelementptr %FBO, %FBO* %val7102, i64 0, i32 4
store i32 %val7105, i32* %val7106
%oldzone7107 = call %mzone* @llvm_pop_zone_stack()
%newzone7108 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr7109 = bitcast %mzone* %newzone7108 to i8*
store i8* %zone_ptr7109, i8** %_impzPtr
%val7110 = load %FBO*, %FBO** %objPtr
ret %FBO* %val7110

else7042:
%val7113 = load %FBO*, %FBO** %xPtr
ret %FBO* %val7113
}
@gsxtmgl-objects2428 = hidden constant [100 x i8] c"zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7133 = load i8*, i8** %_impzPtr
%zone7134 = bitcast i8* %tzone7133 to %mzone*

; let assign value to symbol zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone7134, i64 8)
%zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***
%tzone7114 = load i8*, i8** %_impzPtr
%zone7115 = bitcast i8* %tzone7114 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7115)
; malloc closure structure
%clsptr7116 = call i8* @llvm_zone_malloc(%mzone* %zone7115, i64 24)
%closure7117 = bitcast i8* %clsptr7116 to { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr7118 = call i8* @llvm_zone_malloc(%mzone* %zone7115, i64 8)
%environment7119 = bitcast i8* %envptr7118 to {{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable7120 = call %clsvar* @new_address_table()
%var7121 = bitcast [47 x i8]* @gsxtmgl-objects2426 to i8*
%var7122 = bitcast [57 x i8]* @gsxtmgl-objects2427 to i8*
%addytable7123 = call %clsvar* @add_address_table(%mzone* %zone7115, i8* %var7121, i32 0, i8* %var7122, i32 3, %clsvar* %addytable7120)
%address-table7124 = bitcast %clsvar* %addytable7123 to i8*

; insert table, function and environment into closure struct
%closure.table7127 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure7117, i32 0, i32 0
store i8* %address-table7124, i8** %closure.table7127
%closure.env7128 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure7117, i32 0, i32 1
store i8* %envptr7118, i8** %closure.env7128
%closure.func7129 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure7117, i32 0, i32 2
store %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ__7040, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)** %closure.func7129
%closure_size7130 = call i64 @llvm_zone_mark_size(%mzone* %zone7115)
call void @llvm_zone_ptr_set_size(i8* %clsptr7116, i64 %closure_size7130)
%wrapper_ptr7131 = call i8* @llvm_zone_malloc(%mzone* %zone7115, i64 8)
%closure_wrapper7132 = bitcast i8* %wrapper_ptr7131 to { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**
store { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure7117, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_wrapper7132

; let value assignment
%zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_wrapper7132, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_wrapper7132
store { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ
%tmp_envptr7126 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***}* %environment7119, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**** %tmp_envptr7126


%val7135 = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %val7135
}


@zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ(%FBO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*,  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %FBO* %result
}


define dllexport ccc %FBO* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_native(%FBO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*,  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %FBO* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7136 = bitcast [100 x i8]* @gsxtmgl-objects2428 to i8*
call i32 (i8*, ...) @printf(i8* %var7136)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7137 = bitcast [100 x i8]* @gsxtmgl-objects2428 to i8*
call i32 (i8*, ...) @printf(i8* %var7137)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var7138 = bitcast [100 x i8]* @gsxtmgl-objects2428 to i8*
call i32 (i8*, ...) @printf(i8* %var7138)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*,  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%FBO*, %mzone*, %mzone*}, {%FBO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
%arg_p_1 = getelementptr {%FBO*, %mzone*, %mzone*}, {%FBO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%FBO*, %mzone*, %mzone*}, {%FBO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*,  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2429 = hidden constant [24 x i8] c"id_adhoc_W2kzMixGQk8qXQ\00"
@gsxtmgl-objects2430 = hidden constant [37 x i8] c"{i8*, i8*, i32 (i8*, i8*, %FBO*)*}**\00"
define dllexport fastcc i32 @id_adhoc_W2kzMixGQk8qXQ__7139(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7140 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*
%id_adhoc_W2kzMixGQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%id_adhoc_W2kzMixGQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %id_adhoc_W2kzMixGQk8qXQPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val7141 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val7142 = getelementptr %FBO, %FBO* %val7141, i64 0, i32 0
%val7143 = load i32, i32* %val7142
ret i32 %val7143
}
@gsxtmgl-objects2431 = hidden constant [77 x i8] c"id_adhoc_W2kzMixGQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @id_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7163 = load i8*, i8** %_impzPtr
%zone7164 = bitcast i8* %tzone7163 to %mzone*

; let assign value to symbol id_adhoc_W2kzMixGQk8qXQ
%dat_id_adhoc_W2kzMixGQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone7164, i64 8)
%id_adhoc_W2kzMixGQk8qXQPtr = bitcast i8* %dat_id_adhoc_W2kzMixGQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}***
%tzone7144 = load i8*, i8** %_impzPtr
%zone7145 = bitcast i8* %tzone7144 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7145)
; malloc closure structure
%clsptr7146 = call i8* @llvm_zone_malloc(%mzone* %zone7145, i64 24)
%closure7147 = bitcast i8* %clsptr7146 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr7148 = call i8* @llvm_zone_malloc(%mzone* %zone7145, i64 8)
%environment7149 = bitcast i8* %envptr7148 to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable7150 = call %clsvar* @new_address_table()
%var7151 = bitcast [24 x i8]* @gsxtmgl-objects2429 to i8*
%var7152 = bitcast [37 x i8]* @gsxtmgl-objects2430 to i8*
%addytable7153 = call %clsvar* @add_address_table(%mzone* %zone7145, i8* %var7151, i32 0, i8* %var7152, i32 3, %clsvar* %addytable7150)
%address-table7154 = bitcast %clsvar* %addytable7153 to i8*

; insert table, function and environment into closure struct
%closure.table7157 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7147, i32 0, i32 0
store i8* %address-table7154, i8** %closure.table7157
%closure.env7158 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7147, i32 0, i32 1
store i8* %envptr7148, i8** %closure.env7158
%closure.func7159 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7147, i32 0, i32 2
store i32 (i8*, i8*, %FBO*)* @id_adhoc_W2kzMixGQk8qXQ__7139, i32 (i8*, i8*, %FBO*)** %closure.func7159
%closure_size7160 = call i64 @llvm_zone_mark_size(%mzone* %zone7145)
call void @llvm_zone_ptr_set_size(i8* %clsptr7146, i64 %closure_size7160)
%wrapper_ptr7161 = call i8* @llvm_zone_malloc(%mzone* %zone7145, i64 8)
%closure_wrapper7162 = bitcast i8* %wrapper_ptr7161 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7147, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7162

; let value assignment
%id_adhoc_W2kzMixGQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7162, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7162
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %id_adhoc_W2kzMixGQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %id_adhoc_W2kzMixGQk8qXQPtr

; add data to environment
; don't need to alloc for env var id_adhoc_W2kzMixGQk8qXQ
%tmp_envptr7156 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %environment7149, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %id_adhoc_W2kzMixGQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %tmp_envptr7156


%val7165 = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %id_adhoc_W2kzMixGQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %val7165
}


@id_adhoc_W2kzMixGQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@id_adhoc_W2kzMixGQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @id_adhoc_W2kzMixGQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixGQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @id_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @id_adhoc_W2kzMixGQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @id_adhoc_W2kzMixGQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @id_adhoc_W2kzMixGQk8qXQ(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @id_adhoc_W2kzMixGQk8qXQ_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @id_adhoc_W2kzMixGQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7166 = bitcast [77 x i8]* @gsxtmgl-objects2431 to i8*
call i32 (i8*, ...) @printf(i8* %var7166)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @id_adhoc_W2kzMixGQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @id_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2432 = hidden constant [38 x i8] c"colour_tex_adhoc_W1RleHR1cmUqLEZCTypd\00"
@gsxtmgl-objects2433 = hidden constant [43 x i8] c"{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**\00"
define dllexport fastcc %Texture* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd__7167(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7168 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***}*
%colour_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%colour_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr = load {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**** %colour_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val7169 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val7170 = getelementptr %FBO, %FBO* %val7169, i64 0, i32 1
%val7171 = load %Texture*, %Texture** %val7170
ret %Texture* %val7171
}
@gsxtmgl-objects2434 = hidden constant [91 x i8] c"colour_tex_adhoc_W1RleHR1cmUqLEZCTypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7191 = load i8*, i8** %_impzPtr
%zone7192 = bitcast i8* %tzone7191 to %mzone*

; let assign value to symbol colour_tex_adhoc_W1RleHR1cmUqLEZCTypd
%dat_colour_tex_adhoc_W1RleHR1cmUqLEZCTypd = call i8* @llvm_zone_malloc(%mzone* %zone7192, i64 8)
%colour_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr = bitcast i8* %dat_colour_tex_adhoc_W1RleHR1cmUqLEZCTypd to { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***
%tzone7172 = load i8*, i8** %_impzPtr
%zone7173 = bitcast i8* %tzone7172 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7173)
; malloc closure structure
%clsptr7174 = call i8* @llvm_zone_malloc(%mzone* %zone7173, i64 24)
%closure7175 = bitcast i8* %clsptr7174 to { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr7176 = call i8* @llvm_zone_malloc(%mzone* %zone7173, i64 8)
%environment7177 = bitcast i8* %envptr7176 to {{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable7178 = call %clsvar* @new_address_table()
%var7179 = bitcast [38 x i8]* @gsxtmgl-objects2432 to i8*
%var7180 = bitcast [43 x i8]* @gsxtmgl-objects2433 to i8*
%addytable7181 = call %clsvar* @add_address_table(%mzone* %zone7173, i8* %var7179, i32 0, i8* %var7180, i32 3, %clsvar* %addytable7178)
%address-table7182 = bitcast %clsvar* %addytable7181 to i8*

; insert table, function and environment into closure struct
%closure.table7185 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure7175, i32 0, i32 0
store i8* %address-table7182, i8** %closure.table7185
%closure.env7186 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure7175, i32 0, i32 1
store i8* %envptr7176, i8** %closure.env7186
%closure.func7187 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure7175, i32 0, i32 2
store %Texture* (i8*, i8*, %FBO*)* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd__7167, %Texture* (i8*, i8*, %FBO*)** %closure.func7187
%closure_size7188 = call i64 @llvm_zone_mark_size(%mzone* %zone7173)
call void @llvm_zone_ptr_set_size(i8* %clsptr7174, i64 %closure_size7188)
%wrapper_ptr7189 = call i8* @llvm_zone_malloc(%mzone* %zone7173, i64 8)
%closure_wrapper7190 = bitcast i8* %wrapper_ptr7189 to { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**
store { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure7175, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_wrapper7190

; let value assignment
%colour_tex_adhoc_W1RleHR1cmUqLEZCTypd = select i1 true, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_wrapper7190, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_wrapper7190
store { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %colour_tex_adhoc_W1RleHR1cmUqLEZCTypd, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*** %colour_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr

; add data to environment
; don't need to alloc for env var colour_tex_adhoc_W1RleHR1cmUqLEZCTypd
%tmp_envptr7184 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***}* %environment7177, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*** %colour_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**** %tmp_envptr7184


%val7193 = load {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*** %colour_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr
ret {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %val7193
}


@colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_var = dllexport global [1 x i8*] [ i8* null ]

@colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %FBO*)*,  %Texture* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret %Texture* %result
}


define dllexport ccc %Texture* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %FBO*)*,  %Texture* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret %Texture* %result
}


define dllexport ccc i8*  @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7194 = bitcast [91 x i8]* @gsxtmgl-objects2434 to i8*
call i32 (i8*, ...) @printf(i8* %var7194)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %FBO*)*,  %Texture* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %FBO*)*,  %Texture* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2435 = hidden constant [37 x i8] c"depth_tex_adhoc_W1RleHR1cmUqLEZCTypd\00"
define dllexport fastcc %Texture* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd__7195(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7196 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***}*
%depth_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr_ = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%depth_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr = load {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**** %depth_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val7197 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val7198 = getelementptr %FBO, %FBO* %val7197, i64 0, i32 2
%val7199 = load %Texture*, %Texture** %val7198
ret %Texture* %val7199
}
@gsxtmgl-objects2436 = hidden constant [90 x i8] c"depth_tex_adhoc_W1RleHR1cmUqLEZCTypd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7219 = load i8*, i8** %_impzPtr
%zone7220 = bitcast i8* %tzone7219 to %mzone*

; let assign value to symbol depth_tex_adhoc_W1RleHR1cmUqLEZCTypd
%dat_depth_tex_adhoc_W1RleHR1cmUqLEZCTypd = call i8* @llvm_zone_malloc(%mzone* %zone7220, i64 8)
%depth_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr = bitcast i8* %dat_depth_tex_adhoc_W1RleHR1cmUqLEZCTypd to { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***
%tzone7200 = load i8*, i8** %_impzPtr
%zone7201 = bitcast i8* %tzone7200 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7201)
; malloc closure structure
%clsptr7202 = call i8* @llvm_zone_malloc(%mzone* %zone7201, i64 24)
%closure7203 = bitcast i8* %clsptr7202 to { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr7204 = call i8* @llvm_zone_malloc(%mzone* %zone7201, i64 8)
%environment7205 = bitcast i8* %envptr7204 to {{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable7206 = call %clsvar* @new_address_table()
%var7207 = bitcast [37 x i8]* @gsxtmgl-objects2435 to i8*
%var7208 = bitcast [43 x i8]* @gsxtmgl-objects2433 to i8*
%addytable7209 = call %clsvar* @add_address_table(%mzone* %zone7201, i8* %var7207, i32 0, i8* %var7208, i32 3, %clsvar* %addytable7206)
%address-table7210 = bitcast %clsvar* %addytable7209 to i8*

; insert table, function and environment into closure struct
%closure.table7213 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure7203, i32 0, i32 0
store i8* %address-table7210, i8** %closure.table7213
%closure.env7214 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure7203, i32 0, i32 1
store i8* %envptr7204, i8** %closure.env7214
%closure.func7215 = getelementptr { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure7203, i32 0, i32 2
store %Texture* (i8*, i8*, %FBO*)* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd__7195, %Texture* (i8*, i8*, %FBO*)** %closure.func7215
%closure_size7216 = call i64 @llvm_zone_mark_size(%mzone* %zone7201)
call void @llvm_zone_ptr_set_size(i8* %clsptr7202, i64 %closure_size7216)
%wrapper_ptr7217 = call i8* @llvm_zone_malloc(%mzone* %zone7201, i64 8)
%closure_wrapper7218 = bitcast i8* %wrapper_ptr7217 to { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**
store { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure7203, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_wrapper7218

; let value assignment
%depth_tex_adhoc_W1RleHR1cmUqLEZCTypd = select i1 true, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_wrapper7218, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_wrapper7218
store { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %depth_tex_adhoc_W1RleHR1cmUqLEZCTypd, { i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*** %depth_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr

; add data to environment
; don't need to alloc for env var depth_tex_adhoc_W1RleHR1cmUqLEZCTypd
%tmp_envptr7212 = getelementptr {{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}***}* %environment7205, i32 0, i32 0
store {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*** %depth_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**** %tmp_envptr7212


%val7221 = load {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*** %depth_tex_adhoc_W1RleHR1cmUqLEZCTypdPtr
ret {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %val7221
}


@depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_var = dllexport global [1 x i8*] [ i8* null ]

@depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Texture* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %FBO*)*,  %Texture* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret %Texture* %result
}


define dllexport ccc %Texture* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %FBO*)*,  %Texture* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret %Texture* %result
}


define dllexport ccc i8*  @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7222 = bitcast [90 x i8]* @gsxtmgl-objects2436 to i8*
call i32 (i8*, ...) @printf(i8* %var7222)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %FBO*)*,  %Texture* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%tmpres = bitcast %Texture* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}, {i8*, i8*, %Texture* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %Texture* (i8*, i8*, %FBO*)*,  %Texture* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Texture* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2437 = hidden constant [27 x i8] c"width_adhoc_W2kzMixGQk8qXQ\00"
define dllexport fastcc i32 @width_adhoc_W2kzMixGQk8qXQ__7223(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7224 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*
%width_adhoc_W2kzMixGQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%width_adhoc_W2kzMixGQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %width_adhoc_W2kzMixGQk8qXQPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val7225 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val7226 = getelementptr %FBO, %FBO* %val7225, i64 0, i32 3
%val7227 = load i32, i32* %val7226
ret i32 %val7227
}
@gsxtmgl-objects2438 = hidden constant [80 x i8] c"width_adhoc_W2kzMixGQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @width_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7247 = load i8*, i8** %_impzPtr
%zone7248 = bitcast i8* %tzone7247 to %mzone*

; let assign value to symbol width_adhoc_W2kzMixGQk8qXQ
%dat_width_adhoc_W2kzMixGQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone7248, i64 8)
%width_adhoc_W2kzMixGQk8qXQPtr = bitcast i8* %dat_width_adhoc_W2kzMixGQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}***
%tzone7228 = load i8*, i8** %_impzPtr
%zone7229 = bitcast i8* %tzone7228 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7229)
; malloc closure structure
%clsptr7230 = call i8* @llvm_zone_malloc(%mzone* %zone7229, i64 24)
%closure7231 = bitcast i8* %clsptr7230 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr7232 = call i8* @llvm_zone_malloc(%mzone* %zone7229, i64 8)
%environment7233 = bitcast i8* %envptr7232 to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable7234 = call %clsvar* @new_address_table()
%var7235 = bitcast [27 x i8]* @gsxtmgl-objects2437 to i8*
%var7236 = bitcast [37 x i8]* @gsxtmgl-objects2430 to i8*
%addytable7237 = call %clsvar* @add_address_table(%mzone* %zone7229, i8* %var7235, i32 0, i8* %var7236, i32 3, %clsvar* %addytable7234)
%address-table7238 = bitcast %clsvar* %addytable7237 to i8*

; insert table, function and environment into closure struct
%closure.table7241 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7231, i32 0, i32 0
store i8* %address-table7238, i8** %closure.table7241
%closure.env7242 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7231, i32 0, i32 1
store i8* %envptr7232, i8** %closure.env7242
%closure.func7243 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7231, i32 0, i32 2
store i32 (i8*, i8*, %FBO*)* @width_adhoc_W2kzMixGQk8qXQ__7223, i32 (i8*, i8*, %FBO*)** %closure.func7243
%closure_size7244 = call i64 @llvm_zone_mark_size(%mzone* %zone7229)
call void @llvm_zone_ptr_set_size(i8* %clsptr7230, i64 %closure_size7244)
%wrapper_ptr7245 = call i8* @llvm_zone_malloc(%mzone* %zone7229, i64 8)
%closure_wrapper7246 = bitcast i8* %wrapper_ptr7245 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7231, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7246

; let value assignment
%width_adhoc_W2kzMixGQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7246, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7246
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %width_adhoc_W2kzMixGQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %width_adhoc_W2kzMixGQk8qXQPtr

; add data to environment
; don't need to alloc for env var width_adhoc_W2kzMixGQk8qXQ
%tmp_envptr7240 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %environment7233, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %width_adhoc_W2kzMixGQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %tmp_envptr7240


%val7249 = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %width_adhoc_W2kzMixGQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %val7249
}


@width_adhoc_W2kzMixGQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@width_adhoc_W2kzMixGQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @width_adhoc_W2kzMixGQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixGQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @width_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @width_adhoc_W2kzMixGQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @width_adhoc_W2kzMixGQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @width_adhoc_W2kzMixGQk8qXQ(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @width_adhoc_W2kzMixGQk8qXQ_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @width_adhoc_W2kzMixGQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7250 = bitcast [80 x i8]* @gsxtmgl-objects2438 to i8*
call i32 (i8*, ...) @printf(i8* %var7250)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @width_adhoc_W2kzMixGQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @width_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2439 = hidden constant [28 x i8] c"height_adhoc_W2kzMixGQk8qXQ\00"
define dllexport fastcc i32 @height_adhoc_W2kzMixGQk8qXQ__7251(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7252 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*
%height_adhoc_W2kzMixGQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%height_adhoc_W2kzMixGQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %height_adhoc_W2kzMixGQk8qXQPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val7253 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val7254 = getelementptr %FBO, %FBO* %val7253, i64 0, i32 4
%val7255 = load i32, i32* %val7254
ret i32 %val7255
}
@gsxtmgl-objects2440 = hidden constant [81 x i8] c"height_adhoc_W2kzMixGQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @height_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7275 = load i8*, i8** %_impzPtr
%zone7276 = bitcast i8* %tzone7275 to %mzone*

; let assign value to symbol height_adhoc_W2kzMixGQk8qXQ
%dat_height_adhoc_W2kzMixGQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone7276, i64 8)
%height_adhoc_W2kzMixGQk8qXQPtr = bitcast i8* %dat_height_adhoc_W2kzMixGQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}***
%tzone7256 = load i8*, i8** %_impzPtr
%zone7257 = bitcast i8* %tzone7256 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7257)
; malloc closure structure
%clsptr7258 = call i8* @llvm_zone_malloc(%mzone* %zone7257, i64 24)
%closure7259 = bitcast i8* %clsptr7258 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr7260 = call i8* @llvm_zone_malloc(%mzone* %zone7257, i64 8)
%environment7261 = bitcast i8* %envptr7260 to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable7262 = call %clsvar* @new_address_table()
%var7263 = bitcast [28 x i8]* @gsxtmgl-objects2439 to i8*
%var7264 = bitcast [37 x i8]* @gsxtmgl-objects2430 to i8*
%addytable7265 = call %clsvar* @add_address_table(%mzone* %zone7257, i8* %var7263, i32 0, i8* %var7264, i32 3, %clsvar* %addytable7262)
%address-table7266 = bitcast %clsvar* %addytable7265 to i8*

; insert table, function and environment into closure struct
%closure.table7269 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7259, i32 0, i32 0
store i8* %address-table7266, i8** %closure.table7269
%closure.env7270 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7259, i32 0, i32 1
store i8* %envptr7260, i8** %closure.env7270
%closure.func7271 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7259, i32 0, i32 2
store i32 (i8*, i8*, %FBO*)* @height_adhoc_W2kzMixGQk8qXQ__7251, i32 (i8*, i8*, %FBO*)** %closure.func7271
%closure_size7272 = call i64 @llvm_zone_mark_size(%mzone* %zone7257)
call void @llvm_zone_ptr_set_size(i8* %clsptr7258, i64 %closure_size7272)
%wrapper_ptr7273 = call i8* @llvm_zone_malloc(%mzone* %zone7257, i64 8)
%closure_wrapper7274 = bitcast i8* %wrapper_ptr7273 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7259, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7274

; let value assignment
%height_adhoc_W2kzMixGQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7274, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7274
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %height_adhoc_W2kzMixGQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %height_adhoc_W2kzMixGQk8qXQPtr

; add data to environment
; don't need to alloc for env var height_adhoc_W2kzMixGQk8qXQ
%tmp_envptr7268 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %environment7261, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %height_adhoc_W2kzMixGQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %tmp_envptr7268


%val7277 = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %height_adhoc_W2kzMixGQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %val7277
}


@height_adhoc_W2kzMixGQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@height_adhoc_W2kzMixGQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @height_adhoc_W2kzMixGQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixGQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @height_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @height_adhoc_W2kzMixGQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @height_adhoc_W2kzMixGQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @height_adhoc_W2kzMixGQk8qXQ(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @height_adhoc_W2kzMixGQk8qXQ_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @height_adhoc_W2kzMixGQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7278 = bitcast [81 x i8]* @gsxtmgl-objects2440 to i8*
call i32 (i8*, ...) @printf(i8* %var7278)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @height_adhoc_W2kzMixGQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @height_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2441 = hidden constant [11 x i8] c"<FBO: 0x0>\00"
@gsxtmgl-objects2442 = hidden constant [10 x i8] c"<FBO: id=\00"
@gsxtmgl-objects2443 = hidden constant [12 x i8] c" color_tex=\00"
@gsxtmgl-objects2444 = hidden constant [12 x i8] c" depth_tex=\00"
@gsxtmgl-objects2445 = hidden constant [8 x i8] c" width=\00"
@gsxtmgl-objects2446 = hidden constant [9 x i8] c" height=\00"
@gsxtmgl-objects2447 = hidden constant [3 x i8] c">
\00"
@gsxtmgl-objects2448 = hidden constant [28 x i8] c"print_adhoc_W3ZvaWQsRkJPKl0\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsRkJPKl0__7279(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7280 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}*
%print_adhoc_W3ZvaWQsRkJPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsRkJPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %FBO*)*}***, {i8*, i8*, void (i8*, i8*, %FBO*)*}**** %print_adhoc_W3ZvaWQsRkJPKl0Ptr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val7282 = load %FBO*, %FBO** %fboPtr
%val7283 = icmp eq %FBO* %val7282, null
br i1 %val7283, label %then7281, label %else7281

then7281:
%var7284 = bitcast [11 x i8]* @gsxtmgl-objects2441 to i8*

%val7285 = call i32 (i8*, ...) @printf(i8* %var7284)
br label %ifcont7281

else7281:
%var7287 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var7288 = bitcast [10 x i8]* @gsxtmgl-objects2442 to i8*

%val7289 = call i32 (i8*, ...) @printf(i8* %var7287, i8* %var7288)
%val7290 = load %FBO*, %FBO** %fboPtr
%res7291 = call fastcc i32 @id_adhoc_W2kzMixGQk8qXQ(%FBO* %val7290)
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %res7291)
%var7293 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var7294 = bitcast [12 x i8]* @gsxtmgl-objects2443 to i8*

%val7295 = call i32 (i8*, ...) @printf(i8* %var7293, i8* %var7294)
%val7296 = load %FBO*, %FBO** %fboPtr
%res7297 = call fastcc %Texture* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val7296)
call fastcc void @print_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %res7297)
%var7299 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var7300 = bitcast [12 x i8]* @gsxtmgl-objects2444 to i8*

%val7301 = call i32 (i8*, ...) @printf(i8* %var7299, i8* %var7300)
%val7302 = load %FBO*, %FBO** %fboPtr
%res7303 = call fastcc %Texture* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val7302)
call fastcc void @print_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %res7303)
%var7305 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var7306 = bitcast [8 x i8]* @gsxtmgl-objects2445 to i8*

%val7307 = call i32 (i8*, ...) @printf(i8* %var7305, i8* %var7306)
%val7308 = load %FBO*, %FBO** %fboPtr
%res7309 = call fastcc i32 @width_adhoc_W2kzMixGQk8qXQ(%FBO* %val7308)
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %res7309)
%var7311 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var7312 = bitcast [9 x i8]* @gsxtmgl-objects2446 to i8*

%val7313 = call i32 (i8*, ...) @printf(i8* %var7311, i8* %var7312)
%val7314 = load %FBO*, %FBO** %fboPtr
%res7315 = call fastcc i32 @height_adhoc_W2kzMixGQk8qXQ(%FBO* %val7314)
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %res7315)
%var7317 = bitcast [3 x i8]* @gsxtmgl-objects212 to i8*
%var7318 = bitcast [3 x i8]* @gsxtmgl-objects2447 to i8*

%val7319 = call i32 (i8*, ...) @printf(i8* %var7317, i8* %var7318)
br label %ifcont7281

ifcont7281:
ret void
}
@gsxtmgl-objects2449 = hidden constant [81 x i8] c"print_adhoc_W3ZvaWQsRkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %FBO*)*}** @print_adhoc_W3ZvaWQsRkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7341 = load i8*, i8** %_impzPtr
%zone7342 = bitcast i8* %tzone7341 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsRkJPKl0
%dat_print_adhoc_W3ZvaWQsRkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone7342, i64 8)
%print_adhoc_W3ZvaWQsRkJPKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsRkJPKl0 to { i8*, i8*, void (i8*, i8*, %FBO*)*}***
%tzone7322 = load i8*, i8** %_impzPtr
%zone7323 = bitcast i8* %tzone7322 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7323)
; malloc closure structure
%clsptr7324 = call i8* @llvm_zone_malloc(%mzone* %zone7323, i64 24)
%closure7325 = bitcast i8* %clsptr7324 to { i8*, i8*, void (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr7326 = call i8* @llvm_zone_malloc(%mzone* %zone7323, i64 8)
%environment7327 = bitcast i8* %envptr7326 to {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable7328 = call %clsvar* @new_address_table()
%var7329 = bitcast [28 x i8]* @gsxtmgl-objects2448 to i8*
%var7330 = bitcast [38 x i8]* @gsxtmgl-objects2424 to i8*
%addytable7331 = call %clsvar* @add_address_table(%mzone* %zone7323, i8* %var7329, i32 0, i8* %var7330, i32 3, %clsvar* %addytable7328)
%address-table7332 = bitcast %clsvar* %addytable7331 to i8*

; insert table, function and environment into closure struct
%closure.table7335 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*)*}, { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure7325, i32 0, i32 0
store i8* %address-table7332, i8** %closure.table7335
%closure.env7336 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*)*}, { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure7325, i32 0, i32 1
store i8* %envptr7326, i8** %closure.env7336
%closure.func7337 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*)*}, { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure7325, i32 0, i32 2
store void (i8*, i8*, %FBO*)* @print_adhoc_W3ZvaWQsRkJPKl0__7279, void (i8*, i8*, %FBO*)** %closure.func7337
%closure_size7338 = call i64 @llvm_zone_mark_size(%mzone* %zone7323)
call void @llvm_zone_ptr_set_size(i8* %clsptr7324, i64 %closure_size7338)
%wrapper_ptr7339 = call i8* @llvm_zone_malloc(%mzone* %zone7323, i64 8)
%closure_wrapper7340 = bitcast i8* %wrapper_ptr7339 to { i8*, i8*, void (i8*, i8*, %FBO*)*}**
store { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure7325, { i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_wrapper7340

; let value assignment
%print_adhoc_W3ZvaWQsRkJPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_wrapper7340, { i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_wrapper7340
store { i8*, i8*, void (i8*, i8*, %FBO*)*}** %print_adhoc_W3ZvaWQsRkJPKl0, { i8*, i8*, void (i8*, i8*, %FBO*)*}*** %print_adhoc_W3ZvaWQsRkJPKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsRkJPKl0
%tmp_envptr7334 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}* %environment7327, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %FBO*)*}*** %print_adhoc_W3ZvaWQsRkJPKl0Ptr, {i8*, i8*, void (i8*, i8*, %FBO*)*}**** %tmp_envptr7334


%val7343 = load {i8*, i8*, void (i8*, i8*, %FBO*)*}**, {i8*, i8*, void (i8*, i8*, %FBO*)*}*** %print_adhoc_W3ZvaWQsRkJPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %FBO*)*}** %val7343
}


@print_adhoc_W3ZvaWQsRkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsRkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsRkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %FBO*)*}** @print_adhoc_W3ZvaWQsRkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsRkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsRkJPKl0(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsRkJPKl0_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsRkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7344 = bitcast [81 x i8]* @gsxtmgl-objects2449 to i8*
call i32 (i8*, ...) @printf(i8* %var7344)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsRkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2450 = hidden constant [58 x i8] c"<FBO: id=%d color_tex=%d depth_tex=%d width=%d height=%d>\00"
@gsxtmgl-objects2451 = hidden constant [35 x i8] c"toString_adhoc_W1N0cmluZyosRkJPKl0\00"
@gsxtmgl-objects2452 = hidden constant [42 x i8] c"{i8*, i8*, %String* (i8*, i8*, %FBO*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosRkJPKl0__7345(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7346 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %FBO*)*}***}*
%toString_adhoc_W1N0cmluZyosRkJPKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosRkJPKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %FBO*)*}***, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**** %toString_adhoc_W1N0cmluZyosRkJPKl0Ptr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%tzone7353 = load i8*, i8** %_impzPtr
%zone7354 = bitcast i8* %tzone7353 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%val7347 = getelementptr i64, i64* null, i32 1
%zonesize7348 = mul i64 1, 256
%tzone7349 = load i8*, i8** %_impzPtr
%zone7350 = bitcast i8* %tzone7349 to %mzone*
%dat7351 = call i8* @llvm_zone_malloc(%mzone* %zone7350, i64 %zonesize7348)
call i8* @memset(i8* %dat7351, i32 0, i64 %zonesize7348)
%val7352 = bitcast i8* %dat7351 to i8*

; let value assignment
%str = select i1 true, i8* %val7352, i8* %val7352
store i8* %str, i8** %strPtr

; promote local stack var allocations
%tzone7377 = load i8*, i8** %_impzPtr
%zone7378 = bitcast i8* %tzone7377 to %mzone*
%ifptr7355 = alloca i32
%val7356 = load %FBO*, %FBO** %fboPtr
%val7357 = icmp eq %FBO* %val7356, null
br i1 %val7357, label %then7355, label %else7355

then7355:
%val7358 = load i8*, i8** %strPtr
%var7359 = bitcast [11 x i8]* @gsxtmgl-objects2441 to i8*

%val7360 = call i32 (i8*,i8*, ...) @sprintf(i8* %val7358, i8* %var7359)
store i32 %val7360, i32* %ifptr7355
br label %ifcont7355

else7355:
%val7361 = load i8*, i8** %strPtr
%var7362 = bitcast [58 x i8]* @gsxtmgl-objects2450 to i8*
%val7363 = load %FBO*, %FBO** %fboPtr
%res7364 = call fastcc i32 @id_adhoc_W2kzMixGQk8qXQ(%FBO* %val7363)
%val7365 = load %FBO*, %FBO** %fboPtr
%res7366 = call fastcc %Texture* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val7365)
%val7367 = load %FBO*, %FBO** %fboPtr
%res7368 = call fastcc %Texture* @depth_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val7367)
%val7369 = load %FBO*, %FBO** %fboPtr
%res7370 = call fastcc i32 @width_adhoc_W2kzMixGQk8qXQ(%FBO* %val7369)
%val7371 = load %FBO*, %FBO** %fboPtr
%res7372 = call fastcc i32 @height_adhoc_W2kzMixGQk8qXQ(%FBO* %val7371)

%val7373 = call i32 (i8*,i8*, ...) @sprintf(i8* %val7361, i8* %var7362, i32 %res7364, %Texture* %res7366, %Texture* %res7368, i32 %res7370, i32 %res7372)
store i32 %val7373, i32* %ifptr7355
br label %ifcont7355

ifcont7355:
%ifres7374 = load i32, i32* %ifptr7355

%val7375 = load i8*, i8** %strPtr
%res7376 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val7375)
ret %String* %res7376
}
@gsxtmgl-objects2453 = hidden constant [88 x i8] c"toString_adhoc_W1N0cmluZyosRkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** @toString_adhoc_W1N0cmluZyosRkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7398 = load i8*, i8** %_impzPtr
%zone7399 = bitcast i8* %tzone7398 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosRkJPKl0
%dat_toString_adhoc_W1N0cmluZyosRkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone7399, i64 8)
%toString_adhoc_W1N0cmluZyosRkJPKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosRkJPKl0 to { i8*, i8*, %String* (i8*, i8*, %FBO*)*}***
%tzone7379 = load i8*, i8** %_impzPtr
%zone7380 = bitcast i8* %tzone7379 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7380)
; malloc closure structure
%clsptr7381 = call i8* @llvm_zone_malloc(%mzone* %zone7380, i64 24)
%closure7382 = bitcast i8* %clsptr7381 to { i8*, i8*, %String* (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr7383 = call i8* @llvm_zone_malloc(%mzone* %zone7380, i64 8)
%environment7384 = bitcast i8* %envptr7383 to {{i8*, i8*, %String* (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable7385 = call %clsvar* @new_address_table()
%var7386 = bitcast [35 x i8]* @gsxtmgl-objects2451 to i8*
%var7387 = bitcast [42 x i8]* @gsxtmgl-objects2452 to i8*
%addytable7388 = call %clsvar* @add_address_table(%mzone* %zone7380, i8* %var7386, i32 0, i8* %var7387, i32 3, %clsvar* %addytable7385)
%address-table7389 = bitcast %clsvar* %addytable7388 to i8*

; insert table, function and environment into closure struct
%closure.table7392 = getelementptr { i8*, i8*, %String* (i8*, i8*, %FBO*)*}, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure7382, i32 0, i32 0
store i8* %address-table7389, i8** %closure.table7392
%closure.env7393 = getelementptr { i8*, i8*, %String* (i8*, i8*, %FBO*)*}, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure7382, i32 0, i32 1
store i8* %envptr7383, i8** %closure.env7393
%closure.func7394 = getelementptr { i8*, i8*, %String* (i8*, i8*, %FBO*)*}, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure7382, i32 0, i32 2
store %String* (i8*, i8*, %FBO*)* @toString_adhoc_W1N0cmluZyosRkJPKl0__7345, %String* (i8*, i8*, %FBO*)** %closure.func7394
%closure_size7395 = call i64 @llvm_zone_mark_size(%mzone* %zone7380)
call void @llvm_zone_ptr_set_size(i8* %clsptr7381, i64 %closure_size7395)
%wrapper_ptr7396 = call i8* @llvm_zone_malloc(%mzone* %zone7380, i64 8)
%closure_wrapper7397 = bitcast i8* %wrapper_ptr7396 to { i8*, i8*, %String* (i8*, i8*, %FBO*)*}**
store { i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure7382, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_wrapper7397

; let value assignment
%toString_adhoc_W1N0cmluZyosRkJPKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_wrapper7397, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_wrapper7397
store { i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %toString_adhoc_W1N0cmluZyosRkJPKl0, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}*** %toString_adhoc_W1N0cmluZyosRkJPKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosRkJPKl0
%tmp_envptr7391 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %FBO*)*}***}* %environment7384, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %FBO*)*}*** %toString_adhoc_W1N0cmluZyosRkJPKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**** %tmp_envptr7391


%val7400 = load {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}*** %toString_adhoc_W1N0cmluZyosRkJPKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %val7400
}


@toString_adhoc_W1N0cmluZyosRkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosRkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosRkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** @toString_adhoc_W1N0cmluZyosRkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosRkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosRkJPKl0(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %FBO*)*,  %String* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosRkJPKl0_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %FBO*)*,  %String* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosRkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7401 = bitcast [88 x i8]* @gsxtmgl-objects2453 to i8*
call i32 (i8*, ...) @printf(i8* %var7401)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %FBO*)*,  %String* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosRkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %FBO*)*,  %String* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2454 = hidden constant [19 x i8] c"Error creating FBO\00"
@gsxtmgl-objects2455 = hidden constant [19 x i8] c"FBO_adhoc_W0ZCTypd\00"
@gsxtmgl-objects2456 = hidden constant [32 x i8] c"{i8*, i8*, %FBO* (i8*, i8*)*}**\00"
define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTypd__7402(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7403 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*)*}***}*
%FBO_adhoc_W0ZCTypdPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%FBO_adhoc_W0ZCTypdPtr = load {i8*, i8*, %FBO* (i8*, i8*)*}***, {i8*, i8*, %FBO* (i8*, i8*)*}**** %FBO_adhoc_W0ZCTypdPtr_

; setup arguments


%tzone7407 = load i8*, i8** %_impzPtr
%zone7408 = bitcast i8* %tzone7407 to %mzone*

; let assign value to symbol fbo
%fboPtr = alloca %FBO*
%null7404 = bitcast i8* null to %Texture*
%null7405 = bitcast i8* null to %Texture*
%res7406 = call fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd(i32 0, %Texture* %null7404, %Texture* %null7405, i32 0, i32 0)

; let value assignment
%fbo = select i1 true, %FBO* %res7406, %FBO* %res7406
store %FBO* %fbo, %FBO** %fboPtr

%val7409 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val7410 = getelementptr %FBO, %FBO* %val7409, i64 0, i32 0
call fastcc void @glGenFramebuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val7410)
%var7412 = bitcast [19 x i8]* @gsxtmgl-objects2454 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var7412)
%val7414 = load %FBO*, %FBO** %fboPtr
ret %FBO* %val7414
}
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*)*}** @FBO_adhoc_W0ZCTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7434 = load i8*, i8** %_impzPtr
%zone7435 = bitcast i8* %tzone7434 to %mzone*

; let assign value to symbol FBO_adhoc_W0ZCTypd
%dat_FBO_adhoc_W0ZCTypd = call i8* @llvm_zone_malloc(%mzone* %zone7435, i64 8)
%FBO_adhoc_W0ZCTypdPtr = bitcast i8* %dat_FBO_adhoc_W0ZCTypd to { i8*, i8*, %FBO* (i8*, i8*)*}***
%tzone7415 = load i8*, i8** %_impzPtr
%zone7416 = bitcast i8* %tzone7415 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7416)
; malloc closure structure
%clsptr7417 = call i8* @llvm_zone_malloc(%mzone* %zone7416, i64 24)
%closure7418 = bitcast i8* %clsptr7417 to { i8*, i8*, %FBO* (i8*, i8*)*}*

; malloc environment structure
%envptr7419 = call i8* @llvm_zone_malloc(%mzone* %zone7416, i64 8)
%environment7420 = bitcast i8* %envptr7419 to {{i8*, i8*, %FBO* (i8*, i8*)*}***}*

; malloc closure address table
%addytable7421 = call %clsvar* @new_address_table()
%var7422 = bitcast [19 x i8]* @gsxtmgl-objects2455 to i8*
%var7423 = bitcast [32 x i8]* @gsxtmgl-objects2456 to i8*
%addytable7424 = call %clsvar* @add_address_table(%mzone* %zone7416, i8* %var7422, i32 0, i8* %var7423, i32 3, %clsvar* %addytable7421)
%address-table7425 = bitcast %clsvar* %addytable7424 to i8*

; insert table, function and environment into closure struct
%closure.table7428 = getelementptr { i8*, i8*, %FBO* (i8*, i8*)*}, { i8*, i8*, %FBO* (i8*, i8*)*}* %closure7418, i32 0, i32 0
store i8* %address-table7425, i8** %closure.table7428
%closure.env7429 = getelementptr { i8*, i8*, %FBO* (i8*, i8*)*}, { i8*, i8*, %FBO* (i8*, i8*)*}* %closure7418, i32 0, i32 1
store i8* %envptr7419, i8** %closure.env7429
%closure.func7430 = getelementptr { i8*, i8*, %FBO* (i8*, i8*)*}, { i8*, i8*, %FBO* (i8*, i8*)*}* %closure7418, i32 0, i32 2
store %FBO* (i8*, i8*)* @FBO_adhoc_W0ZCTypd__7402, %FBO* (i8*, i8*)** %closure.func7430
%closure_size7431 = call i64 @llvm_zone_mark_size(%mzone* %zone7416)
call void @llvm_zone_ptr_set_size(i8* %clsptr7417, i64 %closure_size7431)
%wrapper_ptr7432 = call i8* @llvm_zone_malloc(%mzone* %zone7416, i64 8)
%closure_wrapper7433 = bitcast i8* %wrapper_ptr7432 to { i8*, i8*, %FBO* (i8*, i8*)*}**
store { i8*, i8*, %FBO* (i8*, i8*)*}* %closure7418, { i8*, i8*, %FBO* (i8*, i8*)*}** %closure_wrapper7433

; let value assignment
%FBO_adhoc_W0ZCTypd = select i1 true, { i8*, i8*, %FBO* (i8*, i8*)*}** %closure_wrapper7433, { i8*, i8*, %FBO* (i8*, i8*)*}** %closure_wrapper7433
store { i8*, i8*, %FBO* (i8*, i8*)*}** %FBO_adhoc_W0ZCTypd, { i8*, i8*, %FBO* (i8*, i8*)*}*** %FBO_adhoc_W0ZCTypdPtr

; add data to environment
; don't need to alloc for env var FBO_adhoc_W0ZCTypd
%tmp_envptr7427 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***}* %environment7420, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*)*}*** %FBO_adhoc_W0ZCTypdPtr, {i8*, i8*, %FBO* (i8*, i8*)*}**** %tmp_envptr7427


%val7436 = load {i8*, i8*, %FBO* (i8*, i8*)*}**, {i8*, i8*, %FBO* (i8*, i8*)*}*** %FBO_adhoc_W0ZCTypdPtr
ret {i8*, i8*, %FBO* (i8*, i8*)*}** %val7436
}


@FBO_adhoc_W0ZCTypd_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_adhoc_W0ZCTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_adhoc_W0ZCTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*)*}** @FBO_adhoc_W0ZCTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_adhoc_W0ZCTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_adhoc_W0ZCTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_adhoc_W0ZCTypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_adhoc_W0ZCTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_adhoc_W0ZCTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2457 = hidden constant [31 x i8] c"FBO_adhoc_W0ZCTyosVGV4dHVyZSpd\00"
@gsxtmgl-objects2458 = hidden constant [43 x i8] c"{i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}**\00"
define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd__7437(i8* %_impz,i8* %_impenv, %Texture* %colour) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7438 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}***}*
%FBO_adhoc_W0ZCTyosVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}***}* %impenv, i32 0, i32 0
%FBO_adhoc_W0ZCTyosVGV4dHVyZSpdPtr = load {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}***, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}**** %FBO_adhoc_W0ZCTyosVGV4dHVyZSpdPtr_

; setup arguments
%colourPtr = alloca %Texture*
store %Texture* %colour, %Texture** %colourPtr


%tzone7446 = load i8*, i8** %_impzPtr
%zone7447 = bitcast i8* %tzone7446 to %mzone*

; let assign value to symbol fbo
%fboPtr = alloca %FBO*
%val7439 = load %Texture*, %Texture** %colourPtr
%null7440 = bitcast i8* null to %Texture*
%val7441 = load %Texture*, %Texture** %colourPtr
%res7442 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7441)
%val7443 = load %Texture*, %Texture** %colourPtr
%res7444 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7443)
%res7445 = call fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd(i32 0, %Texture* %val7439, %Texture* %null7440, i32 %res7442, i32 %res7444)

; let value assignment
%fbo = select i1 true, %FBO* %res7445, %FBO* %res7445
store %FBO* %fbo, %FBO** %fboPtr

%val7448 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val7449 = getelementptr %FBO, %FBO* %val7448, i64 0, i32 0
call fastcc void @glGenFramebuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val7449)
%var7451 = bitcast [19 x i8]* @gsxtmgl-objects2454 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var7451)
%val7453 = load i32, i32* @GL_FRAMEBUFFER
%val7454 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val7455 = getelementptr %FBO, %FBO* %val7454, i64 0, i32 0
%val7456 = load i32, i32* %val7455
call fastcc void @glBindFramebuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val7453, i32 %val7456)
%val7458 = load %Texture*, %Texture** %colourPtr
%res7459 = call fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7458)
%val7460 = load i32, i32* @GL_FRAMEBUFFER
%val7461 = load i32, i32* @GL_COLOR_ATTACHMENT0
%val7462 = load i32, i32* @GL_TEXTURE_2D
%val7463 = load %Texture*, %Texture** %colourPtr
%res7464 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7463)
call fastcc void @glFramebufferTexture2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %val7460, i32 %val7461, i32 %val7462, i32 %res7464, i32 0)
%val7466 = load %Texture*, %Texture** %colourPtr
call fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val7466)
%val7468 = load %Texture*, %Texture** %colourPtr
call fastcc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val7468)
%val7470 = load i32, i32* @GL_FRAMEBUFFER
call fastcc void @glBindFramebuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val7470, i32 0)
%val7472 = load %FBO*, %FBO** %fboPtr
ret %FBO* %val7472
}
@gsxtmgl-objects2459 = hidden constant [84 x i8] c"FBO_adhoc_W0ZCTyosVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}** @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7492 = load i8*, i8** %_impzPtr
%zone7493 = bitcast i8* %tzone7492 to %mzone*

; let assign value to symbol FBO_adhoc_W0ZCTyosVGV4dHVyZSpd
%dat_FBO_adhoc_W0ZCTyosVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone7493, i64 8)
%FBO_adhoc_W0ZCTyosVGV4dHVyZSpdPtr = bitcast i8* %dat_FBO_adhoc_W0ZCTyosVGV4dHVyZSpd to { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}***
%tzone7473 = load i8*, i8** %_impzPtr
%zone7474 = bitcast i8* %tzone7473 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7474)
; malloc closure structure
%clsptr7475 = call i8* @llvm_zone_malloc(%mzone* %zone7474, i64 24)
%closure7476 = bitcast i8* %clsptr7475 to { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}*

; malloc environment structure
%envptr7477 = call i8* @llvm_zone_malloc(%mzone* %zone7474, i64 8)
%environment7478 = bitcast i8* %envptr7477 to {{i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}***}*

; malloc closure address table
%addytable7479 = call %clsvar* @new_address_table()
%var7480 = bitcast [31 x i8]* @gsxtmgl-objects2457 to i8*
%var7481 = bitcast [43 x i8]* @gsxtmgl-objects2458 to i8*
%addytable7482 = call %clsvar* @add_address_table(%mzone* %zone7474, i8* %var7480, i32 0, i8* %var7481, i32 3, %clsvar* %addytable7479)
%address-table7483 = bitcast %clsvar* %addytable7482 to i8*

; insert table, function and environment into closure struct
%closure.table7486 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}, { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}* %closure7476, i32 0, i32 0
store i8* %address-table7483, i8** %closure.table7486
%closure.env7487 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}, { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}* %closure7476, i32 0, i32 1
store i8* %envptr7477, i8** %closure.env7487
%closure.func7488 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}, { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}* %closure7476, i32 0, i32 2
store %FBO* (i8*, i8*, %Texture*)* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd__7437, %FBO* (i8*, i8*, %Texture*)** %closure.func7488
%closure_size7489 = call i64 @llvm_zone_mark_size(%mzone* %zone7474)
call void @llvm_zone_ptr_set_size(i8* %clsptr7475, i64 %closure_size7489)
%wrapper_ptr7490 = call i8* @llvm_zone_malloc(%mzone* %zone7474, i64 8)
%closure_wrapper7491 = bitcast i8* %wrapper_ptr7490 to { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}**
store { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}* %closure7476, { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}** %closure_wrapper7491

; let value assignment
%FBO_adhoc_W0ZCTyosVGV4dHVyZSpd = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}** %closure_wrapper7491, { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}** %closure_wrapper7491
store { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}** %FBO_adhoc_W0ZCTyosVGV4dHVyZSpd, { i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}*** %FBO_adhoc_W0ZCTyosVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var FBO_adhoc_W0ZCTyosVGV4dHVyZSpd
%tmp_envptr7485 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}***}* %environment7478, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}*** %FBO_adhoc_W0ZCTyosVGV4dHVyZSpdPtr, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}**** %tmp_envptr7485


%val7494 = load {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}**, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}*** %FBO_adhoc_W0ZCTyosVGV4dHVyZSpdPtr
ret {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}** %val7494
}


@FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}** @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %Texture*)*,  %FBO* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_native(%Texture* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %Texture*)*,  %FBO* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7495 = bitcast [84 x i8]* @gsxtmgl-objects2459 to i8*
call i32 (i8*, ...) @printf(i8* %var7495)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %Texture*)*,  %FBO* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*}*
%arg_p_0 = getelementptr {%Texture*}, {%Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %Texture*)*,  %FBO* (i8*, i8*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2460 = hidden constant [43 x i8] c"FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd\00"
@gsxtmgl-objects2461 = hidden constant [54 x i8] c"{i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}**\00"
define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd__7496(i8* %_impz,i8* %_impenv, %Texture* %colour, %Texture* %depth) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7497 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}***}*
%FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpdPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}***}* %impenv, i32 0, i32 0
%FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpdPtr = load {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}***, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}**** %FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpdPtr_

; setup arguments
%colourPtr = alloca %Texture*
store %Texture* %colour, %Texture** %colourPtr
%depthPtr = alloca %Texture*
store %Texture* %depth, %Texture** %depthPtr


%tzone7505 = load i8*, i8** %_impzPtr
%zone7506 = bitcast i8* %tzone7505 to %mzone*

; let assign value to symbol fbo
%fboPtr = alloca %FBO*
%val7498 = load %Texture*, %Texture** %colourPtr
%val7499 = load %Texture*, %Texture** %depthPtr
%val7500 = load %Texture*, %Texture** %colourPtr
%res7501 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7500)
%val7502 = load %Texture*, %Texture** %colourPtr
%res7503 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7502)
%res7504 = call fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLFRleHR1cmUqLFRleHR1cmUqLGkzMixpMzJd(i32 0, %Texture* %val7498, %Texture* %val7499, i32 %res7501, i32 %res7503)

; let value assignment
%fbo = select i1 true, %FBO* %res7504, %FBO* %res7504
store %FBO* %fbo, %FBO** %fboPtr

%val7507 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val7508 = getelementptr %FBO, %FBO* %val7507, i64 0, i32 0
call fastcc void @glGenFramebuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val7508)
%var7510 = bitcast [19 x i8]* @gsxtmgl-objects2454 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var7510)
%val7512 = load i32, i32* @GL_FRAMEBUFFER
%val7513 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val7514 = getelementptr %FBO, %FBO* %val7513, i64 0, i32 0
%val7515 = load i32, i32* %val7514
call fastcc void @glBindFramebuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val7512, i32 %val7515)
%val7517 = load %Texture*, %Texture** %colourPtr
%res7518 = call fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7517)
%val7519 = load i32, i32* @GL_FRAMEBUFFER
%val7520 = load i32, i32* @GL_COLOR_ATTACHMENT0
%val7521 = load i32, i32* @GL_TEXTURE_2D
%val7522 = load %Texture*, %Texture** %colourPtr
%res7523 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7522)
call fastcc void @glFramebufferTexture2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %val7519, i32 %val7520, i32 %val7521, i32 %res7523, i32 0)
%val7525 = load %Texture*, %Texture** %colourPtr
call fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val7525)
%val7527 = load %Texture*, %Texture** %colourPtr
call fastcc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val7527)
%val7529 = load %Texture*, %Texture** %depthPtr
%res7530 = call fastcc i32 @bind_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7529)
%val7531 = load i32, i32* @GL_FRAMEBUFFER
%val7532 = load i32, i32* @GL_DEPTH_ATTACHMENT
%val7533 = load i32, i32* @GL_TEXTURE_2D
%val7534 = load %Texture*, %Texture** %depthPtr
%res7535 = call fastcc i32 @id_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7534)
call fastcc void @glFramebufferTexture2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %val7531, i32 %val7532, i32 %val7533, i32 %res7535, i32 0)
%val7537 = load %Texture*, %Texture** %depthPtr
call fastcc void @unbind_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val7537)
%val7539 = load %Texture*, %Texture** %depthPtr
call fastcc void @update_adhoc_W3ZvaWQsVGV4dHVyZSpd(%Texture* %val7539)
%val7541 = load i32, i32* @GL_FRAMEBUFFER
call fastcc void @glBindFramebuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val7541, i32 0)
%val7543 = load %FBO*, %FBO** %fboPtr
ret %FBO* %val7543
}
@gsxtmgl-objects2462 = hidden constant [96 x i8] c"FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}** @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7563 = load i8*, i8** %_impzPtr
%zone7564 = bitcast i8* %tzone7563 to %mzone*

; let assign value to symbol FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd
%dat_FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd = call i8* @llvm_zone_malloc(%mzone* %zone7564, i64 8)
%FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpdPtr = bitcast i8* %dat_FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd to { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}***
%tzone7544 = load i8*, i8** %_impzPtr
%zone7545 = bitcast i8* %tzone7544 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7545)
; malloc closure structure
%clsptr7546 = call i8* @llvm_zone_malloc(%mzone* %zone7545, i64 24)
%closure7547 = bitcast i8* %clsptr7546 to { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}*

; malloc environment structure
%envptr7548 = call i8* @llvm_zone_malloc(%mzone* %zone7545, i64 8)
%environment7549 = bitcast i8* %envptr7548 to {{i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}***}*

; malloc closure address table
%addytable7550 = call %clsvar* @new_address_table()
%var7551 = bitcast [43 x i8]* @gsxtmgl-objects2460 to i8*
%var7552 = bitcast [54 x i8]* @gsxtmgl-objects2461 to i8*
%addytable7553 = call %clsvar* @add_address_table(%mzone* %zone7545, i8* %var7551, i32 0, i8* %var7552, i32 3, %clsvar* %addytable7550)
%address-table7554 = bitcast %clsvar* %addytable7553 to i8*

; insert table, function and environment into closure struct
%closure.table7557 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}, { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}* %closure7547, i32 0, i32 0
store i8* %address-table7554, i8** %closure.table7557
%closure.env7558 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}, { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}* %closure7547, i32 0, i32 1
store i8* %envptr7548, i8** %closure.env7558
%closure.func7559 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}, { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}* %closure7547, i32 0, i32 2
store %FBO* (i8*, i8*, %Texture*, %Texture*)* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd__7496, %FBO* (i8*, i8*, %Texture*, %Texture*)** %closure.func7559
%closure_size7560 = call i64 @llvm_zone_mark_size(%mzone* %zone7545)
call void @llvm_zone_ptr_set_size(i8* %clsptr7546, i64 %closure_size7560)
%wrapper_ptr7561 = call i8* @llvm_zone_malloc(%mzone* %zone7545, i64 8)
%closure_wrapper7562 = bitcast i8* %wrapper_ptr7561 to { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}**
store { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}* %closure7547, { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}** %closure_wrapper7562

; let value assignment
%FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}** %closure_wrapper7562, { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}** %closure_wrapper7562
store { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}** %FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd, { i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}*** %FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpdPtr

; add data to environment
; don't need to alloc for env var FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd
%tmp_envptr7556 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}***}* %environment7549, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}*** %FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpdPtr, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}**** %tmp_envptr7556


%val7565 = load {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}**, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}*** %FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpdPtr
ret {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}** %val7565
}


@FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}** @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd(%Texture* %arg_0,%Texture* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %Texture*, %Texture*)*,  %FBO* (i8*, i8*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, %Texture* %arg_1)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_native(%Texture* %arg_0,%Texture* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %Texture*, %Texture*)*,  %FBO* (i8*, i8*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, %Texture* %arg_1)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7566 = bitcast [96 x i8]* @gsxtmgl-objects2462 to i8*
call i32 (i8*, ...) @printf(i8* %var7566)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Texture*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7567 = bitcast [96 x i8]* @gsxtmgl-objects2462 to i8*
call i32 (i8*, ...) @printf(i8* %var7567)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Texture*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %Texture*, %Texture*)*,  %FBO* (i8*, i8*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, %Texture* %arg_1)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Texture*, %Texture*}*
%arg_p_0 = getelementptr {%Texture*, %Texture*}, {%Texture*, %Texture*}* %fstruct, i32 0, i32 0
%arg_0 = load %Texture*, %Texture** %arg_p_0
%arg_p_1 = getelementptr {%Texture*, %Texture*}, {%Texture*, %Texture*}* %fstruct, i32 0, i32 1
%arg_1 = load %Texture*, %Texture** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}, {i8*, i8*, %FBO* (i8*, i8*, %Texture*, %Texture*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %Texture*, %Texture*)*,  %FBO* (i8*, i8*, %Texture*, %Texture*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %Texture* %arg_0, %Texture* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2463 = hidden constant [30 x i8] c"FBO_adhoc_W0ZCTyosaTMyLGkzMl0\00"
@gsxtmgl-objects2464 = hidden constant [42 x i8] c"{i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}**\00"
define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLGkzMl0__7568(i8* %_impz,i8* %_impenv, i32 %width_s_40, i32 %height_s_41) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7569 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}***}*
%FBO_adhoc_W0ZCTyosaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%FBO_adhoc_W0ZCTyosaTMyLGkzMl0Ptr = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}***, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}**** %FBO_adhoc_W0ZCTyosaTMyLGkzMl0Ptr_

; setup arguments
%width_s_40Ptr = alloca i32
store i32 %width_s_40, i32* %width_s_40Ptr
%height_s_41Ptr = alloca i32
store i32 %height_s_41, i32* %height_s_41Ptr


%val7570 = load i32, i32* %width_s_40Ptr
%val7571 = load i32, i32* %height_s_41Ptr
%res7572 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ(i32 %val7570, i32 %val7571, i32 4)
%res7573 = call fastcc %FBO* @FBO_adhoc_W0ZCTyosVGV4dHVyZSpd(%Texture* %res7572)
ret %FBO* %res7573
}
@gsxtmgl-objects2465 = hidden constant [83 x i8] c"FBO_adhoc_W0ZCTyosaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}** @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7593 = load i8*, i8** %_impzPtr
%zone7594 = bitcast i8* %tzone7593 to %mzone*

; let assign value to symbol FBO_adhoc_W0ZCTyosaTMyLGkzMl0
%dat_FBO_adhoc_W0ZCTyosaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone7594, i64 8)
%FBO_adhoc_W0ZCTyosaTMyLGkzMl0Ptr = bitcast i8* %dat_FBO_adhoc_W0ZCTyosaTMyLGkzMl0 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}***
%tzone7574 = load i8*, i8** %_impzPtr
%zone7575 = bitcast i8* %tzone7574 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7575)
; malloc closure structure
%clsptr7576 = call i8* @llvm_zone_malloc(%mzone* %zone7575, i64 24)
%closure7577 = bitcast i8* %clsptr7576 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr7578 = call i8* @llvm_zone_malloc(%mzone* %zone7575, i64 8)
%environment7579 = bitcast i8* %envptr7578 to {{i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable7580 = call %clsvar* @new_address_table()
%var7581 = bitcast [30 x i8]* @gsxtmgl-objects2463 to i8*
%var7582 = bitcast [42 x i8]* @gsxtmgl-objects2464 to i8*
%addytable7583 = call %clsvar* @add_address_table(%mzone* %zone7575, i8* %var7581, i32 0, i8* %var7582, i32 3, %clsvar* %addytable7580)
%address-table7584 = bitcast %clsvar* %addytable7583 to i8*

; insert table, function and environment into closure struct
%closure.table7587 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}* %closure7577, i32 0, i32 0
store i8* %address-table7584, i8** %closure.table7587
%closure.env7588 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}* %closure7577, i32 0, i32 1
store i8* %envptr7578, i8** %closure.env7588
%closure.func7589 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}* %closure7577, i32 0, i32 2
store %FBO* (i8*, i8*, i32, i32)* @FBO_adhoc_W0ZCTyosaTMyLGkzMl0__7568, %FBO* (i8*, i8*, i32, i32)** %closure.func7589
%closure_size7590 = call i64 @llvm_zone_mark_size(%mzone* %zone7575)
call void @llvm_zone_ptr_set_size(i8* %clsptr7576, i64 %closure_size7590)
%wrapper_ptr7591 = call i8* @llvm_zone_malloc(%mzone* %zone7575, i64 8)
%closure_wrapper7592 = bitcast i8* %wrapper_ptr7591 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}* %closure7577, { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}** %closure_wrapper7592

; let value assignment
%FBO_adhoc_W0ZCTyosaTMyLGkzMl0 = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}** %closure_wrapper7592, { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}** %closure_wrapper7592
store { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}** %FBO_adhoc_W0ZCTyosaTMyLGkzMl0, { i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}*** %FBO_adhoc_W0ZCTyosaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var FBO_adhoc_W0ZCTyosaTMyLGkzMl0
%tmp_envptr7586 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}***}* %environment7579, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}*** %FBO_adhoc_W0ZCTyosaTMyLGkzMl0Ptr, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}**** %tmp_envptr7586


%val7595 = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}**, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}*** %FBO_adhoc_W0ZCTyosaTMyLGkzMl0Ptr
ret {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}** %val7595
}


@FBO_adhoc_W0ZCTyosaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_adhoc_W0ZCTyosaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}** @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLGkzMl0(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32)*,  %FBO* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32)*,  %FBO* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7596 = bitcast [83 x i8]* @gsxtmgl-objects2465 to i8*
call i32 (i8*, ...) @printf(i8* %var7596)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7597 = bitcast [83 x i8]* @gsxtmgl-objects2465 to i8*
call i32 (i8*, ...) @printf(i8* %var7597)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32)*,  %FBO* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32)*,  %FBO* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2466 = hidden constant [34 x i8] c"FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0\00"
@gsxtmgl-objects2467 = hidden constant [46 x i8] c"{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**\00"
define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0__7598(i8* %_impz,i8* %_impenv, i32 %width_s_42, i32 %height_s_43, i1 %depth) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7599 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***}*
%FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***}* %impenv, i32 0, i32 0
%FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**** %FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr_

; setup arguments
%width_s_42Ptr = alloca i32
store i32 %width_s_42, i32* %width_s_42Ptr
%height_s_43Ptr = alloca i32
store i32 %height_s_43, i32* %height_s_43Ptr
%depthPtr = alloca i1
store i1 %depth, i1* %depthPtr


%val7600 = load i32, i32* %width_s_42Ptr
%val7601 = load i32, i32* %height_s_43Ptr
%res7602 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ(i32 %val7600, i32 %val7601, i32 4)
%val7603 = load i32, i32* %width_s_42Ptr
%val7604 = load i32, i32* %height_s_43Ptr
%res7605 = call fastcc %Texture* @Texture_adhoc_W1RleHR1cmUqLGkzMixpMzIsaTMyXQ(i32 %val7603, i32 %val7604, i32 1)
%res7606 = call fastcc %FBO* @FBO_adhoc_W0ZCTyosVGV4dHVyZSosVGV4dHVyZSpd(%Texture* %res7602, %Texture* %res7605)
ret %FBO* %res7606
}
@gsxtmgl-objects2468 = hidden constant [87 x i8] c"FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7626 = load i8*, i8** %_impzPtr
%zone7627 = bitcast i8* %tzone7626 to %mzone*

; let assign value to symbol FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0
%dat_FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0 = call i8* @llvm_zone_malloc(%mzone* %zone7627, i64 8)
%FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr = bitcast i8* %dat_FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***
%tzone7607 = load i8*, i8** %_impzPtr
%zone7608 = bitcast i8* %tzone7607 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7608)
; malloc closure structure
%clsptr7609 = call i8* @llvm_zone_malloc(%mzone* %zone7608, i64 24)
%closure7610 = bitcast i8* %clsptr7609 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*

; malloc environment structure
%envptr7611 = call i8* @llvm_zone_malloc(%mzone* %zone7608, i64 8)
%environment7612 = bitcast i8* %envptr7611 to {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***}*

; malloc closure address table
%addytable7613 = call %clsvar* @new_address_table()
%var7614 = bitcast [34 x i8]* @gsxtmgl-objects2466 to i8*
%var7615 = bitcast [46 x i8]* @gsxtmgl-objects2467 to i8*
%addytable7616 = call %clsvar* @add_address_table(%mzone* %zone7608, i8* %var7614, i32 0, i8* %var7615, i32 3, %clsvar* %addytable7613)
%address-table7617 = bitcast %clsvar* %addytable7616 to i8*

; insert table, function and environment into closure struct
%closure.table7620 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure7610, i32 0, i32 0
store i8* %address-table7617, i8** %closure.table7620
%closure.env7621 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure7610, i32 0, i32 1
store i8* %envptr7611, i8** %closure.env7621
%closure.func7622 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure7610, i32 0, i32 2
store %FBO* (i8*, i8*, i32, i32, i1)* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0__7598, %FBO* (i8*, i8*, i32, i32, i1)** %closure.func7622
%closure_size7623 = call i64 @llvm_zone_mark_size(%mzone* %zone7608)
call void @llvm_zone_ptr_set_size(i8* %clsptr7609, i64 %closure_size7623)
%wrapper_ptr7624 = call i8* @llvm_zone_malloc(%mzone* %zone7608, i64 8)
%closure_wrapper7625 = bitcast i8* %wrapper_ptr7624 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**
store { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure7610, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_wrapper7625

; let value assignment
%FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0 = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_wrapper7625, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_wrapper7625
store { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*** %FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr

; add data to environment
; don't need to alloc for env var FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0
%tmp_envptr7619 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***}* %environment7612, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*** %FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**** %tmp_envptr7619


%val7628 = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*** %FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr
ret {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %val7628
}


@FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0(i32 %arg_0,i32 %arg_1,i1 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i1)*,  %FBO* (i8*, i8*, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i1 %arg_2)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_native(i32 %arg_0,i32 %arg_1,i1 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i1)*,  %FBO* (i8*, i8*, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i1 %arg_2)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7629 = bitcast [87 x i8]* @gsxtmgl-objects2468 to i8*
call i32 (i8*, ...) @printf(i8* %var7629)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7630 = bitcast [87 x i8]* @gsxtmgl-objects2468 to i8*
call i32 (i8*, ...) @printf(i8* %var7630)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var7631 = bitcast [87 x i8]* @gsxtmgl-objects2468 to i8*
call i32 (i8*, ...) @printf(i8* %var7631)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i1  @i1value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i1)*,  %FBO* (i8*, i8*, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i1 %arg_2)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i1}*
%arg_p_0 = getelementptr {i32, i32, i1}, {i32, i32, i1}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i1}, {i32, i32, i1}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i1}, {i32, i32, i1}* %fstruct, i32 0, i32 2
%arg_2 = load i1, i1* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i1)*,  %FBO* (i8*, i8*, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i1 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2469 = hidden constant [26 x i8] c"bind_adhoc_W2kzMixGQk8qXQ\00"
define dllexport fastcc i32 @bind_adhoc_W2kzMixGQk8qXQ__7632(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7633 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*
%bind_adhoc_W2kzMixGQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%bind_adhoc_W2kzMixGQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %bind_adhoc_W2kzMixGQk8qXQPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val7634 = load i32, i32* @GL_FRAMEBUFFER
%val7635 = load %FBO*, %FBO** %fboPtr
%res7636 = call fastcc i32 @id_adhoc_W2kzMixGQk8qXQ(%FBO* %val7635)
call fastcc void @glBindFramebuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val7634, i32 %res7636)
%val7638 = load %FBO*, %FBO** %fboPtr
%res7639 = call fastcc i32 @id_adhoc_W2kzMixGQk8qXQ(%FBO* %val7638)
ret i32 %res7639
}
@gsxtmgl-objects2470 = hidden constant [79 x i8] c"bind_adhoc_W2kzMixGQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @bind_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7659 = load i8*, i8** %_impzPtr
%zone7660 = bitcast i8* %tzone7659 to %mzone*

; let assign value to symbol bind_adhoc_W2kzMixGQk8qXQ
%dat_bind_adhoc_W2kzMixGQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone7660, i64 8)
%bind_adhoc_W2kzMixGQk8qXQPtr = bitcast i8* %dat_bind_adhoc_W2kzMixGQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}***
%tzone7640 = load i8*, i8** %_impzPtr
%zone7641 = bitcast i8* %tzone7640 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7641)
; malloc closure structure
%clsptr7642 = call i8* @llvm_zone_malloc(%mzone* %zone7641, i64 24)
%closure7643 = bitcast i8* %clsptr7642 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr7644 = call i8* @llvm_zone_malloc(%mzone* %zone7641, i64 8)
%environment7645 = bitcast i8* %envptr7644 to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable7646 = call %clsvar* @new_address_table()
%var7647 = bitcast [26 x i8]* @gsxtmgl-objects2469 to i8*
%var7648 = bitcast [37 x i8]* @gsxtmgl-objects2430 to i8*
%addytable7649 = call %clsvar* @add_address_table(%mzone* %zone7641, i8* %var7647, i32 0, i8* %var7648, i32 3, %clsvar* %addytable7646)
%address-table7650 = bitcast %clsvar* %addytable7649 to i8*

; insert table, function and environment into closure struct
%closure.table7653 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7643, i32 0, i32 0
store i8* %address-table7650, i8** %closure.table7653
%closure.env7654 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7643, i32 0, i32 1
store i8* %envptr7644, i8** %closure.env7654
%closure.func7655 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7643, i32 0, i32 2
store i32 (i8*, i8*, %FBO*)* @bind_adhoc_W2kzMixGQk8qXQ__7632, i32 (i8*, i8*, %FBO*)** %closure.func7655
%closure_size7656 = call i64 @llvm_zone_mark_size(%mzone* %zone7641)
call void @llvm_zone_ptr_set_size(i8* %clsptr7642, i64 %closure_size7656)
%wrapper_ptr7657 = call i8* @llvm_zone_malloc(%mzone* %zone7641, i64 8)
%closure_wrapper7658 = bitcast i8* %wrapper_ptr7657 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7643, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7658

; let value assignment
%bind_adhoc_W2kzMixGQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7658, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7658
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %bind_adhoc_W2kzMixGQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %bind_adhoc_W2kzMixGQk8qXQPtr

; add data to environment
; don't need to alloc for env var bind_adhoc_W2kzMixGQk8qXQ
%tmp_envptr7652 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %environment7645, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %bind_adhoc_W2kzMixGQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %tmp_envptr7652


%val7661 = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %bind_adhoc_W2kzMixGQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %val7661
}


@bind_adhoc_W2kzMixGQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@bind_adhoc_W2kzMixGQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @bind_adhoc_W2kzMixGQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixGQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @bind_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @bind_adhoc_W2kzMixGQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @bind_adhoc_W2kzMixGQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @bind_adhoc_W2kzMixGQk8qXQ(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @bind_adhoc_W2kzMixGQk8qXQ_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @bind_adhoc_W2kzMixGQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7662 = bitcast [79 x i8]* @gsxtmgl-objects2470 to i8*
call i32 (i8*, ...) @printf(i8* %var7662)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @bind_adhoc_W2kzMixGQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @bind_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2471 = hidden constant [28 x i8] c"unbind_adhoc_W2kzMixGQk8qXQ\00"
define dllexport fastcc i32 @unbind_adhoc_W2kzMixGQk8qXQ__7663(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7664 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*
%unbind_adhoc_W2kzMixGQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%unbind_adhoc_W2kzMixGQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %unbind_adhoc_W2kzMixGQk8qXQPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val7665 = load i32, i32* @GL_FRAMEBUFFER
call fastcc void @glBindFramebuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val7665, i32 0)
%val7667 = load %FBO*, %FBO** %fboPtr
%res7668 = call fastcc i32 @id_adhoc_W2kzMixGQk8qXQ(%FBO* %val7667)
ret i32 %res7668
}
@gsxtmgl-objects2472 = hidden constant [81 x i8] c"unbind_adhoc_W2kzMixGQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @unbind_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7688 = load i8*, i8** %_impzPtr
%zone7689 = bitcast i8* %tzone7688 to %mzone*

; let assign value to symbol unbind_adhoc_W2kzMixGQk8qXQ
%dat_unbind_adhoc_W2kzMixGQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone7689, i64 8)
%unbind_adhoc_W2kzMixGQk8qXQPtr = bitcast i8* %dat_unbind_adhoc_W2kzMixGQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}***
%tzone7669 = load i8*, i8** %_impzPtr
%zone7670 = bitcast i8* %tzone7669 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7670)
; malloc closure structure
%clsptr7671 = call i8* @llvm_zone_malloc(%mzone* %zone7670, i64 24)
%closure7672 = bitcast i8* %clsptr7671 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr7673 = call i8* @llvm_zone_malloc(%mzone* %zone7670, i64 8)
%environment7674 = bitcast i8* %envptr7673 to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable7675 = call %clsvar* @new_address_table()
%var7676 = bitcast [28 x i8]* @gsxtmgl-objects2471 to i8*
%var7677 = bitcast [37 x i8]* @gsxtmgl-objects2430 to i8*
%addytable7678 = call %clsvar* @add_address_table(%mzone* %zone7670, i8* %var7676, i32 0, i8* %var7677, i32 3, %clsvar* %addytable7675)
%address-table7679 = bitcast %clsvar* %addytable7678 to i8*

; insert table, function and environment into closure struct
%closure.table7682 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7672, i32 0, i32 0
store i8* %address-table7679, i8** %closure.table7682
%closure.env7683 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7672, i32 0, i32 1
store i8* %envptr7673, i8** %closure.env7683
%closure.func7684 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7672, i32 0, i32 2
store i32 (i8*, i8*, %FBO*)* @unbind_adhoc_W2kzMixGQk8qXQ__7663, i32 (i8*, i8*, %FBO*)** %closure.func7684
%closure_size7685 = call i64 @llvm_zone_mark_size(%mzone* %zone7670)
call void @llvm_zone_ptr_set_size(i8* %clsptr7671, i64 %closure_size7685)
%wrapper_ptr7686 = call i8* @llvm_zone_malloc(%mzone* %zone7670, i64 8)
%closure_wrapper7687 = bitcast i8* %wrapper_ptr7686 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7672, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7687

; let value assignment
%unbind_adhoc_W2kzMixGQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7687, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7687
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %unbind_adhoc_W2kzMixGQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %unbind_adhoc_W2kzMixGQk8qXQPtr

; add data to environment
; don't need to alloc for env var unbind_adhoc_W2kzMixGQk8qXQ
%tmp_envptr7681 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %environment7674, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %unbind_adhoc_W2kzMixGQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %tmp_envptr7681


%val7690 = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %unbind_adhoc_W2kzMixGQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %val7690
}


@unbind_adhoc_W2kzMixGQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@unbind_adhoc_W2kzMixGQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @unbind_adhoc_W2kzMixGQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W2kzMixGQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @unbind_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @unbind_adhoc_W2kzMixGQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @unbind_adhoc_W2kzMixGQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @unbind_adhoc_W2kzMixGQk8qXQ(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @unbind_adhoc_W2kzMixGQk8qXQ_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @unbind_adhoc_W2kzMixGQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7691 = bitcast [81 x i8]* @gsxtmgl-objects2472 to i8*
call i32 (i8*, ...) @printf(i8* %var7691)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @unbind_adhoc_W2kzMixGQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @unbind_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2473 = hidden constant [33 x i8] c"pull_colour_adhoc_W2kzMixGQk8qXQ\00"
define dllexport fastcc i32 @pull_colour_adhoc_W2kzMixGQk8qXQ__7692(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7693 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*
%pull_colour_adhoc_W2kzMixGQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%pull_colour_adhoc_W2kzMixGQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %pull_colour_adhoc_W2kzMixGQk8qXQPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%tzone7696 = load i8*, i8** %_impzPtr
%zone7697 = bitcast i8* %tzone7696 to %mzone*

; let assign value to symbol tex
%texPtr = alloca %Texture*
%val7694 = load %FBO*, %FBO** %fboPtr
%res7695 = call fastcc %Texture* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val7694)

; let value assignment
%tex = select i1 true, %Texture* %res7695, %Texture* %res7695
store %Texture* %tex, %Texture** %texPtr

%val7698 = load i32, i32* @GL_FRAMEBUFFER
%val7699 = load %FBO*, %FBO** %fboPtr
%res7700 = call fastcc i32 @id_adhoc_W2kzMixGQk8qXQ(%FBO* %val7699)
call fastcc void @glBindFramebuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val7698, i32 %res7700)
%val7702 = load %Texture*, %Texture** %texPtr
%res7703 = call fastcc i32 @width_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7702)
%val7704 = load %Texture*, %Texture** %texPtr
%res7705 = call fastcc i32 @height_adhoc_W2kzMixUZXh0dXJlKl0(%Texture* %val7704)
%val7706 = load i32, i32* @GL_RGBA
%val7707 = load i32, i32* @GL_UNSIGNED_BYTE
%val7708 = load %Texture*, %Texture** %texPtr
%res7709 = call fastcc i8* @data_adhoc_W2k4KixUZXh0dXJlKl0(%Texture* %val7708)
call fastcc void @glReadPixels_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTgqXQ(i32 0, i32 0, i32 %res7703, i32 %res7705, i32 %val7706, i32 %val7707, i8* %res7709)
%val7711 = load i32, i32* @GL_FRAMEBUFFER
call fastcc void @glBindFramebuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val7711, i32 0)
%val7713 = load %FBO*, %FBO** %fboPtr
%res7714 = call fastcc i32 @id_adhoc_W2kzMixGQk8qXQ(%FBO* %val7713)
ret i32 %res7714
}
@gsxtmgl-objects2474 = hidden constant [86 x i8] c"pull_colour_adhoc_W2kzMixGQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @pull_colour_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7734 = load i8*, i8** %_impzPtr
%zone7735 = bitcast i8* %tzone7734 to %mzone*

; let assign value to symbol pull_colour_adhoc_W2kzMixGQk8qXQ
%dat_pull_colour_adhoc_W2kzMixGQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone7735, i64 8)
%pull_colour_adhoc_W2kzMixGQk8qXQPtr = bitcast i8* %dat_pull_colour_adhoc_W2kzMixGQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}***
%tzone7715 = load i8*, i8** %_impzPtr
%zone7716 = bitcast i8* %tzone7715 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7716)
; malloc closure structure
%clsptr7717 = call i8* @llvm_zone_malloc(%mzone* %zone7716, i64 24)
%closure7718 = bitcast i8* %clsptr7717 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr7719 = call i8* @llvm_zone_malloc(%mzone* %zone7716, i64 8)
%environment7720 = bitcast i8* %envptr7719 to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable7721 = call %clsvar* @new_address_table()
%var7722 = bitcast [33 x i8]* @gsxtmgl-objects2473 to i8*
%var7723 = bitcast [37 x i8]* @gsxtmgl-objects2430 to i8*
%addytable7724 = call %clsvar* @add_address_table(%mzone* %zone7716, i8* %var7722, i32 0, i8* %var7723, i32 3, %clsvar* %addytable7721)
%address-table7725 = bitcast %clsvar* %addytable7724 to i8*

; insert table, function and environment into closure struct
%closure.table7728 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7718, i32 0, i32 0
store i8* %address-table7725, i8** %closure.table7728
%closure.env7729 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7718, i32 0, i32 1
store i8* %envptr7719, i8** %closure.env7729
%closure.func7730 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7718, i32 0, i32 2
store i32 (i8*, i8*, %FBO*)* @pull_colour_adhoc_W2kzMixGQk8qXQ__7692, i32 (i8*, i8*, %FBO*)** %closure.func7730
%closure_size7731 = call i64 @llvm_zone_mark_size(%mzone* %zone7716)
call void @llvm_zone_ptr_set_size(i8* %clsptr7717, i64 %closure_size7731)
%wrapper_ptr7732 = call i8* @llvm_zone_malloc(%mzone* %zone7716, i64 8)
%closure_wrapper7733 = bitcast i8* %wrapper_ptr7732 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure7718, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7733

; let value assignment
%pull_colour_adhoc_W2kzMixGQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7733, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper7733
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %pull_colour_adhoc_W2kzMixGQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %pull_colour_adhoc_W2kzMixGQk8qXQPtr

; add data to environment
; don't need to alloc for env var pull_colour_adhoc_W2kzMixGQk8qXQ
%tmp_envptr7727 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %environment7720, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %pull_colour_adhoc_W2kzMixGQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %tmp_envptr7727


%val7736 = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %pull_colour_adhoc_W2kzMixGQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %val7736
}


@pull_colour_adhoc_W2kzMixGQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@pull_colour_adhoc_W2kzMixGQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @pull_colour_adhoc_W2kzMixGQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @pull_colour_adhoc_W2kzMixGQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @pull_colour_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @pull_colour_adhoc_W2kzMixGQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @pull_colour_adhoc_W2kzMixGQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pull_colour_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @pull_colour_adhoc_W2kzMixGQk8qXQ(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pull_colour_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @pull_colour_adhoc_W2kzMixGQk8qXQ_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pull_colour_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @pull_colour_adhoc_W2kzMixGQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7737 = bitcast [86 x i8]* @gsxtmgl-objects2474 to i8*
call i32 (i8*, ...) @printf(i8* %var7737)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pull_colour_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @pull_colour_adhoc_W2kzMixGQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @pull_colour_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects2475 = hidden constant [46 x i8] c"write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ\00"
@gsxtmgl-objects2476 = hidden constant [48 x i8] c"{i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}**\00"
define dllexport fastcc void @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ__7738(i8* %_impz,i8* %_impenv, %FBO* %fbo, %String* %filename) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone7739 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}***}*
%write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}***}* %impenv, i32 0, i32 0
%write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQPtr = load {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}***, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}**** %write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr
%filenamePtr = alloca %String*
store %String* %filename, %String** %filenamePtr


%val7740 = load %FBO*, %FBO** %fboPtr
%res7741 = call fastcc i32 @pull_colour_adhoc_W2kzMixGQk8qXQ(%FBO* %val7740)
%val7742 = load %FBO*, %FBO** %fboPtr
%res7743 = call fastcc %Texture* @colour_tex_adhoc_W1RleHR1cmUqLEZCTypd(%FBO* %val7742)
%val7744 = load %String*, %String** %filenamePtr
%res7745 = call ccc i1 @impc_true()
call fastcc void @write_adhoc_W3ZvaWQsVGV4dHVyZSosU3RyaW5nKixpMV0(%Texture* %res7743, %String* %val7744, i1 %res7745)
ret void
}
@gsxtmgl-objects2477 = hidden constant [99 x i8] c"write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}** @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone7767 = load i8*, i8** %_impzPtr
%zone7768 = bitcast i8* %tzone7767 to %mzone*

; let assign value to symbol write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ
%dat_write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ = call i8* @llvm_zone_malloc(%mzone* %zone7768, i64 8)
%write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQPtr = bitcast i8* %dat_write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ to { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}***
%tzone7748 = load i8*, i8** %_impzPtr
%zone7749 = bitcast i8* %tzone7748 to %mzone*
call void @llvm_zone_mark(%mzone* %zone7749)
; malloc closure structure
%clsptr7750 = call i8* @llvm_zone_malloc(%mzone* %zone7749, i64 24)
%closure7751 = bitcast i8* %clsptr7750 to { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}*

; malloc environment structure
%envptr7752 = call i8* @llvm_zone_malloc(%mzone* %zone7749, i64 8)
%environment7753 = bitcast i8* %envptr7752 to {{i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}***}*

; malloc closure address table
%addytable7754 = call %clsvar* @new_address_table()
%var7755 = bitcast [46 x i8]* @gsxtmgl-objects2475 to i8*
%var7756 = bitcast [48 x i8]* @gsxtmgl-objects2476 to i8*
%addytable7757 = call %clsvar* @add_address_table(%mzone* %zone7749, i8* %var7755, i32 0, i8* %var7756, i32 3, %clsvar* %addytable7754)
%address-table7758 = bitcast %clsvar* %addytable7757 to i8*

; insert table, function and environment into closure struct
%closure.table7761 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}* %closure7751, i32 0, i32 0
store i8* %address-table7758, i8** %closure.table7761
%closure.env7762 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}* %closure7751, i32 0, i32 1
store i8* %envptr7752, i8** %closure.env7762
%closure.func7763 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}, { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}* %closure7751, i32 0, i32 2
store void (i8*, i8*, %FBO*, %String*)* @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ__7738, void (i8*, i8*, %FBO*, %String*)** %closure.func7763
%closure_size7764 = call i64 @llvm_zone_mark_size(%mzone* %zone7749)
call void @llvm_zone_ptr_set_size(i8* %clsptr7750, i64 %closure_size7764)
%wrapper_ptr7765 = call i8* @llvm_zone_malloc(%mzone* %zone7749, i64 8)
%closure_wrapper7766 = bitcast i8* %wrapper_ptr7765 to { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}**
store { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}* %closure7751, { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}** %closure_wrapper7766

; let value assignment
%write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}** %closure_wrapper7766, { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}** %closure_wrapper7766
store { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}** %write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ, { i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}*** %write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQPtr

; add data to environment
; don't need to alloc for env var write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ
%tmp_envptr7760 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}***}* %environment7753, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}*** %write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQPtr, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}**** %tmp_envptr7760


%val7769 = load {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}**, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}*** %write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQPtr
ret {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}** %val7769
}


@write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}** @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ(%FBO* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, %String*)*,  void (i8*, i8*, %FBO*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, %String* %arg_1)
ret void
}


define dllexport ccc void @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_native(%FBO* %arg_0,%String* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, %String*)*,  void (i8*, i8*, %FBO*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, %String* %arg_1)
ret void
}


define dllexport ccc i8*  @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var7770 = bitcast [99 x i8]* @gsxtmgl-objects2477 to i8*
call i32 (i8*, ...) @printf(i8* %var7770)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var7771 = bitcast [99 x i8]* @gsxtmgl-objects2477 to i8*
call i32 (i8*, ...) @printf(i8* %var7771)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %String*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, %String*)*,  void (i8*, i8*, %FBO*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, %String* %arg_1)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*, %String*}*
%arg_p_0 = getelementptr {%FBO*, %String*}, {%FBO*, %String*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
%arg_p_1 = getelementptr {%FBO*, %String*}, {%FBO*, %String*}* %fstruct, i32 0, i32 1
%arg_1 = load %String*, %String** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @write_colour_adhoc_W3ZvaWQsRkJPKixTdHJpbmcqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}, {i8*, i8*, void (i8*, i8*, %FBO*, %String*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*, %String*)*,  void (i8*, i8*, %FBO*, %String*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, %String* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


