@gsxtmgl-objects0 = hidden constant [18 x i8] c"%s: Invalid Enum
\00"
@gsxtmgl-objects1 = hidden constant [19 x i8] c"%s: Invalid Value
\00"
@gsxtmgl-objects2 = hidden constant [23 x i8] c"%s: Invalid Operation
\00"
@gsxtmgl-objects3 = hidden constant [19 x i8] c"%s: Out Of Memory
\00"
@gsxtmgl-objects4 = hidden constant [35 x i8] c"%s: Invalid Framebuffer Operation
\00"
@gsxtmgl-objects5 = hidden constant [4 x i8] c"%s
\00"
@gsxtmgl-objects6 = hidden constant [36 x i8] c"gl_print_error_adhoc_W3ZvaWQsaTgqXQ\00"
@gsxtmgl-objects7 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i8*)*}**\00"
define dllexport fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ__1(i8* %_impz,i8* %_impenv, i8* %msg) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*
%gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr = load {i8*, i8*, void (i8*, i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*, i8*)*}**** %gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr_

; setup arguments
%msgPtr = alloca i8*
store i8* %msg, i8** %msgPtr


%tzone4 = load i8*, i8** %_impzPtr
%zone5 = bitcast i8* %tzone4 to %mzone*

; let assign value to symbol err
%errPtr = alloca i32
%res3 = call fastcc i32 @glGetError_adhoc_W2kzMl0()

; let value assignment
%err = select i1 true, i32 %res3, i32 %res3
store i32 %err, i32* %errPtr

; promote local stack var allocations
%tzone56 = load i8*, i8** %_impzPtr
%zone57 = bitcast i8* %tzone56 to %mzone*
%ifptr6 = alloca i32
%ifptr13 = alloca i32
%ifptr20 = alloca i32
%ifptr27 = alloca i32
%ifptr34 = alloca i32
%ifptr41 = alloca i32
%val7 = load i32, i32* %errPtr
%val8 = load i32, i32* @GL_INVALID_ENUM
%cmp9 = icmp eq i32 %val7, %val8
br i1 %cmp9, label %then6, label %else6

then6:
%var10 = bitcast [18 x i8]* @gsxtmgl-objects0 to i8*
%val11 = load i8*, i8** %msgPtr

%val12 = call i32 (i8*, ...) @printf(i8* %var10, i8* %val11)
store i32 %val12, i32* %ifptr6
br label %ifcont6

else6:
%val14 = load i32, i32* %errPtr
%val15 = load i32, i32* @GL_INVALID_VALUE
%cmp16 = icmp eq i32 %val14, %val15
br i1 %cmp16, label %then13, label %else13

then13:
%var17 = bitcast [19 x i8]* @gsxtmgl-objects1 to i8*
%val18 = load i8*, i8** %msgPtr

%val19 = call i32 (i8*, ...) @printf(i8* %var17, i8* %val18)
store i32 %val19, i32* %ifptr13
br label %ifcont13

else13:
%val21 = load i32, i32* %errPtr
%val22 = load i32, i32* @GL_INVALID_OPERATION
%cmp23 = icmp eq i32 %val21, %val22
br i1 %cmp23, label %then20, label %else20

then20:
%var24 = bitcast [23 x i8]* @gsxtmgl-objects2 to i8*
%val25 = load i8*, i8** %msgPtr

%val26 = call i32 (i8*, ...) @printf(i8* %var24, i8* %val25)
store i32 %val26, i32* %ifptr20
br label %ifcont20

else20:
%val28 = load i32, i32* %errPtr
%val29 = load i32, i32* @GL_OUT_OF_MEMORY
%cmp30 = icmp eq i32 %val28, %val29
br i1 %cmp30, label %then27, label %else27

then27:
%var31 = bitcast [19 x i8]* @gsxtmgl-objects3 to i8*
%val32 = load i8*, i8** %msgPtr

%val33 = call i32 (i8*, ...) @printf(i8* %var31, i8* %val32)
store i32 %val33, i32* %ifptr27
br label %ifcont27

else27:
%val35 = load i32, i32* %errPtr
%val36 = load i32, i32* @GL_INVALID_FRAMEBUFFER_OPERATION
%cmp37 = icmp eq i32 %val35, %val36
br i1 %cmp37, label %then34, label %else34

then34:
%var38 = bitcast [35 x i8]* @gsxtmgl-objects4 to i8*
%val39 = load i8*, i8** %msgPtr

%val40 = call i32 (i8*, ...) @printf(i8* %var38, i8* %val39)
store i32 %val40, i32* %ifptr34
br label %ifcont34

else34:
%val42 = load i32, i32* %errPtr
%val43 = load i32, i32* @GL_NO_ERROR
%cmp44 = icmp eq i32 %val42, %val43
br i1 %cmp44, label %then41, label %else41

then41:
%val45 = trunc i64 1 to i32
store i32 %val45, i32* %ifptr41
br label %ifcont41

else41:
%var46 = bitcast [4 x i8]* @gsxtmgl-objects5 to i8*
%val47 = load i8*, i8** %msgPtr

%val48 = call i32 (i8*, ...) @printf(i8* %var46, i8* %val47)
store i32 %val48, i32* %ifptr41
br label %ifcont41

ifcont41:
%ifres49 = load i32, i32* %ifptr41

store i32 %ifres49, i32* %ifptr34
br label %ifcont34

ifcont34:
%ifres50 = load i32, i32* %ifptr34

store i32 %ifres50, i32* %ifptr27
br label %ifcont27

ifcont27:
%ifres51 = load i32, i32* %ifptr27

store i32 %ifres51, i32* %ifptr20
br label %ifcont20

ifcont20:
%ifres52 = load i32, i32* %ifptr20

store i32 %ifres52, i32* %ifptr13
br label %ifcont13

ifcont13:
%ifres53 = load i32, i32* %ifptr13

store i32 %ifres53, i32* %ifptr6
br label %ifcont6

ifcont6:
%ifres54 = load i32, i32* %ifptr6

ret void
}
@gsxtmgl-objects8 = hidden constant [89 x i8] c"gl_print_error_adhoc_W3ZvaWQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone77 = load i8*, i8** %_impzPtr
%zone78 = bitcast i8* %tzone77 to %mzone*

; let assign value to symbol gl_print_error_adhoc_W3ZvaWQsaTgqXQ
%dat_gl_print_error_adhoc_W3ZvaWQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone78, i64 8)
%gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr = bitcast i8* %dat_gl_print_error_adhoc_W3ZvaWQsaTgqXQ to { i8*, i8*, void (i8*, i8*, i8*)*}***
%tzone58 = load i8*, i8** %_impzPtr
%zone59 = bitcast i8* %tzone58 to %mzone*
call void @llvm_zone_mark(%mzone* %zone59)
; malloc closure structure
%clsptr60 = call i8* @llvm_zone_malloc(%mzone* %zone59, i64 24)
%closure61 = bitcast i8* %clsptr60 to { i8*, i8*, void (i8*, i8*, i8*)*}*

; malloc environment structure
%envptr62 = call i8* @llvm_zone_malloc(%mzone* %zone59, i64 8)
%environment63 = bitcast i8* %envptr62 to {{i8*, i8*, void (i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable64 = call %clsvar* @new_address_table()
%var65 = bitcast [36 x i8]* @gsxtmgl-objects6 to i8*
%var66 = bitcast [36 x i8]* @gsxtmgl-objects7 to i8*
%addytable67 = call %clsvar* @add_address_table(%mzone* %zone59, i8* %var65, i32 0, i8* %var66, i32 3, %clsvar* %addytable64)
%address-table68 = bitcast %clsvar* %addytable67 to i8*

; insert table, function and environment into closure struct
%closure.table71 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure61, i32 0, i32 0
store i8* %address-table68, i8** %closure.table71
%closure.env72 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure61, i32 0, i32 1
store i8* %envptr62, i8** %closure.env72
%closure.func73 = getelementptr { i8*, i8*, void (i8*, i8*, i8*)*}, { i8*, i8*, void (i8*, i8*, i8*)*}* %closure61, i32 0, i32 2
store void (i8*, i8*, i8*)* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ__1, void (i8*, i8*, i8*)** %closure.func73
%closure_size74 = call i64 @llvm_zone_mark_size(%mzone* %zone59)
call void @llvm_zone_ptr_set_size(i8* %clsptr60, i64 %closure_size74)
%wrapper_ptr75 = call i8* @llvm_zone_malloc(%mzone* %zone59, i64 8)
%closure_wrapper76 = bitcast i8* %wrapper_ptr75 to { i8*, i8*, void (i8*, i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*, i8*)*}* %closure61, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper76

; let value assignment
%gl_print_error_adhoc_W3ZvaWQsaTgqXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper76, { i8*, i8*, void (i8*, i8*, i8*)*}** %closure_wrapper76
store { i8*, i8*, void (i8*, i8*, i8*)*}** %gl_print_error_adhoc_W3ZvaWQsaTgqXQ, { i8*, i8*, void (i8*, i8*, i8*)*}*** %gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var gl_print_error_adhoc_W3ZvaWQsaTgqXQ
%tmp_envptr70 = getelementptr {{i8*, i8*, void (i8*, i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*, i8*)*}***}* %environment63, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i8*)*}*** %gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr, {i8*, i8*, void (i8*, i8*, i8*)*}**** %tmp_envptr70


%val79 = load {i8*, i8*, void (i8*, i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*, i8*)*}*** %gl_print_error_adhoc_W3ZvaWQsaTgqXQPtr
ret {i8*, i8*, void (i8*, i8*, i8*)*}** %val79
}


@gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i8*)*}** @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_native(i8* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
ret void
}


define dllexport ccc i8*  @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var80 = bitcast [89 x i8]* @gsxtmgl-objects8 to i8*
call i32 (i8*, ...) @printf(i8* %var80)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*}*
%arg_p_0 = getelementptr {i8*}, {i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i8*)*}, {i8*, i8*, void (i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i8*)*,  void (i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i8* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects9 = hidden constant [13 x i8] c"OpenGL Error\00"
@gsxtmgl-objects10 = hidden constant [30 x i8] c"gl_print_error_adhoc_W3ZvaWRd\00"
@gsxtmgl-objects11 = hidden constant [31 x i8] c"{i8*, i8*, void (i8*, i8*)*}**\00"
define dllexport fastcc void @gl_print_error_adhoc_W3ZvaWRd__81(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone82 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%gl_print_error_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%gl_print_error_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %gl_print_error_adhoc_W3ZvaWRdPtr_

; setup arguments


%var83 = bitcast [13 x i8]* @gsxtmgl-objects9 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var83)
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @gl_print_error_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone104 = load i8*, i8** %_impzPtr
%zone105 = bitcast i8* %tzone104 to %mzone*

; let assign value to symbol gl_print_error_adhoc_W3ZvaWRd
%dat_gl_print_error_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone105, i64 8)
%gl_print_error_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_gl_print_error_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone85 = load i8*, i8** %_impzPtr
%zone86 = bitcast i8* %tzone85 to %mzone*
call void @llvm_zone_mark(%mzone* %zone86)
; malloc closure structure
%clsptr87 = call i8* @llvm_zone_malloc(%mzone* %zone86, i64 24)
%closure88 = bitcast i8* %clsptr87 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr89 = call i8* @llvm_zone_malloc(%mzone* %zone86, i64 8)
%environment90 = bitcast i8* %envptr89 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable91 = call %clsvar* @new_address_table()
%var92 = bitcast [30 x i8]* @gsxtmgl-objects10 to i8*
%var93 = bitcast [31 x i8]* @gsxtmgl-objects11 to i8*
%addytable94 = call %clsvar* @add_address_table(%mzone* %zone86, i8* %var92, i32 0, i8* %var93, i32 3, %clsvar* %addytable91)
%address-table95 = bitcast %clsvar* %addytable94 to i8*

; insert table, function and environment into closure struct
%closure.table98 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure88, i32 0, i32 0
store i8* %address-table95, i8** %closure.table98
%closure.env99 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure88, i32 0, i32 1
store i8* %envptr89, i8** %closure.env99
%closure.func100 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure88, i32 0, i32 2
store void (i8*, i8*)* @gl_print_error_adhoc_W3ZvaWRd__81, void (i8*, i8*)** %closure.func100
%closure_size101 = call i64 @llvm_zone_mark_size(%mzone* %zone86)
call void @llvm_zone_ptr_set_size(i8* %clsptr87, i64 %closure_size101)
%wrapper_ptr102 = call i8* @llvm_zone_malloc(%mzone* %zone86, i64 8)
%closure_wrapper103 = bitcast i8* %wrapper_ptr102 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure88, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper103

; let value assignment
%gl_print_error_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper103, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper103
store { i8*, i8*, void (i8*, i8*)*}** %gl_print_error_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %gl_print_error_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var gl_print_error_adhoc_W3ZvaWRd
%tmp_envptr97 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment90, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %gl_print_error_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr97


%val106 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %gl_print_error_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val106
}


@gl_print_error_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@gl_print_error_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @gl_print_error_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @gl_print_error_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @gl_print_error_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @gl_print_error_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @gl_print_error_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @gl_print_error_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @gl_print_error_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_error_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects12 = hidden constant [3 x i8] c"%s\00"
@gsxtmgl-objects13 = hidden constant [51 x i8] c"--------------------------------------------------\00"
@gsxtmgl-objects14 = hidden constant [29 x i8] c"Extempore OpenGL driver info\00"
@gsxtmgl-objects15 = hidden constant [15 x i8] c"  Vendor:  %s
\00"
@gsxtmgl-objects16 = hidden constant [15 x i8] c"Renderer:  %s
\00"
@gsxtmgl-objects17 = hidden constant [15 x i8] c" Version:  %s
\00"
@gsxtmgl-objects18 = hidden constant [36 x i8] c"gl_print_driver_info_adhoc_W3ZvaWRd\00"
define dllexport fastcc void @gl_print_driver_info_adhoc_W3ZvaWRd__107(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone108 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*)*}***}*
%gl_print_driver_info_adhoc_W3ZvaWRdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%gl_print_driver_info_adhoc_W3ZvaWRdPtr = load {i8*, i8*, void (i8*, i8*)*}***, {i8*, i8*, void (i8*, i8*)*}**** %gl_print_driver_info_adhoc_W3ZvaWRdPtr_

; setup arguments


%var109 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var110 = bitcast [51 x i8]* @gsxtmgl-objects13 to i8*

%val111 = call i32 (i8*, ...) @printf(i8* %var109, i8* %var110)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%var113 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var114 = bitcast [29 x i8]* @gsxtmgl-objects14 to i8*

%val115 = call i32 (i8*, ...) @printf(i8* %var113, i8* %var114)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%var117 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var118 = bitcast [51 x i8]* @gsxtmgl-objects13 to i8*

%val119 = call i32 (i8*, ...) @printf(i8* %var117, i8* %var118)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%var121 = bitcast [15 x i8]* @gsxtmgl-objects15 to i8*
%val122 = load i32, i32* @GL_VENDOR
%res123 = call fastcc i8* @glGetString_adhoc_W2k4KixpMzJd(i32 %val122)

%val124 = call i32 (i8*, ...) @printf(i8* %var121, i8* %res123)
%var125 = bitcast [15 x i8]* @gsxtmgl-objects16 to i8*
%val126 = load i32, i32* @GL_RENDERER
%res127 = call fastcc i8* @glGetString_adhoc_W2k4KixpMzJd(i32 %val126)

%val128 = call i32 (i8*, ...) @printf(i8* %var125, i8* %res127)
%var129 = bitcast [15 x i8]* @gsxtmgl-objects17 to i8*
%val130 = load i32, i32* @GL_VERSION
%res131 = call fastcc i8* @glGetString_adhoc_W2k4KixpMzJd(i32 %val130)

%val132 = call i32 (i8*, ...) @printf(i8* %var129, i8* %res131)
%var133 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var134 = bitcast [51 x i8]* @gsxtmgl-objects13 to i8*

%val135 = call i32 (i8*, ...) @printf(i8* %var133, i8* %var134)
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret void
}
define dllexport ccc {i8*, i8*, void (i8*, i8*)*}** @gl_print_driver_info_adhoc_W3ZvaWRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone157 = load i8*, i8** %_impzPtr
%zone158 = bitcast i8* %tzone157 to %mzone*

; let assign value to symbol gl_print_driver_info_adhoc_W3ZvaWRd
%dat_gl_print_driver_info_adhoc_W3ZvaWRd = call i8* @llvm_zone_malloc(%mzone* %zone158, i64 8)
%gl_print_driver_info_adhoc_W3ZvaWRdPtr = bitcast i8* %dat_gl_print_driver_info_adhoc_W3ZvaWRd to { i8*, i8*, void (i8*, i8*)*}***
%tzone138 = load i8*, i8** %_impzPtr
%zone139 = bitcast i8* %tzone138 to %mzone*
call void @llvm_zone_mark(%mzone* %zone139)
; malloc closure structure
%clsptr140 = call i8* @llvm_zone_malloc(%mzone* %zone139, i64 24)
%closure141 = bitcast i8* %clsptr140 to { i8*, i8*, void (i8*, i8*)*}*

; malloc environment structure
%envptr142 = call i8* @llvm_zone_malloc(%mzone* %zone139, i64 8)
%environment143 = bitcast i8* %envptr142 to {{i8*, i8*, void (i8*, i8*)*}***}*

; malloc closure address table
%addytable144 = call %clsvar* @new_address_table()
%var145 = bitcast [36 x i8]* @gsxtmgl-objects18 to i8*
%var146 = bitcast [31 x i8]* @gsxtmgl-objects11 to i8*
%addytable147 = call %clsvar* @add_address_table(%mzone* %zone139, i8* %var145, i32 0, i8* %var146, i32 3, %clsvar* %addytable144)
%address-table148 = bitcast %clsvar* %addytable147 to i8*

; insert table, function and environment into closure struct
%closure.table151 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure141, i32 0, i32 0
store i8* %address-table148, i8** %closure.table151
%closure.env152 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure141, i32 0, i32 1
store i8* %envptr142, i8** %closure.env152
%closure.func153 = getelementptr { i8*, i8*, void (i8*, i8*)*}, { i8*, i8*, void (i8*, i8*)*}* %closure141, i32 0, i32 2
store void (i8*, i8*)* @gl_print_driver_info_adhoc_W3ZvaWRd__107, void (i8*, i8*)** %closure.func153
%closure_size154 = call i64 @llvm_zone_mark_size(%mzone* %zone139)
call void @llvm_zone_ptr_set_size(i8* %clsptr140, i64 %closure_size154)
%wrapper_ptr155 = call i8* @llvm_zone_malloc(%mzone* %zone139, i64 8)
%closure_wrapper156 = bitcast i8* %wrapper_ptr155 to { i8*, i8*, void (i8*, i8*)*}**
store { i8*, i8*, void (i8*, i8*)*}* %closure141, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper156

; let value assignment
%gl_print_driver_info_adhoc_W3ZvaWRd = select i1 true, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper156, { i8*, i8*, void (i8*, i8*)*}** %closure_wrapper156
store { i8*, i8*, void (i8*, i8*)*}** %gl_print_driver_info_adhoc_W3ZvaWRd, { i8*, i8*, void (i8*, i8*)*}*** %gl_print_driver_info_adhoc_W3ZvaWRdPtr

; add data to environment
; don't need to alloc for env var gl_print_driver_info_adhoc_W3ZvaWRd
%tmp_envptr150 = getelementptr {{i8*, i8*, void (i8*, i8*)*}***}, {{i8*, i8*, void (i8*, i8*)*}***}* %environment143, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*)*}*** %gl_print_driver_info_adhoc_W3ZvaWRdPtr, {i8*, i8*, void (i8*, i8*)*}**** %tmp_envptr150


%val159 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %gl_print_driver_info_adhoc_W3ZvaWRdPtr
ret {i8*, i8*, void (i8*, i8*)*}** %val159
}


@gl_print_driver_info_adhoc_W3ZvaWRd_var = dllexport global [1 x i8*] [ i8* null ]

@gl_print_driver_info_adhoc_W3ZvaWRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @gl_print_driver_info_adhoc_W3ZvaWRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*)*}** @gl_print_driver_info_adhoc_W3ZvaWRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @gl_print_driver_info_adhoc_W3ZvaWRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @gl_print_driver_info_adhoc_W3ZvaWRd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc void @gl_print_driver_info_adhoc_W3ZvaWRd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
ret void
}


define dllexport ccc i8*  @gl_print_driver_info_adhoc_W3ZvaWRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @gl_print_driver_info_adhoc_W3ZvaWRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @gl_print_driver_info_adhoc_W3ZvaWRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*)*}**
%closure = load {i8*, i8*, void (i8*, i8*)*}*, {i8*, i8*, void (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*)*,  void (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%VBO = type {i32,i32,i64,i8*}
@gsxtmgl-objects19 = hidden constant [41 x i8] c"VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ\00"
@gsxtmgl-objects20 = hidden constant [52 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**\00"
define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ__160(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone161 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}*
%VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}* %impenv, i32 0, i32 0
%VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**** %VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i64
store i64 %arg_2, i64* %arg_2Ptr
%arg_3Ptr = alloca i8*
store i8* %arg_3, i8** %arg_3Ptr


%tzone166 = load i8*, i8** %_impzPtr
%zone167 = bitcast i8* %tzone166 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VBO*
%tzone162 = load i8*, i8** %_impzPtr
%zone163 = bitcast i8* %tzone162 to %mzone*
%dat164 = call i8* @llvm_zone_malloc(%mzone* %zone163, i64 24)
call i8* @memset(i8* %dat164, i32 0, i64 24)
%val165 = bitcast i8* %dat164 to %VBO*

; let value assignment
%obj = select i1 true, %VBO* %val165, %VBO* %val165
store %VBO* %obj, %VBO** %objPtr

%val168 = load %VBO*, %VBO** %objPtr
%val169 = load i32, i32* %arg_0Ptr
; set tuple
%val170 = getelementptr %VBO, %VBO* %val168, i64 0, i32 0
store i32 %val169, i32* %val170
%val171 = load %VBO*, %VBO** %objPtr
%val172 = load i32, i32* %arg_1Ptr
; set tuple
%val173 = getelementptr %VBO, %VBO* %val171, i64 0, i32 1
store i32 %val172, i32* %val173
%val174 = load %VBO*, %VBO** %objPtr
%val175 = load i64, i64* %arg_2Ptr
; set tuple
%val176 = getelementptr %VBO, %VBO* %val174, i64 0, i32 2
store i64 %val175, i64* %val176
%val177 = load %VBO*, %VBO** %objPtr
%val178 = load i8*, i8** %arg_3Ptr
; set tuple
%val179 = getelementptr %VBO, %VBO* %val177, i64 0, i32 3
store i8* %val178, i8** %val179
%val180 = load %VBO*, %VBO** %objPtr
ret %VBO* %val180
}
@gsxtmgl-objects21 = hidden constant [94 x i8] c"VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone200 = load i8*, i8** %_impzPtr
%zone201 = bitcast i8* %tzone200 to %mzone*

; let assign value to symbol VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ
%dat_VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone201, i64 8)
%VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr = bitcast i8* %dat_VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***
%tzone181 = load i8*, i8** %_impzPtr
%zone182 = bitcast i8* %tzone181 to %mzone*
call void @llvm_zone_mark(%mzone* %zone182)
; malloc closure structure
%clsptr183 = call i8* @llvm_zone_malloc(%mzone* %zone182, i64 24)
%closure184 = bitcast i8* %clsptr183 to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*

; malloc environment structure
%envptr185 = call i8* @llvm_zone_malloc(%mzone* %zone182, i64 8)
%environment186 = bitcast i8* %envptr185 to {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}*

; malloc closure address table
%addytable187 = call %clsvar* @new_address_table()
%var188 = bitcast [41 x i8]* @gsxtmgl-objects19 to i8*
%var189 = bitcast [52 x i8]* @gsxtmgl-objects20 to i8*
%addytable190 = call %clsvar* @add_address_table(%mzone* %zone182, i8* %var188, i32 0, i8* %var189, i32 3, %clsvar* %addytable187)
%address-table191 = bitcast %clsvar* %addytable190 to i8*

; insert table, function and environment into closure struct
%closure.table194 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure184, i32 0, i32 0
store i8* %address-table191, i8** %closure.table194
%closure.env195 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure184, i32 0, i32 1
store i8* %envptr185, i8** %closure.env195
%closure.func196 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure184, i32 0, i32 2
store %VBO* (i8*, i8*, i32, i32, i64, i8*)* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ__160, %VBO* (i8*, i8*, i32, i32, i64, i8*)** %closure.func196
%closure_size197 = call i64 @llvm_zone_mark_size(%mzone* %zone182)
call void @llvm_zone_ptr_set_size(i8* %clsptr183, i64 %closure_size197)
%wrapper_ptr198 = call i8* @llvm_zone_malloc(%mzone* %zone182, i64 8)
%closure_wrapper199 = bitcast i8* %wrapper_ptr198 to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
store { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure184, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_wrapper199

; let value assignment
%VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_wrapper199, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_wrapper199
store { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*** %VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ
%tmp_envptr193 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}* %environment186, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*** %VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**** %tmp_envptr193


%val202 = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*** %VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr
ret {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %val202
}


@VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_native(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var203 = bitcast [94 x i8]* @gsxtmgl-objects21 to i8*
call i32 (i8*, ...) @printf(i8* %var203)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var204 = bitcast [94 x i8]* @gsxtmgl-objects21 to i8*
call i32 (i8*, ...) @printf(i8* %var204)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var205 = bitcast [94 x i8]* @gsxtmgl-objects21 to i8*
call i32 (i8*, ...) @printf(i8* %var205)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr_or_str(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var206 = bitcast [94 x i8]* @gsxtmgl-objects21 to i8*
call i32 (i8*, ...) @printf(i8* %var206)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i8*  @cptr_value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i64, i8*}*
%arg_p_0 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 3
%arg_3 = load i8*, i8** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects22 = hidden constant [43 x i8] c"VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ\00"
define dllexport fastcc %VBO* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ__207(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone208 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}*
%VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}* %impenv, i32 0, i32 0
%VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**** %VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i64
store i64 %arg_2, i64* %arg_2Ptr
%arg_3Ptr = alloca i8*
store i8* %arg_3, i8** %arg_3Ptr


%tzone213 = load i8*, i8** %_impzPtr
%zone214 = bitcast i8* %tzone213 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VBO*
%tzone209 = load i8*, i8** %_impzPtr
%zone210 = bitcast i8* %tzone209 to %mzone*
%dat211 = call i8* @llvm_zone_malloc(%mzone* %zone210, i64 24)
call i8* @memset(i8* %dat211, i32 0, i64 24)
%val212 = bitcast i8* %dat211 to %VBO*

; let value assignment
%obj = select i1 true, %VBO* %val212, %VBO* %val212
store %VBO* %obj, %VBO** %objPtr

%val215 = load %VBO*, %VBO** %objPtr
%val216 = load i32, i32* %arg_0Ptr
; set tuple
%val217 = getelementptr %VBO, %VBO* %val215, i64 0, i32 0
store i32 %val216, i32* %val217
%val218 = load %VBO*, %VBO** %objPtr
%val219 = load i32, i32* %arg_1Ptr
; set tuple
%val220 = getelementptr %VBO, %VBO* %val218, i64 0, i32 1
store i32 %val219, i32* %val220
%val221 = load %VBO*, %VBO** %objPtr
%val222 = load i64, i64* %arg_2Ptr
; set tuple
%val223 = getelementptr %VBO, %VBO* %val221, i64 0, i32 2
store i64 %val222, i64* %val223
%val224 = load %VBO*, %VBO** %objPtr
%val225 = load i8*, i8** %arg_3Ptr
; set tuple
%val226 = getelementptr %VBO, %VBO* %val224, i64 0, i32 3
store i8* %val225, i8** %val226
%val227 = load %VBO*, %VBO** %objPtr
ret %VBO* %val227
}
@gsxtmgl-objects23 = hidden constant [96 x i8] c"VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone247 = load i8*, i8** %_impzPtr
%zone248 = bitcast i8* %tzone247 to %mzone*

; let assign value to symbol VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ
%dat_VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone248, i64 8)
%VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr = bitcast i8* %dat_VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***
%tzone228 = load i8*, i8** %_impzPtr
%zone229 = bitcast i8* %tzone228 to %mzone*
call void @llvm_zone_mark(%mzone* %zone229)
; malloc closure structure
%clsptr230 = call i8* @llvm_zone_malloc(%mzone* %zone229, i64 24)
%closure231 = bitcast i8* %clsptr230 to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*

; malloc environment structure
%envptr232 = call i8* @llvm_zone_malloc(%mzone* %zone229, i64 8)
%environment233 = bitcast i8* %envptr232 to {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}*

; malloc closure address table
%addytable234 = call %clsvar* @new_address_table()
%var235 = bitcast [43 x i8]* @gsxtmgl-objects22 to i8*
%var236 = bitcast [52 x i8]* @gsxtmgl-objects20 to i8*
%addytable237 = call %clsvar* @add_address_table(%mzone* %zone229, i8* %var235, i32 0, i8* %var236, i32 3, %clsvar* %addytable234)
%address-table238 = bitcast %clsvar* %addytable237 to i8*

; insert table, function and environment into closure struct
%closure.table241 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure231, i32 0, i32 0
store i8* %address-table238, i8** %closure.table241
%closure.env242 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure231, i32 0, i32 1
store i8* %envptr232, i8** %closure.env242
%closure.func243 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure231, i32 0, i32 2
store %VBO* (i8*, i8*, i32, i32, i64, i8*)* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ__207, %VBO* (i8*, i8*, i32, i32, i64, i8*)** %closure.func243
%closure_size244 = call i64 @llvm_zone_mark_size(%mzone* %zone229)
call void @llvm_zone_ptr_set_size(i8* %clsptr230, i64 %closure_size244)
%wrapper_ptr245 = call i8* @llvm_zone_malloc(%mzone* %zone229, i64 8)
%closure_wrapper246 = bitcast i8* %wrapper_ptr245 to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
store { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure231, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_wrapper246

; let value assignment
%VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_wrapper246, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_wrapper246
store { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*** %VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ
%tmp_envptr240 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}* %environment233, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*** %VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**** %tmp_envptr240


%val249 = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*** %VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr
ret {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %val249
}


@VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_native(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var250 = bitcast [96 x i8]* @gsxtmgl-objects23 to i8*
call i32 (i8*, ...) @printf(i8* %var250)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var251 = bitcast [96 x i8]* @gsxtmgl-objects23 to i8*
call i32 (i8*, ...) @printf(i8* %var251)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var252 = bitcast [96 x i8]* @gsxtmgl-objects23 to i8*
call i32 (i8*, ...) @printf(i8* %var252)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr_or_str(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var253 = bitcast [96 x i8]* @gsxtmgl-objects23 to i8*
call i32 (i8*, ...) @printf(i8* %var253)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i8*  @cptr_value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i64, i8*}*
%arg_p_0 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 3
%arg_3 = load i8*, i8** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_z_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects24 = hidden constant [43 x i8] c"VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ\00"
define dllexport fastcc %VBO* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ__254(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone255 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}*
%VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}* %impenv, i32 0, i32 0
%VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**** %VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i64
store i64 %arg_2, i64* %arg_2Ptr
%arg_3Ptr = alloca i8*
store i8* %arg_3, i8** %arg_3Ptr


%tzone258 = load i8*, i8** %_impzPtr
%zone259 = bitcast i8* %tzone258 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VBO*
%dat256 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat256, i32 0, i64 24)
%val257 = bitcast i8* %dat256 to %VBO*

; let value assignment
%obj = select i1 true, %VBO* %val257, %VBO* %val257
store %VBO* %obj, %VBO** %objPtr

%val260 = load %VBO*, %VBO** %objPtr
%val261 = load i32, i32* %arg_0Ptr
; set tuple
%val262 = getelementptr %VBO, %VBO* %val260, i64 0, i32 0
store i32 %val261, i32* %val262
%val263 = load %VBO*, %VBO** %objPtr
%val264 = load i32, i32* %arg_1Ptr
; set tuple
%val265 = getelementptr %VBO, %VBO* %val263, i64 0, i32 1
store i32 %val264, i32* %val265
%val266 = load %VBO*, %VBO** %objPtr
%val267 = load i64, i64* %arg_2Ptr
; set tuple
%val268 = getelementptr %VBO, %VBO* %val266, i64 0, i32 2
store i64 %val267, i64* %val268
%val269 = load %VBO*, %VBO** %objPtr
%val270 = load i8*, i8** %arg_3Ptr
; set tuple
%val271 = getelementptr %VBO, %VBO* %val269, i64 0, i32 3
store i8* %val270, i8** %val271
%val272 = load %VBO*, %VBO** %objPtr
ret %VBO* %val272
}
@gsxtmgl-objects25 = hidden constant [96 x i8] c"VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone292 = load i8*, i8** %_impzPtr
%zone293 = bitcast i8* %tzone292 to %mzone*

; let assign value to symbol VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ
%dat_VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone293, i64 8)
%VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr = bitcast i8* %dat_VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***
%tzone273 = load i8*, i8** %_impzPtr
%zone274 = bitcast i8* %tzone273 to %mzone*
call void @llvm_zone_mark(%mzone* %zone274)
; malloc closure structure
%clsptr275 = call i8* @llvm_zone_malloc(%mzone* %zone274, i64 24)
%closure276 = bitcast i8* %clsptr275 to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*

; malloc environment structure
%envptr277 = call i8* @llvm_zone_malloc(%mzone* %zone274, i64 8)
%environment278 = bitcast i8* %envptr277 to {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}*

; malloc closure address table
%addytable279 = call %clsvar* @new_address_table()
%var280 = bitcast [43 x i8]* @gsxtmgl-objects24 to i8*
%var281 = bitcast [52 x i8]* @gsxtmgl-objects20 to i8*
%addytable282 = call %clsvar* @add_address_table(%mzone* %zone274, i8* %var280, i32 0, i8* %var281, i32 3, %clsvar* %addytable279)
%address-table283 = bitcast %clsvar* %addytable282 to i8*

; insert table, function and environment into closure struct
%closure.table286 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure276, i32 0, i32 0
store i8* %address-table283, i8** %closure.table286
%closure.env287 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure276, i32 0, i32 1
store i8* %envptr277, i8** %closure.env287
%closure.func288 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure276, i32 0, i32 2
store %VBO* (i8*, i8*, i32, i32, i64, i8*)* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ__254, %VBO* (i8*, i8*, i32, i32, i64, i8*)** %closure.func288
%closure_size289 = call i64 @llvm_zone_mark_size(%mzone* %zone274)
call void @llvm_zone_ptr_set_size(i8* %clsptr275, i64 %closure_size289)
%wrapper_ptr290 = call i8* @llvm_zone_malloc(%mzone* %zone274, i64 8)
%closure_wrapper291 = bitcast i8* %wrapper_ptr290 to { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
store { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure276, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_wrapper291

; let value assignment
%VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_wrapper291, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_wrapper291
store { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ, { i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*** %VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr

; add data to environment
; don't need to alloc for env var VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ
%tmp_envptr285 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}***}* %environment278, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*** %VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**** %tmp_envptr285


%val294 = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*** %VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQPtr
ret {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %val294
}


@VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_native(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var295 = bitcast [96 x i8]* @gsxtmgl-objects25 to i8*
call i32 (i8*, ...) @printf(i8* %var295)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var296 = bitcast [96 x i8]* @gsxtmgl-objects25 to i8*
call i32 (i8*, ...) @printf(i8* %var296)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var297 = bitcast [96 x i8]* @gsxtmgl-objects25 to i8*
call i32 (i8*, ...) @printf(i8* %var297)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i64  @i64value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_cptr_or_str(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var298 = bitcast [96 x i8]* @gsxtmgl-objects25 to i8*
call i32 (i8*, ...) @printf(i8* %var298)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i8*  @cptr_value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i64, i8*}*
%arg_p_0 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 3
%arg_3 = load i8*, i8** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_h_adhoc_W1ZCTyosaTMyLGkzMixpNjQsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO* (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32, i32, i64, i8*)*,  %VBO* (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects26 = hidden constant [43 x i8] c"VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd\00"
@gsxtmgl-objects27 = hidden constant [51 x i8] c"{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}**\00"
define dllexport fastcc %VBO @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd__299(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone300 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}***}*
%VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpdPtr_ = getelementptr {{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}***}, {{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}***}* %impenv, i32 0, i32 0
%VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpdPtr = load {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}***, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}**** %VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i64
store i64 %arg_2, i64* %arg_2Ptr
%arg_3Ptr = alloca i8*
store i8* %arg_3, i8** %arg_3Ptr


%tzone302 = load i8*, i8** %_impzPtr
%zone303 = bitcast i8* %tzone302 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VBO*
%dat301 = alloca %VBO, align 16

; let value assignment
%obj = select i1 true, %VBO* %dat301, %VBO* %dat301
store %VBO* %obj, %VBO** %objPtr

%val304 = load %VBO*, %VBO** %objPtr
%val305 = load i32, i32* %arg_0Ptr
; set tuple
%val306 = getelementptr %VBO, %VBO* %val304, i64 0, i32 0
store i32 %val305, i32* %val306
%val307 = load %VBO*, %VBO** %objPtr
%val308 = load i32, i32* %arg_1Ptr
; set tuple
%val309 = getelementptr %VBO, %VBO* %val307, i64 0, i32 1
store i32 %val308, i32* %val309
%val310 = load %VBO*, %VBO** %objPtr
%val311 = load i64, i64* %arg_2Ptr
; set tuple
%val312 = getelementptr %VBO, %VBO* %val310, i64 0, i32 2
store i64 %val311, i64* %val312
%val313 = load %VBO*, %VBO** %objPtr
%val314 = load i8*, i8** %arg_3Ptr
; set tuple
%val315 = getelementptr %VBO, %VBO* %val313, i64 0, i32 3
store i8* %val314, i8** %val315
%val316 = load %VBO*, %VBO** %objPtr
; pointer ref
%val317 = getelementptr %VBO, %VBO* %val316, i64 0
%val318 = load %VBO, %VBO* %val317
ret %VBO %val318
}
@gsxtmgl-objects28 = hidden constant [96 x i8] c"VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}** @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone338 = load i8*, i8** %_impzPtr
%zone339 = bitcast i8* %tzone338 to %mzone*

; let assign value to symbol VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd
%dat_VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd = call i8* @llvm_zone_malloc(%mzone* %zone339, i64 8)
%VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpdPtr = bitcast i8* %dat_VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd to { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}***
%tzone319 = load i8*, i8** %_impzPtr
%zone320 = bitcast i8* %tzone319 to %mzone*
call void @llvm_zone_mark(%mzone* %zone320)
; malloc closure structure
%clsptr321 = call i8* @llvm_zone_malloc(%mzone* %zone320, i64 24)
%closure322 = bitcast i8* %clsptr321 to { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}*

; malloc environment structure
%envptr323 = call i8* @llvm_zone_malloc(%mzone* %zone320, i64 8)
%environment324 = bitcast i8* %envptr323 to {{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}***}*

; malloc closure address table
%addytable325 = call %clsvar* @new_address_table()
%var326 = bitcast [43 x i8]* @gsxtmgl-objects26 to i8*
%var327 = bitcast [51 x i8]* @gsxtmgl-objects27 to i8*
%addytable328 = call %clsvar* @add_address_table(%mzone* %zone320, i8* %var326, i32 0, i8* %var327, i32 3, %clsvar* %addytable325)
%address-table329 = bitcast %clsvar* %addytable328 to i8*

; insert table, function and environment into closure struct
%closure.table332 = getelementptr { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}* %closure322, i32 0, i32 0
store i8* %address-table329, i8** %closure.table332
%closure.env333 = getelementptr { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}* %closure322, i32 0, i32 1
store i8* %envptr323, i8** %closure.env333
%closure.func334 = getelementptr { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}* %closure322, i32 0, i32 2
store %VBO (i8*, i8*, i32, i32, i64, i8*)* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd__299, %VBO (i8*, i8*, i32, i32, i64, i8*)** %closure.func334
%closure_size335 = call i64 @llvm_zone_mark_size(%mzone* %zone320)
call void @llvm_zone_ptr_set_size(i8* %clsptr321, i64 %closure_size335)
%wrapper_ptr336 = call i8* @llvm_zone_malloc(%mzone* %zone320, i64 8)
%closure_wrapper337 = bitcast i8* %wrapper_ptr336 to { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}**
store { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}* %closure322, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}** %closure_wrapper337

; let value assignment
%VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd = select i1 true, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}** %closure_wrapper337, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}** %closure_wrapper337
store { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}** %VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd, { i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}*** %VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpdPtr

; add data to environment
; don't need to alloc for env var VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd
%tmp_envptr331 = getelementptr {{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}***}, {{i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}***}* %environment324, i32 0, i32 0
store {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}*** %VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpdPtr, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}**** %tmp_envptr331


%val340 = load {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}**, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}*** %VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpdPtr
ret {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}** %val340
}


@VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}** @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO (i8*, i8*, i32, i32, i64, i8*)*,  %VBO (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
ret %VBO %result
}


define dllexport ccc %VBO @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_native(i32 %arg_0,i32 %arg_1,i64 %arg_2,i8* %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO (i8*, i8*, i32, i32, i64, i8*)*,  %VBO (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
ret %VBO %result
}


define dllexport ccc void @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i64, i8*}*
%arg_p_0 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i64, i64* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i64, i8*}, {i32, i32, i64, i8*}* %fstruct, i32 0, i32 3
%arg_3 = load i8*, i8** %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_val_adhoc_W1ZCTyxpMzIsaTMyLGk2NCxpOCpd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}**
%closure = load {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}*, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}, {i8*, i8*, %VBO (i8*, i8*, i32, i32, i64, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VBO (i8*, i8*, i32, i32, i64, i8*)*,  %VBO (i8*, i8*, i32, i32, i64, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i64 %arg_2, i8* %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects29 = hidden constant [28 x i8] c"hcopy_adhoc_W1ZCTyosVkJPKl0\00"
@gsxtmgl-objects30 = hidden constant [39 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**\00"
define dllexport fastcc %VBO* @hcopy_adhoc_W1ZCTyosVkJPKl0__345(i8* %_impz,i8* %_impenv, %VBO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone346 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***}*
%hcopy_adhoc_W1ZCTyosVkJPKl0Ptr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1ZCTyosVkJPKl0Ptr = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**** %hcopy_adhoc_W1ZCTyosVkJPKl0Ptr_

; setup arguments
%xPtr = alloca %VBO*
store %VBO* %x, %VBO** %xPtr


%tzone349 = load i8*, i8** %_impzPtr
%zone350 = bitcast i8* %tzone349 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VBO*
%dat347 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat347, i32 0, i64 24)
%val348 = bitcast i8* %dat347 to %VBO*

; let value assignment
%obj = select i1 true, %VBO* %val348, %VBO* %val348
store %VBO* %obj, %VBO** %objPtr

%val351 = load %VBO*, %VBO** %objPtr
%val352 = load %VBO*, %VBO** %xPtr
; tuple ref
%val353 = getelementptr %VBO, %VBO* %val352, i64 0, i32 0
%val354 = load i32, i32* %val353
; set tuple
%val355 = getelementptr %VBO, %VBO* %val351, i64 0, i32 0
store i32 %val354, i32* %val355
%val356 = load %VBO*, %VBO** %objPtr
%val357 = load %VBO*, %VBO** %xPtr
; tuple ref
%val358 = getelementptr %VBO, %VBO* %val357, i64 0, i32 1
%val359 = load i32, i32* %val358
; set tuple
%val360 = getelementptr %VBO, %VBO* %val356, i64 0, i32 1
store i32 %val359, i32* %val360
%val361 = load %VBO*, %VBO** %objPtr
%val362 = load %VBO*, %VBO** %xPtr
; tuple ref
%val363 = getelementptr %VBO, %VBO* %val362, i64 0, i32 2
%val364 = load i64, i64* %val363
; set tuple
%val365 = getelementptr %VBO, %VBO* %val361, i64 0, i32 2
store i64 %val364, i64* %val365
%val366 = load %VBO*, %VBO** %objPtr
%val367 = load %VBO*, %VBO** %xPtr
; tuple ref
%val368 = getelementptr %VBO, %VBO* %val367, i64 0, i32 3
%val369 = load i8*, i8** %val368
; set tuple
%val370 = getelementptr %VBO, %VBO* %val366, i64 0, i32 3
store i8* %val369, i8** %val370
%val371 = load %VBO*, %VBO** %objPtr
ret %VBO* %val371
}
@gsxtmgl-objects31 = hidden constant [81 x i8] c"hcopy_adhoc_W1ZCTyosVkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** @hcopy_adhoc_W1ZCTyosVkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone391 = load i8*, i8** %_impzPtr
%zone392 = bitcast i8* %tzone391 to %mzone*

; let assign value to symbol hcopy_adhoc_W1ZCTyosVkJPKl0
%dat_hcopy_adhoc_W1ZCTyosVkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone392, i64 8)
%hcopy_adhoc_W1ZCTyosVkJPKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1ZCTyosVkJPKl0 to { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***
%tzone372 = load i8*, i8** %_impzPtr
%zone373 = bitcast i8* %tzone372 to %mzone*
call void @llvm_zone_mark(%mzone* %zone373)
; malloc closure structure
%clsptr374 = call i8* @llvm_zone_malloc(%mzone* %zone373, i64 24)
%closure375 = bitcast i8* %clsptr374 to { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr376 = call i8* @llvm_zone_malloc(%mzone* %zone373, i64 8)
%environment377 = bitcast i8* %envptr376 to {{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable378 = call %clsvar* @new_address_table()
%var379 = bitcast [28 x i8]* @gsxtmgl-objects29 to i8*
%var380 = bitcast [39 x i8]* @gsxtmgl-objects30 to i8*
%addytable381 = call %clsvar* @add_address_table(%mzone* %zone373, i8* %var379, i32 0, i8* %var380, i32 3, %clsvar* %addytable378)
%address-table382 = bitcast %clsvar* %addytable381 to i8*

; insert table, function and environment into closure struct
%closure.table385 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure375, i32 0, i32 0
store i8* %address-table382, i8** %closure.table385
%closure.env386 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure375, i32 0, i32 1
store i8* %envptr376, i8** %closure.env386
%closure.func387 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure375, i32 0, i32 2
store %VBO* (i8*, i8*, %VBO*)* @hcopy_adhoc_W1ZCTyosVkJPKl0__345, %VBO* (i8*, i8*, %VBO*)** %closure.func387
%closure_size388 = call i64 @llvm_zone_mark_size(%mzone* %zone373)
call void @llvm_zone_ptr_set_size(i8* %clsptr374, i64 %closure_size388)
%wrapper_ptr389 = call i8* @llvm_zone_malloc(%mzone* %zone373, i64 8)
%closure_wrapper390 = bitcast i8* %wrapper_ptr389 to { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**
store { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure375, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_wrapper390

; let value assignment
%hcopy_adhoc_W1ZCTyosVkJPKl0 = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_wrapper390, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_wrapper390
store { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %hcopy_adhoc_W1ZCTyosVkJPKl0, { i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*** %hcopy_adhoc_W1ZCTyosVkJPKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1ZCTyosVkJPKl0
%tmp_envptr384 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}***}* %environment377, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*** %hcopy_adhoc_W1ZCTyosVkJPKl0Ptr, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**** %tmp_envptr384


%val393 = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*** %hcopy_adhoc_W1ZCTyosVkJPKl0Ptr
ret {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %val393
}


@hcopy_adhoc_W1ZCTyosVkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1ZCTyosVkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1ZCTyosVkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** @hcopy_adhoc_W1ZCTyosVkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1ZCTyosVkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @hcopy_adhoc_W1ZCTyosVkJPKl0(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*)*,  %VBO* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret %VBO* %result
}


define dllexport ccc %VBO* @hcopy_adhoc_W1ZCTyosVkJPKl0_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*)*,  %VBO* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret %VBO* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1ZCTyosVkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var394 = bitcast [81 x i8]* @gsxtmgl-objects31 to i8*
call i32 (i8*, ...) @printf(i8* %var394)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*)*,  %VBO* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1ZCTyosVkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZCTyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*)*,  %VBO* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects32 = hidden constant [28 x i8] c"hfree_adhoc_W3ZvaWQsVkJPKl0\00"
@gsxtmgl-objects33 = hidden constant [38 x i8] c"{i8*, i8*, void (i8*, i8*, %VBO*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsVkJPKl0__395(i8* %_impz,i8* %_impenv, %VBO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone396 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*
%hfree_adhoc_W3ZvaWQsVkJPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsVkJPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %VBO*)*}***, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %hfree_adhoc_W3ZvaWQsVkJPKl0Ptr_

; setup arguments
%xPtr = alloca %VBO*
store %VBO* %x, %VBO** %xPtr


%val397 = load %VBO*, %VBO** %xPtr
%val398 = bitcast %VBO* %val397 to i8*
call ccc void @free(i8* %val398)
ret void
}
@gsxtmgl-objects34 = hidden constant [81 x i8] c"hfree_adhoc_W3ZvaWQsVkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @hfree_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone420 = load i8*, i8** %_impzPtr
%zone421 = bitcast i8* %tzone420 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsVkJPKl0
%dat_hfree_adhoc_W3ZvaWQsVkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone421, i64 8)
%hfree_adhoc_W3ZvaWQsVkJPKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsVkJPKl0 to { i8*, i8*, void (i8*, i8*, %VBO*)*}***
%tzone401 = load i8*, i8** %_impzPtr
%zone402 = bitcast i8* %tzone401 to %mzone*
call void @llvm_zone_mark(%mzone* %zone402)
; malloc closure structure
%clsptr403 = call i8* @llvm_zone_malloc(%mzone* %zone402, i64 24)
%closure404 = bitcast i8* %clsptr403 to { i8*, i8*, void (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr405 = call i8* @llvm_zone_malloc(%mzone* %zone402, i64 8)
%environment406 = bitcast i8* %envptr405 to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable407 = call %clsvar* @new_address_table()
%var408 = bitcast [28 x i8]* @gsxtmgl-objects32 to i8*
%var409 = bitcast [38 x i8]* @gsxtmgl-objects33 to i8*
%addytable410 = call %clsvar* @add_address_table(%mzone* %zone402, i8* %var408, i32 0, i8* %var409, i32 3, %clsvar* %addytable407)
%address-table411 = bitcast %clsvar* %addytable410 to i8*

; insert table, function and environment into closure struct
%closure.table414 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure404, i32 0, i32 0
store i8* %address-table411, i8** %closure.table414
%closure.env415 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure404, i32 0, i32 1
store i8* %envptr405, i8** %closure.env415
%closure.func416 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure404, i32 0, i32 2
store void (i8*, i8*, %VBO*)* @hfree_adhoc_W3ZvaWQsVkJPKl0__395, void (i8*, i8*, %VBO*)** %closure.func416
%closure_size417 = call i64 @llvm_zone_mark_size(%mzone* %zone402)
call void @llvm_zone_ptr_set_size(i8* %clsptr403, i64 %closure_size417)
%wrapper_ptr418 = call i8* @llvm_zone_malloc(%mzone* %zone402, i64 8)
%closure_wrapper419 = bitcast i8* %wrapper_ptr418 to { i8*, i8*, void (i8*, i8*, %VBO*)*}**
store { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure404, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper419

; let value assignment
%hfree_adhoc_W3ZvaWQsVkJPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper419, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper419
store { i8*, i8*, void (i8*, i8*, %VBO*)*}** %hfree_adhoc_W3ZvaWQsVkJPKl0, { i8*, i8*, void (i8*, i8*, %VBO*)*}*** %hfree_adhoc_W3ZvaWQsVkJPKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsVkJPKl0
%tmp_envptr413 = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %environment406, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %hfree_adhoc_W3ZvaWQsVkJPKl0Ptr, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %tmp_envptr413


%val422 = load {i8*, i8*, void (i8*, i8*, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %hfree_adhoc_W3ZvaWQsVkJPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VBO*)*}** %val422
}


@hfree_adhoc_W3ZvaWQsVkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsVkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsVkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @hfree_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsVkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsVkJPKl0(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsVkJPKl0_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsVkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var423 = bitcast [81 x i8]* @gsxtmgl-objects34 to i8*
call i32 (i8*, ...) @printf(i8* %var423)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsVkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects35 = hidden constant [47 x i8] c"zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmgl-objects36 = hidden constant [57 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %VBO* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ__424(i8* %_impz,i8* %_impenv, %VBO* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone425 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %VBO*
store %VBO* %x, %VBO** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val427 = load %mzone*, %mzone** %fromzPtr
%val428 = load %VBO*, %VBO** %xPtr
%val429 = bitcast %VBO* %val428 to i8*
%res430 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val427, i8* %val429)
br i1 %res430, label %then426, label %else426

then426:
%val431 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val431)
%zone_ptr432 = bitcast %mzone* %val431 to i8*
store i8* %zone_ptr432, i8** %_impzPtr
%tzone438 = load i8*, i8** %_impzPtr
%zone439 = bitcast i8* %tzone438 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VBO*
%tzone434 = load i8*, i8** %_impzPtr
%zone435 = bitcast i8* %tzone434 to %mzone*
%dat436 = call i8* @llvm_zone_malloc(%mzone* %zone435, i64 24)
call i8* @memset(i8* %dat436, i32 0, i64 24)
%val437 = bitcast i8* %dat436 to %VBO*

; let value assignment
%obj = select i1 true, %VBO* %val437, %VBO* %val437
store %VBO* %obj, %VBO** %objPtr

; promote local stack var allocations
%tzone488 = load i8*, i8** %_impzPtr
%zone489 = bitcast i8* %tzone488 to %mzone*
%ifptr455 = alloca i8*
%val440 = load %VBO*, %VBO** %objPtr
%val441 = load %VBO*, %VBO** %xPtr
; tuple ref
%val442 = getelementptr %VBO, %VBO* %val441, i64 0, i32 0
%val443 = load i32, i32* %val442
; set tuple
%val444 = getelementptr %VBO, %VBO* %val440, i64 0, i32 0
store i32 %val443, i32* %val444
%val445 = load %VBO*, %VBO** %objPtr
%val446 = load %VBO*, %VBO** %xPtr
; tuple ref
%val447 = getelementptr %VBO, %VBO* %val446, i64 0, i32 1
%val448 = load i32, i32* %val447
; set tuple
%val449 = getelementptr %VBO, %VBO* %val445, i64 0, i32 1
store i32 %val448, i32* %val449
%val450 = load %VBO*, %VBO** %objPtr
%val451 = load %VBO*, %VBO** %xPtr
; tuple ref
%val452 = getelementptr %VBO, %VBO* %val451, i64 0, i32 2
%val453 = load i64, i64* %val452
; set tuple
%val454 = getelementptr %VBO, %VBO* %val450, i64 0, i32 2
store i64 %val453, i64* %val454
%val456 = load %mzone*, %mzone** %fromzPtr
%val457 = load %VBO*, %VBO** %xPtr
; tuple ref
%val458 = getelementptr %VBO, %VBO* %val457, i64 0, i32 3
%val459 = load i8*, i8** %val458
%val460 = bitcast i8* %val459 to i8*
%res461 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val456, i8* %val460)
br i1 %res461, label %then455, label %else455

then455:
%tzone466 = load i8*, i8** %_impzPtr
%zone467 = bitcast i8* %tzone466 to %mzone*

; let assign value to symbol newptr
%newptrPtr = alloca i8*
%tzone462 = load i8*, i8** %_impzPtr
%zone463 = bitcast i8* %tzone462 to %mzone*
%dat464 = call i8* @llvm_zone_malloc(%mzone* %zone463, i64 1)
call i8* @memset(i8* %dat464, i32 0, i64 1)
%val465 = bitcast i8* %dat464 to i8*

; let value assignment
%newptr = select i1 true, i8* %val465, i8* %val465
store i8* %newptr, i8** %newptrPtr

%val468 = load i8*, i8** %newptrPtr
%val469 = bitcast i8* %val468 to i8*
%val470 = load %VBO*, %VBO** %xPtr
; tuple ref
%val471 = getelementptr %VBO, %VBO* %val470, i64 0, i32 3
%val472 = load i8*, i8** %val471
%val473 = bitcast i8* %val472 to i8*
call ccc void @llvm.memcpy.p0i8.p0i8.i64(i8* %val469, i8* %val473, i64 1, i32 1, i1 0)
%val475 = load %VBO*, %VBO** %objPtr
%val476 = load i8*, i8** %newptrPtr
; set tuple
%val477 = getelementptr %VBO, %VBO* %val475, i64 0, i32 3
store i8* %val476, i8** %val477
store i8* %val476, i8** %ifptr455
br label %ifcont455

else455:
%val478 = load %VBO*, %VBO** %objPtr
%val479 = load %VBO*, %VBO** %xPtr
; tuple ref
%val480 = getelementptr %VBO, %VBO* %val479, i64 0, i32 3
%val481 = load i8*, i8** %val480
; set tuple
%val482 = getelementptr %VBO, %VBO* %val478, i64 0, i32 3
store i8* %val481, i8** %val482
store i8* %val481, i8** %ifptr455
br label %ifcont455

ifcont455:
%ifres483 = load i8*, i8** %ifptr455

%oldzone484 = call %mzone* @llvm_pop_zone_stack()
%newzone485 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr486 = bitcast %mzone* %newzone485 to i8*
store i8* %zone_ptr486, i8** %_impzPtr
%val487 = load %VBO*, %VBO** %objPtr
ret %VBO* %val487

else426:
%val490 = load %VBO*, %VBO** %xPtr
ret %VBO* %val490
}
@gsxtmgl-objects37 = hidden constant [100 x i8] c"zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone510 = load i8*, i8** %_impzPtr
%zone511 = bitcast i8* %tzone510 to %mzone*

; let assign value to symbol zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone511, i64 8)
%zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***
%tzone491 = load i8*, i8** %_impzPtr
%zone492 = bitcast i8* %tzone491 to %mzone*
call void @llvm_zone_mark(%mzone* %zone492)
; malloc closure structure
%clsptr493 = call i8* @llvm_zone_malloc(%mzone* %zone492, i64 24)
%closure494 = bitcast i8* %clsptr493 to { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr495 = call i8* @llvm_zone_malloc(%mzone* %zone492, i64 8)
%environment496 = bitcast i8* %envptr495 to {{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable497 = call %clsvar* @new_address_table()
%var498 = bitcast [47 x i8]* @gsxtmgl-objects35 to i8*
%var499 = bitcast [57 x i8]* @gsxtmgl-objects36 to i8*
%addytable500 = call %clsvar* @add_address_table(%mzone* %zone492, i8* %var498, i32 0, i8* %var499, i32 3, %clsvar* %addytable497)
%address-table501 = bitcast %clsvar* %addytable500 to i8*

; insert table, function and environment into closure struct
%closure.table504 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure494, i32 0, i32 0
store i8* %address-table501, i8** %closure.table504
%closure.env505 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure494, i32 0, i32 1
store i8* %envptr495, i8** %closure.env505
%closure.func506 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure494, i32 0, i32 2
store %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ__424, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)** %closure.func506
%closure_size507 = call i64 @llvm_zone_mark_size(%mzone* %zone492)
call void @llvm_zone_ptr_set_size(i8* %clsptr493, i64 %closure_size507)
%wrapper_ptr508 = call i8* @llvm_zone_malloc(%mzone* %zone492, i64 8)
%closure_wrapper509 = bitcast i8* %wrapper_ptr508 to { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**
store { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure494, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_wrapper509

; let value assignment
%zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_wrapper509, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_wrapper509
store { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ
%tmp_envptr503 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}***}* %environment496, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**** %tmp_envptr503


%val512 = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %val512
}


@zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ(%VBO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*,  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %VBO* %result
}


define dllexport ccc %VBO* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_native(%VBO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*,  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %VBO* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var513 = bitcast [100 x i8]* @gsxtmgl-objects37 to i8*
call i32 (i8*, ...) @printf(i8* %var513)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var514 = bitcast [100 x i8]* @gsxtmgl-objects37 to i8*
call i32 (i8*, ...) @printf(i8* %var514)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var515 = bitcast [100 x i8]* @gsxtmgl-objects37 to i8*
call i32 (i8*, ...) @printf(i8* %var515)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*,  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%VBO*, %mzone*, %mzone*}, {%VBO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
%arg_p_1 = getelementptr {%VBO*, %mzone*, %mzone*}, {%VBO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%VBO*, %mzone*, %mzone*}, {%VBO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZCTyosVkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}, {i8*, i8*, %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)*,  %VBO* (i8*, i8*, %VBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects38 = hidden constant [28 x i8] c"VBO_id_adhoc_W2kzMixWQk8qXQ\00"
@gsxtmgl-objects39 = hidden constant [37 x i8] c"{i8*, i8*, i32 (i8*, i8*, %VBO*)*}**\00"
define dllexport fastcc i32 @VBO_id_adhoc_W2kzMixWQk8qXQ__516(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone517 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}*
%VBO_id_adhoc_W2kzMixWQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%VBO_id_adhoc_W2kzMixWQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**** %VBO_id_adhoc_W2kzMixWQk8qXQPtr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%val518 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val519 = getelementptr %VBO, %VBO* %val518, i64 0, i32 0
%val520 = load i32, i32* %val519
ret i32 %val520
}
@gsxtmgl-objects40 = hidden constant [81 x i8] c"VBO_id_adhoc_W2kzMixWQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** @VBO_id_adhoc_W2kzMixWQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone540 = load i8*, i8** %_impzPtr
%zone541 = bitcast i8* %tzone540 to %mzone*

; let assign value to symbol VBO_id_adhoc_W2kzMixWQk8qXQ
%dat_VBO_id_adhoc_W2kzMixWQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone541, i64 8)
%VBO_id_adhoc_W2kzMixWQk8qXQPtr = bitcast i8* %dat_VBO_id_adhoc_W2kzMixWQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %VBO*)*}***
%tzone521 = load i8*, i8** %_impzPtr
%zone522 = bitcast i8* %tzone521 to %mzone*
call void @llvm_zone_mark(%mzone* %zone522)
; malloc closure structure
%clsptr523 = call i8* @llvm_zone_malloc(%mzone* %zone522, i64 24)
%closure524 = bitcast i8* %clsptr523 to { i8*, i8*, i32 (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr525 = call i8* @llvm_zone_malloc(%mzone* %zone522, i64 8)
%environment526 = bitcast i8* %envptr525 to {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable527 = call %clsvar* @new_address_table()
%var528 = bitcast [28 x i8]* @gsxtmgl-objects38 to i8*
%var529 = bitcast [37 x i8]* @gsxtmgl-objects39 to i8*
%addytable530 = call %clsvar* @add_address_table(%mzone* %zone522, i8* %var528, i32 0, i8* %var529, i32 3, %clsvar* %addytable527)
%address-table531 = bitcast %clsvar* %addytable530 to i8*

; insert table, function and environment into closure struct
%closure.table534 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VBO*)*}, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure524, i32 0, i32 0
store i8* %address-table531, i8** %closure.table534
%closure.env535 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VBO*)*}, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure524, i32 0, i32 1
store i8* %envptr525, i8** %closure.env535
%closure.func536 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VBO*)*}, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure524, i32 0, i32 2
store i32 (i8*, i8*, %VBO*)* @VBO_id_adhoc_W2kzMixWQk8qXQ__516, i32 (i8*, i8*, %VBO*)** %closure.func536
%closure_size537 = call i64 @llvm_zone_mark_size(%mzone* %zone522)
call void @llvm_zone_ptr_set_size(i8* %clsptr523, i64 %closure_size537)
%wrapper_ptr538 = call i8* @llvm_zone_malloc(%mzone* %zone522, i64 8)
%closure_wrapper539 = bitcast i8* %wrapper_ptr538 to { i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure524, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_wrapper539

; let value assignment
%VBO_id_adhoc_W2kzMixWQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_wrapper539, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_wrapper539
store { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %VBO_id_adhoc_W2kzMixWQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}*** %VBO_id_adhoc_W2kzMixWQk8qXQPtr

; add data to environment
; don't need to alloc for env var VBO_id_adhoc_W2kzMixWQk8qXQ
%tmp_envptr533 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}* %environment526, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*** %VBO_id_adhoc_W2kzMixWQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**** %tmp_envptr533


%val542 = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*** %VBO_id_adhoc_W2kzMixWQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %val542
}


@VBO_id_adhoc_W2kzMixWQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_id_adhoc_W2kzMixWQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_id_adhoc_W2kzMixWQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_id_adhoc_W2kzMixWQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** @VBO_id_adhoc_W2kzMixWQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_id_adhoc_W2kzMixWQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_id_adhoc_W2kzMixWQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_id_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @VBO_id_adhoc_W2kzMixWQk8qXQ(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_id_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @VBO_id_adhoc_W2kzMixWQk8qXQ_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_id_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @VBO_id_adhoc_W2kzMixWQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var543 = bitcast [81 x i8]* @gsxtmgl-objects40 to i8*
call i32 (i8*, ...) @printf(i8* %var543)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_id_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @VBO_id_adhoc_W2kzMixWQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_id_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects41 = hidden constant [30 x i8] c"VBO_type_adhoc_W2kzMixWQk8qXQ\00"
define dllexport fastcc i32 @VBO_type_adhoc_W2kzMixWQk8qXQ__544(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone545 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}*
%VBO_type_adhoc_W2kzMixWQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%VBO_type_adhoc_W2kzMixWQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**** %VBO_type_adhoc_W2kzMixWQk8qXQPtr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%val546 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val547 = getelementptr %VBO, %VBO* %val546, i64 0, i32 1
%val548 = load i32, i32* %val547
ret i32 %val548
}
@gsxtmgl-objects42 = hidden constant [83 x i8] c"VBO_type_adhoc_W2kzMixWQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** @VBO_type_adhoc_W2kzMixWQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone568 = load i8*, i8** %_impzPtr
%zone569 = bitcast i8* %tzone568 to %mzone*

; let assign value to symbol VBO_type_adhoc_W2kzMixWQk8qXQ
%dat_VBO_type_adhoc_W2kzMixWQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone569, i64 8)
%VBO_type_adhoc_W2kzMixWQk8qXQPtr = bitcast i8* %dat_VBO_type_adhoc_W2kzMixWQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %VBO*)*}***
%tzone549 = load i8*, i8** %_impzPtr
%zone550 = bitcast i8* %tzone549 to %mzone*
call void @llvm_zone_mark(%mzone* %zone550)
; malloc closure structure
%clsptr551 = call i8* @llvm_zone_malloc(%mzone* %zone550, i64 24)
%closure552 = bitcast i8* %clsptr551 to { i8*, i8*, i32 (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr553 = call i8* @llvm_zone_malloc(%mzone* %zone550, i64 8)
%environment554 = bitcast i8* %envptr553 to {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable555 = call %clsvar* @new_address_table()
%var556 = bitcast [30 x i8]* @gsxtmgl-objects41 to i8*
%var557 = bitcast [37 x i8]* @gsxtmgl-objects39 to i8*
%addytable558 = call %clsvar* @add_address_table(%mzone* %zone550, i8* %var556, i32 0, i8* %var557, i32 3, %clsvar* %addytable555)
%address-table559 = bitcast %clsvar* %addytable558 to i8*

; insert table, function and environment into closure struct
%closure.table562 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VBO*)*}, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure552, i32 0, i32 0
store i8* %address-table559, i8** %closure.table562
%closure.env563 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VBO*)*}, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure552, i32 0, i32 1
store i8* %envptr553, i8** %closure.env563
%closure.func564 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VBO*)*}, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure552, i32 0, i32 2
store i32 (i8*, i8*, %VBO*)* @VBO_type_adhoc_W2kzMixWQk8qXQ__544, i32 (i8*, i8*, %VBO*)** %closure.func564
%closure_size565 = call i64 @llvm_zone_mark_size(%mzone* %zone550)
call void @llvm_zone_ptr_set_size(i8* %clsptr551, i64 %closure_size565)
%wrapper_ptr566 = call i8* @llvm_zone_malloc(%mzone* %zone550, i64 8)
%closure_wrapper567 = bitcast i8* %wrapper_ptr566 to { i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure552, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_wrapper567

; let value assignment
%VBO_type_adhoc_W2kzMixWQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_wrapper567, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_wrapper567
store { i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %VBO_type_adhoc_W2kzMixWQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %VBO*)*}*** %VBO_type_adhoc_W2kzMixWQk8qXQPtr

; add data to environment
; don't need to alloc for env var VBO_type_adhoc_W2kzMixWQk8qXQ
%tmp_envptr561 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %VBO*)*}***}* %environment554, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*** %VBO_type_adhoc_W2kzMixWQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**** %tmp_envptr561


%val570 = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*** %VBO_type_adhoc_W2kzMixWQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %val570
}


@VBO_type_adhoc_W2kzMixWQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_type_adhoc_W2kzMixWQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_type_adhoc_W2kzMixWQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_type_adhoc_W2kzMixWQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** @VBO_type_adhoc_W2kzMixWQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_type_adhoc_W2kzMixWQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_type_adhoc_W2kzMixWQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_type_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @VBO_type_adhoc_W2kzMixWQk8qXQ(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_type_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @VBO_type_adhoc_W2kzMixWQk8qXQ_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_type_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @VBO_type_adhoc_W2kzMixWQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var571 = bitcast [83 x i8]* @gsxtmgl-objects42 to i8*
call i32 (i8*, ...) @printf(i8* %var571)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_type_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @VBO_type_adhoc_W2kzMixWQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_type_adhoc_W2kzMixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VBO*)*}, {i8*, i8*, i32 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VBO*)*,  i32 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects43 = hidden constant [30 x i8] c"VBO_size_adhoc_W2k2NCxWQk8qXQ\00"
@gsxtmgl-objects44 = hidden constant [37 x i8] c"{i8*, i8*, i64 (i8*, i8*, %VBO*)*}**\00"
define dllexport fastcc i64 @VBO_size_adhoc_W2k2NCxWQk8qXQ__572(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone573 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}*
%VBO_size_adhoc_W2k2NCxWQk8qXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%VBO_size_adhoc_W2k2NCxWQk8qXQPtr = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}***, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**** %VBO_size_adhoc_W2k2NCxWQk8qXQPtr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%val574 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val575 = getelementptr %VBO, %VBO* %val574, i64 0, i32 2
%val576 = load i64, i64* %val575
ret i64 %val576
}
@gsxtmgl-objects45 = hidden constant [83 x i8] c"VBO_size_adhoc_W2k2NCxWQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** @VBO_size_adhoc_W2k2NCxWQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone596 = load i8*, i8** %_impzPtr
%zone597 = bitcast i8* %tzone596 to %mzone*

; let assign value to symbol VBO_size_adhoc_W2k2NCxWQk8qXQ
%dat_VBO_size_adhoc_W2k2NCxWQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone597, i64 8)
%VBO_size_adhoc_W2k2NCxWQk8qXQPtr = bitcast i8* %dat_VBO_size_adhoc_W2k2NCxWQk8qXQ to { i8*, i8*, i64 (i8*, i8*, %VBO*)*}***
%tzone577 = load i8*, i8** %_impzPtr
%zone578 = bitcast i8* %tzone577 to %mzone*
call void @llvm_zone_mark(%mzone* %zone578)
; malloc closure structure
%clsptr579 = call i8* @llvm_zone_malloc(%mzone* %zone578, i64 24)
%closure580 = bitcast i8* %clsptr579 to { i8*, i8*, i64 (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr581 = call i8* @llvm_zone_malloc(%mzone* %zone578, i64 8)
%environment582 = bitcast i8* %envptr581 to {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable583 = call %clsvar* @new_address_table()
%var584 = bitcast [30 x i8]* @gsxtmgl-objects43 to i8*
%var585 = bitcast [37 x i8]* @gsxtmgl-objects44 to i8*
%addytable586 = call %clsvar* @add_address_table(%mzone* %zone578, i8* %var584, i32 0, i8* %var585, i32 3, %clsvar* %addytable583)
%address-table587 = bitcast %clsvar* %addytable586 to i8*

; insert table, function and environment into closure struct
%closure.table590 = getelementptr { i8*, i8*, i64 (i8*, i8*, %VBO*)*}, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure580, i32 0, i32 0
store i8* %address-table587, i8** %closure.table590
%closure.env591 = getelementptr { i8*, i8*, i64 (i8*, i8*, %VBO*)*}, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure580, i32 0, i32 1
store i8* %envptr581, i8** %closure.env591
%closure.func592 = getelementptr { i8*, i8*, i64 (i8*, i8*, %VBO*)*}, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure580, i32 0, i32 2
store i64 (i8*, i8*, %VBO*)* @VBO_size_adhoc_W2k2NCxWQk8qXQ__572, i64 (i8*, i8*, %VBO*)** %closure.func592
%closure_size593 = call i64 @llvm_zone_mark_size(%mzone* %zone578)
call void @llvm_zone_ptr_set_size(i8* %clsptr579, i64 %closure_size593)
%wrapper_ptr594 = call i8* @llvm_zone_malloc(%mzone* %zone578, i64 8)
%closure_wrapper595 = bitcast i8* %wrapper_ptr594 to { i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
store { i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure580, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_wrapper595

; let value assignment
%VBO_size_adhoc_W2k2NCxWQk8qXQ = select i1 true, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_wrapper595, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_wrapper595
store { i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %VBO_size_adhoc_W2k2NCxWQk8qXQ, { i8*, i8*, i64 (i8*, i8*, %VBO*)*}*** %VBO_size_adhoc_W2k2NCxWQk8qXQPtr

; add data to environment
; don't need to alloc for env var VBO_size_adhoc_W2k2NCxWQk8qXQ
%tmp_envptr589 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %VBO*)*}***}* %environment582, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*** %VBO_size_adhoc_W2k2NCxWQk8qXQPtr, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**** %tmp_envptr589


%val598 = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*** %VBO_size_adhoc_W2k2NCxWQk8qXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %val598
}


@VBO_size_adhoc_W2k2NCxWQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_size_adhoc_W2k2NCxWQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_size_adhoc_W2k2NCxWQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_size_adhoc_W2k2NCxWQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** @VBO_size_adhoc_W2k2NCxWQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_size_adhoc_W2k2NCxWQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_size_adhoc_W2k2NCxWQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_size_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @VBO_size_adhoc_W2k2NCxWQk8qXQ(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_size_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @VBO_size_adhoc_W2k2NCxWQk8qXQ_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_size_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @VBO_size_adhoc_W2k2NCxWQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var599 = bitcast [83 x i8]* @gsxtmgl-objects45 to i8*
call i32 (i8*, ...) @printf(i8* %var599)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_size_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @VBO_size_adhoc_W2k2NCxWQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_size_adhoc_W2k2NCxWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %VBO*)*}*, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %VBO*)*}, {i8*, i8*, i64 (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %VBO*)*,  i64 (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects46 = hidden constant [30 x i8] c"VBO_data_adhoc_W2k4KixWQk8qXQ\00"
@gsxtmgl-objects47 = hidden constant [37 x i8] c"{i8*, i8*, i8* (i8*, i8*, %VBO*)*}**\00"
define dllexport fastcc i8* @VBO_data_adhoc_W2k4KixWQk8qXQ__600(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone601 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i8* (i8*, i8*, %VBO*)*}***}*
%VBO_data_adhoc_W2k4KixWQk8qXQPtr_ = getelementptr {{i8*, i8*, i8* (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%VBO_data_adhoc_W2k4KixWQk8qXQPtr = load {i8*, i8*, i8* (i8*, i8*, %VBO*)*}***, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**** %VBO_data_adhoc_W2k4KixWQk8qXQPtr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%val602 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val603 = getelementptr %VBO, %VBO* %val602, i64 0, i32 3
%val604 = load i8*, i8** %val603
ret i8* %val604
}
@gsxtmgl-objects48 = hidden constant [83 x i8] c"VBO_data_adhoc_W2k4KixWQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** @VBO_data_adhoc_W2k4KixWQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone624 = load i8*, i8** %_impzPtr
%zone625 = bitcast i8* %tzone624 to %mzone*

; let assign value to symbol VBO_data_adhoc_W2k4KixWQk8qXQ
%dat_VBO_data_adhoc_W2k4KixWQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone625, i64 8)
%VBO_data_adhoc_W2k4KixWQk8qXQPtr = bitcast i8* %dat_VBO_data_adhoc_W2k4KixWQk8qXQ to { i8*, i8*, i8* (i8*, i8*, %VBO*)*}***
%tzone605 = load i8*, i8** %_impzPtr
%zone606 = bitcast i8* %tzone605 to %mzone*
call void @llvm_zone_mark(%mzone* %zone606)
; malloc closure structure
%clsptr607 = call i8* @llvm_zone_malloc(%mzone* %zone606, i64 24)
%closure608 = bitcast i8* %clsptr607 to { i8*, i8*, i8* (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr609 = call i8* @llvm_zone_malloc(%mzone* %zone606, i64 8)
%environment610 = bitcast i8* %envptr609 to {{i8*, i8*, i8* (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable611 = call %clsvar* @new_address_table()
%var612 = bitcast [30 x i8]* @gsxtmgl-objects46 to i8*
%var613 = bitcast [37 x i8]* @gsxtmgl-objects47 to i8*
%addytable614 = call %clsvar* @add_address_table(%mzone* %zone606, i8* %var612, i32 0, i8* %var613, i32 3, %clsvar* %addytable611)
%address-table615 = bitcast %clsvar* %addytable614 to i8*

; insert table, function and environment into closure struct
%closure.table618 = getelementptr { i8*, i8*, i8* (i8*, i8*, %VBO*)*}, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure608, i32 0, i32 0
store i8* %address-table615, i8** %closure.table618
%closure.env619 = getelementptr { i8*, i8*, i8* (i8*, i8*, %VBO*)*}, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure608, i32 0, i32 1
store i8* %envptr609, i8** %closure.env619
%closure.func620 = getelementptr { i8*, i8*, i8* (i8*, i8*, %VBO*)*}, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure608, i32 0, i32 2
store i8* (i8*, i8*, %VBO*)* @VBO_data_adhoc_W2k4KixWQk8qXQ__600, i8* (i8*, i8*, %VBO*)** %closure.func620
%closure_size621 = call i64 @llvm_zone_mark_size(%mzone* %zone606)
call void @llvm_zone_ptr_set_size(i8* %clsptr607, i64 %closure_size621)
%wrapper_ptr622 = call i8* @llvm_zone_malloc(%mzone* %zone606, i64 8)
%closure_wrapper623 = bitcast i8* %wrapper_ptr622 to { i8*, i8*, i8* (i8*, i8*, %VBO*)*}**
store { i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure608, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_wrapper623

; let value assignment
%VBO_data_adhoc_W2k4KixWQk8qXQ = select i1 true, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_wrapper623, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_wrapper623
store { i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %VBO_data_adhoc_W2k4KixWQk8qXQ, { i8*, i8*, i8* (i8*, i8*, %VBO*)*}*** %VBO_data_adhoc_W2k4KixWQk8qXQPtr

; add data to environment
; don't need to alloc for env var VBO_data_adhoc_W2k4KixWQk8qXQ
%tmp_envptr617 = getelementptr {{i8*, i8*, i8* (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, i8* (i8*, i8*, %VBO*)*}***}* %environment610, i32 0, i32 0
store {i8*, i8*, i8* (i8*, i8*, %VBO*)*}*** %VBO_data_adhoc_W2k4KixWQk8qXQPtr, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**** %tmp_envptr617


%val626 = load {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}*** %VBO_data_adhoc_W2k4KixWQk8qXQPtr
ret {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %val626
}


@VBO_data_adhoc_W2k4KixWQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_data_adhoc_W2k4KixWQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_data_adhoc_W2k4KixWQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_data_adhoc_W2k4KixWQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** @VBO_data_adhoc_W2k4KixWQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_data_adhoc_W2k4KixWQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_data_adhoc_W2k4KixWQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_data_adhoc_W2k4KixWQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i8* @VBO_data_adhoc_W2k4KixWQk8qXQ(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_data_adhoc_W2k4KixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %VBO*)*}*, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %VBO*)*,  i8* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i8* %result
}


define dllexport ccc i8* @VBO_data_adhoc_W2k4KixWQk8qXQ_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_data_adhoc_W2k4KixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %VBO*)*}*, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %VBO*)*,  i8* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret i8* %result
}


define dllexport ccc i8*  @VBO_data_adhoc_W2k4KixWQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var627 = bitcast [83 x i8]* @gsxtmgl-objects48 to i8*
call i32 (i8*, ...) @printf(i8* %var627)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_data_adhoc_W2k4KixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %VBO*)*}*, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %VBO*)*,  i8* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%tmpres = bitcast i8* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_data_adhoc_W2k4KixWQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_data_adhoc_W2k4KixWQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i8* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, i8* (i8*, i8*, %VBO*)*}*, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i8* (i8*, i8*, %VBO*)*}, {i8*, i8*, i8* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  i8* (i8*, i8*, %VBO*)*,  i8* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i8* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects49 = hidden constant [11 x i8] c"<VBO: 0x0>\00"
@gsxtmgl-objects50 = hidden constant [39 x i8] c"<VBO: id=%d type=%s nbytes=%d data=%p>\00"
@gsxtmgl-objects51 = hidden constant [5 x i8] c"byte\00"
@gsxtmgl-objects52 = hidden constant [6 x i8] c"short\00"
@gsxtmgl-objects53 = hidden constant [4 x i8] c"int\00"
@gsxtmgl-objects54 = hidden constant [6 x i8] c"float\00"
@gsxtmgl-objects55 = hidden constant [8 x i8] c"unknown\00"
@gsxtmgl-objects56 = hidden constant [28 x i8] c"print_adhoc_W3ZvaWQsVkJPKl0\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsVkJPKl0__628(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone629 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*
%print_adhoc_W3ZvaWQsVkJPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsVkJPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %VBO*)*}***, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %print_adhoc_W3ZvaWQsVkJPKl0Ptr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr

; promote local stack var allocations
%tzone679 = load i8*, i8** %_impzPtr
%zone680 = bitcast i8* %tzone679 to %mzone*
%ifptr630 = alloca i32

%val631 = load %VBO*, %VBO** %vboPtr
%val632 = icmp eq %VBO* %val631, null
br i1 %val632, label %then630, label %else630

then630:
%var633 = bitcast [11 x i8]* @gsxtmgl-objects49 to i8*

%val634 = call i32 (i8*, ...) @printf(i8* %var633)
store i32 %val634, i32* %ifptr630
br label %ifcont630

else630:
%var635 = bitcast [39 x i8]* @gsxtmgl-objects50 to i8*
%val636 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val637 = getelementptr %VBO, %VBO* %val636, i64 0, i32 0
%val638 = load i32, i32* %val637
%tzone641 = load i8*, i8** %_impzPtr
%zone642 = bitcast i8* %tzone641 to %mzone*

; let assign value to symbol type
%typePtr = alloca i32
%val639 = load %VBO*, %VBO** %vboPtr
%res640 = call fastcc i32 @VBO_type_adhoc_W2kzMixWQk8qXQ(%VBO* %val639)

; let value assignment
%type = select i1 true, i32 %res640, i32 %res640
store i32 %type, i32* %typePtr

; promote local stack var allocations
%tzone668 = load i8*, i8** %_impzPtr
%zone669 = bitcast i8* %tzone668 to %mzone*
%ifptr643 = alloca i8*
%ifptr648 = alloca i8*
%ifptr653 = alloca i8*
%ifptr658 = alloca i8*
%val644 = load i32, i32* %typePtr
%val645 = load i32, i32* @GL_BYTE
%cmp646 = icmp eq i32 %val644, %val645
br i1 %cmp646, label %then643, label %else643

then643:
%var647 = bitcast [5 x i8]* @gsxtmgl-objects51 to i8*
store i8* %var647, i8** %ifptr643
br label %ifcont643

else643:
%val649 = load i32, i32* %typePtr
%val650 = load i32, i32* @GL_SHORT
%cmp651 = icmp eq i32 %val649, %val650
br i1 %cmp651, label %then648, label %else648

then648:
%var652 = bitcast [6 x i8]* @gsxtmgl-objects52 to i8*
store i8* %var652, i8** %ifptr648
br label %ifcont648

else648:
%val654 = load i32, i32* %typePtr
%val655 = load i32, i32* @GL_INT
%cmp656 = icmp eq i32 %val654, %val655
br i1 %cmp656, label %then653, label %else653

then653:
%var657 = bitcast [4 x i8]* @gsxtmgl-objects53 to i8*
store i8* %var657, i8** %ifptr653
br label %ifcont653

else653:
%val659 = load i32, i32* %typePtr
%val660 = load i32, i32* @GL_FLOAT
%cmp661 = icmp eq i32 %val659, %val660
br i1 %cmp661, label %then658, label %else658

then658:
%var662 = bitcast [6 x i8]* @gsxtmgl-objects54 to i8*
store i8* %var662, i8** %ifptr658
br label %ifcont658

else658:
%var663 = bitcast [8 x i8]* @gsxtmgl-objects55 to i8*
store i8* %var663, i8** %ifptr658
br label %ifcont658

ifcont658:
%ifres664 = load i8*, i8** %ifptr658

store i8* %ifres664, i8** %ifptr653
br label %ifcont653

ifcont653:
%ifres665 = load i8*, i8** %ifptr653

store i8* %ifres665, i8** %ifptr648
br label %ifcont648

ifcont648:
%ifres666 = load i8*, i8** %ifptr648

store i8* %ifres666, i8** %ifptr643
br label %ifcont643

ifcont643:
%ifres667 = load i8*, i8** %ifptr643

%val670 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val671 = getelementptr %VBO, %VBO* %val670, i64 0, i32 2
%val672 = load i64, i64* %val671
%val673 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val674 = getelementptr %VBO, %VBO* %val673, i64 0, i32 3
%val675 = load i8*, i8** %val674

%val676 = call i32 (i8*, ...) @printf(i8* %var635, i32 %val638, i8* %ifres667, i64 %val672, i8* %val675)
store i32 %val676, i32* %ifptr630
br label %ifcont630

ifcont630:
%ifres677 = load i32, i32* %ifptr630

ret void
}
@gsxtmgl-objects57 = hidden constant [81 x i8] c"print_adhoc_W3ZvaWQsVkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @print_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone700 = load i8*, i8** %_impzPtr
%zone701 = bitcast i8* %tzone700 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsVkJPKl0
%dat_print_adhoc_W3ZvaWQsVkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone701, i64 8)
%print_adhoc_W3ZvaWQsVkJPKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsVkJPKl0 to { i8*, i8*, void (i8*, i8*, %VBO*)*}***
%tzone681 = load i8*, i8** %_impzPtr
%zone682 = bitcast i8* %tzone681 to %mzone*
call void @llvm_zone_mark(%mzone* %zone682)
; malloc closure structure
%clsptr683 = call i8* @llvm_zone_malloc(%mzone* %zone682, i64 24)
%closure684 = bitcast i8* %clsptr683 to { i8*, i8*, void (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr685 = call i8* @llvm_zone_malloc(%mzone* %zone682, i64 8)
%environment686 = bitcast i8* %envptr685 to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable687 = call %clsvar* @new_address_table()
%var688 = bitcast [28 x i8]* @gsxtmgl-objects56 to i8*
%var689 = bitcast [38 x i8]* @gsxtmgl-objects33 to i8*
%addytable690 = call %clsvar* @add_address_table(%mzone* %zone682, i8* %var688, i32 0, i8* %var689, i32 3, %clsvar* %addytable687)
%address-table691 = bitcast %clsvar* %addytable690 to i8*

; insert table, function and environment into closure struct
%closure.table694 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure684, i32 0, i32 0
store i8* %address-table691, i8** %closure.table694
%closure.env695 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure684, i32 0, i32 1
store i8* %envptr685, i8** %closure.env695
%closure.func696 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure684, i32 0, i32 2
store void (i8*, i8*, %VBO*)* @print_adhoc_W3ZvaWQsVkJPKl0__628, void (i8*, i8*, %VBO*)** %closure.func696
%closure_size697 = call i64 @llvm_zone_mark_size(%mzone* %zone682)
call void @llvm_zone_ptr_set_size(i8* %clsptr683, i64 %closure_size697)
%wrapper_ptr698 = call i8* @llvm_zone_malloc(%mzone* %zone682, i64 8)
%closure_wrapper699 = bitcast i8* %wrapper_ptr698 to { i8*, i8*, void (i8*, i8*, %VBO*)*}**
store { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure684, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper699

; let value assignment
%print_adhoc_W3ZvaWQsVkJPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper699, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper699
store { i8*, i8*, void (i8*, i8*, %VBO*)*}** %print_adhoc_W3ZvaWQsVkJPKl0, { i8*, i8*, void (i8*, i8*, %VBO*)*}*** %print_adhoc_W3ZvaWQsVkJPKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsVkJPKl0
%tmp_envptr693 = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %environment686, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %print_adhoc_W3ZvaWQsVkJPKl0Ptr, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %tmp_envptr693


%val702 = load {i8*, i8*, void (i8*, i8*, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %print_adhoc_W3ZvaWQsVkJPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VBO*)*}** %val702
}


@print_adhoc_W3ZvaWQsVkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsVkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsVkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @print_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsVkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsVkJPKl0(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsVkJPKl0_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsVkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var703 = bitcast [81 x i8]* @gsxtmgl-objects57 to i8*
call i32 (i8*, ...) @printf(i8* %var703)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsVkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects58 = hidden constant [35 x i8] c"toString_adhoc_W1N0cmluZyosVkJPKl0\00"
@gsxtmgl-objects59 = hidden constant [42 x i8] c"{i8*, i8*, %String* (i8*, i8*, %VBO*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosVkJPKl0__704(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone705 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %VBO*)*}***}*
%toString_adhoc_W1N0cmluZyosVkJPKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosVkJPKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %VBO*)*}***, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**** %toString_adhoc_W1N0cmluZyosVkJPKl0Ptr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%tzone707 = load i8*, i8** %_impzPtr
%zone708 = bitcast i8* %tzone707 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat706 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat706, i8* %dat706
store i8* %s, i8** %sPtr

; promote local stack var allocations
%tzone761 = load i8*, i8** %_impzPtr
%zone762 = bitcast i8* %tzone761 to %mzone*
%ifptr709 = alloca i32
%val710 = load %VBO*, %VBO** %vboPtr
%val711 = icmp eq %VBO* %val710, null
br i1 %val711, label %then709, label %else709

then709:
%val712 = load i8*, i8** %sPtr
%var713 = bitcast [11 x i8]* @gsxtmgl-objects49 to i8*

%val714 = call i32 (i8*,i8*, ...) @sprintf(i8* %val712, i8* %var713)
store i32 %val714, i32* %ifptr709
br label %ifcont709

else709:
%val715 = load i8*, i8** %sPtr
%var716 = bitcast [39 x i8]* @gsxtmgl-objects50 to i8*
%val717 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val718 = getelementptr %VBO, %VBO* %val717, i64 0, i32 0
%val719 = load i32, i32* %val718
%tzone722 = load i8*, i8** %_impzPtr
%zone723 = bitcast i8* %tzone722 to %mzone*

; let assign value to symbol type
%typePtr = alloca i32
%val720 = load %VBO*, %VBO** %vboPtr
%res721 = call fastcc i32 @VBO_type_adhoc_W2kzMixWQk8qXQ(%VBO* %val720)

; let value assignment
%type = select i1 true, i32 %res721, i32 %res721
store i32 %type, i32* %typePtr

; promote local stack var allocations
%tzone749 = load i8*, i8** %_impzPtr
%zone750 = bitcast i8* %tzone749 to %mzone*
%ifptr724 = alloca i8*
%ifptr729 = alloca i8*
%ifptr734 = alloca i8*
%ifptr739 = alloca i8*
%val725 = load i32, i32* %typePtr
%val726 = load i32, i32* @GL_BYTE
%cmp727 = icmp eq i32 %val725, %val726
br i1 %cmp727, label %then724, label %else724

then724:
%var728 = bitcast [5 x i8]* @gsxtmgl-objects51 to i8*
store i8* %var728, i8** %ifptr724
br label %ifcont724

else724:
%val730 = load i32, i32* %typePtr
%val731 = load i32, i32* @GL_SHORT
%cmp732 = icmp eq i32 %val730, %val731
br i1 %cmp732, label %then729, label %else729

then729:
%var733 = bitcast [6 x i8]* @gsxtmgl-objects52 to i8*
store i8* %var733, i8** %ifptr729
br label %ifcont729

else729:
%val735 = load i32, i32* %typePtr
%val736 = load i32, i32* @GL_INT
%cmp737 = icmp eq i32 %val735, %val736
br i1 %cmp737, label %then734, label %else734

then734:
%var738 = bitcast [4 x i8]* @gsxtmgl-objects53 to i8*
store i8* %var738, i8** %ifptr734
br label %ifcont734

else734:
%val740 = load i32, i32* %typePtr
%val741 = load i32, i32* @GL_FLOAT
%cmp742 = icmp eq i32 %val740, %val741
br i1 %cmp742, label %then739, label %else739

then739:
%var743 = bitcast [6 x i8]* @gsxtmgl-objects54 to i8*
store i8* %var743, i8** %ifptr739
br label %ifcont739

else739:
%var744 = bitcast [8 x i8]* @gsxtmgl-objects55 to i8*
store i8* %var744, i8** %ifptr739
br label %ifcont739

ifcont739:
%ifres745 = load i8*, i8** %ifptr739

store i8* %ifres745, i8** %ifptr734
br label %ifcont734

ifcont734:
%ifres746 = load i8*, i8** %ifptr734

store i8* %ifres746, i8** %ifptr729
br label %ifcont729

ifcont729:
%ifres747 = load i8*, i8** %ifptr729

store i8* %ifres747, i8** %ifptr724
br label %ifcont724

ifcont724:
%ifres748 = load i8*, i8** %ifptr724

%val751 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val752 = getelementptr %VBO, %VBO* %val751, i64 0, i32 2
%val753 = load i64, i64* %val752
%val754 = load %VBO*, %VBO** %vboPtr
; tuple ref
%val755 = getelementptr %VBO, %VBO* %val754, i64 0, i32 3
%val756 = load i8*, i8** %val755

%val757 = call i32 (i8*,i8*, ...) @sprintf(i8* %val715, i8* %var716, i32 %val719, i8* %ifres748, i64 %val753, i8* %val756)
store i32 %val757, i32* %ifptr709
br label %ifcont709

ifcont709:
%ifres758 = load i32, i32* %ifptr709

%val759 = load i8*, i8** %sPtr
%res760 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val759)
ret %String* %res760
}
@gsxtmgl-objects60 = hidden constant [88 x i8] c"toString_adhoc_W1N0cmluZyosVkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** @toString_adhoc_W1N0cmluZyosVkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone782 = load i8*, i8** %_impzPtr
%zone783 = bitcast i8* %tzone782 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosVkJPKl0
%dat_toString_adhoc_W1N0cmluZyosVkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone783, i64 8)
%toString_adhoc_W1N0cmluZyosVkJPKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosVkJPKl0 to { i8*, i8*, %String* (i8*, i8*, %VBO*)*}***
%tzone763 = load i8*, i8** %_impzPtr
%zone764 = bitcast i8* %tzone763 to %mzone*
call void @llvm_zone_mark(%mzone* %zone764)
; malloc closure structure
%clsptr765 = call i8* @llvm_zone_malloc(%mzone* %zone764, i64 24)
%closure766 = bitcast i8* %clsptr765 to { i8*, i8*, %String* (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr767 = call i8* @llvm_zone_malloc(%mzone* %zone764, i64 8)
%environment768 = bitcast i8* %envptr767 to {{i8*, i8*, %String* (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable769 = call %clsvar* @new_address_table()
%var770 = bitcast [35 x i8]* @gsxtmgl-objects58 to i8*
%var771 = bitcast [42 x i8]* @gsxtmgl-objects59 to i8*
%addytable772 = call %clsvar* @add_address_table(%mzone* %zone764, i8* %var770, i32 0, i8* %var771, i32 3, %clsvar* %addytable769)
%address-table773 = bitcast %clsvar* %addytable772 to i8*

; insert table, function and environment into closure struct
%closure.table776 = getelementptr { i8*, i8*, %String* (i8*, i8*, %VBO*)*}, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure766, i32 0, i32 0
store i8* %address-table773, i8** %closure.table776
%closure.env777 = getelementptr { i8*, i8*, %String* (i8*, i8*, %VBO*)*}, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure766, i32 0, i32 1
store i8* %envptr767, i8** %closure.env777
%closure.func778 = getelementptr { i8*, i8*, %String* (i8*, i8*, %VBO*)*}, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure766, i32 0, i32 2
store %String* (i8*, i8*, %VBO*)* @toString_adhoc_W1N0cmluZyosVkJPKl0__704, %String* (i8*, i8*, %VBO*)** %closure.func778
%closure_size779 = call i64 @llvm_zone_mark_size(%mzone* %zone764)
call void @llvm_zone_ptr_set_size(i8* %clsptr765, i64 %closure_size779)
%wrapper_ptr780 = call i8* @llvm_zone_malloc(%mzone* %zone764, i64 8)
%closure_wrapper781 = bitcast i8* %wrapper_ptr780 to { i8*, i8*, %String* (i8*, i8*, %VBO*)*}**
store { i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure766, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_wrapper781

; let value assignment
%toString_adhoc_W1N0cmluZyosVkJPKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_wrapper781, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_wrapper781
store { i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %toString_adhoc_W1N0cmluZyosVkJPKl0, { i8*, i8*, %String* (i8*, i8*, %VBO*)*}*** %toString_adhoc_W1N0cmluZyosVkJPKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosVkJPKl0
%tmp_envptr775 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %VBO*)*}***}* %environment768, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %VBO*)*}*** %toString_adhoc_W1N0cmluZyosVkJPKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**** %tmp_envptr775


%val784 = load {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}*** %toString_adhoc_W1N0cmluZyosVkJPKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %val784
}


@toString_adhoc_W1N0cmluZyosVkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosVkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosVkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** @toString_adhoc_W1N0cmluZyosVkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosVkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosVkJPKl0(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VBO*)*,  %String* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosVkJPKl0_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VBO*)*,  %String* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosVkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var785 = bitcast [88 x i8]* @gsxtmgl-objects60 to i8*
call i32 (i8*, ...) @printf(i8* %var785)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VBO*)*,  %String* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosVkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VBO*)*}, {i8*, i8*, %String* (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VBO*)*,  %String* (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects61 = hidden constant [19 x i8] c"Error creating VBO\00"
@gsxtmgl-objects62 = hidden constant [23 x i8] c"Error setting VBO data\00"
@gsxtmgl-objects63 = hidden constant [9 x i8] c"Created \00"
@gsxtmgl-objects64 = hidden constant [2 x i8] c"
\00"
@gsxtmgl-objects65 = hidden constant [41 x i8] c"VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0\00"
@gsxtmgl-objects66 = hidden constant [45 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**\00"
define dllexport fastcc %VBO* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0__786(i8* %_impz,i8* %_impenv, float* %buf, i64 %buflen) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone787 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***}*
%VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***}* %impenv, i32 0, i32 0
%VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**** %VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%buflenPtr = alloca i64
store i64 %buflen, i64* %buflenPtr


%tzone790 = load i8*, i8** %_impzPtr
%zone791 = bitcast i8* %tzone790 to %mzone*

; let assign value to symbol vbo
%vboPtr = alloca %VBO*
%tzone793 = load i8*, i8** %_impzPtr
%zone794 = bitcast i8* %tzone793 to %mzone*

; let assign value to symbol id
%idPtr = alloca i32*
%dat788 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat788, i32 0, i64 24)
%val789 = bitcast i8* %dat788 to %VBO*

; let value assignment
%vbo = select i1 true, %VBO* %val789, %VBO* %val789
store %VBO* %vbo, %VBO** %vboPtr

%dat792 = alloca i32, align 16

; let value assignment
%id = select i1 true, i32* %dat792, i32* %dat792
store i32* %id, i32** %idPtr

%val795 = load i32*, i32** %idPtr
call fastcc void @glGenBuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val795)
%var797 = bitcast [19 x i8]* @gsxtmgl-objects61 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var797)
%val799 = load %VBO*, %VBO** %vboPtr
%val800 = load i32*, i32** %idPtr
; pointer ref
%val801 = getelementptr i32, i32* %val800, i64 0
%val802 = load i32, i32* %val801
; set tuple
%val803 = getelementptr %VBO, %VBO* %val799, i64 0, i32 0
store i32 %val802, i32* %val803
%val804 = load %VBO*, %VBO** %vboPtr
%val805 = load i32, i32* @GL_FLOAT
; set tuple
%val806 = getelementptr %VBO, %VBO* %val804, i64 0, i32 1
store i32 %val805, i32* %val806
%val807 = load %VBO*, %VBO** %vboPtr
%val808 = load i64, i64* %buflenPtr
%val809 = mul i64 %val808, 4
; set tuple
%val810 = getelementptr %VBO, %VBO* %val807, i64 0, i32 2
store i64 %val809, i64* %val810
%val811 = load %VBO*, %VBO** %vboPtr
%val812 = load float*, float** %bufPtr
%val813 = bitcast float* %val812 to i8*
; set tuple
%val814 = getelementptr %VBO, %VBO* %val811, i64 0, i32 3
store i8* %val813, i8** %val814
%val815 = load i32, i32* @GL_ARRAY_BUFFER
%val816 = load %VBO*, %VBO** %vboPtr
%res817 = call fastcc i32 @VBO_id_adhoc_W2kzMixWQk8qXQ(%VBO* %val816)
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val815, i32 %res817)
%val819 = load i32, i32* @GL_ARRAY_BUFFER
%val820 = load %VBO*, %VBO** %vboPtr
%res821 = call fastcc i64 @VBO_size_adhoc_W2k2NCxWQk8qXQ(%VBO* %val820)
%val822 = load %VBO*, %VBO** %vboPtr
%res823 = call fastcc i8* @VBO_data_adhoc_W2k4KixWQk8qXQ(%VBO* %val822)
%val824 = load i32, i32* @GL_STREAM_DRAW
call fastcc void @glBufferData_adhoc_W3ZvaWQsaTMyLGk2NCxpOCosaTMyXQ(i32 %val819, i64 %res821, i8* %res823, i32 %val824)
%var826 = bitcast [23 x i8]* @gsxtmgl-objects62 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var826)
%var828 = bitcast [9 x i8]* @gsxtmgl-objects63 to i8*

%val829 = call i32 (i8*, ...) @printf(i8* %var828)
%val830 = load %VBO*, %VBO** %vboPtr
call fastcc void @print_adhoc_W3ZvaWQsVkJPKl0(%VBO* %val830)
%var832 = bitcast [2 x i8]* @gsxtmgl-objects64 to i8*

%val833 = call i32 (i8*, ...) @printf(i8* %var832)
%val834 = load %VBO*, %VBO** %vboPtr
ret %VBO* %val834
}
@gsxtmgl-objects67 = hidden constant [94 x i8] c"VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone854 = load i8*, i8** %_impzPtr
%zone855 = bitcast i8* %tzone854 to %mzone*

; let assign value to symbol VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0
%dat_VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0 = call i8* @llvm_zone_malloc(%mzone* %zone855, i64 8)
%VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr = bitcast i8* %dat_VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***
%tzone835 = load i8*, i8** %_impzPtr
%zone836 = bitcast i8* %tzone835 to %mzone*
call void @llvm_zone_mark(%mzone* %zone836)
; malloc closure structure
%clsptr837 = call i8* @llvm_zone_malloc(%mzone* %zone836, i64 24)
%closure838 = bitcast i8* %clsptr837 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*

; malloc environment structure
%envptr839 = call i8* @llvm_zone_malloc(%mzone* %zone836, i64 8)
%environment840 = bitcast i8* %envptr839 to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***}*

; malloc closure address table
%addytable841 = call %clsvar* @new_address_table()
%var842 = bitcast [41 x i8]* @gsxtmgl-objects65 to i8*
%var843 = bitcast [45 x i8]* @gsxtmgl-objects66 to i8*
%addytable844 = call %clsvar* @add_address_table(%mzone* %zone836, i8* %var842, i32 0, i8* %var843, i32 3, %clsvar* %addytable841)
%address-table845 = bitcast %clsvar* %addytable844 to i8*

; insert table, function and environment into closure struct
%closure.table848 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure838, i32 0, i32 0
store i8* %address-table845, i8** %closure.table848
%closure.env849 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure838, i32 0, i32 1
store i8* %envptr839, i8** %closure.env849
%closure.func850 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure838, i32 0, i32 2
store %VBO* (i8*, i8*, float*, i64)* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0__786, %VBO* (i8*, i8*, float*, i64)** %closure.func850
%closure_size851 = call i64 @llvm_zone_mark_size(%mzone* %zone836)
call void @llvm_zone_ptr_set_size(i8* %clsptr837, i64 %closure_size851)
%wrapper_ptr852 = call i8* @llvm_zone_malloc(%mzone* %zone836, i64 8)
%closure_wrapper853 = bitcast i8* %wrapper_ptr852 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure838, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_wrapper853

; let value assignment
%VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0 = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_wrapper853, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_wrapper853
store { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0, { i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*** %VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr

; add data to environment
; don't need to alloc for env var VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0
%tmp_envptr847 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}***}* %environment840, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*** %VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**** %tmp_envptr847


%val856 = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*** %VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0Ptr
ret {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %val856
}


@VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64)*,  %VBO* (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_native(float* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64)*,  %VBO* (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var857 = bitcast [94 x i8]* @gsxtmgl-objects67 to i8*
call i32 (i8*, ...) @printf(i8* %var857)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var858 = bitcast [94 x i8]* @gsxtmgl-objects67 to i8*
call i32 (i8*, ...) @printf(i8* %var858)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64)*,  %VBO* (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64}*
%arg_p_0 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64}, {float*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64)*,  %VBO* (i8*, i8*, float*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects68 = hidden constant [38 x i8] c"VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd\00"
@gsxtmgl-objects69 = hidden constant [43 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**\00"
define dllexport fastcc %VBO* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd__859(i8* %_impz,i8* %_impenv, i32* %buf, i64 %buflen) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone860 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***}*
%VBO_create_adhoc_W1ZCTyosaTMyKixpNjRdPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***}* %impenv, i32 0, i32 0
%VBO_create_adhoc_W1ZCTyosaTMyKixpNjRdPtr = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**** %VBO_create_adhoc_W1ZCTyosaTMyKixpNjRdPtr_

; setup arguments
%bufPtr = alloca i32*
store i32* %buf, i32** %bufPtr
%buflenPtr = alloca i64
store i64 %buflen, i64* %buflenPtr


%tzone863 = load i8*, i8** %_impzPtr
%zone864 = bitcast i8* %tzone863 to %mzone*

; let assign value to symbol vbo
%vboPtr = alloca %VBO*
%tzone866 = load i8*, i8** %_impzPtr
%zone867 = bitcast i8* %tzone866 to %mzone*

; let assign value to symbol id
%idPtr = alloca i32*
%dat861 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat861, i32 0, i64 24)
%val862 = bitcast i8* %dat861 to %VBO*

; let value assignment
%vbo = select i1 true, %VBO* %val862, %VBO* %val862
store %VBO* %vbo, %VBO** %vboPtr

%dat865 = alloca i32, align 16

; let value assignment
%id = select i1 true, i32* %dat865, i32* %dat865
store i32* %id, i32** %idPtr

%val868 = load i32*, i32** %idPtr
call fastcc void @glGenBuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val868)
%var870 = bitcast [19 x i8]* @gsxtmgl-objects61 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var870)
%val872 = load %VBO*, %VBO** %vboPtr
%val873 = load i32*, i32** %idPtr
; pointer ref
%val874 = getelementptr i32, i32* %val873, i64 0
%val875 = load i32, i32* %val874
; set tuple
%val876 = getelementptr %VBO, %VBO* %val872, i64 0, i32 0
store i32 %val875, i32* %val876
%val877 = load %VBO*, %VBO** %vboPtr
%val878 = load i32, i32* @GL_INT
; set tuple
%val879 = getelementptr %VBO, %VBO* %val877, i64 0, i32 1
store i32 %val878, i32* %val879
%val880 = load %VBO*, %VBO** %vboPtr
%val881 = load i64, i64* %buflenPtr
%val882 = mul i64 %val881, 4
; set tuple
%val883 = getelementptr %VBO, %VBO* %val880, i64 0, i32 2
store i64 %val882, i64* %val883
%val884 = load %VBO*, %VBO** %vboPtr
%val885 = load i32*, i32** %bufPtr
%val886 = bitcast i32* %val885 to i8*
; set tuple
%val887 = getelementptr %VBO, %VBO* %val884, i64 0, i32 3
store i8* %val886, i8** %val887
%val888 = load i32, i32* @GL_ARRAY_BUFFER
%val889 = load %VBO*, %VBO** %vboPtr
%res890 = call fastcc i32 @VBO_id_adhoc_W2kzMixWQk8qXQ(%VBO* %val889)
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val888, i32 %res890)
%val892 = load i32, i32* @GL_ARRAY_BUFFER
%val893 = load %VBO*, %VBO** %vboPtr
%res894 = call fastcc i64 @VBO_size_adhoc_W2k2NCxWQk8qXQ(%VBO* %val893)
%val895 = load %VBO*, %VBO** %vboPtr
%res896 = call fastcc i8* @VBO_data_adhoc_W2k4KixWQk8qXQ(%VBO* %val895)
%val897 = load i32, i32* @GL_STREAM_DRAW
call fastcc void @glBufferData_adhoc_W3ZvaWQsaTMyLGk2NCxpOCosaTMyXQ(i32 %val892, i64 %res894, i8* %res896, i32 %val897)
%var899 = bitcast [23 x i8]* @gsxtmgl-objects62 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var899)
%var901 = bitcast [9 x i8]* @gsxtmgl-objects63 to i8*

%val902 = call i32 (i8*, ...) @printf(i8* %var901)
%val903 = load %VBO*, %VBO** %vboPtr
call fastcc void @print_adhoc_W3ZvaWQsVkJPKl0(%VBO* %val903)
%var905 = bitcast [2 x i8]* @gsxtmgl-objects64 to i8*

%val906 = call i32 (i8*, ...) @printf(i8* %var905)
%val907 = load %VBO*, %VBO** %vboPtr
ret %VBO* %val907
}
@gsxtmgl-objects70 = hidden constant [91 x i8] c"VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone927 = load i8*, i8** %_impzPtr
%zone928 = bitcast i8* %tzone927 to %mzone*

; let assign value to symbol VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd
%dat_VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd = call i8* @llvm_zone_malloc(%mzone* %zone928, i64 8)
%VBO_create_adhoc_W1ZCTyosaTMyKixpNjRdPtr = bitcast i8* %dat_VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***
%tzone908 = load i8*, i8** %_impzPtr
%zone909 = bitcast i8* %tzone908 to %mzone*
call void @llvm_zone_mark(%mzone* %zone909)
; malloc closure structure
%clsptr910 = call i8* @llvm_zone_malloc(%mzone* %zone909, i64 24)
%closure911 = bitcast i8* %clsptr910 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*

; malloc environment structure
%envptr912 = call i8* @llvm_zone_malloc(%mzone* %zone909, i64 8)
%environment913 = bitcast i8* %envptr912 to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***}*

; malloc closure address table
%addytable914 = call %clsvar* @new_address_table()
%var915 = bitcast [38 x i8]* @gsxtmgl-objects68 to i8*
%var916 = bitcast [43 x i8]* @gsxtmgl-objects69 to i8*
%addytable917 = call %clsvar* @add_address_table(%mzone* %zone909, i8* %var915, i32 0, i8* %var916, i32 3, %clsvar* %addytable914)
%address-table918 = bitcast %clsvar* %addytable917 to i8*

; insert table, function and environment into closure struct
%closure.table921 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure911, i32 0, i32 0
store i8* %address-table918, i8** %closure.table921
%closure.env922 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure911, i32 0, i32 1
store i8* %envptr912, i8** %closure.env922
%closure.func923 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure911, i32 0, i32 2
store %VBO* (i8*, i8*, i32*, i64)* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd__859, %VBO* (i8*, i8*, i32*, i64)** %closure.func923
%closure_size924 = call i64 @llvm_zone_mark_size(%mzone* %zone909)
call void @llvm_zone_ptr_set_size(i8* %clsptr910, i64 %closure_size924)
%wrapper_ptr925 = call i8* @llvm_zone_malloc(%mzone* %zone909, i64 8)
%closure_wrapper926 = bitcast i8* %wrapper_ptr925 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**
store { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure911, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_wrapper926

; let value assignment
%VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_wrapper926, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_wrapper926
store { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*** %VBO_create_adhoc_W1ZCTyosaTMyKixpNjRdPtr

; add data to environment
; don't need to alloc for env var VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd
%tmp_envptr920 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}***}* %environment913, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*** %VBO_create_adhoc_W1ZCTyosaTMyKixpNjRdPtr, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**** %tmp_envptr920


%val929 = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*** %VBO_create_adhoc_W1ZCTyosaTMyKixpNjRdPtr
ret {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %val929
}


@VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64)*,  %VBO* (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_native(i32* %arg_0,i64 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64)*,  %VBO* (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var930 = bitcast [91 x i8]* @gsxtmgl-objects70 to i8*
call i32 (i8*, ...) @printf(i8* %var930)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var931 = bitcast [91 x i8]* @gsxtmgl-objects70 to i8*
call i32 (i8*, ...) @printf(i8* %var931)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64)*,  %VBO* (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64}*
%arg_p_0 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64}, {i32*, i64}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjRd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64)*,  %VBO* (i8*, i8*, i32*, i64)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects71 = hidden constant [46 x i8] c"VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd\00"
@gsxtmgl-objects72 = hidden constant [50 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}**\00"
define dllexport fastcc %VBO* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd__932(i8* %_impz,i8* %_impenv, float* %buf, i64 %buflen, i32 %usage) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone933 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}***}*
%VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJdPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}***}* %impenv, i32 0, i32 0
%VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJdPtr = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}***, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}**** %VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJdPtr_

; setup arguments
%bufPtr = alloca float*
store float* %buf, float** %bufPtr
%buflenPtr = alloca i64
store i64 %buflen, i64* %buflenPtr
%usagePtr = alloca i32
store i32 %usage, i32* %usagePtr


%tzone936 = load i8*, i8** %_impzPtr
%zone937 = bitcast i8* %tzone936 to %mzone*

; let assign value to symbol vbo
%vboPtr = alloca %VBO*
%tzone939 = load i8*, i8** %_impzPtr
%zone940 = bitcast i8* %tzone939 to %mzone*

; let assign value to symbol id
%idPtr = alloca i32*
%dat934 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat934, i32 0, i64 24)
%val935 = bitcast i8* %dat934 to %VBO*

; let value assignment
%vbo = select i1 true, %VBO* %val935, %VBO* %val935
store %VBO* %vbo, %VBO** %vboPtr

%dat938 = alloca i32, align 16

; let value assignment
%id = select i1 true, i32* %dat938, i32* %dat938
store i32* %id, i32** %idPtr

%val941 = load i32*, i32** %idPtr
call fastcc void @glGenBuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val941)
%var943 = bitcast [19 x i8]* @gsxtmgl-objects61 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var943)
%val945 = load %VBO*, %VBO** %vboPtr
%val946 = load i32*, i32** %idPtr
; pointer ref
%val947 = getelementptr i32, i32* %val946, i64 0
%val948 = load i32, i32* %val947
; set tuple
%val949 = getelementptr %VBO, %VBO* %val945, i64 0, i32 0
store i32 %val948, i32* %val949
%val950 = load %VBO*, %VBO** %vboPtr
%val951 = load i32, i32* @GL_FLOAT
; set tuple
%val952 = getelementptr %VBO, %VBO* %val950, i64 0, i32 1
store i32 %val951, i32* %val952
%val953 = load %VBO*, %VBO** %vboPtr
%val954 = load i64, i64* %buflenPtr
%val955 = mul i64 %val954, 4
; set tuple
%val956 = getelementptr %VBO, %VBO* %val953, i64 0, i32 2
store i64 %val955, i64* %val956
%val957 = load %VBO*, %VBO** %vboPtr
%val958 = load float*, float** %bufPtr
%val959 = bitcast float* %val958 to i8*
; set tuple
%val960 = getelementptr %VBO, %VBO* %val957, i64 0, i32 3
store i8* %val959, i8** %val960
%val961 = load i32, i32* @GL_ARRAY_BUFFER
%val962 = load %VBO*, %VBO** %vboPtr
%res963 = call fastcc i32 @VBO_id_adhoc_W2kzMixWQk8qXQ(%VBO* %val962)
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val961, i32 %res963)
%val965 = load i32, i32* @GL_ARRAY_BUFFER
%val966 = load %VBO*, %VBO** %vboPtr
%res967 = call fastcc i64 @VBO_size_adhoc_W2k2NCxWQk8qXQ(%VBO* %val966)
%val968 = load %VBO*, %VBO** %vboPtr
%res969 = call fastcc i8* @VBO_data_adhoc_W2k4KixWQk8qXQ(%VBO* %val968)
%val970 = load i32, i32* %usagePtr
call fastcc void @glBufferData_adhoc_W3ZvaWQsaTMyLGk2NCxpOCosaTMyXQ(i32 %val965, i64 %res967, i8* %res969, i32 %val970)
%var972 = bitcast [23 x i8]* @gsxtmgl-objects62 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var972)
%var974 = bitcast [9 x i8]* @gsxtmgl-objects63 to i8*

%val975 = call i32 (i8*, ...) @printf(i8* %var974)
%val976 = load %VBO*, %VBO** %vboPtr
call fastcc void @print_adhoc_W3ZvaWQsVkJPKl0(%VBO* %val976)
%var978 = bitcast [2 x i8]* @gsxtmgl-objects64 to i8*

%val979 = call i32 (i8*, ...) @printf(i8* %var978)
%val980 = load %VBO*, %VBO** %vboPtr
ret %VBO* %val980
}
@gsxtmgl-objects73 = hidden constant [99 x i8] c"VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}** @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1000 = load i8*, i8** %_impzPtr
%zone1001 = bitcast i8* %tzone1000 to %mzone*

; let assign value to symbol VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd
%dat_VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone1001, i64 8)
%VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJdPtr = bitcast i8* %dat_VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd to { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}***
%tzone981 = load i8*, i8** %_impzPtr
%zone982 = bitcast i8* %tzone981 to %mzone*
call void @llvm_zone_mark(%mzone* %zone982)
; malloc closure structure
%clsptr983 = call i8* @llvm_zone_malloc(%mzone* %zone982, i64 24)
%closure984 = bitcast i8* %clsptr983 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}*

; malloc environment structure
%envptr985 = call i8* @llvm_zone_malloc(%mzone* %zone982, i64 8)
%environment986 = bitcast i8* %envptr985 to {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}***}*

; malloc closure address table
%addytable987 = call %clsvar* @new_address_table()
%var988 = bitcast [46 x i8]* @gsxtmgl-objects71 to i8*
%var989 = bitcast [50 x i8]* @gsxtmgl-objects72 to i8*
%addytable990 = call %clsvar* @add_address_table(%mzone* %zone982, i8* %var988, i32 0, i8* %var989, i32 3, %clsvar* %addytable987)
%address-table991 = bitcast %clsvar* %addytable990 to i8*

; insert table, function and environment into closure struct
%closure.table994 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}* %closure984, i32 0, i32 0
store i8* %address-table991, i8** %closure.table994
%closure.env995 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}* %closure984, i32 0, i32 1
store i8* %envptr985, i8** %closure.env995
%closure.func996 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}* %closure984, i32 0, i32 2
store %VBO* (i8*, i8*, float*, i64, i32)* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd__932, %VBO* (i8*, i8*, float*, i64, i32)** %closure.func996
%closure_size997 = call i64 @llvm_zone_mark_size(%mzone* %zone982)
call void @llvm_zone_ptr_set_size(i8* %clsptr983, i64 %closure_size997)
%wrapper_ptr998 = call i8* @llvm_zone_malloc(%mzone* %zone982, i64 8)
%closure_wrapper999 = bitcast i8* %wrapper_ptr998 to { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}**
store { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}* %closure984, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}** %closure_wrapper999

; let value assignment
%VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}** %closure_wrapper999, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}** %closure_wrapper999
store { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}** %VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd, { i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}*** %VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJdPtr

; add data to environment
; don't need to alloc for env var VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd
%tmp_envptr993 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}***}* %environment986, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}*** %VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJdPtr, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}**** %tmp_envptr993


%val1002 = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}**, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}*** %VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJdPtr
ret {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}** %val1002
}


@VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}** @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd(float* %arg_0,i64 %arg_1,i32 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i32)*,  %VBO* (i8*, i8*, float*, i64, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i32 %arg_2)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_native(float* %arg_0,i64 %arg_1,i32 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i32)*,  %VBO* (i8*, i8*, float*, i64, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i32 %arg_2)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1003 = bitcast [99 x i8]* @gsxtmgl-objects73 to i8*
call i32 (i8*, ...) @printf(i8* %var1003)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to float*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1004 = bitcast [99 x i8]* @gsxtmgl-objects73 to i8*
call i32 (i8*, ...) @printf(i8* %var1004)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1005 = bitcast [99 x i8]* @gsxtmgl-objects73 to i8*
call i32 (i8*, ...) @printf(i8* %var1005)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i32)*,  %VBO* (i8*, i8*, float*, i64, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i32 %arg_2)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {float*, i64, i32}*
%arg_p_0 = getelementptr {float*, i64, i32}, {float*, i64, i32}* %fstruct, i32 0, i32 0
%arg_0 = load float*, float** %arg_p_0
%arg_p_1 = getelementptr {float*, i64, i32}, {float*, i64, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {float*, i64, i32}, {float*, i64, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}*, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, float*, i64, i32)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, float*, i64, i32)*,  %VBO* (i8*, i8*, float*, i64, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, float* %arg_0, i64 %arg_1, i32 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects74 = hidden constant [44 x i8] c"VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ\00"
@gsxtmgl-objects75 = hidden constant [48 x i8] c"{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}**\00"
define dllexport fastcc %VBO* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ__1006(i8* %_impz,i8* %_impenv, i32* %buf, i64 %buflen, i32 %usage) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1007 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}***}*
%VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQPtr_ = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}***}* %impenv, i32 0, i32 0
%VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQPtr = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}***, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}**** %VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQPtr_

; setup arguments
%bufPtr = alloca i32*
store i32* %buf, i32** %bufPtr
%buflenPtr = alloca i64
store i64 %buflen, i64* %buflenPtr
%usagePtr = alloca i32
store i32 %usage, i32* %usagePtr


%tzone1010 = load i8*, i8** %_impzPtr
%zone1011 = bitcast i8* %tzone1010 to %mzone*

; let assign value to symbol vbo
%vboPtr = alloca %VBO*
%tzone1013 = load i8*, i8** %_impzPtr
%zone1014 = bitcast i8* %tzone1013 to %mzone*

; let assign value to symbol id
%idPtr = alloca i32*
%dat1008 = call i8* @malloc(i64 24)
call i8* @memset(i8* %dat1008, i32 0, i64 24)
%val1009 = bitcast i8* %dat1008 to %VBO*

; let value assignment
%vbo = select i1 true, %VBO* %val1009, %VBO* %val1009
store %VBO* %vbo, %VBO** %vboPtr

%dat1012 = alloca i32, align 16

; let value assignment
%id = select i1 true, i32* %dat1012, i32* %dat1012
store i32* %id, i32** %idPtr

%val1015 = load i32*, i32** %idPtr
call fastcc void @glGenBuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val1015)
%var1017 = bitcast [19 x i8]* @gsxtmgl-objects61 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1017)
%val1019 = load %VBO*, %VBO** %vboPtr
%val1020 = load i32*, i32** %idPtr
; pointer ref
%val1021 = getelementptr i32, i32* %val1020, i64 0
%val1022 = load i32, i32* %val1021
; set tuple
%val1023 = getelementptr %VBO, %VBO* %val1019, i64 0, i32 0
store i32 %val1022, i32* %val1023
%val1024 = load %VBO*, %VBO** %vboPtr
%val1025 = load i32, i32* @GL_INT
; set tuple
%val1026 = getelementptr %VBO, %VBO* %val1024, i64 0, i32 1
store i32 %val1025, i32* %val1026
%val1027 = load %VBO*, %VBO** %vboPtr
%val1028 = load i64, i64* %buflenPtr
%val1029 = mul i64 %val1028, 4
; set tuple
%val1030 = getelementptr %VBO, %VBO* %val1027, i64 0, i32 2
store i64 %val1029, i64* %val1030
%val1031 = load %VBO*, %VBO** %vboPtr
%val1032 = load i32*, i32** %bufPtr
%val1033 = bitcast i32* %val1032 to i8*
; set tuple
%val1034 = getelementptr %VBO, %VBO* %val1031, i64 0, i32 3
store i8* %val1033, i8** %val1034
%val1035 = load i32, i32* @GL_ARRAY_BUFFER
%val1036 = load %VBO*, %VBO** %vboPtr
%res1037 = call fastcc i32 @VBO_id_adhoc_W2kzMixWQk8qXQ(%VBO* %val1036)
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val1035, i32 %res1037)
%val1039 = load i32, i32* @GL_ARRAY_BUFFER
%val1040 = load %VBO*, %VBO** %vboPtr
%res1041 = call fastcc i64 @VBO_size_adhoc_W2k2NCxWQk8qXQ(%VBO* %val1040)
%val1042 = load %VBO*, %VBO** %vboPtr
%res1043 = call fastcc i8* @VBO_data_adhoc_W2k4KixWQk8qXQ(%VBO* %val1042)
%val1044 = load i32, i32* %usagePtr
call fastcc void @glBufferData_adhoc_W3ZvaWQsaTMyLGk2NCxpOCosaTMyXQ(i32 %val1039, i64 %res1041, i8* %res1043, i32 %val1044)
%var1046 = bitcast [23 x i8]* @gsxtmgl-objects62 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1046)
%var1048 = bitcast [9 x i8]* @gsxtmgl-objects63 to i8*

%val1049 = call i32 (i8*, ...) @printf(i8* %var1048)
%val1050 = load %VBO*, %VBO** %vboPtr
call fastcc void @print_adhoc_W3ZvaWQsVkJPKl0(%VBO* %val1050)
%var1052 = bitcast [2 x i8]* @gsxtmgl-objects64 to i8*

%val1053 = call i32 (i8*, ...) @printf(i8* %var1052)
%val1054 = load %VBO*, %VBO** %vboPtr
ret %VBO* %val1054
}
@gsxtmgl-objects76 = hidden constant [97 x i8] c"VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}** @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1074 = load i8*, i8** %_impzPtr
%zone1075 = bitcast i8* %tzone1074 to %mzone*

; let assign value to symbol VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ
%dat_VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone1075, i64 8)
%VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQPtr = bitcast i8* %dat_VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}***
%tzone1055 = load i8*, i8** %_impzPtr
%zone1056 = bitcast i8* %tzone1055 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1056)
; malloc closure structure
%clsptr1057 = call i8* @llvm_zone_malloc(%mzone* %zone1056, i64 24)
%closure1058 = bitcast i8* %clsptr1057 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}*

; malloc environment structure
%envptr1059 = call i8* @llvm_zone_malloc(%mzone* %zone1056, i64 8)
%environment1060 = bitcast i8* %envptr1059 to {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}***}*

; malloc closure address table
%addytable1061 = call %clsvar* @new_address_table()
%var1062 = bitcast [44 x i8]* @gsxtmgl-objects74 to i8*
%var1063 = bitcast [48 x i8]* @gsxtmgl-objects75 to i8*
%addytable1064 = call %clsvar* @add_address_table(%mzone* %zone1056, i8* %var1062, i32 0, i8* %var1063, i32 3, %clsvar* %addytable1061)
%address-table1065 = bitcast %clsvar* %addytable1064 to i8*

; insert table, function and environment into closure struct
%closure.table1068 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}* %closure1058, i32 0, i32 0
store i8* %address-table1065, i8** %closure.table1068
%closure.env1069 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}* %closure1058, i32 0, i32 1
store i8* %envptr1059, i8** %closure.env1069
%closure.func1070 = getelementptr { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}* %closure1058, i32 0, i32 2
store %VBO* (i8*, i8*, i32*, i64, i32)* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ__1006, %VBO* (i8*, i8*, i32*, i64, i32)** %closure.func1070
%closure_size1071 = call i64 @llvm_zone_mark_size(%mzone* %zone1056)
call void @llvm_zone_ptr_set_size(i8* %clsptr1057, i64 %closure_size1071)
%wrapper_ptr1072 = call i8* @llvm_zone_malloc(%mzone* %zone1056, i64 8)
%closure_wrapper1073 = bitcast i8* %wrapper_ptr1072 to { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}**
store { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}* %closure1058, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}** %closure_wrapper1073

; let value assignment
%VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ = select i1 true, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}** %closure_wrapper1073, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}** %closure_wrapper1073
store { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}** %VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ, { i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}*** %VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQPtr

; add data to environment
; don't need to alloc for env var VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ
%tmp_envptr1067 = getelementptr {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}***}, {{i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}***}* %environment1060, i32 0, i32 0
store {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}*** %VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQPtr, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}**** %tmp_envptr1067


%val1076 = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}**, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}*** %VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQPtr
ret {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}** %val1076
}


@VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}** @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VBO* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ(i32* %arg_0,i64 %arg_1,i32 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i32)*,  %VBO* (i8*, i8*, i32*, i64, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i32 %arg_2)
ret %VBO* %result
}


define dllexport ccc %VBO* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_native(i32* %arg_0,i64 %arg_1,i32 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i32)*,  %VBO* (i8*, i8*, i32*, i64, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i32 %arg_2)
ret %VBO* %result
}


define dllexport ccc i8*  @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1077 = bitcast [97 x i8]* @gsxtmgl-objects76 to i8*
call i32 (i8*, ...) @printf(i8* %var1077)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to i32*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1078 = bitcast [97 x i8]* @gsxtmgl-objects76 to i8*
call i32 (i8*, ...) @printf(i8* %var1078)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i64  @i64value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1079 = bitcast [97 x i8]* @gsxtmgl-objects76 to i8*
call i32 (i8*, ...) @printf(i8* %var1079)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i32)*,  %VBO* (i8*, i8*, i32*, i64, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i32 %arg_2)
%tmpres = bitcast %VBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32*, i64, i32}*
%arg_p_0 = getelementptr {i32*, i64, i32}, {i32*, i64, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32*, i32** %arg_p_0
%arg_p_1 = getelementptr {i32*, i64, i32}, {i32*, i64, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i64, i64* %arg_p_1
%arg_p_2 = getelementptr {i32*, i64, i32}, {i32*, i64, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_create_adhoc_W1ZCTyosaTMyKixpNjQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}**
%closure = load {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}*, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}, {i8*, i8*, %VBO* (i8*, i8*, i32*, i64, i32)*}* %closure, i32 0, i32 1
%ff = load  %VBO* (i8*, i8*, i32*, i64, i32)*,  %VBO* (i8*, i8*, i32*, i64, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VBO* %ff(i8* %_impz, i8* %ee, i32* %arg_0, i64 %arg_1, i32 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects77 = hidden constant [18 x i8] c"Error binding VBO\00"
@gsxtmgl-objects78 = hidden constant [27 x i8] c"Error updating VBO subdata\00"
@gsxtmgl-objects79 = hidden constant [38 x i8] c"VBO_update_data_adhoc_W3ZvaWQsVkJPKl0\00"
define dllexport fastcc void @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0__1080(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1081 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*
%VBO_update_data_adhoc_W3ZvaWQsVkJPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%VBO_update_data_adhoc_W3ZvaWQsVkJPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %VBO*)*}***, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %VBO_update_data_adhoc_W3ZvaWQsVkJPKl0Ptr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%val1082 = load i32, i32* @GL_ARRAY_BUFFER
%val1083 = load %VBO*, %VBO** %vboPtr
%res1084 = call fastcc i32 @VBO_id_adhoc_W2kzMixWQk8qXQ(%VBO* %val1083)
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val1082, i32 %res1084)
%var1086 = bitcast [18 x i8]* @gsxtmgl-objects77 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1086)
%val1088 = load i32, i32* @GL_ARRAY_BUFFER
%val1089 = load %VBO*, %VBO** %vboPtr
%res1090 = call fastcc i64 @VBO_size_adhoc_W2k2NCxWQk8qXQ(%VBO* %val1089)
%val1091 = load %VBO*, %VBO** %vboPtr
%res1092 = call fastcc i8* @VBO_data_adhoc_W2k4KixWQk8qXQ(%VBO* %val1091)
call fastcc void @glBufferSubData_adhoc_W3ZvaWQsaTMyLGk2NCxpNjQsaTgqXQ(i32 %val1088, i64 0, i64 %res1090, i8* %res1092)
%var1094 = bitcast [27 x i8]* @gsxtmgl-objects78 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1094)
%val1096 = load i32, i32* @GL_ARRAY_BUFFER
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val1096, i32 0)
ret void
}
@gsxtmgl-objects80 = hidden constant [91 x i8] c"VBO_update_data_adhoc_W3ZvaWQsVkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1117 = load i8*, i8** %_impzPtr
%zone1118 = bitcast i8* %tzone1117 to %mzone*

; let assign value to symbol VBO_update_data_adhoc_W3ZvaWQsVkJPKl0
%dat_VBO_update_data_adhoc_W3ZvaWQsVkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1118, i64 8)
%VBO_update_data_adhoc_W3ZvaWQsVkJPKl0Ptr = bitcast i8* %dat_VBO_update_data_adhoc_W3ZvaWQsVkJPKl0 to { i8*, i8*, void (i8*, i8*, %VBO*)*}***
%tzone1098 = load i8*, i8** %_impzPtr
%zone1099 = bitcast i8* %tzone1098 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1099)
; malloc closure structure
%clsptr1100 = call i8* @llvm_zone_malloc(%mzone* %zone1099, i64 24)
%closure1101 = bitcast i8* %clsptr1100 to { i8*, i8*, void (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr1102 = call i8* @llvm_zone_malloc(%mzone* %zone1099, i64 8)
%environment1103 = bitcast i8* %envptr1102 to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable1104 = call %clsvar* @new_address_table()
%var1105 = bitcast [38 x i8]* @gsxtmgl-objects79 to i8*
%var1106 = bitcast [38 x i8]* @gsxtmgl-objects33 to i8*
%addytable1107 = call %clsvar* @add_address_table(%mzone* %zone1099, i8* %var1105, i32 0, i8* %var1106, i32 3, %clsvar* %addytable1104)
%address-table1108 = bitcast %clsvar* %addytable1107 to i8*

; insert table, function and environment into closure struct
%closure.table1111 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure1101, i32 0, i32 0
store i8* %address-table1108, i8** %closure.table1111
%closure.env1112 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure1101, i32 0, i32 1
store i8* %envptr1102, i8** %closure.env1112
%closure.func1113 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure1101, i32 0, i32 2
store void (i8*, i8*, %VBO*)* @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0__1080, void (i8*, i8*, %VBO*)** %closure.func1113
%closure_size1114 = call i64 @llvm_zone_mark_size(%mzone* %zone1099)
call void @llvm_zone_ptr_set_size(i8* %clsptr1100, i64 %closure_size1114)
%wrapper_ptr1115 = call i8* @llvm_zone_malloc(%mzone* %zone1099, i64 8)
%closure_wrapper1116 = bitcast i8* %wrapper_ptr1115 to { i8*, i8*, void (i8*, i8*, %VBO*)*}**
store { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure1101, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper1116

; let value assignment
%VBO_update_data_adhoc_W3ZvaWQsVkJPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper1116, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper1116
store { i8*, i8*, void (i8*, i8*, %VBO*)*}** %VBO_update_data_adhoc_W3ZvaWQsVkJPKl0, { i8*, i8*, void (i8*, i8*, %VBO*)*}*** %VBO_update_data_adhoc_W3ZvaWQsVkJPKl0Ptr

; add data to environment
; don't need to alloc for env var VBO_update_data_adhoc_W3ZvaWQsVkJPKl0
%tmp_envptr1110 = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %environment1103, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %VBO_update_data_adhoc_W3ZvaWQsVkJPKl0Ptr, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %tmp_envptr1110


%val1119 = load {i8*, i8*, void (i8*, i8*, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %VBO_update_data_adhoc_W3ZvaWQsVkJPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VBO*)*}** %val1119
}


@VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc void @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc i8*  @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1120 = bitcast [91 x i8]* @gsxtmgl-objects80 to i8*
call i32 (i8*, ...) @printf(i8* %var1120)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_update_data_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects81 = hidden constant [19 x i8] c"Error deleting VBO\00"
@gsxtmgl-objects82 = hidden constant [33 x i8] c"VBO_delete_adhoc_W3ZvaWQsVkJPKl0\00"
define dllexport fastcc void @VBO_delete_adhoc_W3ZvaWQsVkJPKl0__1121(i8* %_impz,i8* %_impenv, %VBO* %vbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1122 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*
%VBO_delete_adhoc_W3ZvaWQsVkJPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %impenv, i32 0, i32 0
%VBO_delete_adhoc_W3ZvaWQsVkJPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %VBO*)*}***, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %VBO_delete_adhoc_W3ZvaWQsVkJPKl0Ptr_

; setup arguments
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr


%tzone1124 = load i8*, i8** %_impzPtr
%zone1125 = bitcast i8* %tzone1124 to %mzone*

; let assign value to symbol id
%idPtr = alloca i32*
%dat1123 = alloca i32, align 16

; let value assignment
%id = select i1 true, i32* %dat1123, i32* %dat1123
store i32* %id, i32** %idPtr

%val1126 = load i32*, i32** %idPtr
%val1127 = load %VBO*, %VBO** %vboPtr
%res1128 = call fastcc i32 @VBO_id_adhoc_W2kzMixWQk8qXQ(%VBO* %val1127)
; set pointer
%val1129 = getelementptr i32, i32* %val1126, i64 0
store i32 %res1128, i32* %val1129
%val1130 = load i32*, i32** %idPtr
call fastcc void @glDeleteBuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val1130)
%var1132 = bitcast [19 x i8]* @gsxtmgl-objects81 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1132)
%val1134 = load %VBO*, %VBO** %vboPtr
%val1135 = bitcast %VBO* %val1134 to i8*
call ccc void @free(i8* %val1135)
ret void
}
@gsxtmgl-objects83 = hidden constant [86 x i8] c"VBO_delete_adhoc_W3ZvaWQsVkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1156 = load i8*, i8** %_impzPtr
%zone1157 = bitcast i8* %tzone1156 to %mzone*

; let assign value to symbol VBO_delete_adhoc_W3ZvaWQsVkJPKl0
%dat_VBO_delete_adhoc_W3ZvaWQsVkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1157, i64 8)
%VBO_delete_adhoc_W3ZvaWQsVkJPKl0Ptr = bitcast i8* %dat_VBO_delete_adhoc_W3ZvaWQsVkJPKl0 to { i8*, i8*, void (i8*, i8*, %VBO*)*}***
%tzone1137 = load i8*, i8** %_impzPtr
%zone1138 = bitcast i8* %tzone1137 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1138)
; malloc closure structure
%clsptr1139 = call i8* @llvm_zone_malloc(%mzone* %zone1138, i64 24)
%closure1140 = bitcast i8* %clsptr1139 to { i8*, i8*, void (i8*, i8*, %VBO*)*}*

; malloc environment structure
%envptr1141 = call i8* @llvm_zone_malloc(%mzone* %zone1138, i64 8)
%environment1142 = bitcast i8* %envptr1141 to {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}*

; malloc closure address table
%addytable1143 = call %clsvar* @new_address_table()
%var1144 = bitcast [33 x i8]* @gsxtmgl-objects82 to i8*
%var1145 = bitcast [38 x i8]* @gsxtmgl-objects33 to i8*
%addytable1146 = call %clsvar* @add_address_table(%mzone* %zone1138, i8* %var1144, i32 0, i8* %var1145, i32 3, %clsvar* %addytable1143)
%address-table1147 = bitcast %clsvar* %addytable1146 to i8*

; insert table, function and environment into closure struct
%closure.table1150 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure1140, i32 0, i32 0
store i8* %address-table1147, i8** %closure.table1150
%closure.env1151 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure1140, i32 0, i32 1
store i8* %envptr1141, i8** %closure.env1151
%closure.func1152 = getelementptr { i8*, i8*, void (i8*, i8*, %VBO*)*}, { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure1140, i32 0, i32 2
store void (i8*, i8*, %VBO*)* @VBO_delete_adhoc_W3ZvaWQsVkJPKl0__1121, void (i8*, i8*, %VBO*)** %closure.func1152
%closure_size1153 = call i64 @llvm_zone_mark_size(%mzone* %zone1138)
call void @llvm_zone_ptr_set_size(i8* %clsptr1139, i64 %closure_size1153)
%wrapper_ptr1154 = call i8* @llvm_zone_malloc(%mzone* %zone1138, i64 8)
%closure_wrapper1155 = bitcast i8* %wrapper_ptr1154 to { i8*, i8*, void (i8*, i8*, %VBO*)*}**
store { i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure1140, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper1155

; let value assignment
%VBO_delete_adhoc_W3ZvaWQsVkJPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper1155, { i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_wrapper1155
store { i8*, i8*, void (i8*, i8*, %VBO*)*}** %VBO_delete_adhoc_W3ZvaWQsVkJPKl0, { i8*, i8*, void (i8*, i8*, %VBO*)*}*** %VBO_delete_adhoc_W3ZvaWQsVkJPKl0Ptr

; add data to environment
; don't need to alloc for env var VBO_delete_adhoc_W3ZvaWQsVkJPKl0
%tmp_envptr1149 = getelementptr {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VBO*)*}***}* %environment1142, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %VBO_delete_adhoc_W3ZvaWQsVkJPKl0Ptr, {i8*, i8*, void (i8*, i8*, %VBO*)*}**** %tmp_envptr1149


%val1158 = load {i8*, i8*, void (i8*, i8*, %VBO*)*}**, {i8*, i8*, void (i8*, i8*, %VBO*)*}*** %VBO_delete_adhoc_W3ZvaWQsVkJPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VBO*)*}** %val1158
}


@VBO_delete_adhoc_W3ZvaWQsVkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@VBO_delete_adhoc_W3ZvaWQsVkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VBO*)*}** @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @VBO_delete_adhoc_W3ZvaWQsVkJPKl0(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc void @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_native(%VBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
ret void
}


define dllexport ccc i8*  @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1159 = bitcast [86 x i8]* @gsxtmgl-objects83 to i8*
call i32 (i8*, ...) @printf(i8* %var1159)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VBO*}*
%arg_p_0 = getelementptr {%VBO*}, {%VBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VBO*, %VBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VBO_delete_adhoc_W3ZvaWQsVkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VBO*)*}*, {i8*, i8*, void (i8*, i8*, %VBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VBO*)*}, {i8*, i8*, void (i8*, i8*, %VBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VBO*)*,  void (i8*, i8*, %VBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%VAO = type {i32}
@gsxtmgl-objects84 = hidden constant [25 x i8] c"VAO_adhoc_W1ZBTyosaTMyXQ\00"
@gsxtmgl-objects85 = hidden constant [37 x i8] c"{i8*, i8*, %VAO* (i8*, i8*, i32)*}**\00"
define dllexport fastcc %VAO* @VAO_adhoc_W1ZBTyosaTMyXQ__1160(i8* %_impz,i8* %_impenv, i32 %arg_0) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1161 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}*
%VAO_adhoc_W1ZBTyosaTMyXQPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%VAO_adhoc_W1ZBTyosaTMyXQPtr = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}***, {i8*, i8*, %VAO* (i8*, i8*, i32)*}**** %VAO_adhoc_W1ZBTyosaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr


%tzone1166 = load i8*, i8** %_impzPtr
%zone1167 = bitcast i8* %tzone1166 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VAO*
%tzone1162 = load i8*, i8** %_impzPtr
%zone1163 = bitcast i8* %tzone1162 to %mzone*
%dat1164 = call i8* @llvm_zone_malloc(%mzone* %zone1163, i64 4)
call i8* @memset(i8* %dat1164, i32 0, i64 4)
%val1165 = bitcast i8* %dat1164 to %VAO*

; let value assignment
%obj = select i1 true, %VAO* %val1165, %VAO* %val1165
store %VAO* %obj, %VAO** %objPtr

%val1168 = load %VAO*, %VAO** %objPtr
%val1169 = load i32, i32* %arg_0Ptr
; set tuple
%val1170 = getelementptr %VAO, %VAO* %val1168, i64 0, i32 0
store i32 %val1169, i32* %val1170
%val1171 = load %VAO*, %VAO** %objPtr
ret %VAO* %val1171
}
@gsxtmgl-objects86 = hidden constant [78 x i8] c"VAO_adhoc_W1ZBTyosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*, i32)*}** @VAO_adhoc_W1ZBTyosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1191 = load i8*, i8** %_impzPtr
%zone1192 = bitcast i8* %tzone1191 to %mzone*

; let assign value to symbol VAO_adhoc_W1ZBTyosaTMyXQ
%dat_VAO_adhoc_W1ZBTyosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone1192, i64 8)
%VAO_adhoc_W1ZBTyosaTMyXQPtr = bitcast i8* %dat_VAO_adhoc_W1ZBTyosaTMyXQ to { i8*, i8*, %VAO* (i8*, i8*, i32)*}***
%tzone1172 = load i8*, i8** %_impzPtr
%zone1173 = bitcast i8* %tzone1172 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1173)
; malloc closure structure
%clsptr1174 = call i8* @llvm_zone_malloc(%mzone* %zone1173, i64 24)
%closure1175 = bitcast i8* %clsptr1174 to { i8*, i8*, %VAO* (i8*, i8*, i32)*}*

; malloc environment structure
%envptr1176 = call i8* @llvm_zone_malloc(%mzone* %zone1173, i64 8)
%environment1177 = bitcast i8* %envptr1176 to {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable1178 = call %clsvar* @new_address_table()
%var1179 = bitcast [25 x i8]* @gsxtmgl-objects84 to i8*
%var1180 = bitcast [37 x i8]* @gsxtmgl-objects85 to i8*
%addytable1181 = call %clsvar* @add_address_table(%mzone* %zone1173, i8* %var1179, i32 0, i8* %var1180, i32 3, %clsvar* %addytable1178)
%address-table1182 = bitcast %clsvar* %addytable1181 to i8*

; insert table, function and environment into closure struct
%closure.table1185 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32)*}, { i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure1175, i32 0, i32 0
store i8* %address-table1182, i8** %closure.table1185
%closure.env1186 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32)*}, { i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure1175, i32 0, i32 1
store i8* %envptr1176, i8** %closure.env1186
%closure.func1187 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32)*}, { i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure1175, i32 0, i32 2
store %VAO* (i8*, i8*, i32)* @VAO_adhoc_W1ZBTyosaTMyXQ__1160, %VAO* (i8*, i8*, i32)** %closure.func1187
%closure_size1188 = call i64 @llvm_zone_mark_size(%mzone* %zone1173)
call void @llvm_zone_ptr_set_size(i8* %clsptr1174, i64 %closure_size1188)
%wrapper_ptr1189 = call i8* @llvm_zone_malloc(%mzone* %zone1173, i64 8)
%closure_wrapper1190 = bitcast i8* %wrapper_ptr1189 to { i8*, i8*, %VAO* (i8*, i8*, i32)*}**
store { i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure1175, { i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_wrapper1190

; let value assignment
%VAO_adhoc_W1ZBTyosaTMyXQ = select i1 true, { i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_wrapper1190, { i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_wrapper1190
store { i8*, i8*, %VAO* (i8*, i8*, i32)*}** %VAO_adhoc_W1ZBTyosaTMyXQ, { i8*, i8*, %VAO* (i8*, i8*, i32)*}*** %VAO_adhoc_W1ZBTyosaTMyXQPtr

; add data to environment
; don't need to alloc for env var VAO_adhoc_W1ZBTyosaTMyXQ
%tmp_envptr1184 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}* %environment1177, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*, i32)*}*** %VAO_adhoc_W1ZBTyosaTMyXQPtr, {i8*, i8*, %VAO* (i8*, i8*, i32)*}**** %tmp_envptr1184


%val1193 = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}**, {i8*, i8*, %VAO* (i8*, i8*, i32)*}*** %VAO_adhoc_W1ZBTyosaTMyXQPtr
ret {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %val1193
}


@VAO_adhoc_W1ZBTyosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_adhoc_W1ZBTyosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_adhoc_W1ZBTyosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*, i32)*}** @VAO_adhoc_W1ZBTyosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_adhoc_W1ZBTyosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @VAO_adhoc_W1ZBTyosaTMyXQ(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}*, {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32)*,  %VAO* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %VAO* %result
}


define dllexport ccc %VAO* @VAO_adhoc_W1ZBTyosaTMyXQ_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}*, {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32)*,  %VAO* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %VAO* %result
}


define dllexport ccc i8*  @VAO_adhoc_W1ZBTyosaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1194 = bitcast [78 x i8]* @gsxtmgl-objects86 to i8*
call i32 (i8*, ...) @printf(i8* %var1194)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}*, {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32)*,  %VAO* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%tmpres = bitcast %VAO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VAO_adhoc_W1ZBTyosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}*, {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32)*,  %VAO* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects87 = hidden constant [27 x i8] c"VAO_z_adhoc_W1ZBTyosaTMyXQ\00"
define dllexport fastcc %VAO* @VAO_z_adhoc_W1ZBTyosaTMyXQ__1195(i8* %_impz,i8* %_impenv, i32 %arg_0) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1196 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}*
%VAO_z_adhoc_W1ZBTyosaTMyXQPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%VAO_z_adhoc_W1ZBTyosaTMyXQPtr = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}***, {i8*, i8*, %VAO* (i8*, i8*, i32)*}**** %VAO_z_adhoc_W1ZBTyosaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr


%tzone1201 = load i8*, i8** %_impzPtr
%zone1202 = bitcast i8* %tzone1201 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VAO*
%tzone1197 = load i8*, i8** %_impzPtr
%zone1198 = bitcast i8* %tzone1197 to %mzone*
%dat1199 = call i8* @llvm_zone_malloc(%mzone* %zone1198, i64 4)
call i8* @memset(i8* %dat1199, i32 0, i64 4)
%val1200 = bitcast i8* %dat1199 to %VAO*

; let value assignment
%obj = select i1 true, %VAO* %val1200, %VAO* %val1200
store %VAO* %obj, %VAO** %objPtr

%val1203 = load %VAO*, %VAO** %objPtr
%val1204 = load i32, i32* %arg_0Ptr
; set tuple
%val1205 = getelementptr %VAO, %VAO* %val1203, i64 0, i32 0
store i32 %val1204, i32* %val1205
%val1206 = load %VAO*, %VAO** %objPtr
ret %VAO* %val1206
}
@gsxtmgl-objects88 = hidden constant [80 x i8] c"VAO_z_adhoc_W1ZBTyosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*, i32)*}** @VAO_z_adhoc_W1ZBTyosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1226 = load i8*, i8** %_impzPtr
%zone1227 = bitcast i8* %tzone1226 to %mzone*

; let assign value to symbol VAO_z_adhoc_W1ZBTyosaTMyXQ
%dat_VAO_z_adhoc_W1ZBTyosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone1227, i64 8)
%VAO_z_adhoc_W1ZBTyosaTMyXQPtr = bitcast i8* %dat_VAO_z_adhoc_W1ZBTyosaTMyXQ to { i8*, i8*, %VAO* (i8*, i8*, i32)*}***
%tzone1207 = load i8*, i8** %_impzPtr
%zone1208 = bitcast i8* %tzone1207 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1208)
; malloc closure structure
%clsptr1209 = call i8* @llvm_zone_malloc(%mzone* %zone1208, i64 24)
%closure1210 = bitcast i8* %clsptr1209 to { i8*, i8*, %VAO* (i8*, i8*, i32)*}*

; malloc environment structure
%envptr1211 = call i8* @llvm_zone_malloc(%mzone* %zone1208, i64 8)
%environment1212 = bitcast i8* %envptr1211 to {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable1213 = call %clsvar* @new_address_table()
%var1214 = bitcast [27 x i8]* @gsxtmgl-objects87 to i8*
%var1215 = bitcast [37 x i8]* @gsxtmgl-objects85 to i8*
%addytable1216 = call %clsvar* @add_address_table(%mzone* %zone1208, i8* %var1214, i32 0, i8* %var1215, i32 3, %clsvar* %addytable1213)
%address-table1217 = bitcast %clsvar* %addytable1216 to i8*

; insert table, function and environment into closure struct
%closure.table1220 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32)*}, { i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure1210, i32 0, i32 0
store i8* %address-table1217, i8** %closure.table1220
%closure.env1221 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32)*}, { i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure1210, i32 0, i32 1
store i8* %envptr1211, i8** %closure.env1221
%closure.func1222 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32)*}, { i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure1210, i32 0, i32 2
store %VAO* (i8*, i8*, i32)* @VAO_z_adhoc_W1ZBTyosaTMyXQ__1195, %VAO* (i8*, i8*, i32)** %closure.func1222
%closure_size1223 = call i64 @llvm_zone_mark_size(%mzone* %zone1208)
call void @llvm_zone_ptr_set_size(i8* %clsptr1209, i64 %closure_size1223)
%wrapper_ptr1224 = call i8* @llvm_zone_malloc(%mzone* %zone1208, i64 8)
%closure_wrapper1225 = bitcast i8* %wrapper_ptr1224 to { i8*, i8*, %VAO* (i8*, i8*, i32)*}**
store { i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure1210, { i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_wrapper1225

; let value assignment
%VAO_z_adhoc_W1ZBTyosaTMyXQ = select i1 true, { i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_wrapper1225, { i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_wrapper1225
store { i8*, i8*, %VAO* (i8*, i8*, i32)*}** %VAO_z_adhoc_W1ZBTyosaTMyXQ, { i8*, i8*, %VAO* (i8*, i8*, i32)*}*** %VAO_z_adhoc_W1ZBTyosaTMyXQPtr

; add data to environment
; don't need to alloc for env var VAO_z_adhoc_W1ZBTyosaTMyXQ
%tmp_envptr1219 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}* %environment1212, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*, i32)*}*** %VAO_z_adhoc_W1ZBTyosaTMyXQPtr, {i8*, i8*, %VAO* (i8*, i8*, i32)*}**** %tmp_envptr1219


%val1228 = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}**, {i8*, i8*, %VAO* (i8*, i8*, i32)*}*** %VAO_z_adhoc_W1ZBTyosaTMyXQPtr
ret {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %val1228
}


@VAO_z_adhoc_W1ZBTyosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_z_adhoc_W1ZBTyosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_z_adhoc_W1ZBTyosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*, i32)*}** @VAO_z_adhoc_W1ZBTyosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_z_adhoc_W1ZBTyosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @VAO_z_adhoc_W1ZBTyosaTMyXQ(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}*, {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32)*,  %VAO* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %VAO* %result
}


define dllexport ccc %VAO* @VAO_z_adhoc_W1ZBTyosaTMyXQ_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}*, {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32)*,  %VAO* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %VAO* %result
}


define dllexport ccc i8*  @VAO_z_adhoc_W1ZBTyosaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1229 = bitcast [80 x i8]* @gsxtmgl-objects88 to i8*
call i32 (i8*, ...) @printf(i8* %var1229)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}*, {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32)*,  %VAO* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%tmpres = bitcast %VAO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VAO_z_adhoc_W1ZBTyosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_z_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}*, {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32)*,  %VAO* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects89 = hidden constant [27 x i8] c"VAO_h_adhoc_W1ZBTyosaTMyXQ\00"
define dllexport fastcc %VAO* @VAO_h_adhoc_W1ZBTyosaTMyXQ__1230(i8* %_impz,i8* %_impenv, i32 %arg_0) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1231 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}*
%VAO_h_adhoc_W1ZBTyosaTMyXQPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%VAO_h_adhoc_W1ZBTyosaTMyXQPtr = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}***, {i8*, i8*, %VAO* (i8*, i8*, i32)*}**** %VAO_h_adhoc_W1ZBTyosaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr


%tzone1234 = load i8*, i8** %_impzPtr
%zone1235 = bitcast i8* %tzone1234 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VAO*
%dat1232 = call i8* @malloc(i64 4)
call i8* @memset(i8* %dat1232, i32 0, i64 4)
%val1233 = bitcast i8* %dat1232 to %VAO*

; let value assignment
%obj = select i1 true, %VAO* %val1233, %VAO* %val1233
store %VAO* %obj, %VAO** %objPtr

%val1236 = load %VAO*, %VAO** %objPtr
%val1237 = load i32, i32* %arg_0Ptr
; set tuple
%val1238 = getelementptr %VAO, %VAO* %val1236, i64 0, i32 0
store i32 %val1237, i32* %val1238
%val1239 = load %VAO*, %VAO** %objPtr
ret %VAO* %val1239
}
@gsxtmgl-objects90 = hidden constant [80 x i8] c"VAO_h_adhoc_W1ZBTyosaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*, i32)*}** @VAO_h_adhoc_W1ZBTyosaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1259 = load i8*, i8** %_impzPtr
%zone1260 = bitcast i8* %tzone1259 to %mzone*

; let assign value to symbol VAO_h_adhoc_W1ZBTyosaTMyXQ
%dat_VAO_h_adhoc_W1ZBTyosaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone1260, i64 8)
%VAO_h_adhoc_W1ZBTyosaTMyXQPtr = bitcast i8* %dat_VAO_h_adhoc_W1ZBTyosaTMyXQ to { i8*, i8*, %VAO* (i8*, i8*, i32)*}***
%tzone1240 = load i8*, i8** %_impzPtr
%zone1241 = bitcast i8* %tzone1240 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1241)
; malloc closure structure
%clsptr1242 = call i8* @llvm_zone_malloc(%mzone* %zone1241, i64 24)
%closure1243 = bitcast i8* %clsptr1242 to { i8*, i8*, %VAO* (i8*, i8*, i32)*}*

; malloc environment structure
%envptr1244 = call i8* @llvm_zone_malloc(%mzone* %zone1241, i64 8)
%environment1245 = bitcast i8* %envptr1244 to {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable1246 = call %clsvar* @new_address_table()
%var1247 = bitcast [27 x i8]* @gsxtmgl-objects89 to i8*
%var1248 = bitcast [37 x i8]* @gsxtmgl-objects85 to i8*
%addytable1249 = call %clsvar* @add_address_table(%mzone* %zone1241, i8* %var1247, i32 0, i8* %var1248, i32 3, %clsvar* %addytable1246)
%address-table1250 = bitcast %clsvar* %addytable1249 to i8*

; insert table, function and environment into closure struct
%closure.table1253 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32)*}, { i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure1243, i32 0, i32 0
store i8* %address-table1250, i8** %closure.table1253
%closure.env1254 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32)*}, { i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure1243, i32 0, i32 1
store i8* %envptr1244, i8** %closure.env1254
%closure.func1255 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, i32)*}, { i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure1243, i32 0, i32 2
store %VAO* (i8*, i8*, i32)* @VAO_h_adhoc_W1ZBTyosaTMyXQ__1230, %VAO* (i8*, i8*, i32)** %closure.func1255
%closure_size1256 = call i64 @llvm_zone_mark_size(%mzone* %zone1241)
call void @llvm_zone_ptr_set_size(i8* %clsptr1242, i64 %closure_size1256)
%wrapper_ptr1257 = call i8* @llvm_zone_malloc(%mzone* %zone1241, i64 8)
%closure_wrapper1258 = bitcast i8* %wrapper_ptr1257 to { i8*, i8*, %VAO* (i8*, i8*, i32)*}**
store { i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure1243, { i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_wrapper1258

; let value assignment
%VAO_h_adhoc_W1ZBTyosaTMyXQ = select i1 true, { i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_wrapper1258, { i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_wrapper1258
store { i8*, i8*, %VAO* (i8*, i8*, i32)*}** %VAO_h_adhoc_W1ZBTyosaTMyXQ, { i8*, i8*, %VAO* (i8*, i8*, i32)*}*** %VAO_h_adhoc_W1ZBTyosaTMyXQPtr

; add data to environment
; don't need to alloc for env var VAO_h_adhoc_W1ZBTyosaTMyXQ
%tmp_envptr1252 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, i32)*}***}* %environment1245, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*, i32)*}*** %VAO_h_adhoc_W1ZBTyosaTMyXQPtr, {i8*, i8*, %VAO* (i8*, i8*, i32)*}**** %tmp_envptr1252


%val1261 = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}**, {i8*, i8*, %VAO* (i8*, i8*, i32)*}*** %VAO_h_adhoc_W1ZBTyosaTMyXQPtr
ret {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %val1261
}


@VAO_h_adhoc_W1ZBTyosaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_h_adhoc_W1ZBTyosaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_h_adhoc_W1ZBTyosaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*, i32)*}** @VAO_h_adhoc_W1ZBTyosaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_h_adhoc_W1ZBTyosaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @VAO_h_adhoc_W1ZBTyosaTMyXQ(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}*, {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32)*,  %VAO* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %VAO* %result
}


define dllexport ccc %VAO* @VAO_h_adhoc_W1ZBTyosaTMyXQ_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}*, {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32)*,  %VAO* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %VAO* %result
}


define dllexport ccc i8*  @VAO_h_adhoc_W1ZBTyosaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1262 = bitcast [80 x i8]* @gsxtmgl-objects90 to i8*
call i32 (i8*, ...) @printf(i8* %var1262)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}*, {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32)*,  %VAO* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%tmpres = bitcast %VAO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VAO_h_adhoc_W1ZBTyosaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_h_adhoc_W1ZBTyosaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, i32)*}*, {i8*, i8*, %VAO* (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, i32)*}, {i8*, i8*, %VAO* (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, i32)*,  %VAO* (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects91 = hidden constant [27 x i8] c"VAO_val_adhoc_W1ZBTyxpMzJd\00"
@gsxtmgl-objects92 = hidden constant [36 x i8] c"{i8*, i8*, %VAO (i8*, i8*, i32)*}**\00"
define dllexport fastcc %VAO @VAO_val_adhoc_W1ZBTyxpMzJd__1263(i8* %_impz,i8* %_impenv, i32 %arg_0) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1264 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO (i8*, i8*, i32)*}***}*
%VAO_val_adhoc_W1ZBTyxpMzJdPtr_ = getelementptr {{i8*, i8*, %VAO (i8*, i8*, i32)*}***}, {{i8*, i8*, %VAO (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%VAO_val_adhoc_W1ZBTyxpMzJdPtr = load {i8*, i8*, %VAO (i8*, i8*, i32)*}***, {i8*, i8*, %VAO (i8*, i8*, i32)*}**** %VAO_val_adhoc_W1ZBTyxpMzJdPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr


%tzone1266 = load i8*, i8** %_impzPtr
%zone1267 = bitcast i8* %tzone1266 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VAO*
%dat1265 = alloca %VAO, align 16

; let value assignment
%obj = select i1 true, %VAO* %dat1265, %VAO* %dat1265
store %VAO* %obj, %VAO** %objPtr

%val1268 = load %VAO*, %VAO** %objPtr
%val1269 = load i32, i32* %arg_0Ptr
; set tuple
%val1270 = getelementptr %VAO, %VAO* %val1268, i64 0, i32 0
store i32 %val1269, i32* %val1270
%val1271 = load %VAO*, %VAO** %objPtr
; pointer ref
%val1272 = getelementptr %VAO, %VAO* %val1271, i64 0
%val1273 = load %VAO, %VAO* %val1272
ret %VAO %val1273
}
@gsxtmgl-objects93 = hidden constant [80 x i8] c"VAO_val_adhoc_W1ZBTyxpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VAO (i8*, i8*, i32)*}** @VAO_val_adhoc_W1ZBTyxpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1293 = load i8*, i8** %_impzPtr
%zone1294 = bitcast i8* %tzone1293 to %mzone*

; let assign value to symbol VAO_val_adhoc_W1ZBTyxpMzJd
%dat_VAO_val_adhoc_W1ZBTyxpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone1294, i64 8)
%VAO_val_adhoc_W1ZBTyxpMzJdPtr = bitcast i8* %dat_VAO_val_adhoc_W1ZBTyxpMzJd to { i8*, i8*, %VAO (i8*, i8*, i32)*}***
%tzone1274 = load i8*, i8** %_impzPtr
%zone1275 = bitcast i8* %tzone1274 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1275)
; malloc closure structure
%clsptr1276 = call i8* @llvm_zone_malloc(%mzone* %zone1275, i64 24)
%closure1277 = bitcast i8* %clsptr1276 to { i8*, i8*, %VAO (i8*, i8*, i32)*}*

; malloc environment structure
%envptr1278 = call i8* @llvm_zone_malloc(%mzone* %zone1275, i64 8)
%environment1279 = bitcast i8* %envptr1278 to {{i8*, i8*, %VAO (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable1280 = call %clsvar* @new_address_table()
%var1281 = bitcast [27 x i8]* @gsxtmgl-objects91 to i8*
%var1282 = bitcast [36 x i8]* @gsxtmgl-objects92 to i8*
%addytable1283 = call %clsvar* @add_address_table(%mzone* %zone1275, i8* %var1281, i32 0, i8* %var1282, i32 3, %clsvar* %addytable1280)
%address-table1284 = bitcast %clsvar* %addytable1283 to i8*

; insert table, function and environment into closure struct
%closure.table1287 = getelementptr { i8*, i8*, %VAO (i8*, i8*, i32)*}, { i8*, i8*, %VAO (i8*, i8*, i32)*}* %closure1277, i32 0, i32 0
store i8* %address-table1284, i8** %closure.table1287
%closure.env1288 = getelementptr { i8*, i8*, %VAO (i8*, i8*, i32)*}, { i8*, i8*, %VAO (i8*, i8*, i32)*}* %closure1277, i32 0, i32 1
store i8* %envptr1278, i8** %closure.env1288
%closure.func1289 = getelementptr { i8*, i8*, %VAO (i8*, i8*, i32)*}, { i8*, i8*, %VAO (i8*, i8*, i32)*}* %closure1277, i32 0, i32 2
store %VAO (i8*, i8*, i32)* @VAO_val_adhoc_W1ZBTyxpMzJd__1263, %VAO (i8*, i8*, i32)** %closure.func1289
%closure_size1290 = call i64 @llvm_zone_mark_size(%mzone* %zone1275)
call void @llvm_zone_ptr_set_size(i8* %clsptr1276, i64 %closure_size1290)
%wrapper_ptr1291 = call i8* @llvm_zone_malloc(%mzone* %zone1275, i64 8)
%closure_wrapper1292 = bitcast i8* %wrapper_ptr1291 to { i8*, i8*, %VAO (i8*, i8*, i32)*}**
store { i8*, i8*, %VAO (i8*, i8*, i32)*}* %closure1277, { i8*, i8*, %VAO (i8*, i8*, i32)*}** %closure_wrapper1292

; let value assignment
%VAO_val_adhoc_W1ZBTyxpMzJd = select i1 true, { i8*, i8*, %VAO (i8*, i8*, i32)*}** %closure_wrapper1292, { i8*, i8*, %VAO (i8*, i8*, i32)*}** %closure_wrapper1292
store { i8*, i8*, %VAO (i8*, i8*, i32)*}** %VAO_val_adhoc_W1ZBTyxpMzJd, { i8*, i8*, %VAO (i8*, i8*, i32)*}*** %VAO_val_adhoc_W1ZBTyxpMzJdPtr

; add data to environment
; don't need to alloc for env var VAO_val_adhoc_W1ZBTyxpMzJd
%tmp_envptr1286 = getelementptr {{i8*, i8*, %VAO (i8*, i8*, i32)*}***}, {{i8*, i8*, %VAO (i8*, i8*, i32)*}***}* %environment1279, i32 0, i32 0
store {i8*, i8*, %VAO (i8*, i8*, i32)*}*** %VAO_val_adhoc_W1ZBTyxpMzJdPtr, {i8*, i8*, %VAO (i8*, i8*, i32)*}**** %tmp_envptr1286


%val1295 = load {i8*, i8*, %VAO (i8*, i8*, i32)*}**, {i8*, i8*, %VAO (i8*, i8*, i32)*}*** %VAO_val_adhoc_W1ZBTyxpMzJdPtr
ret {i8*, i8*, %VAO (i8*, i8*, i32)*}** %val1295
}


@VAO_val_adhoc_W1ZBTyxpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_val_adhoc_W1ZBTyxpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_val_adhoc_W1ZBTyxpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_val_adhoc_W1ZBTyxpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO (i8*, i8*, i32)*}** @VAO_val_adhoc_W1ZBTyxpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_val_adhoc_W1ZBTyxpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_val_adhoc_W1ZBTyxpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_val_adhoc_W1ZBTyxpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO @VAO_val_adhoc_W1ZBTyxpMzJd(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_val_adhoc_W1ZBTyxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO (i8*, i8*, i32)*}*, {i8*, i8*, %VAO (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO (i8*, i8*, i32)*}, {i8*, i8*, %VAO (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO (i8*, i8*, i32)*}, {i8*, i8*, %VAO (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO (i8*, i8*, i32)*,  %VAO (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %VAO %result
}


define dllexport ccc %VAO @VAO_val_adhoc_W1ZBTyxpMzJd_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_val_adhoc_W1ZBTyxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO (i8*, i8*, i32)*}*, {i8*, i8*, %VAO (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO (i8*, i8*, i32)*}, {i8*, i8*, %VAO (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO (i8*, i8*, i32)*}, {i8*, i8*, %VAO (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO (i8*, i8*, i32)*,  %VAO (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret %VAO %result
}


define dllexport ccc void @VAO_val_adhoc_W1ZBTyxpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_val_adhoc_W1ZBTyxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %VAO (i8*, i8*, i32)*}*, {i8*, i8*, %VAO (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO (i8*, i8*, i32)*}, {i8*, i8*, %VAO (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO (i8*, i8*, i32)*}, {i8*, i8*, %VAO (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %VAO (i8*, i8*, i32)*,  %VAO (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects94 = hidden constant [28 x i8] c"hcopy_adhoc_W1ZBTyosVkFPKl0\00"
@gsxtmgl-objects95 = hidden constant [39 x i8] c"{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**\00"
define dllexport fastcc %VAO* @hcopy_adhoc_W1ZBTyosVkFPKl0__1297(i8* %_impz,i8* %_impenv, %VAO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1298 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***}*
%hcopy_adhoc_W1ZBTyosVkFPKl0Ptr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1ZBTyosVkFPKl0Ptr = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**** %hcopy_adhoc_W1ZBTyosVkFPKl0Ptr_

; setup arguments
%xPtr = alloca %VAO*
store %VAO* %x, %VAO** %xPtr


%tzone1301 = load i8*, i8** %_impzPtr
%zone1302 = bitcast i8* %tzone1301 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VAO*
%dat1299 = call i8* @malloc(i64 4)
call i8* @memset(i8* %dat1299, i32 0, i64 4)
%val1300 = bitcast i8* %dat1299 to %VAO*

; let value assignment
%obj = select i1 true, %VAO* %val1300, %VAO* %val1300
store %VAO* %obj, %VAO** %objPtr

%val1303 = load %VAO*, %VAO** %objPtr
%val1304 = load %VAO*, %VAO** %xPtr
; tuple ref
%val1305 = getelementptr %VAO, %VAO* %val1304, i64 0, i32 0
%val1306 = load i32, i32* %val1305
; set tuple
%val1307 = getelementptr %VAO, %VAO* %val1303, i64 0, i32 0
store i32 %val1306, i32* %val1307
%val1308 = load %VAO*, %VAO** %objPtr
ret %VAO* %val1308
}
@gsxtmgl-objects96 = hidden constant [81 x i8] c"hcopy_adhoc_W1ZBTyosVkFPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** @hcopy_adhoc_W1ZBTyosVkFPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1328 = load i8*, i8** %_impzPtr
%zone1329 = bitcast i8* %tzone1328 to %mzone*

; let assign value to symbol hcopy_adhoc_W1ZBTyosVkFPKl0
%dat_hcopy_adhoc_W1ZBTyosVkFPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1329, i64 8)
%hcopy_adhoc_W1ZBTyosVkFPKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1ZBTyosVkFPKl0 to { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***
%tzone1309 = load i8*, i8** %_impzPtr
%zone1310 = bitcast i8* %tzone1309 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1310)
; malloc closure structure
%clsptr1311 = call i8* @llvm_zone_malloc(%mzone* %zone1310, i64 24)
%closure1312 = bitcast i8* %clsptr1311 to { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr1313 = call i8* @llvm_zone_malloc(%mzone* %zone1310, i64 8)
%environment1314 = bitcast i8* %envptr1313 to {{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable1315 = call %clsvar* @new_address_table()
%var1316 = bitcast [28 x i8]* @gsxtmgl-objects94 to i8*
%var1317 = bitcast [39 x i8]* @gsxtmgl-objects95 to i8*
%addytable1318 = call %clsvar* @add_address_table(%mzone* %zone1310, i8* %var1316, i32 0, i8* %var1317, i32 3, %clsvar* %addytable1315)
%address-table1319 = bitcast %clsvar* %addytable1318 to i8*

; insert table, function and environment into closure struct
%closure.table1322 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure1312, i32 0, i32 0
store i8* %address-table1319, i8** %closure.table1322
%closure.env1323 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure1312, i32 0, i32 1
store i8* %envptr1313, i8** %closure.env1323
%closure.func1324 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure1312, i32 0, i32 2
store %VAO* (i8*, i8*, %VAO*)* @hcopy_adhoc_W1ZBTyosVkFPKl0__1297, %VAO* (i8*, i8*, %VAO*)** %closure.func1324
%closure_size1325 = call i64 @llvm_zone_mark_size(%mzone* %zone1310)
call void @llvm_zone_ptr_set_size(i8* %clsptr1311, i64 %closure_size1325)
%wrapper_ptr1326 = call i8* @llvm_zone_malloc(%mzone* %zone1310, i64 8)
%closure_wrapper1327 = bitcast i8* %wrapper_ptr1326 to { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**
store { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure1312, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_wrapper1327

; let value assignment
%hcopy_adhoc_W1ZBTyosVkFPKl0 = select i1 true, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_wrapper1327, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_wrapper1327
store { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %hcopy_adhoc_W1ZBTyosVkFPKl0, { i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*** %hcopy_adhoc_W1ZBTyosVkFPKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1ZBTyosVkFPKl0
%tmp_envptr1321 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}***}* %environment1314, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*** %hcopy_adhoc_W1ZBTyosVkFPKl0Ptr, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**** %tmp_envptr1321


%val1330 = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*** %hcopy_adhoc_W1ZBTyosVkFPKl0Ptr
ret {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %val1330
}


@hcopy_adhoc_W1ZBTyosVkFPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1ZBTyosVkFPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1ZBTyosVkFPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** @hcopy_adhoc_W1ZBTyosVkFPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1ZBTyosVkFPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @hcopy_adhoc_W1ZBTyosVkFPKl0(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*)*,  %VAO* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret %VAO* %result
}


define dllexport ccc %VAO* @hcopy_adhoc_W1ZBTyosVkFPKl0_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*)*,  %VAO* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret %VAO* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1ZBTyosVkFPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1331 = bitcast [81 x i8]* @gsxtmgl-objects96 to i8*
call i32 (i8*, ...) @printf(i8* %var1331)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*)*,  %VAO* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%tmpres = bitcast %VAO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1ZBTyosVkFPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1ZBTyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*)*,  %VAO* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects97 = hidden constant [28 x i8] c"hfree_adhoc_W3ZvaWQsVkFPKl0\00"
@gsxtmgl-objects98 = hidden constant [38 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsVkFPKl0__1332(i8* %_impz,i8* %_impenv, %VAO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1333 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}*
%hfree_adhoc_W3ZvaWQsVkFPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsVkFPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %VAO*)*}***, {i8*, i8*, void (i8*, i8*, %VAO*)*}**** %hfree_adhoc_W3ZvaWQsVkFPKl0Ptr_

; setup arguments
%xPtr = alloca %VAO*
store %VAO* %x, %VAO** %xPtr


%val1334 = load %VAO*, %VAO** %xPtr
%val1335 = bitcast %VAO* %val1334 to i8*
call ccc void @free(i8* %val1335)
ret void
}
@gsxtmgl-objects99 = hidden constant [81 x i8] c"hfree_adhoc_W3ZvaWQsVkFPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*)*}** @hfree_adhoc_W3ZvaWQsVkFPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1357 = load i8*, i8** %_impzPtr
%zone1358 = bitcast i8* %tzone1357 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsVkFPKl0
%dat_hfree_adhoc_W3ZvaWQsVkFPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1358, i64 8)
%hfree_adhoc_W3ZvaWQsVkFPKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsVkFPKl0 to { i8*, i8*, void (i8*, i8*, %VAO*)*}***
%tzone1338 = load i8*, i8** %_impzPtr
%zone1339 = bitcast i8* %tzone1338 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1339)
; malloc closure structure
%clsptr1340 = call i8* @llvm_zone_malloc(%mzone* %zone1339, i64 24)
%closure1341 = bitcast i8* %clsptr1340 to { i8*, i8*, void (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr1342 = call i8* @llvm_zone_malloc(%mzone* %zone1339, i64 8)
%environment1343 = bitcast i8* %envptr1342 to {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable1344 = call %clsvar* @new_address_table()
%var1345 = bitcast [28 x i8]* @gsxtmgl-objects97 to i8*
%var1346 = bitcast [38 x i8]* @gsxtmgl-objects98 to i8*
%addytable1347 = call %clsvar* @add_address_table(%mzone* %zone1339, i8* %var1345, i32 0, i8* %var1346, i32 3, %clsvar* %addytable1344)
%address-table1348 = bitcast %clsvar* %addytable1347 to i8*

; insert table, function and environment into closure struct
%closure.table1351 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1341, i32 0, i32 0
store i8* %address-table1348, i8** %closure.table1351
%closure.env1352 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1341, i32 0, i32 1
store i8* %envptr1342, i8** %closure.env1352
%closure.func1353 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1341, i32 0, i32 2
store void (i8*, i8*, %VAO*)* @hfree_adhoc_W3ZvaWQsVkFPKl0__1332, void (i8*, i8*, %VAO*)** %closure.func1353
%closure_size1354 = call i64 @llvm_zone_mark_size(%mzone* %zone1339)
call void @llvm_zone_ptr_set_size(i8* %clsptr1340, i64 %closure_size1354)
%wrapper_ptr1355 = call i8* @llvm_zone_malloc(%mzone* %zone1339, i64 8)
%closure_wrapper1356 = bitcast i8* %wrapper_ptr1355 to { i8*, i8*, void (i8*, i8*, %VAO*)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1341, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper1356

; let value assignment
%hfree_adhoc_W3ZvaWQsVkFPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper1356, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper1356
store { i8*, i8*, void (i8*, i8*, %VAO*)*}** %hfree_adhoc_W3ZvaWQsVkFPKl0, { i8*, i8*, void (i8*, i8*, %VAO*)*}*** %hfree_adhoc_W3ZvaWQsVkFPKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsVkFPKl0
%tmp_envptr1350 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}* %environment1343, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*)*}*** %hfree_adhoc_W3ZvaWQsVkFPKl0Ptr, {i8*, i8*, void (i8*, i8*, %VAO*)*}**** %tmp_envptr1350


%val1359 = load {i8*, i8*, void (i8*, i8*, %VAO*)*}**, {i8*, i8*, void (i8*, i8*, %VAO*)*}*** %hfree_adhoc_W3ZvaWQsVkFPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VAO*)*}** %val1359
}


@hfree_adhoc_W3ZvaWQsVkFPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsVkFPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsVkFPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*)*}** @hfree_adhoc_W3ZvaWQsVkFPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsVkFPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsVkFPKl0(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsVkFPKl0_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsVkFPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1360 = bitcast [81 x i8]* @gsxtmgl-objects99 to i8*
call i32 (i8*, ...) @printf(i8* %var1360)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsVkFPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects100 = hidden constant [47 x i8] c"zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmgl-objects101 = hidden constant [57 x i8] c"{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %VAO* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ__1361(i8* %_impz,i8* %_impenv, %VAO* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1362 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %VAO*
store %VAO* %x, %VAO** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val1364 = load %mzone*, %mzone** %fromzPtr
%val1365 = load %VAO*, %VAO** %xPtr
%val1366 = bitcast %VAO* %val1365 to i8*
%res1367 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val1364, i8* %val1366)
br i1 %res1367, label %then1363, label %else1363

then1363:
%val1368 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val1368)
%zone_ptr1369 = bitcast %mzone* %val1368 to i8*
store i8* %zone_ptr1369, i8** %_impzPtr
%tzone1375 = load i8*, i8** %_impzPtr
%zone1376 = bitcast i8* %tzone1375 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %VAO*
%tzone1371 = load i8*, i8** %_impzPtr
%zone1372 = bitcast i8* %tzone1371 to %mzone*
%dat1373 = call i8* @llvm_zone_malloc(%mzone* %zone1372, i64 4)
call i8* @memset(i8* %dat1373, i32 0, i64 4)
%val1374 = bitcast i8* %dat1373 to %VAO*

; let value assignment
%obj = select i1 true, %VAO* %val1374, %VAO* %val1374
store %VAO* %obj, %VAO** %objPtr

%val1377 = load %VAO*, %VAO** %objPtr
%val1378 = load %VAO*, %VAO** %xPtr
; tuple ref
%val1379 = getelementptr %VAO, %VAO* %val1378, i64 0, i32 0
%val1380 = load i32, i32* %val1379
; set tuple
%val1381 = getelementptr %VAO, %VAO* %val1377, i64 0, i32 0
store i32 %val1380, i32* %val1381
%oldzone1382 = call %mzone* @llvm_pop_zone_stack()
%newzone1383 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr1384 = bitcast %mzone* %newzone1383 to i8*
store i8* %zone_ptr1384, i8** %_impzPtr
%val1385 = load %VAO*, %VAO** %objPtr
ret %VAO* %val1385

else1363:
%val1386 = load %VAO*, %VAO** %xPtr
ret %VAO* %val1386
}
@gsxtmgl-objects102 = hidden constant [100 x i8] c"zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1406 = load i8*, i8** %_impzPtr
%zone1407 = bitcast i8* %tzone1406 to %mzone*

; let assign value to symbol zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone1407, i64 8)
%zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***
%tzone1387 = load i8*, i8** %_impzPtr
%zone1388 = bitcast i8* %tzone1387 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1388)
; malloc closure structure
%clsptr1389 = call i8* @llvm_zone_malloc(%mzone* %zone1388, i64 24)
%closure1390 = bitcast i8* %clsptr1389 to { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr1391 = call i8* @llvm_zone_malloc(%mzone* %zone1388, i64 8)
%environment1392 = bitcast i8* %envptr1391 to {{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable1393 = call %clsvar* @new_address_table()
%var1394 = bitcast [47 x i8]* @gsxtmgl-objects100 to i8*
%var1395 = bitcast [57 x i8]* @gsxtmgl-objects101 to i8*
%addytable1396 = call %clsvar* @add_address_table(%mzone* %zone1388, i8* %var1394, i32 0, i8* %var1395, i32 3, %clsvar* %addytable1393)
%address-table1397 = bitcast %clsvar* %addytable1396 to i8*

; insert table, function and environment into closure struct
%closure.table1400 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure1390, i32 0, i32 0
store i8* %address-table1397, i8** %closure.table1400
%closure.env1401 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure1390, i32 0, i32 1
store i8* %envptr1391, i8** %closure.env1401
%closure.func1402 = getelementptr { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure1390, i32 0, i32 2
store %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ__1361, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)** %closure.func1402
%closure_size1403 = call i64 @llvm_zone_mark_size(%mzone* %zone1388)
call void @llvm_zone_ptr_set_size(i8* %clsptr1389, i64 %closure_size1403)
%wrapper_ptr1404 = call i8* @llvm_zone_malloc(%mzone* %zone1388, i64 8)
%closure_wrapper1405 = bitcast i8* %wrapper_ptr1404 to { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**
store { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure1390, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_wrapper1405

; let value assignment
%zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_wrapper1405, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_wrapper1405
store { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ
%tmp_envptr1399 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}***}* %environment1392, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**** %tmp_envptr1399


%val1408 = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %val1408
}


@zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ(%VAO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*,  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %VAO* %result
}


define dllexport ccc %VAO* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_native(%VAO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*,  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %VAO* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1409 = bitcast [100 x i8]* @gsxtmgl-objects102 to i8*
call i32 (i8*, ...) @printf(i8* %var1409)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1410 = bitcast [100 x i8]* @gsxtmgl-objects102 to i8*
call i32 (i8*, ...) @printf(i8* %var1410)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1411 = bitcast [100 x i8]* @gsxtmgl-objects102 to i8*
call i32 (i8*, ...) @printf(i8* %var1411)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*,  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %VAO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%VAO*, %mzone*, %mzone*}, {%VAO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, %mzone*, %mzone*}, {%VAO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, %mzone*, %mzone*}, {%VAO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1ZBTyosVkFPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}*, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}, {i8*, i8*, %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)*,  %VAO* (i8*, i8*, %VAO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects103 = hidden constant [28 x i8] c"VAO_id_adhoc_W2kzMixWQU8qXQ\00"
@gsxtmgl-objects104 = hidden constant [37 x i8] c"{i8*, i8*, i32 (i8*, i8*, %VAO*)*}**\00"
define dllexport fastcc i32 @VAO_id_adhoc_W2kzMixWQU8qXQ__1412(i8* %_impz,i8* %_impenv, %VAO* %vao) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1413 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %VAO*)*}***}*
%VAO_id_adhoc_W2kzMixWQU8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%VAO_id_adhoc_W2kzMixWQU8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %VAO*)*}***, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**** %VAO_id_adhoc_W2kzMixWQU8qXQPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr


%val1414 = load %VAO*, %VAO** %vaoPtr
; tuple ref
%val1415 = getelementptr %VAO, %VAO* %val1414, i64 0, i32 0
%val1416 = load i32, i32* %val1415
ret i32 %val1416
}
@gsxtmgl-objects105 = hidden constant [81 x i8] c"VAO_id_adhoc_W2kzMixWQU8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** @VAO_id_adhoc_W2kzMixWQU8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1436 = load i8*, i8** %_impzPtr
%zone1437 = bitcast i8* %tzone1436 to %mzone*

; let assign value to symbol VAO_id_adhoc_W2kzMixWQU8qXQ
%dat_VAO_id_adhoc_W2kzMixWQU8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone1437, i64 8)
%VAO_id_adhoc_W2kzMixWQU8qXQPtr = bitcast i8* %dat_VAO_id_adhoc_W2kzMixWQU8qXQ to { i8*, i8*, i32 (i8*, i8*, %VAO*)*}***
%tzone1417 = load i8*, i8** %_impzPtr
%zone1418 = bitcast i8* %tzone1417 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1418)
; malloc closure structure
%clsptr1419 = call i8* @llvm_zone_malloc(%mzone* %zone1418, i64 24)
%closure1420 = bitcast i8* %clsptr1419 to { i8*, i8*, i32 (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr1421 = call i8* @llvm_zone_malloc(%mzone* %zone1418, i64 8)
%environment1422 = bitcast i8* %envptr1421 to {{i8*, i8*, i32 (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable1423 = call %clsvar* @new_address_table()
%var1424 = bitcast [28 x i8]* @gsxtmgl-objects103 to i8*
%var1425 = bitcast [37 x i8]* @gsxtmgl-objects104 to i8*
%addytable1426 = call %clsvar* @add_address_table(%mzone* %zone1418, i8* %var1424, i32 0, i8* %var1425, i32 3, %clsvar* %addytable1423)
%address-table1427 = bitcast %clsvar* %addytable1426 to i8*

; insert table, function and environment into closure struct
%closure.table1430 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VAO*)*}, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure1420, i32 0, i32 0
store i8* %address-table1427, i8** %closure.table1430
%closure.env1431 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VAO*)*}, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure1420, i32 0, i32 1
store i8* %envptr1421, i8** %closure.env1431
%closure.func1432 = getelementptr { i8*, i8*, i32 (i8*, i8*, %VAO*)*}, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure1420, i32 0, i32 2
store i32 (i8*, i8*, %VAO*)* @VAO_id_adhoc_W2kzMixWQU8qXQ__1412, i32 (i8*, i8*, %VAO*)** %closure.func1432
%closure_size1433 = call i64 @llvm_zone_mark_size(%mzone* %zone1418)
call void @llvm_zone_ptr_set_size(i8* %clsptr1419, i64 %closure_size1433)
%wrapper_ptr1434 = call i8* @llvm_zone_malloc(%mzone* %zone1418, i64 8)
%closure_wrapper1435 = bitcast i8* %wrapper_ptr1434 to { i8*, i8*, i32 (i8*, i8*, %VAO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure1420, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_wrapper1435

; let value assignment
%VAO_id_adhoc_W2kzMixWQU8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_wrapper1435, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_wrapper1435
store { i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %VAO_id_adhoc_W2kzMixWQU8qXQ, { i8*, i8*, i32 (i8*, i8*, %VAO*)*}*** %VAO_id_adhoc_W2kzMixWQU8qXQPtr

; add data to environment
; don't need to alloc for env var VAO_id_adhoc_W2kzMixWQU8qXQ
%tmp_envptr1429 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %VAO*)*}***}* %environment1422, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %VAO*)*}*** %VAO_id_adhoc_W2kzMixWQU8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**** %tmp_envptr1429


%val1438 = load {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}*** %VAO_id_adhoc_W2kzMixWQU8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %val1438
}


@VAO_id_adhoc_W2kzMixWQU8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_id_adhoc_W2kzMixWQU8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_id_adhoc_W2kzMixWQU8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_id_adhoc_W2kzMixWQU8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** @VAO_id_adhoc_W2kzMixWQU8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_id_adhoc_W2kzMixWQU8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_id_adhoc_W2kzMixWQU8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_id_adhoc_W2kzMixWQU8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @VAO_id_adhoc_W2kzMixWQU8qXQ(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_id_adhoc_W2kzMixWQU8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VAO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VAO*)*,  i32 (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @VAO_id_adhoc_W2kzMixWQU8qXQ_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_id_adhoc_W2kzMixWQU8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VAO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VAO*)*,  i32 (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @VAO_id_adhoc_W2kzMixWQU8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1439 = bitcast [81 x i8]* @gsxtmgl-objects105 to i8*
call i32 (i8*, ...) @printf(i8* %var1439)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_id_adhoc_W2kzMixWQU8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VAO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VAO*)*,  i32 (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @VAO_id_adhoc_W2kzMixWQU8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_id_adhoc_W2kzMixWQU8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %VAO*)*}*, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %VAO*)*}, {i8*, i8*, i32 (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %VAO*)*,  i32 (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects106 = hidden constant [11 x i8] c"<VAO: 0x0>\00"
@gsxtmgl-objects107 = hidden constant [13 x i8] c"<VAO: id %d>\00"
@gsxtmgl-objects108 = hidden constant [28 x i8] c"print_adhoc_W3ZvaWQsVkFPKl0\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsVkFPKl0__1440(i8* %_impz,i8* %_impenv, %VAO* %vao) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1441 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}*
%print_adhoc_W3ZvaWQsVkFPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsVkFPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %VAO*)*}***, {i8*, i8*, void (i8*, i8*, %VAO*)*}**** %print_adhoc_W3ZvaWQsVkFPKl0Ptr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr

; promote local stack var allocations
%tzone1454 = load i8*, i8** %_impzPtr
%zone1455 = bitcast i8* %tzone1454 to %mzone*
%ifptr1442 = alloca i32

%val1443 = load %VAO*, %VAO** %vaoPtr
%val1444 = icmp eq %VAO* %val1443, null
br i1 %val1444, label %then1442, label %else1442

then1442:
%var1445 = bitcast [11 x i8]* @gsxtmgl-objects106 to i8*

%val1446 = call i32 (i8*, ...) @printf(i8* %var1445)
store i32 %val1446, i32* %ifptr1442
br label %ifcont1442

else1442:
%var1447 = bitcast [13 x i8]* @gsxtmgl-objects107 to i8*
%val1448 = load %VAO*, %VAO** %vaoPtr
; tuple ref
%val1449 = getelementptr %VAO, %VAO* %val1448, i64 0, i32 0
%val1450 = load i32, i32* %val1449

%val1451 = call i32 (i8*, ...) @printf(i8* %var1447, i32 %val1450)
store i32 %val1451, i32* %ifptr1442
br label %ifcont1442

ifcont1442:
%ifres1452 = load i32, i32* %ifptr1442

ret void
}
@gsxtmgl-objects109 = hidden constant [81 x i8] c"print_adhoc_W3ZvaWQsVkFPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*)*}** @print_adhoc_W3ZvaWQsVkFPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1475 = load i8*, i8** %_impzPtr
%zone1476 = bitcast i8* %tzone1475 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsVkFPKl0
%dat_print_adhoc_W3ZvaWQsVkFPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1476, i64 8)
%print_adhoc_W3ZvaWQsVkFPKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsVkFPKl0 to { i8*, i8*, void (i8*, i8*, %VAO*)*}***
%tzone1456 = load i8*, i8** %_impzPtr
%zone1457 = bitcast i8* %tzone1456 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1457)
; malloc closure structure
%clsptr1458 = call i8* @llvm_zone_malloc(%mzone* %zone1457, i64 24)
%closure1459 = bitcast i8* %clsptr1458 to { i8*, i8*, void (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr1460 = call i8* @llvm_zone_malloc(%mzone* %zone1457, i64 8)
%environment1461 = bitcast i8* %envptr1460 to {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable1462 = call %clsvar* @new_address_table()
%var1463 = bitcast [28 x i8]* @gsxtmgl-objects108 to i8*
%var1464 = bitcast [38 x i8]* @gsxtmgl-objects98 to i8*
%addytable1465 = call %clsvar* @add_address_table(%mzone* %zone1457, i8* %var1463, i32 0, i8* %var1464, i32 3, %clsvar* %addytable1462)
%address-table1466 = bitcast %clsvar* %addytable1465 to i8*

; insert table, function and environment into closure struct
%closure.table1469 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1459, i32 0, i32 0
store i8* %address-table1466, i8** %closure.table1469
%closure.env1470 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1459, i32 0, i32 1
store i8* %envptr1460, i8** %closure.env1470
%closure.func1471 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1459, i32 0, i32 2
store void (i8*, i8*, %VAO*)* @print_adhoc_W3ZvaWQsVkFPKl0__1440, void (i8*, i8*, %VAO*)** %closure.func1471
%closure_size1472 = call i64 @llvm_zone_mark_size(%mzone* %zone1457)
call void @llvm_zone_ptr_set_size(i8* %clsptr1458, i64 %closure_size1472)
%wrapper_ptr1473 = call i8* @llvm_zone_malloc(%mzone* %zone1457, i64 8)
%closure_wrapper1474 = bitcast i8* %wrapper_ptr1473 to { i8*, i8*, void (i8*, i8*, %VAO*)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1459, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper1474

; let value assignment
%print_adhoc_W3ZvaWQsVkFPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper1474, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper1474
store { i8*, i8*, void (i8*, i8*, %VAO*)*}** %print_adhoc_W3ZvaWQsVkFPKl0, { i8*, i8*, void (i8*, i8*, %VAO*)*}*** %print_adhoc_W3ZvaWQsVkFPKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsVkFPKl0
%tmp_envptr1468 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}* %environment1461, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*)*}*** %print_adhoc_W3ZvaWQsVkFPKl0Ptr, {i8*, i8*, void (i8*, i8*, %VAO*)*}**** %tmp_envptr1468


%val1477 = load {i8*, i8*, void (i8*, i8*, %VAO*)*}**, {i8*, i8*, void (i8*, i8*, %VAO*)*}*** %print_adhoc_W3ZvaWQsVkFPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VAO*)*}** %val1477
}


@print_adhoc_W3ZvaWQsVkFPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsVkFPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsVkFPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*)*}** @print_adhoc_W3ZvaWQsVkFPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsVkFPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsVkFPKl0(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsVkFPKl0_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsVkFPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1478 = bitcast [81 x i8]* @gsxtmgl-objects109 to i8*
call i32 (i8*, ...) @printf(i8* %var1478)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsVkFPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects110 = hidden constant [35 x i8] c"toString_adhoc_W1N0cmluZyosVkFPKl0\00"
@gsxtmgl-objects111 = hidden constant [42 x i8] c"{i8*, i8*, %String* (i8*, i8*, %VAO*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosVkFPKl0__1479(i8* %_impz,i8* %_impenv, %VAO* %vao) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1480 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %VAO*)*}***}*
%toString_adhoc_W1N0cmluZyosVkFPKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosVkFPKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %VAO*)*}***, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**** %toString_adhoc_W1N0cmluZyosVkFPKl0Ptr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr


%tzone1482 = load i8*, i8** %_impzPtr
%zone1483 = bitcast i8* %tzone1482 to %mzone*

; let assign value to symbol s
%sPtr = alloca i8*
%dat1481 = alloca i8, i64 256, align 16

; let value assignment
%s = select i1 true, i8* %dat1481, i8* %dat1481
store i8* %s, i8** %sPtr

; promote local stack var allocations
%tzone1499 = load i8*, i8** %_impzPtr
%zone1500 = bitcast i8* %tzone1499 to %mzone*
%ifptr1484 = alloca i32
%val1485 = load %VAO*, %VAO** %vaoPtr
%val1486 = icmp eq %VAO* %val1485, null
br i1 %val1486, label %then1484, label %else1484

then1484:
%val1487 = load i8*, i8** %sPtr
%var1488 = bitcast [11 x i8]* @gsxtmgl-objects106 to i8*

%val1489 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1487, i8* %var1488)
store i32 %val1489, i32* %ifptr1484
br label %ifcont1484

else1484:
%val1490 = load i8*, i8** %sPtr
%var1491 = bitcast [13 x i8]* @gsxtmgl-objects107 to i8*
%val1492 = load %VAO*, %VAO** %vaoPtr
; tuple ref
%val1493 = getelementptr %VAO, %VAO* %val1492, i64 0, i32 0
%val1494 = load i32, i32* %val1493

%val1495 = call i32 (i8*,i8*, ...) @sprintf(i8* %val1490, i8* %var1491, i32 %val1494)
store i32 %val1495, i32* %ifptr1484
br label %ifcont1484

ifcont1484:
%ifres1496 = load i32, i32* %ifptr1484

%val1497 = load i8*, i8** %sPtr
%res1498 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val1497)
ret %String* %res1498
}
@gsxtmgl-objects112 = hidden constant [88 x i8] c"toString_adhoc_W1N0cmluZyosVkFPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** @toString_adhoc_W1N0cmluZyosVkFPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1520 = load i8*, i8** %_impzPtr
%zone1521 = bitcast i8* %tzone1520 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosVkFPKl0
%dat_toString_adhoc_W1N0cmluZyosVkFPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1521, i64 8)
%toString_adhoc_W1N0cmluZyosVkFPKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosVkFPKl0 to { i8*, i8*, %String* (i8*, i8*, %VAO*)*}***
%tzone1501 = load i8*, i8** %_impzPtr
%zone1502 = bitcast i8* %tzone1501 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1502)
; malloc closure structure
%clsptr1503 = call i8* @llvm_zone_malloc(%mzone* %zone1502, i64 24)
%closure1504 = bitcast i8* %clsptr1503 to { i8*, i8*, %String* (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr1505 = call i8* @llvm_zone_malloc(%mzone* %zone1502, i64 8)
%environment1506 = bitcast i8* %envptr1505 to {{i8*, i8*, %String* (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable1507 = call %clsvar* @new_address_table()
%var1508 = bitcast [35 x i8]* @gsxtmgl-objects110 to i8*
%var1509 = bitcast [42 x i8]* @gsxtmgl-objects111 to i8*
%addytable1510 = call %clsvar* @add_address_table(%mzone* %zone1502, i8* %var1508, i32 0, i8* %var1509, i32 3, %clsvar* %addytable1507)
%address-table1511 = bitcast %clsvar* %addytable1510 to i8*

; insert table, function and environment into closure struct
%closure.table1514 = getelementptr { i8*, i8*, %String* (i8*, i8*, %VAO*)*}, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure1504, i32 0, i32 0
store i8* %address-table1511, i8** %closure.table1514
%closure.env1515 = getelementptr { i8*, i8*, %String* (i8*, i8*, %VAO*)*}, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure1504, i32 0, i32 1
store i8* %envptr1505, i8** %closure.env1515
%closure.func1516 = getelementptr { i8*, i8*, %String* (i8*, i8*, %VAO*)*}, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure1504, i32 0, i32 2
store %String* (i8*, i8*, %VAO*)* @toString_adhoc_W1N0cmluZyosVkFPKl0__1479, %String* (i8*, i8*, %VAO*)** %closure.func1516
%closure_size1517 = call i64 @llvm_zone_mark_size(%mzone* %zone1502)
call void @llvm_zone_ptr_set_size(i8* %clsptr1503, i64 %closure_size1517)
%wrapper_ptr1518 = call i8* @llvm_zone_malloc(%mzone* %zone1502, i64 8)
%closure_wrapper1519 = bitcast i8* %wrapper_ptr1518 to { i8*, i8*, %String* (i8*, i8*, %VAO*)*}**
store { i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure1504, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_wrapper1519

; let value assignment
%toString_adhoc_W1N0cmluZyosVkFPKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_wrapper1519, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_wrapper1519
store { i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %toString_adhoc_W1N0cmluZyosVkFPKl0, { i8*, i8*, %String* (i8*, i8*, %VAO*)*}*** %toString_adhoc_W1N0cmluZyosVkFPKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosVkFPKl0
%tmp_envptr1513 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %VAO*)*}***}* %environment1506, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %VAO*)*}*** %toString_adhoc_W1N0cmluZyosVkFPKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**** %tmp_envptr1513


%val1522 = load {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}*** %toString_adhoc_W1N0cmluZyosVkFPKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %val1522
}


@toString_adhoc_W1N0cmluZyosVkFPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosVkFPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosVkFPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** @toString_adhoc_W1N0cmluZyosVkFPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosVkFPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosVkFPKl0(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VAO*)*,  %String* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosVkFPKl0_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VAO*)*,  %String* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosVkFPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1523 = bitcast [88 x i8]* @gsxtmgl-objects112 to i8*
call i32 (i8*, ...) @printf(i8* %var1523)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VAO*)*,  %String* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosVkFPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %VAO*)*}*, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %VAO*)*}, {i8*, i8*, %String* (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %VAO*)*,  %String* (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects113 = hidden constant [19 x i8] c"Error creating VAO\00"
@gsxtmgl-objects114 = hidden constant [26 x i8] c"VAO_create_adhoc_W1ZBTypd\00"
@gsxtmgl-objects115 = hidden constant [32 x i8] c"{i8*, i8*, %VAO* (i8*, i8*)*}**\00"
define dllexport fastcc %VAO* @VAO_create_adhoc_W1ZBTypd__1524(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1525 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*)*}***}*
%VAO_create_adhoc_W1ZBTypdPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%VAO_create_adhoc_W1ZBTypdPtr = load {i8*, i8*, %VAO* (i8*, i8*)*}***, {i8*, i8*, %VAO* (i8*, i8*)*}**** %VAO_create_adhoc_W1ZBTypdPtr_

; setup arguments


%tzone1528 = load i8*, i8** %_impzPtr
%zone1529 = bitcast i8* %tzone1528 to %mzone*

; let assign value to symbol vao
%vaoPtr = alloca %VAO*
%tzone1531 = load i8*, i8** %_impzPtr
%zone1532 = bitcast i8* %tzone1531 to %mzone*

; let assign value to symbol id
%idPtr = alloca i32*
%dat1526 = call i8* @malloc(i64 4)
call i8* @memset(i8* %dat1526, i32 0, i64 4)
%val1527 = bitcast i8* %dat1526 to %VAO*

; let value assignment
%vao = select i1 true, %VAO* %val1527, %VAO* %val1527
store %VAO* %vao, %VAO** %vaoPtr

%dat1530 = alloca i32, align 16

; let value assignment
%id = select i1 true, i32* %dat1530, i32* %dat1530
store i32* %id, i32** %idPtr

%val1533 = load i32*, i32** %idPtr
call fastcc void @glGenVertexArrays_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val1533)
%var1535 = bitcast [19 x i8]* @gsxtmgl-objects113 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1535)
%val1537 = load %VAO*, %VAO** %vaoPtr
%val1538 = load i32*, i32** %idPtr
; pointer ref
%val1539 = getelementptr i32, i32* %val1538, i64 0
%val1540 = load i32, i32* %val1539
; set tuple
%val1541 = getelementptr %VAO, %VAO* %val1537, i64 0, i32 0
store i32 %val1540, i32* %val1541
%val1542 = load %VAO*, %VAO** %vaoPtr
ret %VAO* %val1542
}
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*)*}** @VAO_create_adhoc_W1ZBTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1562 = load i8*, i8** %_impzPtr
%zone1563 = bitcast i8* %tzone1562 to %mzone*

; let assign value to symbol VAO_create_adhoc_W1ZBTypd
%dat_VAO_create_adhoc_W1ZBTypd = call i8* @llvm_zone_malloc(%mzone* %zone1563, i64 8)
%VAO_create_adhoc_W1ZBTypdPtr = bitcast i8* %dat_VAO_create_adhoc_W1ZBTypd to { i8*, i8*, %VAO* (i8*, i8*)*}***
%tzone1543 = load i8*, i8** %_impzPtr
%zone1544 = bitcast i8* %tzone1543 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1544)
; malloc closure structure
%clsptr1545 = call i8* @llvm_zone_malloc(%mzone* %zone1544, i64 24)
%closure1546 = bitcast i8* %clsptr1545 to { i8*, i8*, %VAO* (i8*, i8*)*}*

; malloc environment structure
%envptr1547 = call i8* @llvm_zone_malloc(%mzone* %zone1544, i64 8)
%environment1548 = bitcast i8* %envptr1547 to {{i8*, i8*, %VAO* (i8*, i8*)*}***}*

; malloc closure address table
%addytable1549 = call %clsvar* @new_address_table()
%var1550 = bitcast [26 x i8]* @gsxtmgl-objects114 to i8*
%var1551 = bitcast [32 x i8]* @gsxtmgl-objects115 to i8*
%addytable1552 = call %clsvar* @add_address_table(%mzone* %zone1544, i8* %var1550, i32 0, i8* %var1551, i32 3, %clsvar* %addytable1549)
%address-table1553 = bitcast %clsvar* %addytable1552 to i8*

; insert table, function and environment into closure struct
%closure.table1556 = getelementptr { i8*, i8*, %VAO* (i8*, i8*)*}, { i8*, i8*, %VAO* (i8*, i8*)*}* %closure1546, i32 0, i32 0
store i8* %address-table1553, i8** %closure.table1556
%closure.env1557 = getelementptr { i8*, i8*, %VAO* (i8*, i8*)*}, { i8*, i8*, %VAO* (i8*, i8*)*}* %closure1546, i32 0, i32 1
store i8* %envptr1547, i8** %closure.env1557
%closure.func1558 = getelementptr { i8*, i8*, %VAO* (i8*, i8*)*}, { i8*, i8*, %VAO* (i8*, i8*)*}* %closure1546, i32 0, i32 2
store %VAO* (i8*, i8*)* @VAO_create_adhoc_W1ZBTypd__1524, %VAO* (i8*, i8*)** %closure.func1558
%closure_size1559 = call i64 @llvm_zone_mark_size(%mzone* %zone1544)
call void @llvm_zone_ptr_set_size(i8* %clsptr1545, i64 %closure_size1559)
%wrapper_ptr1560 = call i8* @llvm_zone_malloc(%mzone* %zone1544, i64 8)
%closure_wrapper1561 = bitcast i8* %wrapper_ptr1560 to { i8*, i8*, %VAO* (i8*, i8*)*}**
store { i8*, i8*, %VAO* (i8*, i8*)*}* %closure1546, { i8*, i8*, %VAO* (i8*, i8*)*}** %closure_wrapper1561

; let value assignment
%VAO_create_adhoc_W1ZBTypd = select i1 true, { i8*, i8*, %VAO* (i8*, i8*)*}** %closure_wrapper1561, { i8*, i8*, %VAO* (i8*, i8*)*}** %closure_wrapper1561
store { i8*, i8*, %VAO* (i8*, i8*)*}** %VAO_create_adhoc_W1ZBTypd, { i8*, i8*, %VAO* (i8*, i8*)*}*** %VAO_create_adhoc_W1ZBTypdPtr

; add data to environment
; don't need to alloc for env var VAO_create_adhoc_W1ZBTypd
%tmp_envptr1555 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*)*}***}* %environment1548, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*)*}*** %VAO_create_adhoc_W1ZBTypdPtr, {i8*, i8*, %VAO* (i8*, i8*)*}**** %tmp_envptr1555


%val1564 = load {i8*, i8*, %VAO* (i8*, i8*)*}**, {i8*, i8*, %VAO* (i8*, i8*)*}*** %VAO_create_adhoc_W1ZBTypdPtr
ret {i8*, i8*, %VAO* (i8*, i8*)*}** %val1564
}


@VAO_create_adhoc_W1ZBTypd_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_create_adhoc_W1ZBTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_create_adhoc_W1ZBTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_create_adhoc_W1ZBTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*)*}** @VAO_create_adhoc_W1ZBTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_create_adhoc_W1ZBTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_create_adhoc_W1ZBTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_create_adhoc_W1ZBTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @VAO_create_adhoc_W1ZBTypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_create_adhoc_W1ZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*)*}*, {i8*, i8*, %VAO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*)*,  %VAO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee)
ret %VAO* %result
}


define dllexport ccc %VAO* @VAO_create_adhoc_W1ZBTypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_create_adhoc_W1ZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*)*}*, {i8*, i8*, %VAO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*)*,  %VAO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee)
ret %VAO* %result
}


define dllexport ccc i8*  @VAO_create_adhoc_W1ZBTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_create_adhoc_W1ZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*)*}*, {i8*, i8*, %VAO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*)*,  %VAO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %VAO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VAO_create_adhoc_W1ZBTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_create_adhoc_W1ZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*)*}*, {i8*, i8*, %VAO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*)*,  %VAO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects116 = hidden constant [18 x i8] c"Error binding VAO\00"
@gsxtmgl-objects117 = hidden constant [28 x i8] c"Error binding VAO attribute\00"
@gsxtmgl-objects118 = hidden constant [29 x i8] c"Error enabling VAO attribute\00"
@gsxtmgl-objects119 = hidden constant [69 x i8] c"VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0\00"
@gsxtmgl-objects120 = hidden constant [65 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**\00"
define dllexport fastcc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0__1565(i8* %_impz,i8* %_impenv, %VAO* %vao, %VBO* %vbo, i32 %index, i32 %size_s_1, i32 %stride, i32 %offset) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1566 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***}*
%VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**** %VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr
%indexPtr = alloca i32
store i32 %index, i32* %indexPtr
%size_s_1Ptr = alloca i32
store i32 %size_s_1, i32* %size_s_1Ptr
%stridePtr = alloca i32
store i32 %stride, i32* %stridePtr
%offsetPtr = alloca i32
store i32 %offset, i32* %offsetPtr


%val1567 = load %VAO*, %VAO** %vaoPtr
%res1568 = call fastcc i32 @VAO_id_adhoc_W2kzMixWQU8qXQ(%VAO* %val1567)
call fastcc void @glBindVertexArray_adhoc_W3ZvaWQsaTMyXQ(i32 %res1568)
%var1570 = bitcast [18 x i8]* @gsxtmgl-objects116 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1570)
%val1572 = load i32, i32* @GL_ARRAY_BUFFER
%val1573 = load %VBO*, %VBO** %vboPtr
%res1574 = call fastcc i32 @VBO_id_adhoc_W2kzMixWQk8qXQ(%VBO* %val1573)
call fastcc void @glBindBuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val1572, i32 %res1574)
%var1576 = bitcast [18 x i8]* @gsxtmgl-objects77 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1576)
%tzone1578 = load i8*, i8** %_impzPtr
%zone1579 = bitcast i8* %tzone1578 to %mzone*

; let assign value to symbol component_size
%component_sizePtr = alloca i32

; let value assignment
%component_size = select i1 true, i32 4, i32 4
store i32 %component_size, i32* %component_sizePtr

%val1580 = load i32, i32* %indexPtr
%val1581 = load i32, i32* %size_s_1Ptr
%val1582 = load %VBO*, %VBO** %vboPtr
%res1583 = call fastcc i32 @VBO_type_adhoc_W2kzMixWQk8qXQ(%VBO* %val1582)
%val1584 = load i8, i8* @GL_FALSE
%val1585 = load i32, i32* %component_sizePtr
%val1586 = load i32, i32* %stridePtr
%val1587 = mul i32 %val1585, %val1586
%val1588 = load i32, i32* %component_sizePtr
%val1589 = load i32, i32* %offsetPtr
%val1590 = mul i32 %val1588, %val1589
%null1591 = bitcast i8* null to i8*
%val1592 = bitcast i8* %null1591 to i8*
; pointer ref
%val1593 = getelementptr i8, i8* %val1592, i32 %val1590
call fastcc void @glVertexAttribPointer_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTgsaTMyLGk4Kl0(i32 %val1580, i32 %val1581, i32 %res1583, i8 %val1584, i32 %val1587, i8* %val1593)
%var1595 = bitcast [28 x i8]* @gsxtmgl-objects117 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1595)
%val1597 = load i32, i32* %indexPtr
call fastcc void @glEnableVertexAttribArray_adhoc_W3ZvaWQsaTMyXQ(i32 %val1597)
%var1599 = bitcast [29 x i8]* @gsxtmgl-objects118 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1599)
call fastcc void @glBindVertexArray_adhoc_W3ZvaWQsaTMyXQ(i32 0)
ret void
}
@gsxtmgl-objects121 = hidden constant [122 x i8] c"VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1621 = load i8*, i8** %_impzPtr
%zone1622 = bitcast i8* %tzone1621 to %mzone*

; let assign value to symbol VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0
%dat_VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone1622, i64 8)
%VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***
%tzone1602 = load i8*, i8** %_impzPtr
%zone1603 = bitcast i8* %tzone1602 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1603)
; malloc closure structure
%clsptr1604 = call i8* @llvm_zone_malloc(%mzone* %zone1603, i64 24)
%closure1605 = bitcast i8* %clsptr1604 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr1606 = call i8* @llvm_zone_malloc(%mzone* %zone1603, i64 8)
%environment1607 = bitcast i8* %envptr1606 to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable1608 = call %clsvar* @new_address_table()
%var1609 = bitcast [69 x i8]* @gsxtmgl-objects119 to i8*
%var1610 = bitcast [65 x i8]* @gsxtmgl-objects120 to i8*
%addytable1611 = call %clsvar* @add_address_table(%mzone* %zone1603, i8* %var1609, i32 0, i8* %var1610, i32 3, %clsvar* %addytable1608)
%address-table1612 = bitcast %clsvar* %addytable1611 to i8*

; insert table, function and environment into closure struct
%closure.table1615 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure1605, i32 0, i32 0
store i8* %address-table1612, i8** %closure.table1615
%closure.env1616 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure1605, i32 0, i32 1
store i8* %envptr1606, i8** %closure.env1616
%closure.func1617 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure1605, i32 0, i32 2
store void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0__1565, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)** %closure.func1617
%closure_size1618 = call i64 @llvm_zone_mark_size(%mzone* %zone1603)
call void @llvm_zone_ptr_set_size(i8* %clsptr1604, i64 %closure_size1618)
%wrapper_ptr1619 = call i8* @llvm_zone_malloc(%mzone* %zone1603, i64 8)
%closure_wrapper1620 = bitcast i8* %wrapper_ptr1619 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure1605, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_wrapper1620

; let value assignment
%VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_wrapper1620, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_wrapper1620
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*** %VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0
%tmp_envptr1614 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}***}* %environment1607, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*** %VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**** %tmp_envptr1614


%val1623 = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*** %VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %val1623
}


@VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret void
}


define dllexport ccc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_native(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
ret void
}


define dllexport ccc i8*  @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1624 = bitcast [122 x i8]* @gsxtmgl-objects121 to i8*
call i32 (i8*, ...) @printf(i8* %var1624)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1625 = bitcast [122 x i8]* @gsxtmgl-objects121 to i8*
call i32 (i8*, ...) @printf(i8* %var1625)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %VBO*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1626 = bitcast [122 x i8]* @gsxtmgl-objects121 to i8*
call i32 (i8*, ...) @printf(i8* %var1626)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1627 = bitcast [122 x i8]* @gsxtmgl-objects121 to i8*
call i32 (i8*, ...) @printf(i8* %var1627)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var1628 = bitcast [122 x i8]* @gsxtmgl-objects121 to i8*
call i32 (i8*, ...) @printf(i8* %var1628)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var1629 = bitcast [122 x i8]* @gsxtmgl-objects121 to i8*
call i32 (i8*, ...) @printf(i8* %var1629)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, %VBO*, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32}, {%VAO*, %VBO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32}, {%VAO*, %VBO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load %VBO*, %VBO** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32}, {%VAO*, %VBO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32}, {%VAO*, %VBO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32}, {%VAO*, %VBO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {%VAO*, %VBO*, i32, i32, i32, i32}, {%VAO*, %VBO*, i32, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects122 = hidden constant [58 x i8] c"VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd\00"
@gsxtmgl-objects123 = hidden constant [55 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**\00"
define dllexport fastcc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd__1630(i8* %_impz,i8* %_impenv, %VAO* %vao, %VBO* %vbo, i32 %index, i32 %size_s_2) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1631 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***}*
%VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***}* %impenv, i32 0, i32 0
%VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**** %VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%vboPtr = alloca %VBO*
store %VBO* %vbo, %VBO** %vboPtr
%indexPtr = alloca i32
store i32 %index, i32* %indexPtr
%size_s_2Ptr = alloca i32
store i32 %size_s_2, i32* %size_s_2Ptr


%val1632 = load %VAO*, %VAO** %vaoPtr
%val1633 = load %VBO*, %VBO** %vboPtr
%val1634 = load i32, i32* %indexPtr
%val1635 = load i32, i32* %size_s_2Ptr
call fastcc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0(%VAO* %val1632, %VBO* %val1633, i32 %val1634, i32 %val1635, i32 0, i32 0)
ret void
}
@gsxtmgl-objects124 = hidden constant [111 x i8] c"VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1656 = load i8*, i8** %_impzPtr
%zone1657 = bitcast i8* %tzone1656 to %mzone*

; let assign value to symbol VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd
%dat_VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone1657, i64 8)
%VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr = bitcast i8* %dat_VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***
%tzone1637 = load i8*, i8** %_impzPtr
%zone1638 = bitcast i8* %tzone1637 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1638)
; malloc closure structure
%clsptr1639 = call i8* @llvm_zone_malloc(%mzone* %zone1638, i64 24)
%closure1640 = bitcast i8* %clsptr1639 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*

; malloc environment structure
%envptr1641 = call i8* @llvm_zone_malloc(%mzone* %zone1638, i64 8)
%environment1642 = bitcast i8* %envptr1641 to {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***}*

; malloc closure address table
%addytable1643 = call %clsvar* @new_address_table()
%var1644 = bitcast [58 x i8]* @gsxtmgl-objects122 to i8*
%var1645 = bitcast [55 x i8]* @gsxtmgl-objects123 to i8*
%addytable1646 = call %clsvar* @add_address_table(%mzone* %zone1638, i8* %var1644, i32 0, i8* %var1645, i32 3, %clsvar* %addytable1643)
%address-table1647 = bitcast %clsvar* %addytable1646 to i8*

; insert table, function and environment into closure struct
%closure.table1650 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure1640, i32 0, i32 0
store i8* %address-table1647, i8** %closure.table1650
%closure.env1651 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure1640, i32 0, i32 1
store i8* %envptr1641, i8** %closure.env1651
%closure.func1652 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure1640, i32 0, i32 2
store void (i8*, i8*, %VAO*, %VBO*, i32, i32)* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd__1630, void (i8*, i8*, %VAO*, %VBO*, i32, i32)** %closure.func1652
%closure_size1653 = call i64 @llvm_zone_mark_size(%mzone* %zone1638)
call void @llvm_zone_ptr_set_size(i8* %clsptr1639, i64 %closure_size1653)
%wrapper_ptr1654 = call i8* @llvm_zone_malloc(%mzone* %zone1638, i64 8)
%closure_wrapper1655 = bitcast i8* %wrapper_ptr1654 to { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure1640, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_wrapper1655

; let value assignment
%VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_wrapper1655, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_wrapper1655
store { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd, { i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*** %VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr

; add data to environment
; don't need to alloc for env var VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd
%tmp_envptr1649 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}***}* %environment1642, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*** %VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**** %tmp_envptr1649


%val1658 = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*** %VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJdPtr
ret {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %val1658
}


@VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3)
ret void
}


define dllexport ccc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_native(%VAO* %arg_0,%VBO* %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3)
ret void
}


define dllexport ccc i8*  @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1659 = bitcast [111 x i8]* @gsxtmgl-objects124 to i8*
call i32 (i8*, ...) @printf(i8* %var1659)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1660 = bitcast [111 x i8]* @gsxtmgl-objects124 to i8*
call i32 (i8*, ...) @printf(i8* %var1660)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %VBO*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1661 = bitcast [111 x i8]* @gsxtmgl-objects124 to i8*
call i32 (i8*, ...) @printf(i8* %var1661)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1662 = bitcast [111 x i8]* @gsxtmgl-objects124 to i8*
call i32 (i8*, ...) @printf(i8* %var1662)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, %VBO*, i32, i32}*
%arg_p_0 = getelementptr {%VAO*, %VBO*, i32, i32}, {%VAO*, %VBO*, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, %VBO*, i32, i32}, {%VAO*, %VBO*, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load %VBO*, %VBO** %arg_p_1
%arg_p_2 = getelementptr {%VAO*, %VBO*, i32, i32}, {%VAO*, %VBO*, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%VAO*, %VBO*, i32, i32}, {%VAO*, %VBO*, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, %VBO*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, %VBO*, i32, i32)*,  void (i8*, i8*, %VAO*, %VBO*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, %VBO* %arg_1, i32 %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects125 = hidden constant [27 x i8] c"Error binding vertex array\00"
@gsxtmgl-objects126 = hidden constant [27 x i8] c"Error drawing vertex array\00"
@gsxtmgl-objects127 = hidden constant [63 x i8] c"VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0\00"
@gsxtmgl-objects128 = hidden constant [53 x i8] c"{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**\00"
define dllexport fastcc void @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0__1663(i8* %_impz,i8* %_impenv, %VAO* %vao, i32 %draw_mode, i32 %first_element, i32 %count) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1664 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***}*
%VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**** %VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr
%draw_modePtr = alloca i32
store i32 %draw_mode, i32* %draw_modePtr
%first_elementPtr = alloca i32
store i32 %first_element, i32* %first_elementPtr
%countPtr = alloca i32
store i32 %count, i32* %countPtr


%val1665 = load %VAO*, %VAO** %vaoPtr
%res1666 = call fastcc i32 @VAO_id_adhoc_W2kzMixWQU8qXQ(%VAO* %val1665)
call fastcc void @glBindVertexArray_adhoc_W3ZvaWQsaTMyXQ(i32 %res1666)
%var1668 = bitcast [27 x i8]* @gsxtmgl-objects125 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1668)
%val1670 = load i32, i32* %draw_modePtr
%val1671 = load i32, i32* %first_elementPtr
%val1672 = load i32, i32* %countPtr
call fastcc void @glDrawArrays_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val1670, i32 %val1671, i32 %val1672)
%var1674 = bitcast [27 x i8]* @gsxtmgl-objects126 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1674)
call fastcc void @glBindVertexArray_adhoc_W3ZvaWQsaTMyXQ(i32 0)
ret void
}
@gsxtmgl-objects129 = hidden constant [116 x i8] c"VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1696 = load i8*, i8** %_impzPtr
%zone1697 = bitcast i8* %tzone1696 to %mzone*

; let assign value to symbol VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0
%dat_VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone1697, i64 8)
%VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0 to { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***
%tzone1677 = load i8*, i8** %_impzPtr
%zone1678 = bitcast i8* %tzone1677 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1678)
; malloc closure structure
%clsptr1679 = call i8* @llvm_zone_malloc(%mzone* %zone1678, i64 24)
%closure1680 = bitcast i8* %clsptr1679 to { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*

; malloc environment structure
%envptr1681 = call i8* @llvm_zone_malloc(%mzone* %zone1678, i64 8)
%environment1682 = bitcast i8* %envptr1681 to {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***}*

; malloc closure address table
%addytable1683 = call %clsvar* @new_address_table()
%var1684 = bitcast [63 x i8]* @gsxtmgl-objects127 to i8*
%var1685 = bitcast [53 x i8]* @gsxtmgl-objects128 to i8*
%addytable1686 = call %clsvar* @add_address_table(%mzone* %zone1678, i8* %var1684, i32 0, i8* %var1685, i32 3, %clsvar* %addytable1683)
%address-table1687 = bitcast %clsvar* %addytable1686 to i8*

; insert table, function and environment into closure struct
%closure.table1690 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure1680, i32 0, i32 0
store i8* %address-table1687, i8** %closure.table1690
%closure.env1691 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure1680, i32 0, i32 1
store i8* %envptr1681, i8** %closure.env1691
%closure.func1692 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure1680, i32 0, i32 2
store void (i8*, i8*, %VAO*, i32, i32, i32)* @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0__1663, void (i8*, i8*, %VAO*, i32, i32, i32)** %closure.func1692
%closure_size1693 = call i64 @llvm_zone_mark_size(%mzone* %zone1678)
call void @llvm_zone_ptr_set_size(i8* %clsptr1679, i64 %closure_size1693)
%wrapper_ptr1694 = call i8* @llvm_zone_malloc(%mzone* %zone1678, i64 8)
%closure_wrapper1695 = bitcast i8* %wrapper_ptr1694 to { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure1680, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_wrapper1695

; let value assignment
%VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_wrapper1695, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_wrapper1695
store { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0, { i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*** %VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0
%tmp_envptr1689 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}***}* %environment1682, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*** %VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**** %tmp_envptr1689


%val1698 = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*** %VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %val1698
}


@VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0(%VAO* %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32, i32, i32)*,  void (i8*, i8*, %VAO*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret void
}


define dllexport ccc void @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_native(%VAO* %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32, i32, i32)*,  void (i8*, i8*, %VAO*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
ret void
}


define dllexport ccc i8*  @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1699 = bitcast [116 x i8]* @gsxtmgl-objects129 to i8*
call i32 (i8*, ...) @printf(i8* %var1699)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1700 = bitcast [116 x i8]* @gsxtmgl-objects129 to i8*
call i32 (i8*, ...) @printf(i8* %var1700)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1701 = bitcast [116 x i8]* @gsxtmgl-objects129 to i8*
call i32 (i8*, ...) @printf(i8* %var1701)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1702 = bitcast [116 x i8]* @gsxtmgl-objects129 to i8*
call i32 (i8*, ...) @printf(i8* %var1702)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32, i32, i32)*,  void (i8*, i8*, %VAO*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*, i32, i32, i32}*
%arg_p_0 = getelementptr {%VAO*, i32, i32, i32}, {%VAO*, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
%arg_p_1 = getelementptr {%VAO*, i32, i32, i32}, {%VAO*, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {%VAO*, i32, i32, i32}, {%VAO*, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {%VAO*, i32, i32, i32}, {%VAO*, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_bind_and_draw_arrays_adhoc_W3ZvaWQsVkFPKixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}*, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}, {i8*, i8*, void (i8*, i8*, %VAO*, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*, i32, i32, i32)*,  void (i8*, i8*, %VAO*, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects130 = hidden constant [19 x i8] c"Error deleting VAO\00"
@gsxtmgl-objects131 = hidden constant [33 x i8] c"VAO_delete_adhoc_W3ZvaWQsVkFPKl0\00"
define dllexport fastcc void @VAO_delete_adhoc_W3ZvaWQsVkFPKl0__1703(i8* %_impz,i8* %_impenv, %VAO* %vao) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1704 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}*
%VAO_delete_adhoc_W3ZvaWQsVkFPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}* %impenv, i32 0, i32 0
%VAO_delete_adhoc_W3ZvaWQsVkFPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %VAO*)*}***, {i8*, i8*, void (i8*, i8*, %VAO*)*}**** %VAO_delete_adhoc_W3ZvaWQsVkFPKl0Ptr_

; setup arguments
%vaoPtr = alloca %VAO*
store %VAO* %vao, %VAO** %vaoPtr


%tzone1706 = load i8*, i8** %_impzPtr
%zone1707 = bitcast i8* %tzone1706 to %mzone*

; let assign value to symbol id
%idPtr = alloca i32*
%dat1705 = alloca i32, align 16

; let value assignment
%id = select i1 true, i32* %dat1705, i32* %dat1705
store i32* %id, i32** %idPtr

%val1708 = load i32*, i32** %idPtr
%val1709 = load %VAO*, %VAO** %vaoPtr
%res1710 = call fastcc i32 @VAO_id_adhoc_W2kzMixWQU8qXQ(%VAO* %val1709)
; set pointer
%val1711 = getelementptr i32, i32* %val1708, i64 0
store i32 %res1710, i32* %val1711
%val1712 = load i32*, i32** %idPtr
call fastcc void @glDeleteVertexArrays_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val1712)
%var1714 = bitcast [19 x i8]* @gsxtmgl-objects130 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1714)
%val1716 = load %VAO*, %VAO** %vaoPtr
%val1717 = bitcast %VAO* %val1716 to i8*
call ccc void @free(i8* %val1717)
ret void
}
@gsxtmgl-objects132 = hidden constant [86 x i8] c"VAO_delete_adhoc_W3ZvaWQsVkFPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %VAO*)*}** @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1738 = load i8*, i8** %_impzPtr
%zone1739 = bitcast i8* %tzone1738 to %mzone*

; let assign value to symbol VAO_delete_adhoc_W3ZvaWQsVkFPKl0
%dat_VAO_delete_adhoc_W3ZvaWQsVkFPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone1739, i64 8)
%VAO_delete_adhoc_W3ZvaWQsVkFPKl0Ptr = bitcast i8* %dat_VAO_delete_adhoc_W3ZvaWQsVkFPKl0 to { i8*, i8*, void (i8*, i8*, %VAO*)*}***
%tzone1719 = load i8*, i8** %_impzPtr
%zone1720 = bitcast i8* %tzone1719 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1720)
; malloc closure structure
%clsptr1721 = call i8* @llvm_zone_malloc(%mzone* %zone1720, i64 24)
%closure1722 = bitcast i8* %clsptr1721 to { i8*, i8*, void (i8*, i8*, %VAO*)*}*

; malloc environment structure
%envptr1723 = call i8* @llvm_zone_malloc(%mzone* %zone1720, i64 8)
%environment1724 = bitcast i8* %envptr1723 to {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}*

; malloc closure address table
%addytable1725 = call %clsvar* @new_address_table()
%var1726 = bitcast [33 x i8]* @gsxtmgl-objects131 to i8*
%var1727 = bitcast [38 x i8]* @gsxtmgl-objects98 to i8*
%addytable1728 = call %clsvar* @add_address_table(%mzone* %zone1720, i8* %var1726, i32 0, i8* %var1727, i32 3, %clsvar* %addytable1725)
%address-table1729 = bitcast %clsvar* %addytable1728 to i8*

; insert table, function and environment into closure struct
%closure.table1732 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1722, i32 0, i32 0
store i8* %address-table1729, i8** %closure.table1732
%closure.env1733 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1722, i32 0, i32 1
store i8* %envptr1723, i8** %closure.env1733
%closure.func1734 = getelementptr { i8*, i8*, void (i8*, i8*, %VAO*)*}, { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1722, i32 0, i32 2
store void (i8*, i8*, %VAO*)* @VAO_delete_adhoc_W3ZvaWQsVkFPKl0__1703, void (i8*, i8*, %VAO*)** %closure.func1734
%closure_size1735 = call i64 @llvm_zone_mark_size(%mzone* %zone1720)
call void @llvm_zone_ptr_set_size(i8* %clsptr1721, i64 %closure_size1735)
%wrapper_ptr1736 = call i8* @llvm_zone_malloc(%mzone* %zone1720, i64 8)
%closure_wrapper1737 = bitcast i8* %wrapper_ptr1736 to { i8*, i8*, void (i8*, i8*, %VAO*)*}**
store { i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure1722, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper1737

; let value assignment
%VAO_delete_adhoc_W3ZvaWQsVkFPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper1737, { i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_wrapper1737
store { i8*, i8*, void (i8*, i8*, %VAO*)*}** %VAO_delete_adhoc_W3ZvaWQsVkFPKl0, { i8*, i8*, void (i8*, i8*, %VAO*)*}*** %VAO_delete_adhoc_W3ZvaWQsVkFPKl0Ptr

; add data to environment
; don't need to alloc for env var VAO_delete_adhoc_W3ZvaWQsVkFPKl0
%tmp_envptr1731 = getelementptr {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}, {{i8*, i8*, void (i8*, i8*, %VAO*)*}***}* %environment1724, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %VAO*)*}*** %VAO_delete_adhoc_W3ZvaWQsVkFPKl0Ptr, {i8*, i8*, void (i8*, i8*, %VAO*)*}**** %tmp_envptr1731


%val1740 = load {i8*, i8*, void (i8*, i8*, %VAO*)*}**, {i8*, i8*, void (i8*, i8*, %VAO*)*}*** %VAO_delete_adhoc_W3ZvaWQsVkFPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %VAO*)*}** %val1740
}


@VAO_delete_adhoc_W3ZvaWQsVkFPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_delete_adhoc_W3ZvaWQsVkFPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %VAO*)*}** @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @VAO_delete_adhoc_W3ZvaWQsVkFPKl0(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret void
}


define dllexport ccc void @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_native(%VAO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
ret void
}


define dllexport ccc i8*  @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1741 = bitcast [86 x i8]* @gsxtmgl-objects132 to i8*
call i32 (i8*, ...) @printf(i8* %var1741)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %VAO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%VAO*}*
%arg_p_0 = getelementptr {%VAO*}, {%VAO*}* %fstruct, i32 0, i32 0
%arg_0 = load %VAO*, %VAO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_delete_adhoc_W3ZvaWQsVkFPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %VAO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %VAO*)*}*, {i8*, i8*, void (i8*, i8*, %VAO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %VAO*)*}, {i8*, i8*, void (i8*, i8*, %VAO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %VAO*)*,  void (i8*, i8*, %VAO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %VAO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects133 = hidden constant [34 x i8] c"VAO_create_ss_quad_adhoc_W1ZBTypd\00"
define dllexport fastcc %VAO* @VAO_create_ss_quad_adhoc_W1ZBTypd__1742(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1743 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %VAO* (i8*, i8*)*}***}*
%VAO_create_ss_quad_adhoc_W1ZBTypdPtr_ = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%VAO_create_ss_quad_adhoc_W1ZBTypdPtr = load {i8*, i8*, %VAO* (i8*, i8*)*}***, {i8*, i8*, %VAO* (i8*, i8*)*}**** %VAO_create_ss_quad_adhoc_W1ZBTypdPtr_

; setup arguments


%tzone1745 = load i8*, i8** %_impzPtr
%zone1746 = bitcast i8* %tzone1745 to %mzone*

; let assign value to symbol ss_quad_pos_st
%ss_quad_pos_stPtr = alloca float*
%dat1744 = alloca float, i64 16, align 16

; let value assignment
%ss_quad_pos_st = select i1 true, float* %dat1744, float* %dat1744
store float* %ss_quad_pos_st, float** %ss_quad_pos_stPtr

%val1747 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1748 = getelementptr float, float* %val1747, i64 0
store float 0xbff0000000000000, float* %val1748
%val1749 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1750 = getelementptr float, float* %val1749, i64 1
store float 0xbff0000000000000, float* %val1750
%val1751 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1752 = getelementptr float, float* %val1751, i64 2
store float 0x0, float* %val1752
%val1753 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1754 = getelementptr float, float* %val1753, i64 3
store float 0x0, float* %val1754
%val1755 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1756 = getelementptr float, float* %val1755, i64 4
store float 0xbff0000000000000, float* %val1756
%val1757 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1758 = getelementptr float, float* %val1757, i64 5
store float 0x3ff0000000000000, float* %val1758
%val1759 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1760 = getelementptr float, float* %val1759, i64 6
store float 0x0, float* %val1760
%val1761 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1762 = getelementptr float, float* %val1761, i64 7
store float 0x3ff0000000000000, float* %val1762
%val1763 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1764 = getelementptr float, float* %val1763, i64 8
store float 0x3ff0000000000000, float* %val1764
%val1765 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1766 = getelementptr float, float* %val1765, i64 9
store float 0xbff0000000000000, float* %val1766
%val1767 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1768 = getelementptr float, float* %val1767, i64 10
store float 0x3ff0000000000000, float* %val1768
%val1769 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1770 = getelementptr float, float* %val1769, i64 11
store float 0x0, float* %val1770
%val1771 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1772 = getelementptr float, float* %val1771, i64 12
store float 0x3ff0000000000000, float* %val1772
%val1773 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1774 = getelementptr float, float* %val1773, i64 13
store float 0x3ff0000000000000, float* %val1774
%val1775 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1776 = getelementptr float, float* %val1775, i64 14
store float 0x3ff0000000000000, float* %val1776
%val1777 = load float*, float** %ss_quad_pos_stPtr
; set pointer
%val1778 = getelementptr float, float* %val1777, i64 15
store float 0x3ff0000000000000, float* %val1778
%tzone1781 = load i8*, i8** %_impzPtr
%zone1782 = bitcast i8* %tzone1781 to %mzone*

; let assign value to symbol vbo
%vboPtr = alloca %VBO*
%tzone1784 = load i8*, i8** %_impzPtr
%zone1785 = bitcast i8* %tzone1784 to %mzone*

; let assign value to symbol vao
%vaoPtr = alloca %VAO*
%val1779 = load float*, float** %ss_quad_pos_stPtr
%res1780 = call fastcc %VBO* @VBO_create_adhoc_W1ZCTyosZmxvYXQqLGk2NF0(float* %val1779, i64 16)

; let value assignment
%vbo = select i1 true, %VBO* %res1780, %VBO* %res1780
store %VBO* %vbo, %VBO** %vboPtr

%res1783 = call fastcc %VAO* @VAO_create_adhoc_W1ZBTypd()

; let value assignment
%vao = select i1 true, %VAO* %res1783, %VAO* %res1783
store %VAO* %vao, %VAO** %vaoPtr

%val1786 = load %VAO*, %VAO** %vaoPtr
%val1787 = load %VBO*, %VBO** %vboPtr
call fastcc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0(%VAO* %val1786, %VBO* %val1787, i32 0, i32 2, i32 4, i32 0)
%val1789 = load %VAO*, %VAO** %vaoPtr
%val1790 = load %VBO*, %VBO** %vboPtr
call fastcc void @VAO_bind_attribute_adhoc_W3ZvaWQsVkFPKixWQk8qLGkzMixpMzIsaTMyLGkzMl0(%VAO* %val1789, %VBO* %val1790, i32 1, i32 2, i32 4, i32 2)
%val1792 = load %VAO*, %VAO** %vaoPtr
ret %VAO* %val1792
}
define dllexport ccc {i8*, i8*, %VAO* (i8*, i8*)*}** @VAO_create_ss_quad_adhoc_W1ZBTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1812 = load i8*, i8** %_impzPtr
%zone1813 = bitcast i8* %tzone1812 to %mzone*

; let assign value to symbol VAO_create_ss_quad_adhoc_W1ZBTypd
%dat_VAO_create_ss_quad_adhoc_W1ZBTypd = call i8* @llvm_zone_malloc(%mzone* %zone1813, i64 8)
%VAO_create_ss_quad_adhoc_W1ZBTypdPtr = bitcast i8* %dat_VAO_create_ss_quad_adhoc_W1ZBTypd to { i8*, i8*, %VAO* (i8*, i8*)*}***
%tzone1793 = load i8*, i8** %_impzPtr
%zone1794 = bitcast i8* %tzone1793 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1794)
; malloc closure structure
%clsptr1795 = call i8* @llvm_zone_malloc(%mzone* %zone1794, i64 24)
%closure1796 = bitcast i8* %clsptr1795 to { i8*, i8*, %VAO* (i8*, i8*)*}*

; malloc environment structure
%envptr1797 = call i8* @llvm_zone_malloc(%mzone* %zone1794, i64 8)
%environment1798 = bitcast i8* %envptr1797 to {{i8*, i8*, %VAO* (i8*, i8*)*}***}*

; malloc closure address table
%addytable1799 = call %clsvar* @new_address_table()
%var1800 = bitcast [34 x i8]* @gsxtmgl-objects133 to i8*
%var1801 = bitcast [32 x i8]* @gsxtmgl-objects115 to i8*
%addytable1802 = call %clsvar* @add_address_table(%mzone* %zone1794, i8* %var1800, i32 0, i8* %var1801, i32 3, %clsvar* %addytable1799)
%address-table1803 = bitcast %clsvar* %addytable1802 to i8*

; insert table, function and environment into closure struct
%closure.table1806 = getelementptr { i8*, i8*, %VAO* (i8*, i8*)*}, { i8*, i8*, %VAO* (i8*, i8*)*}* %closure1796, i32 0, i32 0
store i8* %address-table1803, i8** %closure.table1806
%closure.env1807 = getelementptr { i8*, i8*, %VAO* (i8*, i8*)*}, { i8*, i8*, %VAO* (i8*, i8*)*}* %closure1796, i32 0, i32 1
store i8* %envptr1797, i8** %closure.env1807
%closure.func1808 = getelementptr { i8*, i8*, %VAO* (i8*, i8*)*}, { i8*, i8*, %VAO* (i8*, i8*)*}* %closure1796, i32 0, i32 2
store %VAO* (i8*, i8*)* @VAO_create_ss_quad_adhoc_W1ZBTypd__1742, %VAO* (i8*, i8*)** %closure.func1808
%closure_size1809 = call i64 @llvm_zone_mark_size(%mzone* %zone1794)
call void @llvm_zone_ptr_set_size(i8* %clsptr1795, i64 %closure_size1809)
%wrapper_ptr1810 = call i8* @llvm_zone_malloc(%mzone* %zone1794, i64 8)
%closure_wrapper1811 = bitcast i8* %wrapper_ptr1810 to { i8*, i8*, %VAO* (i8*, i8*)*}**
store { i8*, i8*, %VAO* (i8*, i8*)*}* %closure1796, { i8*, i8*, %VAO* (i8*, i8*)*}** %closure_wrapper1811

; let value assignment
%VAO_create_ss_quad_adhoc_W1ZBTypd = select i1 true, { i8*, i8*, %VAO* (i8*, i8*)*}** %closure_wrapper1811, { i8*, i8*, %VAO* (i8*, i8*)*}** %closure_wrapper1811
store { i8*, i8*, %VAO* (i8*, i8*)*}** %VAO_create_ss_quad_adhoc_W1ZBTypd, { i8*, i8*, %VAO* (i8*, i8*)*}*** %VAO_create_ss_quad_adhoc_W1ZBTypdPtr

; add data to environment
; don't need to alloc for env var VAO_create_ss_quad_adhoc_W1ZBTypd
%tmp_envptr1805 = getelementptr {{i8*, i8*, %VAO* (i8*, i8*)*}***}, {{i8*, i8*, %VAO* (i8*, i8*)*}***}* %environment1798, i32 0, i32 0
store {i8*, i8*, %VAO* (i8*, i8*)*}*** %VAO_create_ss_quad_adhoc_W1ZBTypdPtr, {i8*, i8*, %VAO* (i8*, i8*)*}**** %tmp_envptr1805


%val1814 = load {i8*, i8*, %VAO* (i8*, i8*)*}**, {i8*, i8*, %VAO* (i8*, i8*)*}*** %VAO_create_ss_quad_adhoc_W1ZBTypdPtr
ret {i8*, i8*, %VAO* (i8*, i8*)*}** %val1814
}


@VAO_create_ss_quad_adhoc_W1ZBTypd_var = dllexport global [1 x i8*] [ i8* null ]

@VAO_create_ss_quad_adhoc_W1ZBTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @VAO_create_ss_quad_adhoc_W1ZBTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @VAO_create_ss_quad_adhoc_W1ZBTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %VAO* (i8*, i8*)*}** @VAO_create_ss_quad_adhoc_W1ZBTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %VAO* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @VAO_create_ss_quad_adhoc_W1ZBTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @VAO_create_ss_quad_adhoc_W1ZBTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_create_ss_quad_adhoc_W1ZBTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %VAO* @VAO_create_ss_quad_adhoc_W1ZBTypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_create_ss_quad_adhoc_W1ZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*)*}*, {i8*, i8*, %VAO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*)*,  %VAO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee)
ret %VAO* %result
}


define dllexport ccc %VAO* @VAO_create_ss_quad_adhoc_W1ZBTypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_create_ss_quad_adhoc_W1ZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*)*}*, {i8*, i8*, %VAO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*)*,  %VAO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee)
ret %VAO* %result
}


define dllexport ccc i8*  @VAO_create_ss_quad_adhoc_W1ZBTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_create_ss_quad_adhoc_W1ZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*)*}*, {i8*, i8*, %VAO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*)*,  %VAO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %VAO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @VAO_create_ss_quad_adhoc_W1ZBTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @VAO_create_ss_quad_adhoc_W1ZBTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %VAO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %VAO* (i8*, i8*)*}*, {i8*, i8*, %VAO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %VAO* (i8*, i8*)*}, {i8*, i8*, %VAO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %VAO* (i8*, i8*)*,  %VAO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %VAO* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects134 = hidden constant [23 x i8] c"Error creating Texture\00"
@gsxtmgl-objects135 = hidden constant [29 x i8] c"Texture_create_adhoc_W2kzMl0\00"
@gsxtmgl-objects136 = hidden constant [30 x i8] c"{i8*, i8*, i32 (i8*, i8*)*}**\00"
define dllexport fastcc i32 @Texture_create_adhoc_W2kzMl0__1815(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1816 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*)*}***}*
%Texture_create_adhoc_W2kzMl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%Texture_create_adhoc_W2kzMl0Ptr = load {i8*, i8*, i32 (i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*)*}**** %Texture_create_adhoc_W2kzMl0Ptr_

; setup arguments


%tzone1818 = load i8*, i8** %_impzPtr
%zone1819 = bitcast i8* %tzone1818 to %mzone*

; let assign value to symbol id
%idPtr = alloca i32*
%dat1817 = alloca i32, align 16

; let value assignment
%id = select i1 true, i32* %dat1817, i32* %dat1817
store i32* %id, i32** %idPtr

%val1820 = load i32*, i32** %idPtr
call fastcc void @glGenTextures_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val1820)
%var1822 = bitcast [23 x i8]* @gsxtmgl-objects134 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1822)
%val1824 = load i32*, i32** %idPtr
; pointer ref
%val1825 = getelementptr i32, i32* %val1824, i64 0
%val1826 = load i32, i32* %val1825
ret i32 %val1826
}
define dllexport ccc {i8*, i8*, i32 (i8*, i8*)*}** @Texture_create_adhoc_W2kzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1846 = load i8*, i8** %_impzPtr
%zone1847 = bitcast i8* %tzone1846 to %mzone*

; let assign value to symbol Texture_create_adhoc_W2kzMl0
%dat_Texture_create_adhoc_W2kzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone1847, i64 8)
%Texture_create_adhoc_W2kzMl0Ptr = bitcast i8* %dat_Texture_create_adhoc_W2kzMl0 to { i8*, i8*, i32 (i8*, i8*)*}***
%tzone1827 = load i8*, i8** %_impzPtr
%zone1828 = bitcast i8* %tzone1827 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1828)
; malloc closure structure
%clsptr1829 = call i8* @llvm_zone_malloc(%mzone* %zone1828, i64 24)
%closure1830 = bitcast i8* %clsptr1829 to { i8*, i8*, i32 (i8*, i8*)*}*

; malloc environment structure
%envptr1831 = call i8* @llvm_zone_malloc(%mzone* %zone1828, i64 8)
%environment1832 = bitcast i8* %envptr1831 to {{i8*, i8*, i32 (i8*, i8*)*}***}*

; malloc closure address table
%addytable1833 = call %clsvar* @new_address_table()
%var1834 = bitcast [29 x i8]* @gsxtmgl-objects135 to i8*
%var1835 = bitcast [30 x i8]* @gsxtmgl-objects136 to i8*
%addytable1836 = call %clsvar* @add_address_table(%mzone* %zone1828, i8* %var1834, i32 0, i8* %var1835, i32 3, %clsvar* %addytable1833)
%address-table1837 = bitcast %clsvar* %addytable1836 to i8*

; insert table, function and environment into closure struct
%closure.table1840 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure1830, i32 0, i32 0
store i8* %address-table1837, i8** %closure.table1840
%closure.env1841 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure1830, i32 0, i32 1
store i8* %envptr1831, i8** %closure.env1841
%closure.func1842 = getelementptr { i8*, i8*, i32 (i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*)*}* %closure1830, i32 0, i32 2
store i32 (i8*, i8*)* @Texture_create_adhoc_W2kzMl0__1815, i32 (i8*, i8*)** %closure.func1842
%closure_size1843 = call i64 @llvm_zone_mark_size(%mzone* %zone1828)
call void @llvm_zone_ptr_set_size(i8* %clsptr1829, i64 %closure_size1843)
%wrapper_ptr1844 = call i8* @llvm_zone_malloc(%mzone* %zone1828, i64 8)
%closure_wrapper1845 = bitcast i8* %wrapper_ptr1844 to { i8*, i8*, i32 (i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*)*}* %closure1830, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper1845

; let value assignment
%Texture_create_adhoc_W2kzMl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper1845, { i8*, i8*, i32 (i8*, i8*)*}** %closure_wrapper1845
store { i8*, i8*, i32 (i8*, i8*)*}** %Texture_create_adhoc_W2kzMl0, { i8*, i8*, i32 (i8*, i8*)*}*** %Texture_create_adhoc_W2kzMl0Ptr

; add data to environment
; don't need to alloc for env var Texture_create_adhoc_W2kzMl0
%tmp_envptr1839 = getelementptr {{i8*, i8*, i32 (i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*)*}***}* %environment1832, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*)*}*** %Texture_create_adhoc_W2kzMl0Ptr, {i8*, i8*, i32 (i8*, i8*)*}**** %tmp_envptr1839


%val1848 = load {i8*, i8*, i32 (i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*)*}*** %Texture_create_adhoc_W2kzMl0Ptr
ret {i8*, i8*, i32 (i8*, i8*)*}** %val1848
}


@Texture_create_adhoc_W2kzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_create_adhoc_W2kzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_create_adhoc_W2kzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_create_adhoc_W2kzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*)*}** @Texture_create_adhoc_W2kzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_create_adhoc_W2kzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_create_adhoc_W2kzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_create_adhoc_W2kzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @Texture_create_adhoc_W2kzMl0() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_create_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
ret i32 %result
}


define dllexport ccc i32 @Texture_create_adhoc_W2kzMl0_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_create_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
ret i32 %result
}


define dllexport ccc i8*  @Texture_create_adhoc_W2kzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_create_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @Texture_create_adhoc_W2kzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_create_adhoc_W2kzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*)*,  i32 (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects137 = hidden constant [23 x i8] c"Error deleting Texture\00"
@gsxtmgl-objects138 = hidden constant [36 x i8] c"Texture_delete_adhoc_W3ZvaWQsaTMyXQ\00"
@gsxtmgl-objects139 = hidden constant [36 x i8] c"{i8*, i8*, void (i8*, i8*, i32)*}**\00"
define dllexport fastcc void @Texture_delete_adhoc_W3ZvaWQsaTMyXQ__1849(i8* %_impz,i8* %_impenv, i32 %tex) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1850 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, i32)*}***}*
%Texture_delete_adhoc_W3ZvaWQsaTMyXQPtr_ = getelementptr {{i8*, i8*, void (i8*, i8*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%Texture_delete_adhoc_W3ZvaWQsaTMyXQPtr = load {i8*, i8*, void (i8*, i8*, i32)*}***, {i8*, i8*, void (i8*, i8*, i32)*}**** %Texture_delete_adhoc_W3ZvaWQsaTMyXQPtr_

; setup arguments
%texPtr = alloca i32
store i32 %tex, i32* %texPtr


%tzone1852 = load i8*, i8** %_impzPtr
%zone1853 = bitcast i8* %tzone1852 to %mzone*

; let assign value to symbol id
%idPtr = alloca i32*
%dat1851 = alloca i32, align 16

; let value assignment
%id = select i1 true, i32* %dat1851, i32* %dat1851
store i32* %id, i32** %idPtr

%val1854 = load i32*, i32** %idPtr
%val1855 = load i32, i32* %texPtr
; set pointer
%val1856 = getelementptr i32, i32* %val1854, i64 0
store i32 %val1855, i32* %val1856
%val1857 = load i32*, i32** %idPtr
call fastcc void @glDeleteTextures_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val1857)
%var1859 = bitcast [23 x i8]* @gsxtmgl-objects137 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1859)
ret void
}
@gsxtmgl-objects140 = hidden constant [89 x i8] c"Texture_delete_adhoc_W3ZvaWQsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, i32)*}** @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1880 = load i8*, i8** %_impzPtr
%zone1881 = bitcast i8* %tzone1880 to %mzone*

; let assign value to symbol Texture_delete_adhoc_W3ZvaWQsaTMyXQ
%dat_Texture_delete_adhoc_W3ZvaWQsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone1881, i64 8)
%Texture_delete_adhoc_W3ZvaWQsaTMyXQPtr = bitcast i8* %dat_Texture_delete_adhoc_W3ZvaWQsaTMyXQ to { i8*, i8*, void (i8*, i8*, i32)*}***
%tzone1861 = load i8*, i8** %_impzPtr
%zone1862 = bitcast i8* %tzone1861 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1862)
; malloc closure structure
%clsptr1863 = call i8* @llvm_zone_malloc(%mzone* %zone1862, i64 24)
%closure1864 = bitcast i8* %clsptr1863 to { i8*, i8*, void (i8*, i8*, i32)*}*

; malloc environment structure
%envptr1865 = call i8* @llvm_zone_malloc(%mzone* %zone1862, i64 8)
%environment1866 = bitcast i8* %envptr1865 to {{i8*, i8*, void (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable1867 = call %clsvar* @new_address_table()
%var1868 = bitcast [36 x i8]* @gsxtmgl-objects138 to i8*
%var1869 = bitcast [36 x i8]* @gsxtmgl-objects139 to i8*
%addytable1870 = call %clsvar* @add_address_table(%mzone* %zone1862, i8* %var1868, i32 0, i8* %var1869, i32 3, %clsvar* %addytable1867)
%address-table1871 = bitcast %clsvar* %addytable1870 to i8*

; insert table, function and environment into closure struct
%closure.table1874 = getelementptr { i8*, i8*, void (i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i32)*}* %closure1864, i32 0, i32 0
store i8* %address-table1871, i8** %closure.table1874
%closure.env1875 = getelementptr { i8*, i8*, void (i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i32)*}* %closure1864, i32 0, i32 1
store i8* %envptr1865, i8** %closure.env1875
%closure.func1876 = getelementptr { i8*, i8*, void (i8*, i8*, i32)*}, { i8*, i8*, void (i8*, i8*, i32)*}* %closure1864, i32 0, i32 2
store void (i8*, i8*, i32)* @Texture_delete_adhoc_W3ZvaWQsaTMyXQ__1849, void (i8*, i8*, i32)** %closure.func1876
%closure_size1877 = call i64 @llvm_zone_mark_size(%mzone* %zone1862)
call void @llvm_zone_ptr_set_size(i8* %clsptr1863, i64 %closure_size1877)
%wrapper_ptr1878 = call i8* @llvm_zone_malloc(%mzone* %zone1862, i64 8)
%closure_wrapper1879 = bitcast i8* %wrapper_ptr1878 to { i8*, i8*, void (i8*, i8*, i32)*}**
store { i8*, i8*, void (i8*, i8*, i32)*}* %closure1864, { i8*, i8*, void (i8*, i8*, i32)*}** %closure_wrapper1879

; let value assignment
%Texture_delete_adhoc_W3ZvaWQsaTMyXQ = select i1 true, { i8*, i8*, void (i8*, i8*, i32)*}** %closure_wrapper1879, { i8*, i8*, void (i8*, i8*, i32)*}** %closure_wrapper1879
store { i8*, i8*, void (i8*, i8*, i32)*}** %Texture_delete_adhoc_W3ZvaWQsaTMyXQ, { i8*, i8*, void (i8*, i8*, i32)*}*** %Texture_delete_adhoc_W3ZvaWQsaTMyXQPtr

; add data to environment
; don't need to alloc for env var Texture_delete_adhoc_W3ZvaWQsaTMyXQ
%tmp_envptr1873 = getelementptr {{i8*, i8*, void (i8*, i8*, i32)*}***}, {{i8*, i8*, void (i8*, i8*, i32)*}***}* %environment1866, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, i32)*}*** %Texture_delete_adhoc_W3ZvaWQsaTMyXQPtr, {i8*, i8*, void (i8*, i8*, i32)*}**** %tmp_envptr1873


%val1882 = load {i8*, i8*, void (i8*, i8*, i32)*}**, {i8*, i8*, void (i8*, i8*, i32)*}*** %Texture_delete_adhoc_W3ZvaWQsaTMyXQPtr
ret {i8*, i8*, void (i8*, i8*, i32)*}** %val1882
}


@Texture_delete_adhoc_W3ZvaWQsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_delete_adhoc_W3ZvaWQsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, i32)*}** @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @Texture_delete_adhoc_W3ZvaWQsaTMyXQ(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret void
}


define dllexport ccc void @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret void
}


define dllexport ccc i8*  @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1883 = bitcast [89 x i8]* @gsxtmgl-objects140 to i8*
call i32 (i8*, ...) @printf(i8* %var1883)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_delete_adhoc_W3ZvaWQsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, void (i8*, i8*, i32)*}*, {i8*, i8*, void (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, i32)*}, {i8*, i8*, void (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, i32)*,  void (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects141 = hidden constant [21 x i8] c"Error: data is null.\00"
@gsxtmgl-objects142 = hidden constant [36 x i8] c"Error: only chan must be 1, 3 or 4.\00"
@gsxtmgl-objects143 = hidden constant [28 x i8] c"couldn't Texture_bind_image\00"
@gsxtmgl-objects144 = hidden constant [72 x i8] c"Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0\00"
@gsxtmgl-objects145 = hidden constant [67 x i8] c"{i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}**\00"
define dllexport fastcc i1 @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0__1884(i8* %_impz,i8* %_impenv, i32 %tex, float* %data, i32 %width, i32 %height, i32 %chan, i32 %wrap, i32 %filter) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1885 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}***}*
%Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}***, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}**** %Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%texPtr = alloca i32
store i32 %tex, i32* %texPtr
%dataPtr = alloca float*
store float* %data, float** %dataPtr
%widthPtr = alloca i32
store i32 %width, i32* %widthPtr
%heightPtr = alloca i32
store i32 %height, i32* %heightPtr
%chanPtr = alloca i32
store i32 %chan, i32* %chanPtr
%wrapPtr = alloca i32
store i32 %wrap, i32* %wrapPtr
%filterPtr = alloca i32
store i32 %filter, i32* %filterPtr

; promote local stack var allocations
%tzone1953 = load i8*, i8** %_impzPtr
%zone1954 = bitcast i8* %tzone1953 to %mzone*
%ifptr1894 = alloca i32
%ifptr1898 = alloca i32
%ifptr1902 = alloca i32

%val1887 = load float*, float** %dataPtr
%val1888 = icmp eq float* %val1887, null
br i1 %val1888, label %then1886, label %else1886

then1886:
%var1889 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var1890 = bitcast [21 x i8]* @gsxtmgl-objects141 to i8*

%val1891 = call i32 (i8*, ...) @printf(i8* %var1889, i8* %var1890)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%res1893 = call ccc i1 @impc_false()
ret i1 %res1893

else1886:
%tzone1910 = load i8*, i8** %_impzPtr
%zone1911 = bitcast i8* %tzone1910 to %mzone*

; let assign value to symbol format_s_3
%format_s_3Ptr = alloca i32
%val1895 = load i32, i32* %chanPtr
%cmp1896 = icmp eq i32 %val1895, 1
br i1 %cmp1896, label %then1894, label %else1894

then1894:
%val1897 = load i32, i32* @GL_RED
store i32 %val1897, i32* %ifptr1894
br label %ifcont1894

else1894:
%val1899 = load i32, i32* %chanPtr
%cmp1900 = icmp eq i32 %val1899, 3
br i1 %cmp1900, label %then1898, label %else1898

then1898:
%val1901 = load i32, i32* @GL_RGB
store i32 %val1901, i32* %ifptr1898
br label %ifcont1898

else1898:
%val1903 = load i32, i32* %chanPtr
%cmp1904 = icmp eq i32 %val1903, 4
br i1 %cmp1904, label %then1902, label %else1902

then1902:
%val1905 = load i32, i32* @GL_RGBA
store i32 %val1905, i32* %ifptr1902
br label %ifcont1902

else1902:
%val1906 = trunc i64 0 to i32
store i32 %val1906, i32* %ifptr1902
br label %ifcont1902

ifcont1902:
%ifres1907 = load i32, i32* %ifptr1902

store i32 %ifres1907, i32* %ifptr1898
br label %ifcont1898

ifcont1898:
%ifres1908 = load i32, i32* %ifptr1898

store i32 %ifres1908, i32* %ifptr1894
br label %ifcont1894

ifcont1894:
%ifres1909 = load i32, i32* %ifptr1894


; let value assignment
%format_s_3 = select i1 true, i32 %ifres1909, i32 %ifres1909
store i32 %format_s_3, i32* %format_s_3Ptr

%val1913 = load i32, i32* %format_s_3Ptr
%cmp1914 = icmp eq i32 %val1913, 0
br i1 %cmp1914, label %then1912, label %else1912

then1912:
%var1915 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var1916 = bitcast [36 x i8]* @gsxtmgl-objects142 to i8*

%val1917 = call i32 (i8*, ...) @printf(i8* %var1915, i8* %var1916)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%res1919 = call ccc i1 @impc_false()
ret i1 %res1919

else1912:
%val1920 = load i32, i32* @GL_TEXTURE0
call fastcc void @glActiveTexture_adhoc_W3ZvaWQsaTMyXQ(i32 %val1920)
%val1922 = load i32, i32* @GL_TEXTURE_2D
%val1923 = load i32, i32* %texPtr
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val1922, i32 %val1923)
%val1925 = load i32, i32* @GL_TEXTURE_2D
%val1926 = load i32, i32* %format_s_3Ptr
%val1927 = load i32, i32* %widthPtr
%val1928 = load i32, i32* %heightPtr
%val1929 = load i32, i32* %format_s_3Ptr
%val1930 = load i32, i32* @GL_FLOAT
%val1931 = load float*, float** %dataPtr
%val1932 = bitcast float* %val1931 to i8*
call fastcc void @glTexImage2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %val1925, i32 0, i32 %val1926, i32 %val1927, i32 %val1928, i32 0, i32 %val1929, i32 %val1930, i8* %val1932)
%val1934 = load i32, i32* @GL_TEXTURE_2D
%val1935 = load i32, i32* @GL_TEXTURE_WRAP_S
%val1936 = load i32, i32* %wrapPtr
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val1934, i32 %val1935, i32 %val1936)
%val1938 = load i32, i32* @GL_TEXTURE_2D
%val1939 = load i32, i32* @GL_TEXTURE_WRAP_T
%val1940 = load i32, i32* %wrapPtr
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val1938, i32 %val1939, i32 %val1940)
%val1942 = load i32, i32* @GL_TEXTURE_2D
%val1943 = load i32, i32* @GL_TEXTURE_MIN_FILTER
%val1944 = load i32, i32* %filterPtr
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val1942, i32 %val1943, i32 %val1944)
%val1946 = load i32, i32* @GL_TEXTURE_2D
%val1947 = load i32, i32* @GL_TEXTURE_MAG_FILTER
%val1948 = load i32, i32* %filterPtr
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val1946, i32 %val1947, i32 %val1948)
%var1950 = bitcast [28 x i8]* @gsxtmgl-objects143 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var1950)
%res1952 = call ccc i1 @impc_true()
ret i1 %res1952
}
@gsxtmgl-objects146 = hidden constant [125 x i8] c"Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}** @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone1974 = load i8*, i8** %_impzPtr
%zone1975 = bitcast i8* %tzone1974 to %mzone*

; let assign value to symbol Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0
%dat_Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone1975, i64 8)
%Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0 to { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}***
%tzone1955 = load i8*, i8** %_impzPtr
%zone1956 = bitcast i8* %tzone1955 to %mzone*
call void @llvm_zone_mark(%mzone* %zone1956)
; malloc closure structure
%clsptr1957 = call i8* @llvm_zone_malloc(%mzone* %zone1956, i64 24)
%closure1958 = bitcast i8* %clsptr1957 to { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr1959 = call i8* @llvm_zone_malloc(%mzone* %zone1956, i64 8)
%environment1960 = bitcast i8* %envptr1959 to {{i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable1961 = call %clsvar* @new_address_table()
%var1962 = bitcast [72 x i8]* @gsxtmgl-objects144 to i8*
%var1963 = bitcast [67 x i8]* @gsxtmgl-objects145 to i8*
%addytable1964 = call %clsvar* @add_address_table(%mzone* %zone1956, i8* %var1962, i32 0, i8* %var1963, i32 3, %clsvar* %addytable1961)
%address-table1965 = bitcast %clsvar* %addytable1964 to i8*

; insert table, function and environment into closure struct
%closure.table1968 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}, { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}* %closure1958, i32 0, i32 0
store i8* %address-table1965, i8** %closure.table1968
%closure.env1969 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}, { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}* %closure1958, i32 0, i32 1
store i8* %envptr1959, i8** %closure.env1969
%closure.func1970 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}, { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}* %closure1958, i32 0, i32 2
store i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)* @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0__1884, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)** %closure.func1970
%closure_size1971 = call i64 @llvm_zone_mark_size(%mzone* %zone1956)
call void @llvm_zone_ptr_set_size(i8* %clsptr1957, i64 %closure_size1971)
%wrapper_ptr1972 = call i8* @llvm_zone_malloc(%mzone* %zone1956, i64 8)
%closure_wrapper1973 = bitcast i8* %wrapper_ptr1972 to { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}* %closure1958, { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}** %closure_wrapper1973

; let value assignment
%Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}** %closure_wrapper1973, { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}** %closure_wrapper1973
store { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}** %Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0, { i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}*** %Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0
%tmp_envptr1967 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}***}* %environment1960, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}*** %Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}**** %tmp_envptr1967


%val1976 = load {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}**, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}*** %Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}** %val1976
}


@Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}** @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %arg_0,float* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*,  i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, float* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i32 %arg_6)
ret i1 %result
}


define dllexport ccc i1 @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_native(i32 %arg_0,float* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*,  i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, float* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i32 %arg_6)
ret i1 %result
}


define dllexport ccc i8*  @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var1977 = bitcast [125 x i8]* @gsxtmgl-objects146 to i8*
call i32 (i8*, ...) @printf(i8* %var1977)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var1978 = bitcast [125 x i8]* @gsxtmgl-objects146 to i8*
call i32 (i8*, ...) @printf(i8* %var1978)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to float*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var1979 = bitcast [125 x i8]* @gsxtmgl-objects146 to i8*
call i32 (i8*, ...) @printf(i8* %var1979)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var1980 = bitcast [125 x i8]* @gsxtmgl-objects146 to i8*
call i32 (i8*, ...) @printf(i8* %var1980)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var1981 = bitcast [125 x i8]* @gsxtmgl-objects146 to i8*
call i32 (i8*, ...) @printf(i8* %var1981)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var1982 = bitcast [125 x i8]* @gsxtmgl-objects146 to i8*
call i32 (i8*, ...) @printf(i8* %var1982)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_integer(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var1983 = bitcast [125 x i8]* @gsxtmgl-objects146 to i8*
call i32 (i8*, ...) @printf(i8* %var1983)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc i32  @i32value(i8* %arg_6_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*,  i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, float* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i32 %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, float*, i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, float*, i32, i32, i32, i32, i32}, {i32, float*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, float*, i32, i32, i32, i32, i32}, {i32, float*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load float*, float** %arg_p_1
%arg_p_2 = getelementptr {i32, float*, i32, i32, i32, i32, i32}, {i32, float*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, float*, i32, i32, i32, i32, i32}, {i32, float*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, float*, i32, i32, i32, i32, i32}, {i32, float*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {i32, float*, i32, i32, i32, i32, i32}, {i32, float*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {i32, float*, i32, i32, i32, i32, i32}, {i32, float*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 6
%arg_6 = load i32, i32* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixmbG9hdCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)*,  i1 (i8*, i8*, i32, float*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, float* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i32 %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects147 = hidden constant [68 x i8] c"Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0\00"
@gsxtmgl-objects148 = hidden constant [64 x i8] c"{i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}**\00"
define dllexport fastcc i1 @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0__1984(i8* %_impz,i8* %_impenv, i32 %tex, i8* %data, i32 %width, i32 %height, i32 %chan, i32 %wrap, i32 %filter) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone1985 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}***}*
%Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}***, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}**** %Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%texPtr = alloca i32
store i32 %tex, i32* %texPtr
%dataPtr = alloca i8*
store i8* %data, i8** %dataPtr
%widthPtr = alloca i32
store i32 %width, i32* %widthPtr
%heightPtr = alloca i32
store i32 %height, i32* %heightPtr
%chanPtr = alloca i32
store i32 %chan, i32* %chanPtr
%wrapPtr = alloca i32
store i32 %wrap, i32* %wrapPtr
%filterPtr = alloca i32
store i32 %filter, i32* %filterPtr

; promote local stack var allocations
%tzone2052 = load i8*, i8** %_impzPtr
%zone2053 = bitcast i8* %tzone2052 to %mzone*
%ifptr1994 = alloca i32
%ifptr1998 = alloca i32
%ifptr2002 = alloca i32

%val1987 = load i8*, i8** %dataPtr
%val1988 = icmp eq i8* %val1987, null
br i1 %val1988, label %then1986, label %else1986

then1986:
%var1989 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var1990 = bitcast [21 x i8]* @gsxtmgl-objects141 to i8*

%val1991 = call i32 (i8*, ...) @printf(i8* %var1989, i8* %var1990)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%res1993 = call ccc i1 @impc_false()
ret i1 %res1993

else1986:
%tzone2010 = load i8*, i8** %_impzPtr
%zone2011 = bitcast i8* %tzone2010 to %mzone*

; let assign value to symbol format_s_4
%format_s_4Ptr = alloca i32
%val1995 = load i32, i32* %chanPtr
%cmp1996 = icmp eq i32 %val1995, 1
br i1 %cmp1996, label %then1994, label %else1994

then1994:
%val1997 = load i32, i32* @GL_RED
store i32 %val1997, i32* %ifptr1994
br label %ifcont1994

else1994:
%val1999 = load i32, i32* %chanPtr
%cmp2000 = icmp eq i32 %val1999, 3
br i1 %cmp2000, label %then1998, label %else1998

then1998:
%val2001 = load i32, i32* @GL_RGB
store i32 %val2001, i32* %ifptr1998
br label %ifcont1998

else1998:
%val2003 = load i32, i32* %chanPtr
%cmp2004 = icmp eq i32 %val2003, 4
br i1 %cmp2004, label %then2002, label %else2002

then2002:
%val2005 = load i32, i32* @GL_RGBA
store i32 %val2005, i32* %ifptr2002
br label %ifcont2002

else2002:
%val2006 = trunc i64 0 to i32
store i32 %val2006, i32* %ifptr2002
br label %ifcont2002

ifcont2002:
%ifres2007 = load i32, i32* %ifptr2002

store i32 %ifres2007, i32* %ifptr1998
br label %ifcont1998

ifcont1998:
%ifres2008 = load i32, i32* %ifptr1998

store i32 %ifres2008, i32* %ifptr1994
br label %ifcont1994

ifcont1994:
%ifres2009 = load i32, i32* %ifptr1994


; let value assignment
%format_s_4 = select i1 true, i32 %ifres2009, i32 %ifres2009
store i32 %format_s_4, i32* %format_s_4Ptr

%val2013 = load i32, i32* %format_s_4Ptr
%cmp2014 = icmp eq i32 %val2013, 0
br i1 %cmp2014, label %then2012, label %else2012

then2012:
%var2015 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var2016 = bitcast [36 x i8]* @gsxtmgl-objects142 to i8*

%val2017 = call i32 (i8*, ...) @printf(i8* %var2015, i8* %var2016)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%res2019 = call ccc i1 @impc_false()
ret i1 %res2019

else2012:
%val2020 = load i32, i32* @GL_TEXTURE0
call fastcc void @glActiveTexture_adhoc_W3ZvaWQsaTMyXQ(i32 %val2020)
%val2022 = load i32, i32* @GL_TEXTURE_2D
%val2023 = load i32, i32* %texPtr
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val2022, i32 %val2023)
%val2025 = load i32, i32* @GL_TEXTURE_2D
%val2026 = load i32, i32* %format_s_4Ptr
%val2027 = load i32, i32* %widthPtr
%val2028 = load i32, i32* %heightPtr
%val2029 = load i32, i32* %format_s_4Ptr
%val2030 = load i32, i32* @GL_UNSIGNED_BYTE
%val2031 = load i8*, i8** %dataPtr
call fastcc void @glTexImage2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %val2025, i32 0, i32 %val2026, i32 %val2027, i32 %val2028, i32 0, i32 %val2029, i32 %val2030, i8* %val2031)
%val2033 = load i32, i32* @GL_TEXTURE_2D
%val2034 = load i32, i32* @GL_TEXTURE_WRAP_S
%val2035 = load i32, i32* %wrapPtr
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val2033, i32 %val2034, i32 %val2035)
%val2037 = load i32, i32* @GL_TEXTURE_2D
%val2038 = load i32, i32* @GL_TEXTURE_WRAP_T
%val2039 = load i32, i32* %wrapPtr
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val2037, i32 %val2038, i32 %val2039)
%val2041 = load i32, i32* @GL_TEXTURE_2D
%val2042 = load i32, i32* @GL_TEXTURE_MIN_FILTER
%val2043 = load i32, i32* %filterPtr
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val2041, i32 %val2042, i32 %val2043)
%val2045 = load i32, i32* @GL_TEXTURE_2D
%val2046 = load i32, i32* @GL_TEXTURE_MAG_FILTER
%val2047 = load i32, i32* %filterPtr
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val2045, i32 %val2046, i32 %val2047)
%var2049 = bitcast [28 x i8]* @gsxtmgl-objects143 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var2049)
%res2051 = call ccc i1 @impc_true()
ret i1 %res2051
}
@gsxtmgl-objects149 = hidden constant [121 x i8] c"Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}** @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2073 = load i8*, i8** %_impzPtr
%zone2074 = bitcast i8* %tzone2073 to %mzone*

; let assign value to symbol Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0
%dat_Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2074, i64 8)
%Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0 to { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}***
%tzone2054 = load i8*, i8** %_impzPtr
%zone2055 = bitcast i8* %tzone2054 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2055)
; malloc closure structure
%clsptr2056 = call i8* @llvm_zone_malloc(%mzone* %zone2055, i64 24)
%closure2057 = bitcast i8* %clsptr2056 to { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr2058 = call i8* @llvm_zone_malloc(%mzone* %zone2055, i64 8)
%environment2059 = bitcast i8* %envptr2058 to {{i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable2060 = call %clsvar* @new_address_table()
%var2061 = bitcast [68 x i8]* @gsxtmgl-objects147 to i8*
%var2062 = bitcast [64 x i8]* @gsxtmgl-objects148 to i8*
%addytable2063 = call %clsvar* @add_address_table(%mzone* %zone2055, i8* %var2061, i32 0, i8* %var2062, i32 3, %clsvar* %addytable2060)
%address-table2064 = bitcast %clsvar* %addytable2063 to i8*

; insert table, function and environment into closure struct
%closure.table2067 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}* %closure2057, i32 0, i32 0
store i8* %address-table2064, i8** %closure.table2067
%closure.env2068 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}* %closure2057, i32 0, i32 1
store i8* %envptr2058, i8** %closure.env2068
%closure.func2069 = getelementptr { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}* %closure2057, i32 0, i32 2
store i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)* @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0__1984, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)** %closure.func2069
%closure_size2070 = call i64 @llvm_zone_mark_size(%mzone* %zone2055)
call void @llvm_zone_ptr_set_size(i8* %clsptr2056, i64 %closure_size2070)
%wrapper_ptr2071 = call i8* @llvm_zone_malloc(%mzone* %zone2055, i64 8)
%closure_wrapper2072 = bitcast i8* %wrapper_ptr2071 to { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}* %closure2057, { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper2072

; let value assignment
%Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper2072, { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper2072
store { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}** %Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0, { i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}*** %Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0
%tmp_envptr2066 = getelementptr {{i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}***}* %environment2059, i32 0, i32 0
store {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}*** %Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}**** %tmp_envptr2066


%val2075 = load {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}**, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}*** %Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}** %val2075
}


@Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}** @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i1 @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %arg_0,i8* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*,  i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i32 %arg_6)
ret i1 %result
}


define dllexport ccc i1 @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_native(i32 %arg_0,i8* %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4,i32 %arg_5,i32 %arg_6) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*,  i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i32 %arg_6)
ret i1 %result
}


define dllexport ccc i8*  @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2076 = bitcast [121 x i8]* @gsxtmgl-objects149 to i8*
call i32 (i8*, ...) @printf(i8* %var2076)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2077 = bitcast [121 x i8]* @gsxtmgl-objects149 to i8*
call i32 (i8*, ...) @printf(i8* %var2077)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2078 = bitcast [121 x i8]* @gsxtmgl-objects149 to i8*
call i32 (i8*, ...) @printf(i8* %var2078)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var2079 = bitcast [121 x i8]* @gsxtmgl-objects149 to i8*
call i32 (i8*, ...) @printf(i8* %var2079)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var2080 = bitcast [121 x i8]* @gsxtmgl-objects149 to i8*
call i32 (i8*, ...) @printf(i8* %var2080)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%arg_5_val = call ccc i8* @list_ref(i8* %_sc, i32 5,i8* %args)
%arg_5_rt_check = call i32 @is_integer(i8* %arg_5_val)
%arg_5_bool = icmp ne i32 %arg_5_rt_check, 0
br i1 %arg_5_bool, label %arg_5_true, label %arg_5_false

arg_5_true:
br label %arg_5_continue

arg_5_false:
%var2081 = bitcast [121 x i8]* @gsxtmgl-objects149 to i8*
call i32 (i8*, ...) @printf(i8* %var2081)
%arg_5_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_5_errret

arg_5_continue:
%arg_5 = call ccc i32  @i32value(i8* %arg_5_val)
%arg_6_val = call ccc i8* @list_ref(i8* %_sc, i32 6,i8* %args)
%arg_6_rt_check = call i32 @is_integer(i8* %arg_6_val)
%arg_6_bool = icmp ne i32 %arg_6_rt_check, 0
br i1 %arg_6_bool, label %arg_6_true, label %arg_6_false

arg_6_true:
br label %arg_6_continue

arg_6_false:
%var2082 = bitcast [121 x i8]* @gsxtmgl-objects149 to i8*
call i32 (i8*, ...) @printf(i8* %var2082)
%arg_6_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_6_errret

arg_6_continue:
%arg_6 = call ccc i32  @i32value(i8* %arg_6_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*,  i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i32 %arg_6)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 %result)
ret i8* %res
}


define dllexport ccc void @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i8*, i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i8*, i32, i32, i32, i32, i32}, {i32, i8*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i8*, i32, i32, i32, i32, i32}, {i32, i8*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i32, i8*, i32, i32, i32, i32, i32}, {i32, i8*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i8*, i32, i32, i32, i32, i32}, {i32, i8*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i8*, i32, i32, i32, i32, i32}, {i32, i8*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
%arg_p_5 = getelementptr {i32, i8*, i32, i32, i32, i32, i32}, {i32, i8*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 5
%arg_5 = load i32, i32* %arg_p_5
%arg_p_6 = getelementptr {i32, i8*, i32, i32, i32, i32, i32}, {i32, i8*, i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 6
%arg_6 = load i32, i32* %arg_p_6
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_data_adhoc_W2kxLGkzMixpOCosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)*,  i1 (i8*, i8*, i32, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i1 %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4, i32 %arg_5, i32 %arg_6)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects150 = hidden constant [44 x i8] c"Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ\00"
@gsxtmgl-objects151 = hidden constant [40 x i8] c"{i8*, i8*, i32 (i8*, i8*, i32, i8*)*}**\00"
define dllexport fastcc i32 @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ__2083(i8* %_impz,i8* %_impenv, i32 %tex, i8* %filename) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2084 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i32, i8*)*}***}*
%Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32, i8*)*}***}* %impenv, i32 0, i32 0
%Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQPtr = load {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}***, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}**** %Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQPtr_

; setup arguments
%texPtr = alloca i32
store i32 %tex, i32* %texPtr
%filenamePtr = alloca i8*
store i8* %filename, i8** %filenamePtr


call ccc void @stbi_set_flip_vertically_on_load(i32 1)
%tzone2087 = load i8*, i8** %_impzPtr
%zone2088 = bitcast i8* %tzone2087 to %mzone*

; let assign value to symbol width_ptr
%width_ptrPtr = alloca i32*
%tzone2090 = load i8*, i8** %_impzPtr
%zone2091 = bitcast i8* %tzone2090 to %mzone*

; let assign value to symbol height_ptr
%height_ptrPtr = alloca i32*
%tzone2093 = load i8*, i8** %_impzPtr
%zone2094 = bitcast i8* %tzone2093 to %mzone*

; let assign value to symbol comp_ptr
%comp_ptrPtr = alloca i32*
%tzone2100 = load i8*, i8** %_impzPtr
%zone2101 = bitcast i8* %tzone2100 to %mzone*

; let assign value to symbol data
%dataPtr = alloca i8*
%dat2086 = alloca i32, align 16

; let value assignment
%width_ptr = select i1 true, i32* %dat2086, i32* %dat2086
store i32* %width_ptr, i32** %width_ptrPtr

%dat2089 = alloca i32, align 16

; let value assignment
%height_ptr = select i1 true, i32* %dat2089, i32* %dat2089
store i32* %height_ptr, i32** %height_ptrPtr

%dat2092 = alloca i32, align 16

; let value assignment
%comp_ptr = select i1 true, i32* %dat2092, i32* %dat2092
store i32* %comp_ptr, i32** %comp_ptrPtr

%val2095 = load i8*, i8** %filenamePtr
%val2096 = load i32*, i32** %width_ptrPtr
%val2097 = load i32*, i32** %height_ptrPtr
%val2098 = load i32*, i32** %comp_ptrPtr
%res2099 = call ccc i8* @stbi_load(i8* %val2095, i32* %val2096, i32* %val2097, i32* %val2098, i32 4)

; let value assignment
%data = select i1 true, i8* %res2099, i8* %res2099
store i8* %data, i8** %dataPtr

%val2103 = load i8*, i8** %dataPtr
%val2104 = icmp eq i8* %val2103, null
br i1 %val2104, label %then2102, label %else2102

then2102:
%res2105 = call ccc i8* @stbi_failure_reason()
call fastcc void @print_adhoc_W3ZvaWQsaTgqXQ(i8* %res2105)
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret i32 -1

else2102:
%val2108 = load i32, i32* @GL_TEXTURE0
call fastcc void @glActiveTexture_adhoc_W3ZvaWQsaTMyXQ(i32 %val2108)
%val2110 = load i32, i32* @GL_TEXTURE_2D
%val2111 = load i32, i32* %texPtr
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val2110, i32 %val2111)
%val2113 = load i32, i32* @GL_TEXTURE_2D
%val2114 = load i32, i32* @GL_RGBA
%val2115 = load i32*, i32** %width_ptrPtr
; pointer ref
%val2116 = getelementptr i32, i32* %val2115, i64 0
%val2117 = load i32, i32* %val2116
%val2118 = load i32*, i32** %height_ptrPtr
; pointer ref
%val2119 = getelementptr i32, i32* %val2118, i64 0
%val2120 = load i32, i32* %val2119
%val2121 = load i32, i32* @GL_RGBA
%val2122 = load i32, i32* @GL_UNSIGNED_BYTE
%val2123 = load i8*, i8** %dataPtr
call fastcc void @glTexImage2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %val2113, i32 0, i32 %val2114, i32 %val2117, i32 %val2120, i32 0, i32 %val2121, i32 %val2122, i8* %val2123)
%val2125 = load i32, i32* @GL_TEXTURE_2D
%val2126 = load i32, i32* @GL_TEXTURE_WRAP_S
%val2127 = load i32, i32* @GL_CLAMP_TO_EDGE
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val2125, i32 %val2126, i32 %val2127)
%val2129 = load i32, i32* @GL_TEXTURE_2D
%val2130 = load i32, i32* @GL_TEXTURE_WRAP_T
%val2131 = load i32, i32* @GL_CLAMP_TO_EDGE
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val2129, i32 %val2130, i32 %val2131)
%val2133 = load i32, i32* @GL_TEXTURE_2D
%val2134 = load i32, i32* @GL_TEXTURE_MIN_FILTER
%val2135 = load i32, i32* @GL_LINEAR
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val2133, i32 %val2134, i32 %val2135)
%val2137 = load i32, i32* @GL_TEXTURE_2D
%val2138 = load i32, i32* @GL_TEXTURE_MAG_FILTER
%val2139 = load i32, i32* @GL_LINEAR
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val2137, i32 %val2138, i32 %val2139)
%var2141 = bitcast [28 x i8]* @gsxtmgl-objects143 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var2141)
%val2143 = load i32, i32* %texPtr
ret i32 %val2143
}
@gsxtmgl-objects152 = hidden constant [97 x i8] c"Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}** @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2163 = load i8*, i8** %_impzPtr
%zone2164 = bitcast i8* %tzone2163 to %mzone*

; let assign value to symbol Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ
%dat_Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2164, i64 8)
%Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQPtr = bitcast i8* %dat_Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ to { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}***
%tzone2144 = load i8*, i8** %_impzPtr
%zone2145 = bitcast i8* %tzone2144 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2145)
; malloc closure structure
%clsptr2146 = call i8* @llvm_zone_malloc(%mzone* %zone2145, i64 24)
%closure2147 = bitcast i8* %clsptr2146 to { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}*

; malloc environment structure
%envptr2148 = call i8* @llvm_zone_malloc(%mzone* %zone2145, i64 8)
%environment2149 = bitcast i8* %envptr2148 to {{i8*, i8*, i32 (i8*, i8*, i32, i8*)*}***}*

; malloc closure address table
%addytable2150 = call %clsvar* @new_address_table()
%var2151 = bitcast [44 x i8]* @gsxtmgl-objects150 to i8*
%var2152 = bitcast [40 x i8]* @gsxtmgl-objects151 to i8*
%addytable2153 = call %clsvar* @add_address_table(%mzone* %zone2145, i8* %var2151, i32 0, i8* %var2152, i32 3, %clsvar* %addytable2150)
%address-table2154 = bitcast %clsvar* %addytable2153 to i8*

; insert table, function and environment into closure struct
%closure.table2157 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}* %closure2147, i32 0, i32 0
store i8* %address-table2154, i8** %closure.table2157
%closure.env2158 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}* %closure2147, i32 0, i32 1
store i8* %envptr2148, i8** %closure.env2158
%closure.func2159 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}* %closure2147, i32 0, i32 2
store i32 (i8*, i8*, i32, i8*)* @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ__2083, i32 (i8*, i8*, i32, i8*)** %closure.func2159
%closure_size2160 = call i64 @llvm_zone_mark_size(%mzone* %zone2145)
call void @llvm_zone_ptr_set_size(i8* %clsptr2146, i64 %closure_size2160)
%wrapper_ptr2161 = call i8* @llvm_zone_malloc(%mzone* %zone2145, i64 8)
%closure_wrapper2162 = bitcast i8* %wrapper_ptr2161 to { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}* %closure2147, { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}** %closure_wrapper2162

; let value assignment
%Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}** %closure_wrapper2162, { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}** %closure_wrapper2162
store { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}** %Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ, { i8*, i8*, i32 (i8*, i8*, i32, i8*)*}*** %Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQPtr

; add data to environment
; don't need to alloc for env var Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ
%tmp_envptr2156 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32, i8*)*}***}* %environment2149, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}*** %Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQPtr, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}**** %tmp_envptr2156


%val2165 = load {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}*** %Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQPtr
ret {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}** %val2165
}


@Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}** @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ(i32 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, i8*)*,  i32 (i8*, i8*, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1)
ret i32 %result
}


define dllexport ccc i32 @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_native(i32 %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, i8*)*,  i32 (i8*, i8*, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2166 = bitcast [97 x i8]* @gsxtmgl-objects152 to i8*
call i32 (i8*, ...) @printf(i8* %var2166)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2167 = bitcast [97 x i8]* @gsxtmgl-objects152 to i8*
call i32 (i8*, ...) @printf(i8* %var2167)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, i8*)*,  i32 (i8*, i8*, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i8*}*
%arg_p_0 = getelementptr {i32, i8*}, {i32, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i8*}, {i32, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_bind_image_adhoc_W2kzMixpMzIsaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i32, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, i8*)*,  i32 (i8*, i8*, i32, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%Shader = type {i32,i32}
@gsxtmgl-objects153 = hidden constant [37 x i8] c"Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0\00"
@gsxtmgl-objects154 = hidden constant [45 x i8] c"{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**\00"
define dllexport fastcc %Shader* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0__2168(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2169 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}*
%Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**** %Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr


%tzone2174 = load i8*, i8** %_impzPtr
%zone2175 = bitcast i8* %tzone2174 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Shader*
%tzone2170 = load i8*, i8** %_impzPtr
%zone2171 = bitcast i8* %tzone2170 to %mzone*
%dat2172 = call i8* @llvm_zone_malloc(%mzone* %zone2171, i64 8)
call i8* @memset(i8* %dat2172, i32 0, i64 8)
%val2173 = bitcast i8* %dat2172 to %Shader*

; let value assignment
%obj = select i1 true, %Shader* %val2173, %Shader* %val2173
store %Shader* %obj, %Shader** %objPtr

%val2176 = load %Shader*, %Shader** %objPtr
%val2177 = load i32, i32* %arg_0Ptr
; set tuple
%val2178 = getelementptr %Shader, %Shader* %val2176, i64 0, i32 0
store i32 %val2177, i32* %val2178
%val2179 = load %Shader*, %Shader** %objPtr
%val2180 = load i32, i32* %arg_1Ptr
; set tuple
%val2181 = getelementptr %Shader, %Shader* %val2179, i64 0, i32 1
store i32 %val2180, i32* %val2181
%val2182 = load %Shader*, %Shader** %objPtr
ret %Shader* %val2182
}
@gsxtmgl-objects155 = hidden constant [90 x i8] c"Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2202 = load i8*, i8** %_impzPtr
%zone2203 = bitcast i8* %tzone2202 to %mzone*

; let assign value to symbol Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0
%dat_Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2203, i64 8)
%Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr = bitcast i8* %dat_Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***
%tzone2183 = load i8*, i8** %_impzPtr
%zone2184 = bitcast i8* %tzone2183 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2184)
; malloc closure structure
%clsptr2185 = call i8* @llvm_zone_malloc(%mzone* %zone2184, i64 24)
%closure2186 = bitcast i8* %clsptr2185 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr2187 = call i8* @llvm_zone_malloc(%mzone* %zone2184, i64 8)
%environment2188 = bitcast i8* %envptr2187 to {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable2189 = call %clsvar* @new_address_table()
%var2190 = bitcast [37 x i8]* @gsxtmgl-objects153 to i8*
%var2191 = bitcast [45 x i8]* @gsxtmgl-objects154 to i8*
%addytable2192 = call %clsvar* @add_address_table(%mzone* %zone2184, i8* %var2190, i32 0, i8* %var2191, i32 3, %clsvar* %addytable2189)
%address-table2193 = bitcast %clsvar* %addytable2192 to i8*

; insert table, function and environment into closure struct
%closure.table2196 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure2186, i32 0, i32 0
store i8* %address-table2193, i8** %closure.table2196
%closure.env2197 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure2186, i32 0, i32 1
store i8* %envptr2187, i8** %closure.env2197
%closure.func2198 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure2186, i32 0, i32 2
store %Shader* (i8*, i8*, i32, i32)* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0__2168, %Shader* (i8*, i8*, i32, i32)** %closure.func2198
%closure_size2199 = call i64 @llvm_zone_mark_size(%mzone* %zone2184)
call void @llvm_zone_ptr_set_size(i8* %clsptr2185, i64 %closure_size2199)
%wrapper_ptr2200 = call i8* @llvm_zone_malloc(%mzone* %zone2184, i64 8)
%closure_wrapper2201 = bitcast i8* %wrapper_ptr2200 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure2186, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper2201

; let value assignment
%Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0 = select i1 true, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper2201, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper2201
store { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0
%tmp_envptr2195 = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}* %environment2188, i32 0, i32 0
store {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**** %tmp_envptr2195


%val2204 = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr
ret {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %val2204
}


@Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc %Shader* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc i8*  @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2205 = bitcast [90 x i8]* @gsxtmgl-objects155 to i8*
call i32 (i8*, ...) @printf(i8* %var2205)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2206 = bitcast [90 x i8]* @gsxtmgl-objects155 to i8*
call i32 (i8*, ...) @printf(i8* %var2206)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast %Shader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects156 = hidden constant [39 x i8] c"Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0\00"
define dllexport fastcc %Shader* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0__2207(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2208 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}*
%Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**** %Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr


%tzone2213 = load i8*, i8** %_impzPtr
%zone2214 = bitcast i8* %tzone2213 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Shader*
%tzone2209 = load i8*, i8** %_impzPtr
%zone2210 = bitcast i8* %tzone2209 to %mzone*
%dat2211 = call i8* @llvm_zone_malloc(%mzone* %zone2210, i64 8)
call i8* @memset(i8* %dat2211, i32 0, i64 8)
%val2212 = bitcast i8* %dat2211 to %Shader*

; let value assignment
%obj = select i1 true, %Shader* %val2212, %Shader* %val2212
store %Shader* %obj, %Shader** %objPtr

%val2215 = load %Shader*, %Shader** %objPtr
%val2216 = load i32, i32* %arg_0Ptr
; set tuple
%val2217 = getelementptr %Shader, %Shader* %val2215, i64 0, i32 0
store i32 %val2216, i32* %val2217
%val2218 = load %Shader*, %Shader** %objPtr
%val2219 = load i32, i32* %arg_1Ptr
; set tuple
%val2220 = getelementptr %Shader, %Shader* %val2218, i64 0, i32 1
store i32 %val2219, i32* %val2220
%val2221 = load %Shader*, %Shader** %objPtr
ret %Shader* %val2221
}
@gsxtmgl-objects157 = hidden constant [92 x i8] c"Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2241 = load i8*, i8** %_impzPtr
%zone2242 = bitcast i8* %tzone2241 to %mzone*

; let assign value to symbol Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0
%dat_Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2242, i64 8)
%Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr = bitcast i8* %dat_Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***
%tzone2222 = load i8*, i8** %_impzPtr
%zone2223 = bitcast i8* %tzone2222 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2223)
; malloc closure structure
%clsptr2224 = call i8* @llvm_zone_malloc(%mzone* %zone2223, i64 24)
%closure2225 = bitcast i8* %clsptr2224 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr2226 = call i8* @llvm_zone_malloc(%mzone* %zone2223, i64 8)
%environment2227 = bitcast i8* %envptr2226 to {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable2228 = call %clsvar* @new_address_table()
%var2229 = bitcast [39 x i8]* @gsxtmgl-objects156 to i8*
%var2230 = bitcast [45 x i8]* @gsxtmgl-objects154 to i8*
%addytable2231 = call %clsvar* @add_address_table(%mzone* %zone2223, i8* %var2229, i32 0, i8* %var2230, i32 3, %clsvar* %addytable2228)
%address-table2232 = bitcast %clsvar* %addytable2231 to i8*

; insert table, function and environment into closure struct
%closure.table2235 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure2225, i32 0, i32 0
store i8* %address-table2232, i8** %closure.table2235
%closure.env2236 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure2225, i32 0, i32 1
store i8* %envptr2226, i8** %closure.env2236
%closure.func2237 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure2225, i32 0, i32 2
store %Shader* (i8*, i8*, i32, i32)* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0__2207, %Shader* (i8*, i8*, i32, i32)** %closure.func2237
%closure_size2238 = call i64 @llvm_zone_mark_size(%mzone* %zone2223)
call void @llvm_zone_ptr_set_size(i8* %clsptr2224, i64 %closure_size2238)
%wrapper_ptr2239 = call i8* @llvm_zone_malloc(%mzone* %zone2223, i64 8)
%closure_wrapper2240 = bitcast i8* %wrapper_ptr2239 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure2225, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper2240

; let value assignment
%Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0 = select i1 true, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper2240, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper2240
store { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0
%tmp_envptr2234 = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}* %environment2227, i32 0, i32 0
store {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**** %tmp_envptr2234


%val2243 = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr
ret {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %val2243
}


@Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc %Shader* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc i8*  @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2244 = bitcast [92 x i8]* @gsxtmgl-objects157 to i8*
call i32 (i8*, ...) @printf(i8* %var2244)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2245 = bitcast [92 x i8]* @gsxtmgl-objects157 to i8*
call i32 (i8*, ...) @printf(i8* %var2245)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast %Shader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_z_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects158 = hidden constant [39 x i8] c"Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0\00"
define dllexport fastcc %Shader* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0__2246(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2247 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}*
%Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**** %Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr


%tzone2250 = load i8*, i8** %_impzPtr
%zone2251 = bitcast i8* %tzone2250 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Shader*
%dat2248 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat2248, i32 0, i64 8)
%val2249 = bitcast i8* %dat2248 to %Shader*

; let value assignment
%obj = select i1 true, %Shader* %val2249, %Shader* %val2249
store %Shader* %obj, %Shader** %objPtr

%val2252 = load %Shader*, %Shader** %objPtr
%val2253 = load i32, i32* %arg_0Ptr
; set tuple
%val2254 = getelementptr %Shader, %Shader* %val2252, i64 0, i32 0
store i32 %val2253, i32* %val2254
%val2255 = load %Shader*, %Shader** %objPtr
%val2256 = load i32, i32* %arg_1Ptr
; set tuple
%val2257 = getelementptr %Shader, %Shader* %val2255, i64 0, i32 1
store i32 %val2256, i32* %val2257
%val2258 = load %Shader*, %Shader** %objPtr
ret %Shader* %val2258
}
@gsxtmgl-objects159 = hidden constant [92 x i8] c"Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2278 = load i8*, i8** %_impzPtr
%zone2279 = bitcast i8* %tzone2278 to %mzone*

; let assign value to symbol Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0
%dat_Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone2279, i64 8)
%Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr = bitcast i8* %dat_Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***
%tzone2259 = load i8*, i8** %_impzPtr
%zone2260 = bitcast i8* %tzone2259 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2260)
; malloc closure structure
%clsptr2261 = call i8* @llvm_zone_malloc(%mzone* %zone2260, i64 24)
%closure2262 = bitcast i8* %clsptr2261 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr2263 = call i8* @llvm_zone_malloc(%mzone* %zone2260, i64 8)
%environment2264 = bitcast i8* %envptr2263 to {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable2265 = call %clsvar* @new_address_table()
%var2266 = bitcast [39 x i8]* @gsxtmgl-objects158 to i8*
%var2267 = bitcast [45 x i8]* @gsxtmgl-objects154 to i8*
%addytable2268 = call %clsvar* @add_address_table(%mzone* %zone2260, i8* %var2266, i32 0, i8* %var2267, i32 3, %clsvar* %addytable2265)
%address-table2269 = bitcast %clsvar* %addytable2268 to i8*

; insert table, function and environment into closure struct
%closure.table2272 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure2262, i32 0, i32 0
store i8* %address-table2269, i8** %closure.table2272
%closure.env2273 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure2262, i32 0, i32 1
store i8* %envptr2263, i8** %closure.env2273
%closure.func2274 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure2262, i32 0, i32 2
store %Shader* (i8*, i8*, i32, i32)* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0__2246, %Shader* (i8*, i8*, i32, i32)** %closure.func2274
%closure_size2275 = call i64 @llvm_zone_mark_size(%mzone* %zone2260)
call void @llvm_zone_ptr_set_size(i8* %clsptr2261, i64 %closure_size2275)
%wrapper_ptr2276 = call i8* @llvm_zone_malloc(%mzone* %zone2260, i64 8)
%closure_wrapper2277 = bitcast i8* %wrapper_ptr2276 to { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
store { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure2262, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper2277

; let value assignment
%Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0 = select i1 true, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper2277, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_wrapper2277
store { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0, { i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0
%tmp_envptr2271 = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}***}* %environment2264, i32 0, i32 0
store {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**** %tmp_envptr2271


%val2280 = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*** %Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0Ptr
ret {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %val2280
}


@Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc %Shader* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc i8*  @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2281 = bitcast [92 x i8]* @gsxtmgl-objects159 to i8*
call i32 (i8*, ...) @printf(i8* %var2281)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2282 = bitcast [92 x i8]* @gsxtmgl-objects159 to i8*
call i32 (i8*, ...) @printf(i8* %var2282)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%tmpres = bitcast %Shader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_h_adhoc_W1NoYWRlciosaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i32, i32)*,  %Shader* (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects160 = hidden constant [14 x i8] c"<Shader:null>\00"
@gsxtmgl-objects161 = hidden constant [9 x i8] c"<Shader:\00"
@gsxtmgl-objects162 = hidden constant [2 x i8] c",\00"
@gsxtmgl-objects163 = hidden constant [2 x i8] c">\00"
@gsxtmgl-objects164 = hidden constant [39 x i8] c"toString_adhoc_W1N0cmluZyosU2hhZGVyKl0\00"
@gsxtmgl-objects165 = hidden constant [45 x i8] c"{i8*, i8*, %String* (i8*, i8*, %Shader*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0__2283(i8* %_impz,i8* %_impenv, %Shader* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2284 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %Shader*)*}***}*
%toString_adhoc_W1N0cmluZyosU2hhZGVyKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosU2hhZGVyKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %Shader*)*}***, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}**** %toString_adhoc_W1N0cmluZyosU2hhZGVyKl0Ptr_

; setup arguments
%xPtr = alloca %Shader*
store %Shader* %x, %Shader** %xPtr


%val2286 = load %Shader*, %Shader** %xPtr
%val2287 = icmp eq %Shader* %val2286, null
br i1 %val2287, label %then2285, label %else2285

then2285:
%zone2288 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone2288)
%zone_ptr2289 = bitcast %mzone* %zone2288 to i8*
store i8* %zone_ptr2289, i8** %_impzPtr
%tzone2299 = load i8*, i8** %_impzPtr
%zone2300 = bitcast i8* %tzone2299 to %mzone*

; let assign value to symbol res0
%res0Ptr = alloca %String*
%tzone2304 = load i8*, i8** %_impzPtr
%zone2305 = bitcast i8* %tzone2304 to %mzone*

; let assign value to symbol zone0
%zone0Ptr = alloca %mzone*
%tzone2307 = load i8*, i8** %_impzPtr
%zone2308 = bitcast i8* %tzone2307 to %mzone*

; let assign value to symbol newz0
%newz0Ptr = alloca %mzone*
%tzone2291 = load i8*, i8** %_impzPtr
%zone2292 = bitcast i8* %tzone2291 to %mzone*

; let assign value to symbol xx_t_mst
%xx_t_mstPtr = alloca i8*
%dat2290 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst = select i1 true, i8* %dat2290, i8* %dat2290
store i8* %xx_t_mst, i8** %xx_t_mstPtr

%val2293 = load i8*, i8** %xx_t_mstPtr
%var2294 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var2295 = bitcast [14 x i8]* @gsxtmgl-objects160 to i8*

%val2296 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2293, i8* %var2294, i8* %var2295)
%val2297 = load i8*, i8** %xx_t_mstPtr
%res2298 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2297)

; let value assignment
%res0 = select i1 true, %String* %res2298, %String* %res2298
store %String* %res0, %String** %res0Ptr

%oldzone2301 = call %mzone* @llvm_pop_zone_stack()
%newzone2302 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2303 = bitcast %mzone* %newzone2302 to i8*
store i8* %zone_ptr2303, i8** %_impzPtr

; let value assignment
%zone0 = select i1 true, %mzone* %oldzone2301, %mzone* %oldzone2301
store %mzone* %zone0, %mzone** %zone0Ptr

%res2306 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz0 = select i1 true, %mzone* %res2306, %mzone* %res2306
store %mzone* %newz0, %mzone** %newz0Ptr

%tzone2313 = load i8*, i8** %_impzPtr
%zone2314 = bitcast i8* %tzone2313 to %mzone*

; let assign value to symbol rescopy0
%rescopy0Ptr = alloca %String*
%tzone2319 = load i8*, i8** %_impzPtr
%zone2320 = bitcast i8* %tzone2319 to %mzone*

; let assign value to symbol hook
%hookPtr = alloca {i64,i8*,i8*}*
%tzone2322 = load i8*, i8** %_impzPtr
%zone2323 = bitcast i8* %tzone2322 to %mzone*

; let assign value to symbol f
%fPtr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val2309 = load %String*, %String** %res0Ptr
%val2310 = load %mzone*, %mzone** %zone0Ptr
%val2311 = load %mzone*, %mzone** %newz0Ptr
%res2312 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val2309, %mzone* %val2310, %mzone* %val2311)

; let value assignment
%rescopy0 = select i1 true, %String* %res2312, %String* %res2312
store %String* %rescopy0, %String** %rescopy0Ptr

%val2315 = load %mzone*, %mzone** %zone0Ptr
; tuple ref
%val2316 = getelementptr %mzone, %mzone* %val2315, i64 0, i32 4
%val2317 = load i8*, i8** %val2316
%val2318 = bitcast i8* %val2317 to {i64,i8*,i8*}*

; let value assignment
%hook = select i1 true, {i64,i8*,i8*}* %val2318, {i64,i8*,i8*}* %val2318
store {i64,i8*,i8*}* %hook, {i64,i8*,i8*}** %hookPtr

%null2321 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null2321, {i8*, i8*, void (i8*, i8*)*}** %null2321
store {i8*, i8*, void (i8*, i8*)*}** %f, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; promote local stack var allocations
%tzone2359 = load i8*, i8** %_impzPtr
%zone2360 = bitcast i8* %tzone2359 to %mzone*
%ifptr2349 = alloca i1
%ifptr2325 = alloca i1
; while loop
%val2326 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2327 = icmp eq {i64,i8*,i8*}* %val2326, null
br i1 %val2327, label %then2325, label %else2325

then2325:
%res2328 = call ccc i1 @impc_false()
store i1 %res2328, i1* %ifptr2325
br label %ifcont2325

else2325:
%res2329 = call ccc i1 @impc_true()
store i1 %res2329, i1* %ifptr2325
br label %ifcont2325

ifcont2325:
%ifres2330 = load i1, i1* %ifptr2325

br i1 %ifres2330, label %loop2324, label %after2324

loop2324:
; do set!
%val2331 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val2332 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2331, i64 0, i32 1
%val2333 = load i8*, i8** %val2332
%val2334 = bitcast i8* %val2333 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val2334, {i8*, i8*, void (i8*, i8*)*}*** %fPtr

; apply closure 
%vval2335 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %fPtr
%val2336 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval2335
%fPtr2337 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2336, i32 0, i32 2
%ePtr2338 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2336, i32 0, i32 1
%f2339 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr2337
%e2340 = load i8*, i8** %ePtr2338
%tzone2341 = load i8*, i8** %_impzPtr
%zone2342 = bitcast i8* %tzone2341 to %mzone*
%z2343 = bitcast %mzone* %zone2342 to i8*
tail call fastcc void %f2339(i8* %z2343, i8* %e2340)
; do set!
%val2345 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
; tuple ref
%val2346 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2345, i64 0, i32 2
%val2347 = load i8*, i8** %val2346
%val2348 = bitcast i8* %val2347 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val2348, {i64,i8*,i8*}** %hookPtr
%val2350 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hookPtr
%val2351 = icmp eq {i64,i8*,i8*}* %val2350, null
br i1 %val2351, label %then2349, label %else2349

then2349:
%res2352 = call ccc i1 @impc_false()
store i1 %res2352, i1* %ifptr2349
br label %ifcont2349

else2349:
%res2353 = call ccc i1 @impc_true()
store i1 %res2353, i1* %ifptr2349
br label %ifcont2349

ifcont2349:
%ifres2354 = load i1, i1* %ifptr2349

br i1 %ifres2354, label %loop2324, label %after2324

after2324:
%val2356 = load %mzone*, %mzone** %zone0Ptr
call ccc void @llvm_zone_destroy(%mzone* %val2356)
%val2358 = load %String*, %String** %rescopy0Ptr
ret %String* %val2358

else2285:
%zone2361 = call %mzone* @llvm_zone_create(i64 1024)
call void @llvm_push_zone_stack(%mzone* %zone2361)
%zone_ptr2362 = bitcast %mzone* %zone2361 to i8*
store i8* %zone_ptr2362, i8** %_impzPtr
%tzone2402 = load i8*, i8** %_impzPtr
%zone2403 = bitcast i8* %tzone2402 to %mzone*

; let assign value to symbol res1
%res1Ptr = alloca %String*
%tzone2407 = load i8*, i8** %_impzPtr
%zone2408 = bitcast i8* %tzone2407 to %mzone*

; let assign value to symbol zone1
%zone1Ptr = alloca %mzone*
%tzone2410 = load i8*, i8** %_impzPtr
%zone2411 = bitcast i8* %tzone2410 to %mzone*

; let assign value to symbol newz1
%newz1Ptr = alloca %mzone*
%tzone2364 = load i8*, i8** %_impzPtr
%zone2365 = bitcast i8* %tzone2364 to %mzone*

; let assign value to symbol xx_t_mst_s_5
%xx_t_mst_s_5Ptr = alloca i8*
%dat2363 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_5 = select i1 true, i8* %dat2363, i8* %dat2363
store i8* %xx_t_mst_s_5, i8** %xx_t_mst_s_5Ptr

%val2366 = load i8*, i8** %xx_t_mst_s_5Ptr
%var2367 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var2368 = bitcast [9 x i8]* @gsxtmgl-objects161 to i8*

%val2369 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2366, i8* %var2367, i8* %var2368)
%val2370 = load i8*, i8** %xx_t_mst_s_5Ptr
%res2371 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2370)
%val2372 = load %Shader*, %Shader** %xPtr
; tuple ref
%val2373 = getelementptr %Shader, %Shader* %val2372, i64 0, i32 0
%val2374 = load i32, i32* %val2373
%res2375 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val2374)
%res2376 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2371, %String* %res2375)
%tzone2378 = load i8*, i8** %_impzPtr
%zone2379 = bitcast i8* %tzone2378 to %mzone*

; let assign value to symbol xx_t_mst_s_6
%xx_t_mst_s_6Ptr = alloca i8*
%dat2377 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_6 = select i1 true, i8* %dat2377, i8* %dat2377
store i8* %xx_t_mst_s_6, i8** %xx_t_mst_s_6Ptr

%val2380 = load i8*, i8** %xx_t_mst_s_6Ptr
%var2381 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var2382 = bitcast [2 x i8]* @gsxtmgl-objects162 to i8*

%val2383 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2380, i8* %var2381, i8* %var2382)
%val2384 = load i8*, i8** %xx_t_mst_s_6Ptr
%res2385 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2384)
%res2386 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2376, %String* %res2385)
%val2387 = load %Shader*, %Shader** %xPtr
; tuple ref
%val2388 = getelementptr %Shader, %Shader* %val2387, i64 0, i32 1
%val2389 = load i32, i32* %val2388
%res2390 = call fastcc %String* @toString_adhoc_W1N0cmluZyosaTMyXQ(i32 %val2389)
%res2391 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2386, %String* %res2390)
%tzone2393 = load i8*, i8** %_impzPtr
%zone2394 = bitcast i8* %tzone2393 to %mzone*

; let assign value to symbol xx_t_mst_s_7
%xx_t_mst_s_7Ptr = alloca i8*
%dat2392 = alloca i8, i64 1024, align 16

; let value assignment
%xx_t_mst_s_7 = select i1 true, i8* %dat2392, i8* %dat2392
store i8* %xx_t_mst_s_7, i8** %xx_t_mst_s_7Ptr

%val2395 = load i8*, i8** %xx_t_mst_s_7Ptr
%var2396 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var2397 = bitcast [2 x i8]* @gsxtmgl-objects163 to i8*

%val2398 = call i32 (i8*,i8*, ...) @sprintf(i8* %val2395, i8* %var2396, i8* %var2397)
%val2399 = load i8*, i8** %xx_t_mst_s_7Ptr
%res2400 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val2399)
%res2401 = call fastcc %String* @cat2_adhoc_W1N0cmluZyosU3RyaW5nKixTdHJpbmcqXQ(%String* %res2391, %String* %res2400)

; let value assignment
%res1 = select i1 true, %String* %res2401, %String* %res2401
store %String* %res1, %String** %res1Ptr

%oldzone2404 = call %mzone* @llvm_pop_zone_stack()
%newzone2405 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2406 = bitcast %mzone* %newzone2405 to i8*
store i8* %zone_ptr2406, i8** %_impzPtr

; let value assignment
%zone1 = select i1 true, %mzone* %oldzone2404, %mzone* %oldzone2404
store %mzone* %zone1, %mzone** %zone1Ptr

%res2409 = call ccc %mzone* @llvm_peek_zone_stack()

; let value assignment
%newz1 = select i1 true, %mzone* %res2409, %mzone* %res2409
store %mzone* %newz1, %mzone** %newz1Ptr

%tzone2416 = load i8*, i8** %_impzPtr
%zone2417 = bitcast i8* %tzone2416 to %mzone*

; let assign value to symbol rescopy1
%rescopy1Ptr = alloca %String*
%tzone2422 = load i8*, i8** %_impzPtr
%zone2423 = bitcast i8* %tzone2422 to %mzone*

; let assign value to symbol hook_s_8
%hook_s_8Ptr = alloca {i64,i8*,i8*}*
%tzone2425 = load i8*, i8** %_impzPtr
%zone2426 = bitcast i8* %tzone2425 to %mzone*

; let assign value to symbol f_s_9
%f_s_9Ptr = alloca {i8*, i8*, void (i8*, i8*)*}**
%val2412 = load %String*, %String** %res1Ptr
%val2413 = load %mzone*, %mzone** %zone1Ptr
%val2414 = load %mzone*, %mzone** %newz1Ptr
%res2415 = call fastcc %String* @zcopy_adhoc_W1N0cmluZyosU3RyaW5nKixtem9uZSosbXpvbmUqXQ(%String* %val2412, %mzone* %val2413, %mzone* %val2414)

; let value assignment
%rescopy1 = select i1 true, %String* %res2415, %String* %res2415
store %String* %rescopy1, %String** %rescopy1Ptr

%val2418 = load %mzone*, %mzone** %zone1Ptr
; tuple ref
%val2419 = getelementptr %mzone, %mzone* %val2418, i64 0, i32 4
%val2420 = load i8*, i8** %val2419
%val2421 = bitcast i8* %val2420 to {i64,i8*,i8*}*

; let value assignment
%hook_s_8 = select i1 true, {i64,i8*,i8*}* %val2421, {i64,i8*,i8*}* %val2421
store {i64,i8*,i8*}* %hook_s_8, {i64,i8*,i8*}** %hook_s_8Ptr

%null2424 = bitcast i8* null to {i8*, i8*, void (i8*, i8*)*}**

; let value assignment
%f_s_9 = select i1 true, {i8*, i8*, void (i8*, i8*)*}** %null2424, {i8*, i8*, void (i8*, i8*)*}** %null2424
store {i8*, i8*, void (i8*, i8*)*}** %f_s_9, {i8*, i8*, void (i8*, i8*)*}*** %f_s_9Ptr

; promote local stack var allocations
%tzone2462 = load i8*, i8** %_impzPtr
%zone2463 = bitcast i8* %tzone2462 to %mzone*
%ifptr2452 = alloca i1
%ifptr2428 = alloca i1
; while loop
%val2429 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_8Ptr
%val2430 = icmp eq {i64,i8*,i8*}* %val2429, null
br i1 %val2430, label %then2428, label %else2428

then2428:
%res2431 = call ccc i1 @impc_false()
store i1 %res2431, i1* %ifptr2428
br label %ifcont2428

else2428:
%res2432 = call ccc i1 @impc_true()
store i1 %res2432, i1* %ifptr2428
br label %ifcont2428

ifcont2428:
%ifres2433 = load i1, i1* %ifptr2428

br i1 %ifres2433, label %loop2427, label %after2427

loop2427:
; do set!
%val2434 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_8Ptr
; tuple ref
%val2435 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2434, i64 0, i32 1
%val2436 = load i8*, i8** %val2435
%val2437 = bitcast i8* %val2436 to {i8*, i8*, void (i8*, i8*)*}**
store {i8*, i8*, void (i8*, i8*)*}** %val2437, {i8*, i8*, void (i8*, i8*)*}*** %f_s_9Ptr

; apply closure 
%vval2438 = load {i8*, i8*, void (i8*, i8*)*}**, {i8*, i8*, void (i8*, i8*)*}*** %f_s_9Ptr
%val2439 = load {i8*, i8*, void (i8*, i8*)*}*,{i8*, i8*, void (i8*, i8*)*}** %vval2438
%fPtr2440 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2439, i32 0, i32 2
%ePtr2441 = getelementptr {i8*, i8*, void (i8*, i8*)*}, {i8*, i8*, void (i8*, i8*)*}* %val2439, i32 0, i32 1
%f2442 = load void (i8*, i8*)*, void (i8*, i8*)** %fPtr2440
%e2443 = load i8*, i8** %ePtr2441
%tzone2444 = load i8*, i8** %_impzPtr
%zone2445 = bitcast i8* %tzone2444 to %mzone*
%z2446 = bitcast %mzone* %zone2445 to i8*
tail call fastcc void %f2442(i8* %z2446, i8* %e2443)
; do set!
%val2448 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_8Ptr
; tuple ref
%val2449 = getelementptr {i64,i8*,i8*}, {i64,i8*,i8*}* %val2448, i64 0, i32 2
%val2450 = load i8*, i8** %val2449
%val2451 = bitcast i8* %val2450 to {i64,i8*,i8*}*
store {i64,i8*,i8*}* %val2451, {i64,i8*,i8*}** %hook_s_8Ptr
%val2453 = load {i64,i8*,i8*}*, {i64,i8*,i8*}** %hook_s_8Ptr
%val2454 = icmp eq {i64,i8*,i8*}* %val2453, null
br i1 %val2454, label %then2452, label %else2452

then2452:
%res2455 = call ccc i1 @impc_false()
store i1 %res2455, i1* %ifptr2452
br label %ifcont2452

else2452:
%res2456 = call ccc i1 @impc_true()
store i1 %res2456, i1* %ifptr2452
br label %ifcont2452

ifcont2452:
%ifres2457 = load i1, i1* %ifptr2452

br i1 %ifres2457, label %loop2427, label %after2427

after2427:
%val2459 = load %mzone*, %mzone** %zone1Ptr
call ccc void @llvm_zone_destroy(%mzone* %val2459)
%val2461 = load %String*, %String** %rescopy1Ptr
ret %String* %val2461
}
@gsxtmgl-objects166 = hidden constant [92 x i8] c"toString_adhoc_W1N0cmluZyosU2hhZGVyKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %Shader*)*}** @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2483 = load i8*, i8** %_impzPtr
%zone2484 = bitcast i8* %tzone2483 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosU2hhZGVyKl0
%dat_toString_adhoc_W1N0cmluZyosU2hhZGVyKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2484, i64 8)
%toString_adhoc_W1N0cmluZyosU2hhZGVyKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosU2hhZGVyKl0 to { i8*, i8*, %String* (i8*, i8*, %Shader*)*}***
%tzone2464 = load i8*, i8** %_impzPtr
%zone2465 = bitcast i8* %tzone2464 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2465)
; malloc closure structure
%clsptr2466 = call i8* @llvm_zone_malloc(%mzone* %zone2465, i64 24)
%closure2467 = bitcast i8* %clsptr2466 to { i8*, i8*, %String* (i8*, i8*, %Shader*)*}*

; malloc environment structure
%envptr2468 = call i8* @llvm_zone_malloc(%mzone* %zone2465, i64 8)
%environment2469 = bitcast i8* %envptr2468 to {{i8*, i8*, %String* (i8*, i8*, %Shader*)*}***}*

; malloc closure address table
%addytable2470 = call %clsvar* @new_address_table()
%var2471 = bitcast [39 x i8]* @gsxtmgl-objects164 to i8*
%var2472 = bitcast [45 x i8]* @gsxtmgl-objects165 to i8*
%addytable2473 = call %clsvar* @add_address_table(%mzone* %zone2465, i8* %var2471, i32 0, i8* %var2472, i32 3, %clsvar* %addytable2470)
%address-table2474 = bitcast %clsvar* %addytable2473 to i8*

; insert table, function and environment into closure struct
%closure.table2477 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Shader*)*}, { i8*, i8*, %String* (i8*, i8*, %Shader*)*}* %closure2467, i32 0, i32 0
store i8* %address-table2474, i8** %closure.table2477
%closure.env2478 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Shader*)*}, { i8*, i8*, %String* (i8*, i8*, %Shader*)*}* %closure2467, i32 0, i32 1
store i8* %envptr2468, i8** %closure.env2478
%closure.func2479 = getelementptr { i8*, i8*, %String* (i8*, i8*, %Shader*)*}, { i8*, i8*, %String* (i8*, i8*, %Shader*)*}* %closure2467, i32 0, i32 2
store %String* (i8*, i8*, %Shader*)* @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0__2283, %String* (i8*, i8*, %Shader*)** %closure.func2479
%closure_size2480 = call i64 @llvm_zone_mark_size(%mzone* %zone2465)
call void @llvm_zone_ptr_set_size(i8* %clsptr2466, i64 %closure_size2480)
%wrapper_ptr2481 = call i8* @llvm_zone_malloc(%mzone* %zone2465, i64 8)
%closure_wrapper2482 = bitcast i8* %wrapper_ptr2481 to { i8*, i8*, %String* (i8*, i8*, %Shader*)*}**
store { i8*, i8*, %String* (i8*, i8*, %Shader*)*}* %closure2467, { i8*, i8*, %String* (i8*, i8*, %Shader*)*}** %closure_wrapper2482

; let value assignment
%toString_adhoc_W1N0cmluZyosU2hhZGVyKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %Shader*)*}** %closure_wrapper2482, { i8*, i8*, %String* (i8*, i8*, %Shader*)*}** %closure_wrapper2482
store { i8*, i8*, %String* (i8*, i8*, %Shader*)*}** %toString_adhoc_W1N0cmluZyosU2hhZGVyKl0, { i8*, i8*, %String* (i8*, i8*, %Shader*)*}*** %toString_adhoc_W1N0cmluZyosU2hhZGVyKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosU2hhZGVyKl0
%tmp_envptr2476 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %Shader*)*}***}* %environment2469, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %Shader*)*}*** %toString_adhoc_W1N0cmluZyosU2hhZGVyKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}**** %tmp_envptr2476


%val2485 = load {i8*, i8*, %String* (i8*, i8*, %Shader*)*}**, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}*** %toString_adhoc_W1N0cmluZyosU2hhZGVyKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %Shader*)*}** %val2485
}


@toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %Shader*)*}** @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Shader*)*}*, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Shader*)*}, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Shader*)*}, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Shader*)*,  %String* (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_native(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Shader*)*}*, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Shader*)*}, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Shader*)*}, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Shader*)*,  %String* (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2486 = bitcast [92 x i8]* @gsxtmgl-objects166 to i8*
call i32 (i8*, ...) @printf(i8* %var2486)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Shader*)*}*, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Shader*)*}, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Shader*)*}, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Shader*)*,  %String* (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*}*
%arg_p_0 = getelementptr {%Shader*}, {%Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %Shader*)*}*, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Shader*)*}, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %Shader*)*}, {i8*, i8*, %String* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %Shader*)*,  %String* (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects167 = hidden constant [32 x i8] c"print_adhoc_W3ZvaWQsU2hhZGVyKl0\00"
@gsxtmgl-objects168 = hidden constant [41 x i8] c"{i8*, i8*, void (i8*, i8*, %Shader*)*}**\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsU2hhZGVyKl0__2487(i8* %_impz,i8* %_impenv, %Shader* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2488 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}*
%print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr = load {i8*, i8*, void (i8*, i8*, %Shader*)*}***, {i8*, i8*, void (i8*, i8*, %Shader*)*}**** %print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr_

; setup arguments
%xPtr = alloca %Shader*
store %Shader* %x, %Shader** %xPtr


%val2490 = load %Shader*, %Shader** %xPtr
%val2491 = icmp eq %Shader* %val2490, null
br i1 %val2491, label %then2489, label %else2489

then2489:
%var2492 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var2493 = bitcast [14 x i8]* @gsxtmgl-objects160 to i8*

%val2494 = call i32 (i8*, ...) @printf(i8* %var2492, i8* %var2493)
br label %ifcont2489

else2489:
%var2496 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var2497 = bitcast [9 x i8]* @gsxtmgl-objects161 to i8*

%val2498 = call i32 (i8*, ...) @printf(i8* %var2496, i8* %var2497)
%val2499 = load %Shader*, %Shader** %xPtr
; tuple ref
%val2500 = getelementptr %Shader, %Shader* %val2499, i64 0, i32 0
%val2501 = load i32, i32* %val2500
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val2501)
%var2503 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var2504 = bitcast [2 x i8]* @gsxtmgl-objects162 to i8*

%val2505 = call i32 (i8*, ...) @printf(i8* %var2503, i8* %var2504)
%val2506 = load %Shader*, %Shader** %xPtr
; tuple ref
%val2507 = getelementptr %Shader, %Shader* %val2506, i64 0, i32 1
%val2508 = load i32, i32* %val2507
call fastcc void @print_adhoc_W3ZvaWQsaTMyXQ(i32 %val2508)
%var2510 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var2511 = bitcast [2 x i8]* @gsxtmgl-objects163 to i8*

%val2512 = call i32 (i8*, ...) @printf(i8* %var2510, i8* %var2511)
br label %ifcont2489

ifcont2489:
ret void
}
@gsxtmgl-objects169 = hidden constant [85 x i8] c"print_adhoc_W3ZvaWQsU2hhZGVyKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Shader*)*}** @print_adhoc_W3ZvaWQsU2hhZGVyKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2534 = load i8*, i8** %_impzPtr
%zone2535 = bitcast i8* %tzone2534 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsU2hhZGVyKl0
%dat_print_adhoc_W3ZvaWQsU2hhZGVyKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2535, i64 8)
%print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsU2hhZGVyKl0 to { i8*, i8*, void (i8*, i8*, %Shader*)*}***
%tzone2515 = load i8*, i8** %_impzPtr
%zone2516 = bitcast i8* %tzone2515 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2516)
; malloc closure structure
%clsptr2517 = call i8* @llvm_zone_malloc(%mzone* %zone2516, i64 24)
%closure2518 = bitcast i8* %clsptr2517 to { i8*, i8*, void (i8*, i8*, %Shader*)*}*

; malloc environment structure
%envptr2519 = call i8* @llvm_zone_malloc(%mzone* %zone2516, i64 8)
%environment2520 = bitcast i8* %envptr2519 to {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}*

; malloc closure address table
%addytable2521 = call %clsvar* @new_address_table()
%var2522 = bitcast [32 x i8]* @gsxtmgl-objects167 to i8*
%var2523 = bitcast [41 x i8]* @gsxtmgl-objects168 to i8*
%addytable2524 = call %clsvar* @add_address_table(%mzone* %zone2516, i8* %var2522, i32 0, i8* %var2523, i32 3, %clsvar* %addytable2521)
%address-table2525 = bitcast %clsvar* %addytable2524 to i8*

; insert table, function and environment into closure struct
%closure.table2528 = getelementptr { i8*, i8*, void (i8*, i8*, %Shader*)*}, { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure2518, i32 0, i32 0
store i8* %address-table2525, i8** %closure.table2528
%closure.env2529 = getelementptr { i8*, i8*, void (i8*, i8*, %Shader*)*}, { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure2518, i32 0, i32 1
store i8* %envptr2519, i8** %closure.env2529
%closure.func2530 = getelementptr { i8*, i8*, void (i8*, i8*, %Shader*)*}, { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure2518, i32 0, i32 2
store void (i8*, i8*, %Shader*)* @print_adhoc_W3ZvaWQsU2hhZGVyKl0__2487, void (i8*, i8*, %Shader*)** %closure.func2530
%closure_size2531 = call i64 @llvm_zone_mark_size(%mzone* %zone2516)
call void @llvm_zone_ptr_set_size(i8* %clsptr2517, i64 %closure_size2531)
%wrapper_ptr2532 = call i8* @llvm_zone_malloc(%mzone* %zone2516, i64 8)
%closure_wrapper2533 = bitcast i8* %wrapper_ptr2532 to { i8*, i8*, void (i8*, i8*, %Shader*)*}**
store { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure2518, { i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_wrapper2533

; let value assignment
%print_adhoc_W3ZvaWQsU2hhZGVyKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_wrapper2533, { i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_wrapper2533
store { i8*, i8*, void (i8*, i8*, %Shader*)*}** %print_adhoc_W3ZvaWQsU2hhZGVyKl0, { i8*, i8*, void (i8*, i8*, %Shader*)*}*** %print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsU2hhZGVyKl0
%tmp_envptr2527 = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %environment2520, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Shader*)*}*** %print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr, {i8*, i8*, void (i8*, i8*, %Shader*)*}**** %tmp_envptr2527


%val2536 = load {i8*, i8*, void (i8*, i8*, %Shader*)*}**, {i8*, i8*, void (i8*, i8*, %Shader*)*}*** %print_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %Shader*)*}** %val2536
}


@print_adhoc_W3ZvaWQsU2hhZGVyKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsU2hhZGVyKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsU2hhZGVyKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Shader*)*}** @print_adhoc_W3ZvaWQsU2hhZGVyKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsU2hhZGVyKl0(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU2hhZGVyKl0_native(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsU2hhZGVyKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2537 = bitcast [85 x i8]* @gsxtmgl-objects169 to i8*
call i32 (i8*, ...) @printf(i8* %var2537)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsU2hhZGVyKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*}*
%arg_p_0 = getelementptr {%Shader*}, {%Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects170 = hidden constant [40 x i8] c"Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ\00"
@gsxtmgl-objects171 = hidden constant [44 x i8] c"{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**\00"
define dllexport fastcc %Shader @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ__2538(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2539 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***}*
%Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr = load {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**** %Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr


%tzone2541 = load i8*, i8** %_impzPtr
%zone2542 = bitcast i8* %tzone2541 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Shader*
%dat2540 = alloca %Shader, align 16

; let value assignment
%obj = select i1 true, %Shader* %dat2540, %Shader* %dat2540
store %Shader* %obj, %Shader** %objPtr

%val2543 = load %Shader*, %Shader** %objPtr
%val2544 = load i32, i32* %arg_0Ptr
; set tuple
%val2545 = getelementptr %Shader, %Shader* %val2543, i64 0, i32 0
store i32 %val2544, i32* %val2545
%val2546 = load %Shader*, %Shader** %objPtr
%val2547 = load i32, i32* %arg_1Ptr
; set tuple
%val2548 = getelementptr %Shader, %Shader* %val2546, i64 0, i32 1
store i32 %val2547, i32* %val2548
%val2549 = load %Shader*, %Shader** %objPtr
; pointer ref
%val2550 = getelementptr %Shader, %Shader* %val2549, i64 0
%val2551 = load %Shader, %Shader* %val2550
ret %Shader %val2551
}
@gsxtmgl-objects172 = hidden constant [93 x i8] c"Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2571 = load i8*, i8** %_impzPtr
%zone2572 = bitcast i8* %tzone2571 to %mzone*

; let assign value to symbol Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ
%dat_Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone2572, i64 8)
%Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr = bitcast i8* %dat_Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ to { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***
%tzone2552 = load i8*, i8** %_impzPtr
%zone2553 = bitcast i8* %tzone2552 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2553)
; malloc closure structure
%clsptr2554 = call i8* @llvm_zone_malloc(%mzone* %zone2553, i64 24)
%closure2555 = bitcast i8* %clsptr2554 to { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr2556 = call i8* @llvm_zone_malloc(%mzone* %zone2553, i64 8)
%environment2557 = bitcast i8* %envptr2556 to {{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable2558 = call %clsvar* @new_address_table()
%var2559 = bitcast [40 x i8]* @gsxtmgl-objects170 to i8*
%var2560 = bitcast [44 x i8]* @gsxtmgl-objects171 to i8*
%addytable2561 = call %clsvar* @add_address_table(%mzone* %zone2553, i8* %var2559, i32 0, i8* %var2560, i32 3, %clsvar* %addytable2558)
%address-table2562 = bitcast %clsvar* %addytable2561 to i8*

; insert table, function and environment into closure struct
%closure.table2565 = getelementptr { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure2555, i32 0, i32 0
store i8* %address-table2562, i8** %closure.table2565
%closure.env2566 = getelementptr { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure2555, i32 0, i32 1
store i8* %envptr2556, i8** %closure.env2566
%closure.func2567 = getelementptr { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure2555, i32 0, i32 2
store %Shader (i8*, i8*, i32, i32)* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ__2538, %Shader (i8*, i8*, i32, i32)** %closure.func2567
%closure_size2568 = call i64 @llvm_zone_mark_size(%mzone* %zone2553)
call void @llvm_zone_ptr_set_size(i8* %clsptr2554, i64 %closure_size2568)
%wrapper_ptr2569 = call i8* @llvm_zone_malloc(%mzone* %zone2553, i64 8)
%closure_wrapper2570 = bitcast i8* %wrapper_ptr2569 to { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**
store { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure2555, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure_wrapper2570

; let value assignment
%Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ = select i1 true, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure_wrapper2570, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure_wrapper2570
store { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ, { i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*** %Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ
%tmp_envptr2564 = getelementptr {{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, %Shader (i8*, i8*, i32, i32)*}***}* %environment2557, i32 0, i32 0
store {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*** %Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**** %tmp_envptr2564


%val2573 = load {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*** %Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQPtr
ret {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %val2573
}


@Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader (i8*, i8*, i32, i32)*,  %Shader (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader %result
}


define dllexport ccc %Shader @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader (i8*, i8*, i32, i32)*,  %Shader (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret %Shader %result
}


define dllexport ccc void @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_val_adhoc_W1NoYWRlcixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}*, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}, {i8*, i8*, %Shader (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader (i8*, i8*, i32, i32)*,  %Shader (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects173 = hidden constant [36 x i8] c"hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0\00"
@gsxtmgl-objects174 = hidden constant [45 x i8] c"{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**\00"
define dllexport fastcc %Shader* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0__2576(i8* %_impz,i8* %_impenv, %Shader* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2577 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***}*
%hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr_ = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**** %hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr_

; setup arguments
%xPtr = alloca %Shader*
store %Shader* %x, %Shader** %xPtr


%tzone2580 = load i8*, i8** %_impzPtr
%zone2581 = bitcast i8* %tzone2580 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Shader*
%dat2578 = call i8* @malloc(i64 8)
call i8* @memset(i8* %dat2578, i32 0, i64 8)
%val2579 = bitcast i8* %dat2578 to %Shader*

; let value assignment
%obj = select i1 true, %Shader* %val2579, %Shader* %val2579
store %Shader* %obj, %Shader** %objPtr

%val2582 = load %Shader*, %Shader** %objPtr
%val2583 = load %Shader*, %Shader** %xPtr
; tuple ref
%val2584 = getelementptr %Shader, %Shader* %val2583, i64 0, i32 0
%val2585 = load i32, i32* %val2584
; set tuple
%val2586 = getelementptr %Shader, %Shader* %val2582, i64 0, i32 0
store i32 %val2585, i32* %val2586
%val2587 = load %Shader*, %Shader** %objPtr
%val2588 = load %Shader*, %Shader** %xPtr
; tuple ref
%val2589 = getelementptr %Shader, %Shader* %val2588, i64 0, i32 1
%val2590 = load i32, i32* %val2589
; set tuple
%val2591 = getelementptr %Shader, %Shader* %val2587, i64 0, i32 1
store i32 %val2590, i32* %val2591
%val2592 = load %Shader*, %Shader** %objPtr
ret %Shader* %val2592
}
@gsxtmgl-objects175 = hidden constant [89 x i8] c"hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2612 = load i8*, i8** %_impzPtr
%zone2613 = bitcast i8* %tzone2612 to %mzone*

; let assign value to symbol hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0
%dat_hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2613, i64 8)
%hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0 to { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***
%tzone2593 = load i8*, i8** %_impzPtr
%zone2594 = bitcast i8* %tzone2593 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2594)
; malloc closure structure
%clsptr2595 = call i8* @llvm_zone_malloc(%mzone* %zone2594, i64 24)
%closure2596 = bitcast i8* %clsptr2595 to { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*

; malloc environment structure
%envptr2597 = call i8* @llvm_zone_malloc(%mzone* %zone2594, i64 8)
%environment2598 = bitcast i8* %envptr2597 to {{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***}*

; malloc closure address table
%addytable2599 = call %clsvar* @new_address_table()
%var2600 = bitcast [36 x i8]* @gsxtmgl-objects173 to i8*
%var2601 = bitcast [45 x i8]* @gsxtmgl-objects174 to i8*
%addytable2602 = call %clsvar* @add_address_table(%mzone* %zone2594, i8* %var2600, i32 0, i8* %var2601, i32 3, %clsvar* %addytable2599)
%address-table2603 = bitcast %clsvar* %addytable2602 to i8*

; insert table, function and environment into closure struct
%closure.table2606 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure2596, i32 0, i32 0
store i8* %address-table2603, i8** %closure.table2606
%closure.env2607 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure2596, i32 0, i32 1
store i8* %envptr2597, i8** %closure.env2607
%closure.func2608 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure2596, i32 0, i32 2
store %Shader* (i8*, i8*, %Shader*)* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0__2576, %Shader* (i8*, i8*, %Shader*)** %closure.func2608
%closure_size2609 = call i64 @llvm_zone_mark_size(%mzone* %zone2594)
call void @llvm_zone_ptr_set_size(i8* %clsptr2595, i64 %closure_size2609)
%wrapper_ptr2610 = call i8* @llvm_zone_malloc(%mzone* %zone2594, i64 8)
%closure_wrapper2611 = bitcast i8* %wrapper_ptr2610 to { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**
store { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure2596, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_wrapper2611

; let value assignment
%hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0 = select i1 true, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_wrapper2611, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_wrapper2611
store { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0, { i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*** %hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0
%tmp_envptr2605 = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}***}* %environment2598, i32 0, i32 0
store {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*** %hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**** %tmp_envptr2605


%val2614 = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*** %hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0Ptr
ret {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %val2614
}


@hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*)*,  %Shader* (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret %Shader* %result
}


define dllexport ccc %Shader* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_native(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*)*,  %Shader* (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret %Shader* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2615 = bitcast [89 x i8]* @gsxtmgl-objects175 to i8*
call i32 (i8*, ...) @printf(i8* %var2615)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*)*,  %Shader* (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%tmpres = bitcast %Shader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*}*
%arg_p_0 = getelementptr {%Shader*}, {%Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W1NoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*)*,  %Shader* (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects176 = hidden constant [32 x i8] c"hfree_adhoc_W3ZvaWQsU2hhZGVyKl0\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0__2616(i8* %_impz,i8* %_impenv, %Shader* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2617 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}*
%hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr = load {i8*, i8*, void (i8*, i8*, %Shader*)*}***, {i8*, i8*, void (i8*, i8*, %Shader*)*}**** %hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr_

; setup arguments
%xPtr = alloca %Shader*
store %Shader* %x, %Shader** %xPtr


%val2618 = load %Shader*, %Shader** %xPtr
%val2619 = bitcast %Shader* %val2618 to i8*
call ccc void @free(i8* %val2619)
ret void
}
@gsxtmgl-objects177 = hidden constant [85 x i8] c"hfree_adhoc_W3ZvaWQsU2hhZGVyKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %Shader*)*}** @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2641 = load i8*, i8** %_impzPtr
%zone2642 = bitcast i8* %tzone2641 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsU2hhZGVyKl0
%dat_hfree_adhoc_W3ZvaWQsU2hhZGVyKl0 = call i8* @llvm_zone_malloc(%mzone* %zone2642, i64 8)
%hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsU2hhZGVyKl0 to { i8*, i8*, void (i8*, i8*, %Shader*)*}***
%tzone2622 = load i8*, i8** %_impzPtr
%zone2623 = bitcast i8* %tzone2622 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2623)
; malloc closure structure
%clsptr2624 = call i8* @llvm_zone_malloc(%mzone* %zone2623, i64 24)
%closure2625 = bitcast i8* %clsptr2624 to { i8*, i8*, void (i8*, i8*, %Shader*)*}*

; malloc environment structure
%envptr2626 = call i8* @llvm_zone_malloc(%mzone* %zone2623, i64 8)
%environment2627 = bitcast i8* %envptr2626 to {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}*

; malloc closure address table
%addytable2628 = call %clsvar* @new_address_table()
%var2629 = bitcast [32 x i8]* @gsxtmgl-objects176 to i8*
%var2630 = bitcast [41 x i8]* @gsxtmgl-objects168 to i8*
%addytable2631 = call %clsvar* @add_address_table(%mzone* %zone2623, i8* %var2629, i32 0, i8* %var2630, i32 3, %clsvar* %addytable2628)
%address-table2632 = bitcast %clsvar* %addytable2631 to i8*

; insert table, function and environment into closure struct
%closure.table2635 = getelementptr { i8*, i8*, void (i8*, i8*, %Shader*)*}, { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure2625, i32 0, i32 0
store i8* %address-table2632, i8** %closure.table2635
%closure.env2636 = getelementptr { i8*, i8*, void (i8*, i8*, %Shader*)*}, { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure2625, i32 0, i32 1
store i8* %envptr2626, i8** %closure.env2636
%closure.func2637 = getelementptr { i8*, i8*, void (i8*, i8*, %Shader*)*}, { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure2625, i32 0, i32 2
store void (i8*, i8*, %Shader*)* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0__2616, void (i8*, i8*, %Shader*)** %closure.func2637
%closure_size2638 = call i64 @llvm_zone_mark_size(%mzone* %zone2623)
call void @llvm_zone_ptr_set_size(i8* %clsptr2624, i64 %closure_size2638)
%wrapper_ptr2639 = call i8* @llvm_zone_malloc(%mzone* %zone2623, i64 8)
%closure_wrapper2640 = bitcast i8* %wrapper_ptr2639 to { i8*, i8*, void (i8*, i8*, %Shader*)*}**
store { i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure2625, { i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_wrapper2640

; let value assignment
%hfree_adhoc_W3ZvaWQsU2hhZGVyKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_wrapper2640, { i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_wrapper2640
store { i8*, i8*, void (i8*, i8*, %Shader*)*}** %hfree_adhoc_W3ZvaWQsU2hhZGVyKl0, { i8*, i8*, void (i8*, i8*, %Shader*)*}*** %hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsU2hhZGVyKl0
%tmp_envptr2634 = getelementptr {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, void (i8*, i8*, %Shader*)*}***}* %environment2627, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %Shader*)*}*** %hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr, {i8*, i8*, void (i8*, i8*, %Shader*)*}**** %tmp_envptr2634


%val2643 = load {i8*, i8*, void (i8*, i8*, %Shader*)*}**, {i8*, i8*, void (i8*, i8*, %Shader*)*}*** %hfree_adhoc_W3ZvaWQsU2hhZGVyKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %Shader*)*}** %val2643
}


@hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %Shader*)*}** @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_native(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2644 = bitcast [85 x i8]* @gsxtmgl-objects177 to i8*
call i32 (i8*, ...) @printf(i8* %var2644)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*}*
%arg_p_0 = getelementptr {%Shader*}, {%Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %Shader*)*}*, {i8*, i8*, void (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %Shader*)*}, {i8*, i8*, void (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %Shader*)*,  void (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects178 = hidden constant [55 x i8] c"zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmgl-objects179 = hidden constant [63 x i8] c"{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %Shader* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ__2645(i8* %_impz,i8* %_impenv, %Shader* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2646 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %Shader*
store %Shader* %x, %Shader** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val2648 = load %mzone*, %mzone** %fromzPtr
%val2649 = load %Shader*, %Shader** %xPtr
%val2650 = bitcast %Shader* %val2649 to i8*
%res2651 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val2648, i8* %val2650)
br i1 %res2651, label %then2647, label %else2647

then2647:
%val2652 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val2652)
%zone_ptr2653 = bitcast %mzone* %val2652 to i8*
store i8* %zone_ptr2653, i8** %_impzPtr
%tzone2659 = load i8*, i8** %_impzPtr
%zone2660 = bitcast i8* %tzone2659 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %Shader*
%tzone2655 = load i8*, i8** %_impzPtr
%zone2656 = bitcast i8* %tzone2655 to %mzone*
%dat2657 = call i8* @llvm_zone_malloc(%mzone* %zone2656, i64 8)
call i8* @memset(i8* %dat2657, i32 0, i64 8)
%val2658 = bitcast i8* %dat2657 to %Shader*

; let value assignment
%obj = select i1 true, %Shader* %val2658, %Shader* %val2658
store %Shader* %obj, %Shader** %objPtr

%val2661 = load %Shader*, %Shader** %objPtr
%val2662 = load %Shader*, %Shader** %xPtr
; tuple ref
%val2663 = getelementptr %Shader, %Shader* %val2662, i64 0, i32 0
%val2664 = load i32, i32* %val2663
; set tuple
%val2665 = getelementptr %Shader, %Shader* %val2661, i64 0, i32 0
store i32 %val2664, i32* %val2665
%val2666 = load %Shader*, %Shader** %objPtr
%val2667 = load %Shader*, %Shader** %xPtr
; tuple ref
%val2668 = getelementptr %Shader, %Shader* %val2667, i64 0, i32 1
%val2669 = load i32, i32* %val2668
; set tuple
%val2670 = getelementptr %Shader, %Shader* %val2666, i64 0, i32 1
store i32 %val2669, i32* %val2670
%oldzone2671 = call %mzone* @llvm_pop_zone_stack()
%newzone2672 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr2673 = bitcast %mzone* %newzone2672 to i8*
store i8* %zone_ptr2673, i8** %_impzPtr
%val2674 = load %Shader*, %Shader** %objPtr
ret %Shader* %val2674

else2647:
%val2675 = load %Shader*, %Shader** %xPtr
ret %Shader* %val2675
}
@gsxtmgl-objects180 = hidden constant [108 x i8] c"zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2695 = load i8*, i8** %_impzPtr
%zone2696 = bitcast i8* %tzone2695 to %mzone*

; let assign value to symbol zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2696, i64 8)
%zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***
%tzone2676 = load i8*, i8** %_impzPtr
%zone2677 = bitcast i8* %tzone2676 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2677)
; malloc closure structure
%clsptr2678 = call i8* @llvm_zone_malloc(%mzone* %zone2677, i64 24)
%closure2679 = bitcast i8* %clsptr2678 to { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr2680 = call i8* @llvm_zone_malloc(%mzone* %zone2677, i64 8)
%environment2681 = bitcast i8* %envptr2680 to {{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable2682 = call %clsvar* @new_address_table()
%var2683 = bitcast [55 x i8]* @gsxtmgl-objects178 to i8*
%var2684 = bitcast [63 x i8]* @gsxtmgl-objects179 to i8*
%addytable2685 = call %clsvar* @add_address_table(%mzone* %zone2677, i8* %var2683, i32 0, i8* %var2684, i32 3, %clsvar* %addytable2682)
%address-table2686 = bitcast %clsvar* %addytable2685 to i8*

; insert table, function and environment into closure struct
%closure.table2689 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure2679, i32 0, i32 0
store i8* %address-table2686, i8** %closure.table2689
%closure.env2690 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure2679, i32 0, i32 1
store i8* %envptr2680, i8** %closure.env2690
%closure.func2691 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure2679, i32 0, i32 2
store %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ__2645, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)** %closure.func2691
%closure_size2692 = call i64 @llvm_zone_mark_size(%mzone* %zone2677)
call void @llvm_zone_ptr_set_size(i8* %clsptr2678, i64 %closure_size2692)
%wrapper_ptr2693 = call i8* @llvm_zone_malloc(%mzone* %zone2677, i64 8)
%closure_wrapper2694 = bitcast i8* %wrapper_ptr2693 to { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**
store { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure2679, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_wrapper2694

; let value assignment
%zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_wrapper2694, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_wrapper2694
store { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ
%tmp_envptr2688 = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}***}* %environment2681, i32 0, i32 0
store {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**** %tmp_envptr2688


%val2697 = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %val2697
}


@zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ(%Shader* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*,  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Shader* %result
}


define dllexport ccc %Shader* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_native(%Shader* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*,  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %Shader* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2698 = bitcast [108 x i8]* @gsxtmgl-objects180 to i8*
call i32 (i8*, ...) @printf(i8* %var2698)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var2699 = bitcast [108 x i8]* @gsxtmgl-objects180 to i8*
call i32 (i8*, ...) @printf(i8* %var2699)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var2700 = bitcast [108 x i8]* @gsxtmgl-objects180 to i8*
call i32 (i8*, ...) @printf(i8* %var2700)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*,  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %Shader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%Shader*, %mzone*, %mzone*}, {%Shader*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
%arg_p_1 = getelementptr {%Shader*, %mzone*, %mzone*}, {%Shader*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%Shader*, %mzone*, %mzone*}, {%Shader*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W1NoYWRlciosU2hhZGVyKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}*, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}, {i8*, i8*, %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)*,  %Shader* (i8*, i8*, %Shader*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects181 = hidden constant [35 x i8] c"Shader_id_adhoc_W2kzMixTaGFkZXIqXQ\00"
@gsxtmgl-objects182 = hidden constant [40 x i8] c"{i8*, i8*, i32 (i8*, i8*, %Shader*)*}**\00"
define dllexport fastcc i32 @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ__2701(i8* %_impz,i8* %_impenv, %Shader* %shader) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2702 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}*
%Shader_id_adhoc_W2kzMixTaGFkZXIqXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 0
%Shader_id_adhoc_W2kzMixTaGFkZXIqXQPtr = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}***, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**** %Shader_id_adhoc_W2kzMixTaGFkZXIqXQPtr_

; setup arguments
%shaderPtr = alloca %Shader*
store %Shader* %shader, %Shader** %shaderPtr


%val2703 = load %Shader*, %Shader** %shaderPtr
; tuple ref
%val2704 = getelementptr %Shader, %Shader* %val2703, i64 0, i32 0
%val2705 = load i32, i32* %val2704
ret i32 %val2705
}
@gsxtmgl-objects183 = hidden constant [88 x i8] c"Shader_id_adhoc_W2kzMixTaGFkZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2725 = load i8*, i8** %_impzPtr
%zone2726 = bitcast i8* %tzone2725 to %mzone*

; let assign value to symbol Shader_id_adhoc_W2kzMixTaGFkZXIqXQ
%dat_Shader_id_adhoc_W2kzMixTaGFkZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2726, i64 8)
%Shader_id_adhoc_W2kzMixTaGFkZXIqXQPtr = bitcast i8* %dat_Shader_id_adhoc_W2kzMixTaGFkZXIqXQ to { i8*, i8*, i32 (i8*, i8*, %Shader*)*}***
%tzone2706 = load i8*, i8** %_impzPtr
%zone2707 = bitcast i8* %tzone2706 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2707)
; malloc closure structure
%clsptr2708 = call i8* @llvm_zone_malloc(%mzone* %zone2707, i64 24)
%closure2709 = bitcast i8* %clsptr2708 to { i8*, i8*, i32 (i8*, i8*, %Shader*)*}*

; malloc environment structure
%envptr2710 = call i8* @llvm_zone_malloc(%mzone* %zone2707, i64 8)
%environment2711 = bitcast i8* %envptr2710 to {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}*

; malloc closure address table
%addytable2712 = call %clsvar* @new_address_table()
%var2713 = bitcast [35 x i8]* @gsxtmgl-objects181 to i8*
%var2714 = bitcast [40 x i8]* @gsxtmgl-objects182 to i8*
%addytable2715 = call %clsvar* @add_address_table(%mzone* %zone2707, i8* %var2713, i32 0, i8* %var2714, i32 3, %clsvar* %addytable2712)
%address-table2716 = bitcast %clsvar* %addytable2715 to i8*

; insert table, function and environment into closure struct
%closure.table2719 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure2709, i32 0, i32 0
store i8* %address-table2716, i8** %closure.table2719
%closure.env2720 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure2709, i32 0, i32 1
store i8* %envptr2710, i8** %closure.env2720
%closure.func2721 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure2709, i32 0, i32 2
store i32 (i8*, i8*, %Shader*)* @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ__2701, i32 (i8*, i8*, %Shader*)** %closure.func2721
%closure_size2722 = call i64 @llvm_zone_mark_size(%mzone* %zone2707)
call void @llvm_zone_ptr_set_size(i8* %clsptr2708, i64 %closure_size2722)
%wrapper_ptr2723 = call i8* @llvm_zone_malloc(%mzone* %zone2707, i64 8)
%closure_wrapper2724 = bitcast i8* %wrapper_ptr2723 to { i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
store { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure2709, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_wrapper2724

; let value assignment
%Shader_id_adhoc_W2kzMixTaGFkZXIqXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_wrapper2724, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_wrapper2724
store { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %Shader_id_adhoc_W2kzMixTaGFkZXIqXQ, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}*** %Shader_id_adhoc_W2kzMixTaGFkZXIqXQPtr

; add data to environment
; don't need to alloc for env var Shader_id_adhoc_W2kzMixTaGFkZXIqXQ
%tmp_envptr2718 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}* %environment2711, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*** %Shader_id_adhoc_W2kzMixTaGFkZXIqXQPtr, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**** %tmp_envptr2718


%val2727 = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*** %Shader_id_adhoc_W2kzMixTaGFkZXIqXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %val2727
}


@Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_native(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2728 = bitcast [88 x i8]* @gsxtmgl-objects183 to i8*
call i32 (i8*, ...) @printf(i8* %var2728)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*}*
%arg_p_0 = getelementptr {%Shader*}, {%Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects184 = hidden constant [37 x i8] c"Shader_type_adhoc_W2kzMixTaGFkZXIqXQ\00"
define dllexport fastcc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ__2729(i8* %_impz,i8* %_impenv, %Shader* %shader) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2730 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}*
%Shader_type_adhoc_W2kzMixTaGFkZXIqXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 0
%Shader_type_adhoc_W2kzMixTaGFkZXIqXQPtr = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}***, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**** %Shader_type_adhoc_W2kzMixTaGFkZXIqXQPtr_

; setup arguments
%shaderPtr = alloca %Shader*
store %Shader* %shader, %Shader** %shaderPtr


%val2731 = load %Shader*, %Shader** %shaderPtr
; tuple ref
%val2732 = getelementptr %Shader, %Shader* %val2731, i64 0, i32 1
%val2733 = load i32, i32* %val2732
ret i32 %val2733
}
@gsxtmgl-objects185 = hidden constant [90 x i8] c"Shader_type_adhoc_W2kzMixTaGFkZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2753 = load i8*, i8** %_impzPtr
%zone2754 = bitcast i8* %tzone2753 to %mzone*

; let assign value to symbol Shader_type_adhoc_W2kzMixTaGFkZXIqXQ
%dat_Shader_type_adhoc_W2kzMixTaGFkZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2754, i64 8)
%Shader_type_adhoc_W2kzMixTaGFkZXIqXQPtr = bitcast i8* %dat_Shader_type_adhoc_W2kzMixTaGFkZXIqXQ to { i8*, i8*, i32 (i8*, i8*, %Shader*)*}***
%tzone2734 = load i8*, i8** %_impzPtr
%zone2735 = bitcast i8* %tzone2734 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2735)
; malloc closure structure
%clsptr2736 = call i8* @llvm_zone_malloc(%mzone* %zone2735, i64 24)
%closure2737 = bitcast i8* %clsptr2736 to { i8*, i8*, i32 (i8*, i8*, %Shader*)*}*

; malloc environment structure
%envptr2738 = call i8* @llvm_zone_malloc(%mzone* %zone2735, i64 8)
%environment2739 = bitcast i8* %envptr2738 to {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}*

; malloc closure address table
%addytable2740 = call %clsvar* @new_address_table()
%var2741 = bitcast [37 x i8]* @gsxtmgl-objects184 to i8*
%var2742 = bitcast [40 x i8]* @gsxtmgl-objects182 to i8*
%addytable2743 = call %clsvar* @add_address_table(%mzone* %zone2735, i8* %var2741, i32 0, i8* %var2742, i32 3, %clsvar* %addytable2740)
%address-table2744 = bitcast %clsvar* %addytable2743 to i8*

; insert table, function and environment into closure struct
%closure.table2747 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure2737, i32 0, i32 0
store i8* %address-table2744, i8** %closure.table2747
%closure.env2748 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure2737, i32 0, i32 1
store i8* %envptr2738, i8** %closure.env2748
%closure.func2749 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure2737, i32 0, i32 2
store i32 (i8*, i8*, %Shader*)* @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ__2729, i32 (i8*, i8*, %Shader*)** %closure.func2749
%closure_size2750 = call i64 @llvm_zone_mark_size(%mzone* %zone2735)
call void @llvm_zone_ptr_set_size(i8* %clsptr2736, i64 %closure_size2750)
%wrapper_ptr2751 = call i8* @llvm_zone_malloc(%mzone* %zone2735, i64 8)
%closure_wrapper2752 = bitcast i8* %wrapper_ptr2751 to { i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
store { i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure2737, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_wrapper2752

; let value assignment
%Shader_type_adhoc_W2kzMixTaGFkZXIqXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_wrapper2752, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_wrapper2752
store { i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %Shader_type_adhoc_W2kzMixTaGFkZXIqXQ, { i8*, i8*, i32 (i8*, i8*, %Shader*)*}*** %Shader_type_adhoc_W2kzMixTaGFkZXIqXQPtr

; add data to environment
; don't need to alloc for env var Shader_type_adhoc_W2kzMixTaGFkZXIqXQ
%tmp_envptr2746 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Shader*)*}***}* %environment2739, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*** %Shader_type_adhoc_W2kzMixTaGFkZXIqXQPtr, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**** %tmp_envptr2746


%val2755 = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*** %Shader_type_adhoc_W2kzMixTaGFkZXIqXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %val2755
}


@Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_native(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2756 = bitcast [90 x i8]* @gsxtmgl-objects185 to i8*
call i32 (i8*, ...) @printf(i8* %var2756)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*}*
%arg_p_0 = getelementptr {%Shader*}, {%Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*)*,  i32 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects186 = hidden constant [14 x i8] c"%sShader: %s
\00"
@gsxtmgl-objects187 = hidden constant [5 x i8] c"Vert\00"
@gsxtmgl-objects188 = hidden constant [5 x i8] c"Frag\00"
@gsxtmgl-objects189 = hidden constant [5 x i8] c"Geom\00"
@gsxtmgl-objects190 = hidden constant [1 x i8] c"\00"
@gsxtmgl-objects191 = hidden constant [3 x i8] c"OK\00"
@gsxtmgl-objects192 = hidden constant [47 x i8] c"Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ\00"
@gsxtmgl-objects193 = hidden constant [40 x i8] c"{i8*, i8*, i64 (i8*, i8*, %Shader*)*}**\00"
@gsxtmgl-objects194 = hidden constant [7 x i8] c"logbuf\00"
@gsxtmgl-objects195 = hidden constant [4 x i8] c"i8*\00"
@gsxtmgl-objects196 = hidden constant [15 x i8] c"max_log_length\00"
@gsxtmgl-objects197 = hidden constant [4 x i8] c"i32\00"
@gsxtmgl-objects198 = hidden constant [15 x i8] c"_anon_lambda_1\00"
define dllexport fastcc i64 @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ__2757(i8* %_impz,i8* %_impenv, %Shader* %shader) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2770 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}*
%Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 0
%Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQPtr = load {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}**** %Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQPtr_
%logbufPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 1
%logbufPtr = load i8**, i8*** %logbufPtr_
%max_log_lengthPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 2
%max_log_lengthPtr = load i32*, i32** %max_log_lengthPtr_
%_anon_lambda_1Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}* %impenv, i32 0, i32 3
%_anon_lambda_1Ptr = load {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}**** %_anon_lambda_1Ptr_

; setup arguments
%shaderPtr = alloca %Shader*
store %Shader* %shader, %Shader** %shaderPtr


%tzone2772 = load i8*, i8** %_impzPtr
%zone2773 = bitcast i8* %tzone2772 to %mzone*

; let assign value to symbol len_ptr
%len_ptrPtr = alloca i32*
%dat2771 = alloca i32, i64 1, align 16

; let value assignment
%len_ptr = select i1 true, i32* %dat2771, i32* %dat2771
store i32* %len_ptr, i32** %len_ptrPtr

; promote local stack var allocations
%tzone2817 = load i8*, i8** %_impzPtr
%zone2818 = bitcast i8* %tzone2817 to %mzone*
%ifptr2803 = alloca i8*
%ifptr2781 = alloca i8*
%ifptr2787 = alloca i8*
%ifptr2793 = alloca i8*
%val2774 = load %Shader*, %Shader** %shaderPtr
%res2775 = call fastcc i32 @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val2774)
%val2776 = load i32, i32* %max_log_lengthPtr
%val2777 = load i32*, i32** %len_ptrPtr
%val2778 = load i8*, i8** %logbufPtr
call fastcc void @glGetShaderInfoLog_adhoc_W3ZvaWQsaTMyLGkzMixpMzIqLGk4Kl0(i32 %res2775, i32 %val2776, i32* %val2777, i8* %val2778)
%var2780 = bitcast [14 x i8]* @gsxtmgl-objects186 to i8*
%val2782 = load %Shader*, %Shader** %shaderPtr
%res2783 = call fastcc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val2782)
%val2784 = load i32, i32* @GL_VERTEX_SHADER
%cmp2785 = icmp eq i32 %res2783, %val2784
br i1 %cmp2785, label %then2781, label %else2781

then2781:
%var2786 = bitcast [5 x i8]* @gsxtmgl-objects187 to i8*
store i8* %var2786, i8** %ifptr2781
br label %ifcont2781

else2781:
%val2788 = load %Shader*, %Shader** %shaderPtr
%res2789 = call fastcc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val2788)
%val2790 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp2791 = icmp eq i32 %res2789, %val2790
br i1 %cmp2791, label %then2787, label %else2787

then2787:
%var2792 = bitcast [5 x i8]* @gsxtmgl-objects188 to i8*
store i8* %var2792, i8** %ifptr2787
br label %ifcont2787

else2787:
%val2794 = load %Shader*, %Shader** %shaderPtr
%res2795 = call fastcc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val2794)
%val2796 = load i32, i32* @GL_GEOMETRY_SHADER
%cmp2797 = icmp eq i32 %res2795, %val2796
br i1 %cmp2797, label %then2793, label %else2793

then2793:
%var2798 = bitcast [5 x i8]* @gsxtmgl-objects189 to i8*
store i8* %var2798, i8** %ifptr2793
br label %ifcont2793

else2793:
%var2799 = bitcast [1 x i8]* @gsxtmgl-objects190 to i8*
store i8* %var2799, i8** %ifptr2793
br label %ifcont2793

ifcont2793:
%ifres2800 = load i8*, i8** %ifptr2793

store i8* %ifres2800, i8** %ifptr2787
br label %ifcont2787

ifcont2787:
%ifres2801 = load i8*, i8** %ifptr2787

store i8* %ifres2801, i8** %ifptr2781
br label %ifcont2781

ifcont2781:
%ifres2802 = load i8*, i8** %ifptr2781

%val2804 = load i32*, i32** %len_ptrPtr
; pointer ref
%val2805 = getelementptr i32, i32* %val2804, i64 0
%val2806 = load i32, i32* %val2805
%cmp2807 = icmp eq i32 %val2806, 0
br i1 %cmp2807, label %then2803, label %else2803

then2803:
%var2808 = bitcast [3 x i8]* @gsxtmgl-objects191 to i8*
store i8* %var2808, i8** %ifptr2803
br label %ifcont2803

else2803:
%val2809 = load i8*, i8** %logbufPtr
store i8* %val2809, i8** %ifptr2803
br label %ifcont2803

ifcont2803:
%ifres2810 = load i8*, i8** %ifptr2803


%val2811 = call i32 (i8*, ...) @printf(i8* %var2780, i8* %ifres2802, i8* %ifres2810)
%val2813 = load i32*, i32** %len_ptrPtr
; pointer ref
%val2814 = getelementptr i32, i32* %val2813, i64 0
%val2815 = load i32, i32* %val2814
%cmp2816 = icmp eq i32 %val2815, 0
br i1 %cmp2816, label %then2812, label %else2812

then2812:
ret i64 0

else2812:
ret i64 1
}
@gsxtmgl-objects199 = hidden constant [100 x i8] c"Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, %Shader*)*}** @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2856 = load i8*, i8** %_impzPtr
%zone2857 = bitcast i8* %tzone2856 to %mzone*

; let assign value to symbol Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ
%dat_Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ = call i8* @llvm_zone_malloc(%mzone* %zone2857, i64 8)
%Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQPtr = bitcast i8* %dat_Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ to {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***
%tzone2758 = load i8*, i8** %_impzPtr
%zone2759 = bitcast i8* %tzone2758 to %mzone*

; let assign value to symbol max_log_length
%dat_max_log_length = call i8* @llvm_zone_malloc(%mzone* %zone2759, i64 4)
%max_log_lengthPtr = bitcast i8* %dat_max_log_length to i32*
%tzone2768 = load i8*, i8** %_impzPtr
%zone2769 = bitcast i8* %tzone2768 to %mzone*

; let assign value to symbol logbuf
%dat_logbuf = call i8* @llvm_zone_malloc(%mzone* %zone2769, i64 8)
%logbufPtr = bitcast i8* %dat_logbuf to i8**

; let value assignment
%max_log_length = select i1 true, i32 4096, i32 4096
store i32 %max_log_length, i32* %max_log_lengthPtr

%val2760 = load i32, i32* %max_log_lengthPtr
%tmp2761 = zext i32 %val2760 to i64
%val2762 = getelementptr i32, i32* null, i32 1
%zonesize2763 = mul i64 1, %tmp2761
%tzone2764 = load i8*, i8** %_impzPtr
%zone2765 = bitcast i8* %tzone2764 to %mzone*
%dat2766 = call i8* @llvm_zone_malloc(%mzone* %zone2765, i64 %zonesize2763)
call i8* @memset(i8* %dat2766, i32 0, i64 %zonesize2763)
%val2767 = bitcast i8* %dat2766 to i8*

; let value assignment
%logbuf = select i1 true, i8* %val2767, i8* %val2767
store i8* %logbuf, i8** %logbufPtr

%tzone2853 = load i8*, i8** %_impzPtr
%zone2854 = bitcast i8* %tzone2853 to %mzone*

; let assign value to symbol _anon_lambda_1
%dat__anon_lambda_1 = call i8* @llvm_zone_malloc(%mzone* %zone2854, i64 8)
%_anon_lambda_1Ptr = bitcast i8* %dat__anon_lambda_1 to { i8*, i8*, i64 (i8*, i8*, %Shader*)*}***
%tzone2819 = load i8*, i8** %_impzPtr
%zone2820 = bitcast i8* %tzone2819 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2820)
; malloc closure structure
%clsptr2821 = call i8* @llvm_zone_malloc(%mzone* %zone2820, i64 24)
%closure2822 = bitcast i8* %clsptr2821 to { i8*, i8*, i64 (i8*, i8*, %Shader*)*}*

; malloc environment structure
%envptr2823 = call i8* @llvm_zone_malloc(%mzone* %zone2820, i64 32)
%environment2824 = bitcast i8* %envptr2823 to {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}*

; malloc closure address table
%addytable2825 = call %clsvar* @new_address_table()
%var2826 = bitcast [47 x i8]* @gsxtmgl-objects192 to i8*
%var2827 = bitcast [40 x i8]* @gsxtmgl-objects193 to i8*
%addytable2828 = call %clsvar* @add_address_table(%mzone* %zone2820, i8* %var2826, i32 0, i8* %var2827, i32 3, %clsvar* %addytable2825)
%var2829 = bitcast [7 x i8]* @gsxtmgl-objects194 to i8*
%var2830 = bitcast [4 x i8]* @gsxtmgl-objects195 to i8*
%addytable2831 = call %clsvar* @add_address_table(%mzone* %zone2820, i8* %var2829, i32 8, i8* %var2830, i32 3, %clsvar* %addytable2828)
%var2832 = bitcast [15 x i8]* @gsxtmgl-objects196 to i8*
%var2833 = bitcast [4 x i8]* @gsxtmgl-objects197 to i8*
%addytable2834 = call %clsvar* @add_address_table(%mzone* %zone2820, i8* %var2832, i32 16, i8* %var2833, i32 3, %clsvar* %addytable2831)
%var2835 = bitcast [15 x i8]* @gsxtmgl-objects198 to i8*
%var2836 = bitcast [40 x i8]* @gsxtmgl-objects193 to i8*
%addytable2837 = call %clsvar* @add_address_table(%mzone* %zone2820, i8* %var2835, i32 24, i8* %var2836, i32 3, %clsvar* %addytable2834)
%address-table2838 = bitcast %clsvar* %addytable2837 to i8*

; insert table, function and environment into closure struct
%closure.table2847 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Shader*)*}, { i8*, i8*, i64 (i8*, i8*, %Shader*)*}* %closure2822, i32 0, i32 0
store i8* %address-table2838, i8** %closure.table2847
%closure.env2848 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Shader*)*}, { i8*, i8*, i64 (i8*, i8*, %Shader*)*}* %closure2822, i32 0, i32 1
store i8* %envptr2823, i8** %closure.env2848
%closure.func2849 = getelementptr { i8*, i8*, i64 (i8*, i8*, %Shader*)*}, { i8*, i8*, i64 (i8*, i8*, %Shader*)*}* %closure2822, i32 0, i32 2
store i64 (i8*, i8*, %Shader*)* @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ__2757, i64 (i8*, i8*, %Shader*)** %closure.func2849
%closure_size2850 = call i64 @llvm_zone_mark_size(%mzone* %zone2820)
call void @llvm_zone_ptr_set_size(i8* %clsptr2821, i64 %closure_size2850)
%wrapper_ptr2851 = call i8* @llvm_zone_malloc(%mzone* %zone2820, i64 8)
%closure_wrapper2852 = bitcast i8* %wrapper_ptr2851 to { i8*, i8*, i64 (i8*, i8*, %Shader*)*}**
store { i8*, i8*, i64 (i8*, i8*, %Shader*)*}* %closure2822, { i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %closure_wrapper2852

; let value assignment
%_anon_lambda_1 = select i1 true, { i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %closure_wrapper2852, { i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %closure_wrapper2852
store { i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %_anon_lambda_1, { i8*, i8*, i64 (i8*, i8*, %Shader*)*}*** %_anon_lambda_1Ptr

; add data to environment
; don't need to alloc for env var Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ
%tmp_envptr2840 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}* %environment2824, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, %Shader*)*}*** %Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQPtr, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}**** %tmp_envptr2840

; don't need to alloc for env var logbuf
%tmp_envptr2842 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}* %environment2824, i32 0, i32 1
store i8** %logbufPtr, i8*** %tmp_envptr2842

; don't need to alloc for env var max_log_length
%tmp_envptr2844 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}* %environment2824, i32 0, i32 2
store i32* %max_log_lengthPtr, i32** %tmp_envptr2844

; don't need to alloc for env var _anon_lambda_1
%tmp_envptr2846 = getelementptr {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}, {{i8*, i8*, i64 (i8*, i8*, %Shader*)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}***}* %environment2824, i32 0, i32 3
store {i8*, i8*, i64 (i8*, i8*, %Shader*)*}*** %_anon_lambda_1Ptr, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}**** %tmp_envptr2846


%val2855 = load {i8*, i8*, i64 (i8*, i8*, %Shader*)*}**, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}*** %_anon_lambda_1Ptr

; let value assignment
%Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ = select i1 true, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %val2855, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %val2855
store {i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}*** %Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQPtr

%val2858 = load {i8*, i8*, i64 (i8*, i8*, %Shader*)*}**, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}*** %Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQPtr
ret {i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %val2858
}


@Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, %Shader*)*}** @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Shader*)*}, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Shader*)*}, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Shader*)*,  i64 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret i64 %result
}


define dllexport ccc i64 @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_native(%Shader* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Shader*)*}, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Shader*)*}, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Shader*)*,  i64 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2859 = bitcast [100 x i8]* @gsxtmgl-objects199 to i8*
call i32 (i8*, ...) @printf(i8* %var2859)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Shader*)*}, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Shader*)*}, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Shader*)*,  i64 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*}*
%arg_p_0 = getelementptr {%Shader*}, {%Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, %Shader*)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, %Shader*)*}*, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Shader*)*}, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, %Shader*)*}, {i8*, i8*, i64 (i8*, i8*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, %Shader*)*,  i64 (i8*, i8*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects200 = hidden constant [16 x i8] c"   Program: %s
\00"
@gsxtmgl-objects201 = hidden constant [48 x i8] c"ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd\00"
@gsxtmgl-objects202 = hidden constant [35 x i8] c"{i8*, i8*, i64 (i8*, i8*, i32)*}**\00"
@gsxtmgl-objects203 = hidden constant [15 x i8] c"_anon_lambda_2\00"
define dllexport fastcc i64 @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd__2860(i8* %_impz,i8* %_impenv, i32 %program) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2873 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}*
%ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJdPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}, {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJdPtr = load {i8*, i8*, i64 (i8*, i8*, i32)*}***, {i8*, i8*, i64 (i8*, i8*, i32)*}**** %ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJdPtr_
%logbufPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}, {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 1
%logbufPtr = load i8**, i8*** %logbufPtr_
%max_log_lengthPtr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}, {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 2
%max_log_lengthPtr = load i32*, i32** %max_log_lengthPtr_
%_anon_lambda_2Ptr_ = getelementptr {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}, {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}* %impenv, i32 0, i32 3
%_anon_lambda_2Ptr = load {i8*, i8*, i64 (i8*, i8*, i32)*}***, {i8*, i8*, i64 (i8*, i8*, i32)*}**** %_anon_lambda_2Ptr_

; setup arguments
%programPtr = alloca i32
store i32 %program, i32* %programPtr


%tzone2875 = load i8*, i8** %_impzPtr
%zone2876 = bitcast i8* %tzone2875 to %mzone*

; let assign value to symbol len_ptr
%len_ptrPtr = alloca i32*
%dat2874 = alloca i32, i64 1, align 16

; let value assignment
%len_ptr = select i1 true, i32* %dat2874, i32* %dat2874
store i32* %len_ptr, i32** %len_ptrPtr

; promote local stack var allocations
%tzone2897 = load i8*, i8** %_impzPtr
%zone2898 = bitcast i8* %tzone2897 to %mzone*
%ifptr2883 = alloca i8*
%val2877 = load i32, i32* %programPtr
%val2878 = load i32, i32* %max_log_lengthPtr
%val2879 = load i32*, i32** %len_ptrPtr
%val2880 = load i8*, i8** %logbufPtr
call fastcc void @glGetProgramInfoLog_adhoc_W3ZvaWQsaTMyLGkzMixpMzIqLGk4Kl0(i32 %val2877, i32 %val2878, i32* %val2879, i8* %val2880)
%var2882 = bitcast [16 x i8]* @gsxtmgl-objects200 to i8*
%val2884 = load i32*, i32** %len_ptrPtr
; pointer ref
%val2885 = getelementptr i32, i32* %val2884, i64 0
%val2886 = load i32, i32* %val2885
%cmp2887 = icmp eq i32 %val2886, 0
br i1 %cmp2887, label %then2883, label %else2883

then2883:
%var2888 = bitcast [3 x i8]* @gsxtmgl-objects191 to i8*
store i8* %var2888, i8** %ifptr2883
br label %ifcont2883

else2883:
%val2889 = load i8*, i8** %logbufPtr
store i8* %val2889, i8** %ifptr2883
br label %ifcont2883

ifcont2883:
%ifres2890 = load i8*, i8** %ifptr2883


%val2891 = call i32 (i8*, ...) @printf(i8* %var2882, i8* %ifres2890)
%val2893 = load i32*, i32** %len_ptrPtr
; pointer ref
%val2894 = getelementptr i32, i32* %val2893, i64 0
%val2895 = load i32, i32* %val2894
%cmp2896 = icmp eq i32 %val2895, 0
br i1 %cmp2896, label %then2892, label %else2892

then2892:
ret i64 0

else2892:
ret i64 1
}
@gsxtmgl-objects204 = hidden constant [101 x i8] c"ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i64 (i8*, i8*, i32)*}** @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone2936 = load i8*, i8** %_impzPtr
%zone2937 = bitcast i8* %tzone2936 to %mzone*

; let assign value to symbol ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd
%dat_ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd = call i8* @llvm_zone_malloc(%mzone* %zone2937, i64 8)
%ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJdPtr = bitcast i8* %dat_ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd to {i8*, i8*, i64 (i8*, i8*, i32)*}***
%tzone2861 = load i8*, i8** %_impzPtr
%zone2862 = bitcast i8* %tzone2861 to %mzone*

; let assign value to symbol max_log_length
%dat_max_log_length = call i8* @llvm_zone_malloc(%mzone* %zone2862, i64 4)
%max_log_lengthPtr = bitcast i8* %dat_max_log_length to i32*
%tzone2871 = load i8*, i8** %_impzPtr
%zone2872 = bitcast i8* %tzone2871 to %mzone*

; let assign value to symbol logbuf
%dat_logbuf = call i8* @llvm_zone_malloc(%mzone* %zone2872, i64 8)
%logbufPtr = bitcast i8* %dat_logbuf to i8**

; let value assignment
%max_log_length = select i1 true, i32 4096, i32 4096
store i32 %max_log_length, i32* %max_log_lengthPtr

%val2863 = load i32, i32* %max_log_lengthPtr
%tmp2864 = zext i32 %val2863 to i64
%val2865 = getelementptr i32, i32* null, i32 1
%zonesize2866 = mul i64 1, %tmp2864
%tzone2867 = load i8*, i8** %_impzPtr
%zone2868 = bitcast i8* %tzone2867 to %mzone*
%dat2869 = call i8* @llvm_zone_malloc(%mzone* %zone2868, i64 %zonesize2866)
call i8* @memset(i8* %dat2869, i32 0, i64 %zonesize2866)
%val2870 = bitcast i8* %dat2869 to i8*

; let value assignment
%logbuf = select i1 true, i8* %val2870, i8* %val2870
store i8* %logbuf, i8** %logbufPtr

%tzone2933 = load i8*, i8** %_impzPtr
%zone2934 = bitcast i8* %tzone2933 to %mzone*

; let assign value to symbol _anon_lambda_2
%dat__anon_lambda_2 = call i8* @llvm_zone_malloc(%mzone* %zone2934, i64 8)
%_anon_lambda_2Ptr = bitcast i8* %dat__anon_lambda_2 to { i8*, i8*, i64 (i8*, i8*, i32)*}***
%tzone2899 = load i8*, i8** %_impzPtr
%zone2900 = bitcast i8* %tzone2899 to %mzone*
call void @llvm_zone_mark(%mzone* %zone2900)
; malloc closure structure
%clsptr2901 = call i8* @llvm_zone_malloc(%mzone* %zone2900, i64 24)
%closure2902 = bitcast i8* %clsptr2901 to { i8*, i8*, i64 (i8*, i8*, i32)*}*

; malloc environment structure
%envptr2903 = call i8* @llvm_zone_malloc(%mzone* %zone2900, i64 32)
%environment2904 = bitcast i8* %envptr2903 to {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable2905 = call %clsvar* @new_address_table()
%var2906 = bitcast [48 x i8]* @gsxtmgl-objects201 to i8*
%var2907 = bitcast [35 x i8]* @gsxtmgl-objects202 to i8*
%addytable2908 = call %clsvar* @add_address_table(%mzone* %zone2900, i8* %var2906, i32 0, i8* %var2907, i32 3, %clsvar* %addytable2905)
%var2909 = bitcast [7 x i8]* @gsxtmgl-objects194 to i8*
%var2910 = bitcast [4 x i8]* @gsxtmgl-objects195 to i8*
%addytable2911 = call %clsvar* @add_address_table(%mzone* %zone2900, i8* %var2909, i32 8, i8* %var2910, i32 3, %clsvar* %addytable2908)
%var2912 = bitcast [15 x i8]* @gsxtmgl-objects196 to i8*
%var2913 = bitcast [4 x i8]* @gsxtmgl-objects197 to i8*
%addytable2914 = call %clsvar* @add_address_table(%mzone* %zone2900, i8* %var2912, i32 16, i8* %var2913, i32 3, %clsvar* %addytable2911)
%var2915 = bitcast [15 x i8]* @gsxtmgl-objects203 to i8*
%var2916 = bitcast [35 x i8]* @gsxtmgl-objects202 to i8*
%addytable2917 = call %clsvar* @add_address_table(%mzone* %zone2900, i8* %var2915, i32 24, i8* %var2916, i32 3, %clsvar* %addytable2914)
%address-table2918 = bitcast %clsvar* %addytable2917 to i8*

; insert table, function and environment into closure struct
%closure.table2927 = getelementptr { i8*, i8*, i64 (i8*, i8*, i32)*}, { i8*, i8*, i64 (i8*, i8*, i32)*}* %closure2902, i32 0, i32 0
store i8* %address-table2918, i8** %closure.table2927
%closure.env2928 = getelementptr { i8*, i8*, i64 (i8*, i8*, i32)*}, { i8*, i8*, i64 (i8*, i8*, i32)*}* %closure2902, i32 0, i32 1
store i8* %envptr2903, i8** %closure.env2928
%closure.func2929 = getelementptr { i8*, i8*, i64 (i8*, i8*, i32)*}, { i8*, i8*, i64 (i8*, i8*, i32)*}* %closure2902, i32 0, i32 2
store i64 (i8*, i8*, i32)* @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd__2860, i64 (i8*, i8*, i32)** %closure.func2929
%closure_size2930 = call i64 @llvm_zone_mark_size(%mzone* %zone2900)
call void @llvm_zone_ptr_set_size(i8* %clsptr2901, i64 %closure_size2930)
%wrapper_ptr2931 = call i8* @llvm_zone_malloc(%mzone* %zone2900, i64 8)
%closure_wrapper2932 = bitcast i8* %wrapper_ptr2931 to { i8*, i8*, i64 (i8*, i8*, i32)*}**
store { i8*, i8*, i64 (i8*, i8*, i32)*}* %closure2902, { i8*, i8*, i64 (i8*, i8*, i32)*}** %closure_wrapper2932

; let value assignment
%_anon_lambda_2 = select i1 true, { i8*, i8*, i64 (i8*, i8*, i32)*}** %closure_wrapper2932, { i8*, i8*, i64 (i8*, i8*, i32)*}** %closure_wrapper2932
store { i8*, i8*, i64 (i8*, i8*, i32)*}** %_anon_lambda_2, { i8*, i8*, i64 (i8*, i8*, i32)*}*** %_anon_lambda_2Ptr

; add data to environment
; don't need to alloc for env var ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd
%tmp_envptr2920 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}, {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}* %environment2904, i32 0, i32 0
store {i8*, i8*, i64 (i8*, i8*, i32)*}*** %ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJdPtr, {i8*, i8*, i64 (i8*, i8*, i32)*}**** %tmp_envptr2920

; don't need to alloc for env var logbuf
%tmp_envptr2922 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}, {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}* %environment2904, i32 0, i32 1
store i8** %logbufPtr, i8*** %tmp_envptr2922

; don't need to alloc for env var max_log_length
%tmp_envptr2924 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}, {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}* %environment2904, i32 0, i32 2
store i32* %max_log_lengthPtr, i32** %tmp_envptr2924

; don't need to alloc for env var _anon_lambda_2
%tmp_envptr2926 = getelementptr {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}, {{i8*, i8*, i64 (i8*, i8*, i32)*}***, i8**, i32*, {i8*, i8*, i64 (i8*, i8*, i32)*}***}* %environment2904, i32 0, i32 3
store {i8*, i8*, i64 (i8*, i8*, i32)*}*** %_anon_lambda_2Ptr, {i8*, i8*, i64 (i8*, i8*, i32)*}**** %tmp_envptr2926


%val2935 = load {i8*, i8*, i64 (i8*, i8*, i32)*}**, {i8*, i8*, i64 (i8*, i8*, i32)*}*** %_anon_lambda_2Ptr

; let value assignment
%ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd = select i1 true, {i8*, i8*, i64 (i8*, i8*, i32)*}** %val2935, {i8*, i8*, i64 (i8*, i8*, i32)*}** %val2935
store {i8*, i8*, i64 (i8*, i8*, i32)*}** %ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd, {i8*, i8*, i64 (i8*, i8*, i32)*}*** %ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJdPtr

%val2938 = load {i8*, i8*, i64 (i8*, i8*, i32)*}**, {i8*, i8*, i64 (i8*, i8*, i32)*}*** %ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJdPtr
ret {i8*, i8*, i64 (i8*, i8*, i32)*}** %val2938
}


@ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i64 (i8*, i8*, i32)*}** @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i64 (i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i64 @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i32)*}*, {i8*, i8*, i64 (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i32)*}, {i8*, i8*, i64 (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i32)*}, {i8*, i8*, i64 (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i32)*,  i64 (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret i64 %result
}


define dllexport ccc i64 @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_native(i32 %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i32)*}*, {i8*, i8*, i64 (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i32)*}, {i8*, i8*, i64 (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i32)*}, {i8*, i8*, i64 (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i32)*,  i64 (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i32 %arg_0)
ret i64 %result
}


define dllexport ccc i8*  @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var2939 = bitcast [101 x i8]* @gsxtmgl-objects204 to i8*
call i32 (i8*, ...) @printf(i8* %var2939)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i32)*}*, {i8*, i8*, i64 (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i32)*}, {i8*, i8*, i64 (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i32)*}, {i8*, i8*, i64 (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i32)*,  i64 (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%res = call ccc i8* @mk_i64(i8* %_sc, i64 %result)
ret i8* %res
}


define dllexport ccc void @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32}*
%arg_p_0 = getelementptr {i32}, {i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i64 (i8*, i8*, i32)*}**
%closure = load {i8*, i8*, i64 (i8*, i8*, i32)*}*, {i8*, i8*, i64 (i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i32)*}, {i8*, i8*, i64 (i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i64 (i8*, i8*, i32)*}, {i8*, i8*, i64 (i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  i64 (i8*, i8*, i32)*,  i64 (i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i64 %ff(i8* %_impz, i8* %ee, i32 %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects205 = hidden constant [93 x i8] c"Error: shader type must be one of GL_VERTEX_SHADER, GL_FRAGMENT_SHADER or GL_GEOMETRY_SHADER\00"
@gsxtmgl-objects206 = hidden constant [44 x i8] c"Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0\00"
@gsxtmgl-objects207 = hidden constant [45 x i8] c"{i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}**\00"
define dllexport fastcc %Shader* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0__2940(i8* %_impz,i8* %_impenv, i8* %source, i32 %type) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone2941 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}***}*
%Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}***}* %impenv, i32 0, i32 0
%Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0Ptr = load {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}***, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}**** %Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0Ptr_

; setup arguments
%sourcePtr = alloca i8*
store i8* %source, i8** %sourcePtr
%typePtr = alloca i32
store i32 %type, i32* %typePtr

; promote local stack var allocations
%tzone3002 = load i8*, i8** %_impzPtr
%zone3003 = bitcast i8* %tzone3002 to %mzone*
%ifptr2943 = alloca i1
%ifptr2944 = alloca i1
%ifptr2951 = alloca i1
%ifptr2958 = alloca i1

%val2945 = load i32, i32* %typePtr
%val2946 = load i32, i32* @GL_VERTEX_SHADER
%cmp2947 = icmp eq i32 %val2945, %val2946
br i1 %cmp2947, label %then2944, label %else2944

then2944:
%val2948 = load i32, i32* %typePtr
%val2949 = load i32, i32* @GL_VERTEX_SHADER
%cmp2950 = icmp eq i32 %val2948, %val2949
store i1 %cmp2950, i1* %ifptr2944
br label %ifcont2944

else2944:
%val2952 = load i32, i32* %typePtr
%val2953 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp2954 = icmp eq i32 %val2952, %val2953
br i1 %cmp2954, label %then2951, label %else2951

then2951:
%val2955 = load i32, i32* %typePtr
%val2956 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp2957 = icmp eq i32 %val2955, %val2956
store i1 %cmp2957, i1* %ifptr2951
br label %ifcont2951

else2951:
%val2959 = load i32, i32* %typePtr
%val2960 = load i32, i32* @GL_GEOMETRY_SHADER
%cmp2961 = icmp eq i32 %val2959, %val2960
br i1 %cmp2961, label %then2958, label %else2958

then2958:
%val2962 = load i32, i32* %typePtr
%val2963 = load i32, i32* @GL_GEOMETRY_SHADER
%cmp2964 = icmp eq i32 %val2962, %val2963
store i1 %cmp2964, i1* %ifptr2958
br label %ifcont2958

else2958:
%res2965 = call ccc i1 @impc_false()
store i1 %res2965, i1* %ifptr2958
br label %ifcont2958

ifcont2958:
%ifres2966 = load i1, i1* %ifptr2958

store i1 %ifres2966, i1* %ifptr2951
br label %ifcont2951

ifcont2951:
%ifres2967 = load i1, i1* %ifptr2951

store i1 %ifres2967, i1* %ifptr2944
br label %ifcont2944

ifcont2944:
%ifres2968 = load i1, i1* %ifptr2944

br i1 %ifres2968, label %then2943, label %else2943

then2943:
%res2969 = call ccc i1 @impc_false()
store i1 %res2969, i1* %ifptr2943
br label %ifcont2943

else2943:
%res2970 = call ccc i1 @impc_true()
store i1 %res2970, i1* %ifptr2943
br label %ifcont2943

ifcont2943:
%ifres2971 = load i1, i1* %ifptr2943

br i1 %ifres2971, label %then2942, label %else2942

then2942:
%var2972 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var2973 = bitcast [93 x i8]* @gsxtmgl-objects205 to i8*

%val2974 = call i32 (i8*, ...) @printf(i8* %var2972, i8* %var2973)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%null2976 = bitcast i8* null to %Shader*
ret %Shader* %null2976

else2942:
%tzone2979 = load i8*, i8** %_impzPtr
%zone2980 = bitcast i8* %tzone2979 to %mzone*

; let assign value to symbol shader_id
%shader_idPtr = alloca i32
%tzone2982 = load i8*, i8** %_impzPtr
%zone2983 = bitcast i8* %tzone2982 to %mzone*

; let assign value to symbol source_ptr
%source_ptrPtr = alloca i8**
%tzone2987 = load i8*, i8** %_impzPtr
%zone2988 = bitcast i8* %tzone2987 to %mzone*

; let assign value to symbol shader
%shaderPtr = alloca %Shader*
%val2977 = load i32, i32* %typePtr
%res2978 = call fastcc i32 @glCreateShader_adhoc_W2kzMixpMzJd(i32 %val2977)

; let value assignment
%shader_id = select i1 true, i32 %res2978, i32 %res2978
store i32 %shader_id, i32* %shader_idPtr

%dat2981 = alloca i8*, align 16

; let value assignment
%source_ptr = select i1 true, i8** %dat2981, i8** %dat2981
store i8** %source_ptr, i8*** %source_ptrPtr

%val2984 = load i32, i32* %shader_idPtr
%val2985 = load i32, i32* %typePtr
%res2986 = call fastcc %Shader* @Shader_adhoc_W1NoYWRlciosaTMyLGkzMl0(i32 %val2984, i32 %val2985)

; let value assignment
%shader = select i1 true, %Shader* %res2986, %Shader* %res2986
store %Shader* %shader, %Shader** %shaderPtr

%val2989 = load i8**, i8*** %source_ptrPtr
%val2990 = load i8*, i8** %sourcePtr
; set pointer
%val2991 = getelementptr i8*, i8** %val2989, i64 0
store i8* %val2990, i8** %val2991
%val2992 = load i32, i32* %shader_idPtr
%val2993 = load i8**, i8*** %source_ptrPtr
%null2994 = bitcast i8* null to i8*
%val2995 = bitcast i8* %null2994 to i32*
call fastcc void @glShaderSource_adhoc_W3ZvaWQsaTMyLGkzMixpOCoqLGkzMipd(i32 %val2992, i32 1, i8** %val2993, i32* %val2995)
%val2997 = load i32, i32* %shader_idPtr
call fastcc void @glCompileShader_adhoc_W3ZvaWQsaTMyXQ(i32 %val2997)
%val2999 = load %Shader*, %Shader** %shaderPtr
%res3000 = call fastcc i64 @Shader_print_info_log_adhoc_W2k2NCxTaGFkZXIqXQ(%Shader* %val2999)
%val3001 = load %Shader*, %Shader** %shaderPtr
ret %Shader* %val3001
}
@gsxtmgl-objects208 = hidden constant [97 x i8] c"Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}** @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3023 = load i8*, i8** %_impzPtr
%zone3024 = bitcast i8* %tzone3023 to %mzone*

; let assign value to symbol Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0
%dat_Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone3024, i64 8)
%Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0Ptr = bitcast i8* %dat_Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0 to { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}***
%tzone3004 = load i8*, i8** %_impzPtr
%zone3005 = bitcast i8* %tzone3004 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3005)
; malloc closure structure
%clsptr3006 = call i8* @llvm_zone_malloc(%mzone* %zone3005, i64 24)
%closure3007 = bitcast i8* %clsptr3006 to { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}*

; malloc environment structure
%envptr3008 = call i8* @llvm_zone_malloc(%mzone* %zone3005, i64 8)
%environment3009 = bitcast i8* %envptr3008 to {{i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}***}*

; malloc closure address table
%addytable3010 = call %clsvar* @new_address_table()
%var3011 = bitcast [44 x i8]* @gsxtmgl-objects206 to i8*
%var3012 = bitcast [45 x i8]* @gsxtmgl-objects207 to i8*
%addytable3013 = call %clsvar* @add_address_table(%mzone* %zone3005, i8* %var3011, i32 0, i8* %var3012, i32 3, %clsvar* %addytable3010)
%address-table3014 = bitcast %clsvar* %addytable3013 to i8*

; insert table, function and environment into closure struct
%closure.table3017 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}* %closure3007, i32 0, i32 0
store i8* %address-table3014, i8** %closure.table3017
%closure.env3018 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}* %closure3007, i32 0, i32 1
store i8* %envptr3008, i8** %closure.env3018
%closure.func3019 = getelementptr { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}, { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}* %closure3007, i32 0, i32 2
store %Shader* (i8*, i8*, i8*, i32)* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0__2940, %Shader* (i8*, i8*, i8*, i32)** %closure.func3019
%closure_size3020 = call i64 @llvm_zone_mark_size(%mzone* %zone3005)
call void @llvm_zone_ptr_set_size(i8* %clsptr3006, i64 %closure_size3020)
%wrapper_ptr3021 = call i8* @llvm_zone_malloc(%mzone* %zone3005, i64 8)
%closure_wrapper3022 = bitcast i8* %wrapper_ptr3021 to { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}**
store { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}* %closure3007, { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}** %closure_wrapper3022

; let value assignment
%Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0 = select i1 true, { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}** %closure_wrapper3022, { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}** %closure_wrapper3022
store { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}** %Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0, { i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}*** %Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0
%tmp_envptr3016 = getelementptr {{i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}***}, {{i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}***}* %environment3009, i32 0, i32 0
store {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}*** %Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0Ptr, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}**** %tmp_envptr3016


%val3025 = load {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}**, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}*** %Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0Ptr
ret {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}** %val3025
}


@Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}** @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %Shader* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0(i8* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i8*, i32)*,  %Shader* (i8*, i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc %Shader* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_native(i8* %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i8*, i32)*,  %Shader* (i8*, i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1)
ret %Shader* %result
}


define dllexport ccc i8*  @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3026 = bitcast [97 x i8]* @gsxtmgl-objects208 to i8*
call i32 (i8*, ...) @printf(i8* %var3026)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3027 = bitcast [97 x i8]* @gsxtmgl-objects208 to i8*
call i32 (i8*, ...) @printf(i8* %var3027)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i8*, i32)*,  %Shader* (i8*, i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1)
%tmpres = bitcast %Shader* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i32}*
%arg_p_0 = getelementptr {i8*, i32}, {i8*, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i32}, {i8*, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}**
%closure = load {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}*, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}, {i8*, i8*, %Shader* (i8*, i8*, i8*, i32)*}* %closure, i32 0, i32 1
%ff = load  %Shader* (i8*, i8*, i8*, i32)*,  %Shader* (i8*, i8*, i8*, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %Shader* %ff(i8* %_impz, i8* %ee, i8* %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects209 = hidden constant [62 x i8] c"Error: input shader types must be vert and frag respectively.\00"
@gsxtmgl-objects210 = hidden constant [56 x i8] c"ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd\00"
@gsxtmgl-objects211 = hidden constant [50 x i8] c"{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}**\00"
define dllexport fastcc i32 @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd__3028(i8* %_impz,i8* %_impenv, %Shader* %vert, %Shader* %frag) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3029 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}***}*
%ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipdPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipdPtr = load {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}***, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}**** %ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipdPtr_

; setup arguments
%vertPtr = alloca %Shader*
store %Shader* %vert, %Shader** %vertPtr
%fragPtr = alloca %Shader*
store %Shader* %frag, %Shader** %fragPtr

; promote local stack var allocations
%tzone3073 = load i8*, i8** %_impzPtr
%zone3074 = bitcast i8* %tzone3073 to %mzone*
%ifptr3031 = alloca i1
%ifptr3032 = alloca i1
%ifptr3037 = alloca i1

%val3033 = load %Shader*, %Shader** %vertPtr
%res3034 = call fastcc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val3033)
%val3035 = load i32, i32* @GL_VERTEX_SHADER
%cmp3036 = icmp eq i32 %res3034, %val3035
br i1 %cmp3036, label %then3032, label %else3032

then3032:
%val3038 = load %Shader*, %Shader** %fragPtr
%res3039 = call fastcc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val3038)
%val3040 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp3041 = icmp eq i32 %res3039, %val3040
br i1 %cmp3041, label %then3037, label %else3037

then3037:
%val3042 = load %Shader*, %Shader** %fragPtr
%res3043 = call fastcc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val3042)
%val3044 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp3045 = icmp eq i32 %res3043, %val3044
store i1 %cmp3045, i1* %ifptr3037
br label %ifcont3037

else3037:
%res3046 = call ccc i1 @impc_false()
store i1 %res3046, i1* %ifptr3037
br label %ifcont3037

ifcont3037:
%ifres3047 = load i1, i1* %ifptr3037

store i1 %ifres3047, i1* %ifptr3032
br label %ifcont3032

else3032:
%res3048 = call ccc i1 @impc_false()
store i1 %res3048, i1* %ifptr3032
br label %ifcont3032

ifcont3032:
%ifres3049 = load i1, i1* %ifptr3032

br i1 %ifres3049, label %then3031, label %else3031

then3031:
%res3050 = call ccc i1 @impc_false()
store i1 %res3050, i1* %ifptr3031
br label %ifcont3031

else3031:
%res3051 = call ccc i1 @impc_true()
store i1 %res3051, i1* %ifptr3031
br label %ifcont3031

ifcont3031:
%ifres3052 = load i1, i1* %ifptr3031

br i1 %ifres3052, label %then3030, label %else3030

then3030:
%var3053 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var3054 = bitcast [62 x i8]* @gsxtmgl-objects209 to i8*

%val3055 = call i32 (i8*, ...) @printf(i8* %var3053, i8* %var3054)
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret i32 -1

else3030:
%tzone3058 = load i8*, i8** %_impzPtr
%zone3059 = bitcast i8* %tzone3058 to %mzone*

; let assign value to symbol program
%programPtr = alloca i32
%res3057 = call fastcc i32 @glCreateProgram_adhoc_W2kzMl0()

; let value assignment
%program = select i1 true, i32 %res3057, i32 %res3057
store i32 %program, i32* %programPtr

%val3060 = load i32, i32* %programPtr
%val3061 = load %Shader*, %Shader** %vertPtr
%res3062 = call fastcc i32 @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val3061)
call fastcc void @glAttachShader_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val3060, i32 %res3062)
%val3064 = load i32, i32* %programPtr
%val3065 = load %Shader*, %Shader** %fragPtr
%res3066 = call fastcc i32 @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val3065)
call fastcc void @glAttachShader_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val3064, i32 %res3066)
%val3068 = load i32, i32* %programPtr
call fastcc void @glLinkProgram_adhoc_W3ZvaWQsaTMyXQ(i32 %val3068)
%val3070 = load i32, i32* %programPtr
%res3071 = call fastcc i64 @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd(i32 %val3070)
%val3072 = load i32, i32* %programPtr
ret i32 %val3072
}
@gsxtmgl-objects212 = hidden constant [109 x i8] c"ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}** @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3094 = load i8*, i8** %_impzPtr
%zone3095 = bitcast i8* %tzone3094 to %mzone*

; let assign value to symbol ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd
%dat_ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd = call i8* @llvm_zone_malloc(%mzone* %zone3095, i64 8)
%ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipdPtr = bitcast i8* %dat_ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd to { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}***
%tzone3075 = load i8*, i8** %_impzPtr
%zone3076 = bitcast i8* %tzone3075 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3076)
; malloc closure structure
%clsptr3077 = call i8* @llvm_zone_malloc(%mzone* %zone3076, i64 24)
%closure3078 = bitcast i8* %clsptr3077 to { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}*

; malloc environment structure
%envptr3079 = call i8* @llvm_zone_malloc(%mzone* %zone3076, i64 8)
%environment3080 = bitcast i8* %envptr3079 to {{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}***}*

; malloc closure address table
%addytable3081 = call %clsvar* @new_address_table()
%var3082 = bitcast [56 x i8]* @gsxtmgl-objects210 to i8*
%var3083 = bitcast [50 x i8]* @gsxtmgl-objects211 to i8*
%addytable3084 = call %clsvar* @add_address_table(%mzone* %zone3076, i8* %var3082, i32 0, i8* %var3083, i32 3, %clsvar* %addytable3081)
%address-table3085 = bitcast %clsvar* %addytable3084 to i8*

; insert table, function and environment into closure struct
%closure.table3088 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}* %closure3078, i32 0, i32 0
store i8* %address-table3085, i8** %closure.table3088
%closure.env3089 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}* %closure3078, i32 0, i32 1
store i8* %envptr3079, i8** %closure.env3089
%closure.func3090 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}* %closure3078, i32 0, i32 2
store i32 (i8*, i8*, %Shader*, %Shader*)* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd__3028, i32 (i8*, i8*, %Shader*, %Shader*)** %closure.func3090
%closure_size3091 = call i64 @llvm_zone_mark_size(%mzone* %zone3076)
call void @llvm_zone_ptr_set_size(i8* %clsptr3077, i64 %closure_size3091)
%wrapper_ptr3092 = call i8* @llvm_zone_malloc(%mzone* %zone3076, i64 8)
%closure_wrapper3093 = bitcast i8* %wrapper_ptr3092 to { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}**
store { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}* %closure3078, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}** %closure_wrapper3093

; let value assignment
%ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}** %closure_wrapper3093, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}** %closure_wrapper3093
store { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}** %ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}*** %ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipdPtr

; add data to environment
; don't need to alloc for env var ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd
%tmp_envptr3087 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}***}* %environment3080, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}*** %ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipdPtr, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}**** %tmp_envptr3087


%val3096 = load {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}**, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}*** %ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipdPtr
ret {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}** %val3096
}


@ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}** @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd(%Shader* %arg_0,%Shader* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*, %Shader*)*,  i32 (i8*, i8*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %Shader* %arg_1)
ret i32 %result
}


define dllexport ccc i32 @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_native(%Shader* %arg_0,%Shader* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*, %Shader*)*,  i32 (i8*, i8*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %Shader* %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3097 = bitcast [109 x i8]* @gsxtmgl-objects212 to i8*
call i32 (i8*, ...) @printf(i8* %var3097)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3098 = bitcast [109 x i8]* @gsxtmgl-objects212 to i8*
call i32 (i8*, ...) @printf(i8* %var3098)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*, %Shader*)*,  i32 (i8*, i8*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %Shader* %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*, %Shader*}*
%arg_p_0 = getelementptr {%Shader*, %Shader*}, {%Shader*, %Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
%arg_p_1 = getelementptr {%Shader*, %Shader*}, {%Shader*, %Shader*}* %fstruct, i32 0, i32 1
%arg_1 = load %Shader*, %Shader** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*, %Shader*)*,  i32 (i8*, i8*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %Shader* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects213 = hidden constant [67 x i8] c"ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0\00"
@gsxtmgl-objects214 = hidden constant [60 x i8] c"{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}**\00"
define dllexport fastcc i32 @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0__3099(i8* %_impz,i8* %_impenv, %Shader* %vert, %Shader* %geom, %Shader* %frag) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3100 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}***}*
%ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0Ptr = load {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}***, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}**** %ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0Ptr_

; setup arguments
%vertPtr = alloca %Shader*
store %Shader* %vert, %Shader** %vertPtr
%geomPtr = alloca %Shader*
store %Shader* %geom, %Shader** %geomPtr
%fragPtr = alloca %Shader*
store %Shader* %frag, %Shader** %fragPtr

; promote local stack var allocations
%tzone3155 = load i8*, i8** %_impzPtr
%zone3156 = bitcast i8* %tzone3155 to %mzone*
%ifptr3102 = alloca i1
%ifptr3103 = alloca i1
%ifptr3108 = alloca i1
%ifptr3113 = alloca i1

%val3104 = load %Shader*, %Shader** %vertPtr
%res3105 = call fastcc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val3104)
%val3106 = load i32, i32* @GL_VERTEX_SHADER
%cmp3107 = icmp eq i32 %res3105, %val3106
br i1 %cmp3107, label %then3103, label %else3103

then3103:
%val3109 = load %Shader*, %Shader** %geomPtr
%res3110 = call fastcc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val3109)
%val3111 = load i32, i32* @GL_GEOMETRY_SHADER
%cmp3112 = icmp eq i32 %res3110, %val3111
br i1 %cmp3112, label %then3108, label %else3108

then3108:
%val3114 = load %Shader*, %Shader** %fragPtr
%res3115 = call fastcc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val3114)
%val3116 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp3117 = icmp eq i32 %res3115, %val3116
br i1 %cmp3117, label %then3113, label %else3113

then3113:
%val3118 = load %Shader*, %Shader** %fragPtr
%res3119 = call fastcc i32 @Shader_type_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val3118)
%val3120 = load i32, i32* @GL_FRAGMENT_SHADER
%cmp3121 = icmp eq i32 %res3119, %val3120
store i1 %cmp3121, i1* %ifptr3113
br label %ifcont3113

else3113:
%res3122 = call ccc i1 @impc_false()
store i1 %res3122, i1* %ifptr3113
br label %ifcont3113

ifcont3113:
%ifres3123 = load i1, i1* %ifptr3113

store i1 %ifres3123, i1* %ifptr3108
br label %ifcont3108

else3108:
%res3124 = call ccc i1 @impc_false()
store i1 %res3124, i1* %ifptr3108
br label %ifcont3108

ifcont3108:
%ifres3125 = load i1, i1* %ifptr3108

store i1 %ifres3125, i1* %ifptr3103
br label %ifcont3103

else3103:
%res3126 = call ccc i1 @impc_false()
store i1 %res3126, i1* %ifptr3103
br label %ifcont3103

ifcont3103:
%ifres3127 = load i1, i1* %ifptr3103

br i1 %ifres3127, label %then3102, label %else3102

then3102:
%res3128 = call ccc i1 @impc_false()
store i1 %res3128, i1* %ifptr3102
br label %ifcont3102

else3102:
%res3129 = call ccc i1 @impc_true()
store i1 %res3129, i1* %ifptr3102
br label %ifcont3102

ifcont3102:
%ifres3130 = load i1, i1* %ifptr3102

br i1 %ifres3130, label %then3101, label %else3101

then3101:
%var3131 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var3132 = bitcast [62 x i8]* @gsxtmgl-objects209 to i8*

%val3133 = call i32 (i8*, ...) @printf(i8* %var3131, i8* %var3132)
call fastcc void @print_return_adhoc_W3ZvaWRd()
ret i32 -1

else3101:
%tzone3136 = load i8*, i8** %_impzPtr
%zone3137 = bitcast i8* %tzone3136 to %mzone*

; let assign value to symbol program
%programPtr = alloca i32
%res3135 = call fastcc i32 @glCreateProgram_adhoc_W2kzMl0()

; let value assignment
%program = select i1 true, i32 %res3135, i32 %res3135
store i32 %program, i32* %programPtr

%val3138 = load i32, i32* %programPtr
%val3139 = load %Shader*, %Shader** %vertPtr
%res3140 = call fastcc i32 @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val3139)
call fastcc void @glAttachShader_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val3138, i32 %res3140)
%val3142 = load i32, i32* %programPtr
%val3143 = load %Shader*, %Shader** %geomPtr
%res3144 = call fastcc i32 @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val3143)
call fastcc void @glAttachShader_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val3142, i32 %res3144)
%val3146 = load i32, i32* %programPtr
%val3147 = load %Shader*, %Shader** %fragPtr
%res3148 = call fastcc i32 @Shader_id_adhoc_W2kzMixTaGFkZXIqXQ(%Shader* %val3147)
call fastcc void @glAttachShader_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val3146, i32 %res3148)
%val3150 = load i32, i32* %programPtr
call fastcc void @glLinkProgram_adhoc_W3ZvaWQsaTMyXQ(i32 %val3150)
%val3152 = load i32, i32* %programPtr
%res3153 = call fastcc i64 @ShaderProgram_print_info_log_adhoc_W2k2NCxpMzJd(i32 %val3152)
%val3154 = load i32, i32* %programPtr
ret i32 %val3154
}
@gsxtmgl-objects215 = hidden constant [120 x i8] c"ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}** @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3176 = load i8*, i8** %_impzPtr
%zone3177 = bitcast i8* %tzone3176 to %mzone*

; let assign value to symbol ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0
%dat_ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3177, i64 8)
%ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0Ptr = bitcast i8* %dat_ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0 to { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}***
%tzone3157 = load i8*, i8** %_impzPtr
%zone3158 = bitcast i8* %tzone3157 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3158)
; malloc closure structure
%clsptr3159 = call i8* @llvm_zone_malloc(%mzone* %zone3158, i64 24)
%closure3160 = bitcast i8* %clsptr3159 to { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}*

; malloc environment structure
%envptr3161 = call i8* @llvm_zone_malloc(%mzone* %zone3158, i64 8)
%environment3162 = bitcast i8* %envptr3161 to {{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}***}*

; malloc closure address table
%addytable3163 = call %clsvar* @new_address_table()
%var3164 = bitcast [67 x i8]* @gsxtmgl-objects213 to i8*
%var3165 = bitcast [60 x i8]* @gsxtmgl-objects214 to i8*
%addytable3166 = call %clsvar* @add_address_table(%mzone* %zone3158, i8* %var3164, i32 0, i8* %var3165, i32 3, %clsvar* %addytable3163)
%address-table3167 = bitcast %clsvar* %addytable3166 to i8*

; insert table, function and environment into closure struct
%closure.table3170 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}* %closure3160, i32 0, i32 0
store i8* %address-table3167, i8** %closure.table3170
%closure.env3171 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}* %closure3160, i32 0, i32 1
store i8* %envptr3161, i8** %closure.env3171
%closure.func3172 = getelementptr { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}* %closure3160, i32 0, i32 2
store i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0__3099, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)** %closure.func3172
%closure_size3173 = call i64 @llvm_zone_mark_size(%mzone* %zone3158)
call void @llvm_zone_ptr_set_size(i8* %clsptr3159, i64 %closure_size3173)
%wrapper_ptr3174 = call i8* @llvm_zone_malloc(%mzone* %zone3158, i64 8)
%closure_wrapper3175 = bitcast i8* %wrapper_ptr3174 to { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}**
store { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}* %closure3160, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}** %closure_wrapper3175

; let value assignment
%ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}** %closure_wrapper3175, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}** %closure_wrapper3175
store { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}** %ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0, { i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}*** %ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0Ptr

; add data to environment
; don't need to alloc for env var ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0
%tmp_envptr3169 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}***}* %environment3162, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}*** %ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0Ptr, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}**** %tmp_envptr3169


%val3178 = load {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}**, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}*** %ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}** %val3178
}


@ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}** @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0(%Shader* %arg_0,%Shader* %arg_1,%Shader* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*,  i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %Shader* %arg_1, %Shader* %arg_2)
ret i32 %result
}


define dllexport ccc i32 @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_native(%Shader* %arg_0,%Shader* %arg_1,%Shader* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*,  i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %Shader* %arg_1, %Shader* %arg_2)
ret i32 %result
}


define dllexport ccc i8*  @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3179 = bitcast [120 x i8]* @gsxtmgl-objects215 to i8*
call i32 (i8*, ...) @printf(i8* %var3179)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %Shader*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3180 = bitcast [120 x i8]* @gsxtmgl-objects215 to i8*
call i32 (i8*, ...) @printf(i8* %var3180)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %Shader*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3181 = bitcast [120 x i8]* @gsxtmgl-objects215 to i8*
call i32 (i8*, ...) @printf(i8* %var3181)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %Shader*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*,  i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %Shader* %arg_1, %Shader* %arg_2)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%Shader*, %Shader*, %Shader*}*
%arg_p_0 = getelementptr {%Shader*, %Shader*, %Shader*}, {%Shader*, %Shader*, %Shader*}* %fstruct, i32 0, i32 0
%arg_0 = load %Shader*, %Shader** %arg_p_0
%arg_p_1 = getelementptr {%Shader*, %Shader*, %Shader*}, {%Shader*, %Shader*, %Shader*}* %fstruct, i32 0, i32 1
%arg_1 = load %Shader*, %Shader** %arg_p_1
%arg_p_2 = getelementptr {%Shader*, %Shader*, %Shader*}, {%Shader*, %Shader*, %Shader*}* %fstruct, i32 0, i32 2
%arg_2 = load %Shader*, %Shader** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}*, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}, {i8*, i8*, i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)*,  i32 (i8*, i8*, %Shader*, %Shader*, %Shader*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %Shader* %arg_0, %Shader* %arg_1, %Shader* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects216 = hidden constant [46 x i8] c"ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ\00"
@gsxtmgl-objects217 = hidden constant [40 x i8] c"{i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}**\00"
define dllexport fastcc i32 @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ__3182(i8* %_impz,i8* %_impenv, i8* %vsource, i8* %fsource) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3183 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}***}*
%ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQPtr = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}**** %ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQPtr_

; setup arguments
%vsourcePtr = alloca i8*
store i8* %vsource, i8** %vsourcePtr
%fsourcePtr = alloca i8*
store i8* %fsource, i8** %fsourcePtr


%tzone3187 = load i8*, i8** %_impzPtr
%zone3188 = bitcast i8* %tzone3187 to %mzone*

; let assign value to symbol vert
%vertPtr = alloca %Shader*
%tzone3192 = load i8*, i8** %_impzPtr
%zone3193 = bitcast i8* %tzone3192 to %mzone*

; let assign value to symbol frag
%fragPtr = alloca %Shader*
%val3184 = load i8*, i8** %vsourcePtr
%val3185 = load i32, i32* @GL_VERTEX_SHADER
%res3186 = call fastcc %Shader* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0(i8* %val3184, i32 %val3185)

; let value assignment
%vert = select i1 true, %Shader* %res3186, %Shader* %res3186
store %Shader* %vert, %Shader** %vertPtr

%val3189 = load i8*, i8** %fsourcePtr
%val3190 = load i32, i32* @GL_FRAGMENT_SHADER
%res3191 = call fastcc %Shader* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0(i8* %val3189, i32 %val3190)

; let value assignment
%frag = select i1 true, %Shader* %res3191, %Shader* %res3191
store %Shader* %frag, %Shader** %fragPtr

; promote local stack var allocations
%tzone3211 = load i8*, i8** %_impzPtr
%zone3212 = bitcast i8* %tzone3211 to %mzone*
%ifptr3195 = alloca i1
%ifptr3200 = alloca i1
%val3196 = load %Shader*, %Shader** %vertPtr
%val3197 = icmp eq %Shader* %val3196, null
br i1 %val3197, label %then3195, label %else3195

then3195:
%val3198 = load %Shader*, %Shader** %vertPtr
%val3199 = icmp eq %Shader* %val3198, null
store i1 %val3199, i1* %ifptr3195
br label %ifcont3195

else3195:
%val3201 = load %Shader*, %Shader** %fragPtr
%val3202 = icmp eq %Shader* %val3201, null
br i1 %val3202, label %then3200, label %else3200

then3200:
%val3203 = load %Shader*, %Shader** %fragPtr
%val3204 = icmp eq %Shader* %val3203, null
store i1 %val3204, i1* %ifptr3200
br label %ifcont3200

else3200:
%res3205 = call ccc i1 @impc_false()
store i1 %res3205, i1* %ifptr3200
br label %ifcont3200

ifcont3200:
%ifres3206 = load i1, i1* %ifptr3200

store i1 %ifres3206, i1* %ifptr3195
br label %ifcont3195

ifcont3195:
%ifres3207 = load i1, i1* %ifptr3195

br i1 %ifres3207, label %then3194, label %else3194

then3194:
ret i32 -1

else3194:
%val3208 = load %Shader*, %Shader** %vertPtr
%val3209 = load %Shader*, %Shader** %fragPtr
%res3210 = call fastcc i32 @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlcipd(%Shader* %val3208, %Shader* %val3209)
ret i32 %res3210
}
@gsxtmgl-objects218 = hidden constant [99 x i8] c"ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}** @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3232 = load i8*, i8** %_impzPtr
%zone3233 = bitcast i8* %tzone3232 to %mzone*

; let assign value to symbol ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ
%dat_ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3233, i64 8)
%ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQPtr = bitcast i8* %dat_ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ to { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}***
%tzone3213 = load i8*, i8** %_impzPtr
%zone3214 = bitcast i8* %tzone3213 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3214)
; malloc closure structure
%clsptr3215 = call i8* @llvm_zone_malloc(%mzone* %zone3214, i64 24)
%closure3216 = bitcast i8* %clsptr3215 to { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3217 = call i8* @llvm_zone_malloc(%mzone* %zone3214, i64 8)
%environment3218 = bitcast i8* %envptr3217 to {{i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3219 = call %clsvar* @new_address_table()
%var3220 = bitcast [46 x i8]* @gsxtmgl-objects216 to i8*
%var3221 = bitcast [40 x i8]* @gsxtmgl-objects217 to i8*
%addytable3222 = call %clsvar* @add_address_table(%mzone* %zone3214, i8* %var3220, i32 0, i8* %var3221, i32 3, %clsvar* %addytable3219)
%address-table3223 = bitcast %clsvar* %addytable3222 to i8*

; insert table, function and environment into closure struct
%closure.table3226 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}* %closure3216, i32 0, i32 0
store i8* %address-table3223, i8** %closure.table3226
%closure.env3227 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}* %closure3216, i32 0, i32 1
store i8* %envptr3217, i8** %closure.env3227
%closure.func3228 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}* %closure3216, i32 0, i32 2
store i32 (i8*, i8*, i8*, i8*)* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ__3182, i32 (i8*, i8*, i8*, i8*)** %closure.func3228
%closure_size3229 = call i64 @llvm_zone_mark_size(%mzone* %zone3214)
call void @llvm_zone_ptr_set_size(i8* %clsptr3215, i64 %closure_size3229)
%wrapper_ptr3230 = call i8* @llvm_zone_malloc(%mzone* %zone3214, i64 8)
%closure_wrapper3231 = bitcast i8* %wrapper_ptr3230 to { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}* %closure3216, { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}** %closure_wrapper3231

; let value assignment
%ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}** %closure_wrapper3231, { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}** %closure_wrapper3231
store { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}** %ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ, { i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}*** %ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQPtr

; add data to environment
; don't need to alloc for env var ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ
%tmp_envptr3225 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}***}* %environment3218, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}*** %ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQPtr, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}**** %tmp_envptr3225


%val3234 = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}*** %ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQPtr
ret {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}** %val3234
}


@ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}** @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret i32 %result
}


define dllexport ccc i32 @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_native(i8* %arg_0,i8* %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3235 = bitcast [99 x i8]* @gsxtmgl-objects218 to i8*
call i32 (i8*, ...) @printf(i8* %var3235)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3236 = bitcast [99 x i8]* @gsxtmgl-objects218 to i8*
call i32 (i8*, ...) @printf(i8* %var3236)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*}, {i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects219 = hidden constant [51 x i8] c"ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0\00"
@gsxtmgl-objects220 = hidden constant [45 x i8] c"{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**\00"
define dllexport fastcc i32 @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0__3237(i8* %_impz,i8* %_impenv, i8* %vsource, i8* %gsource, i8* %fsource) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3238 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***}*
%ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***}* %impenv, i32 0, i32 0
%ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**** %ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr_

; setup arguments
%vsourcePtr = alloca i8*
store i8* %vsource, i8** %vsourcePtr
%gsourcePtr = alloca i8*
store i8* %gsource, i8** %gsourcePtr
%fsourcePtr = alloca i8*
store i8* %fsource, i8** %fsourcePtr


%tzone3242 = load i8*, i8** %_impzPtr
%zone3243 = bitcast i8* %tzone3242 to %mzone*

; let assign value to symbol vert
%vertPtr = alloca %Shader*
%tzone3247 = load i8*, i8** %_impzPtr
%zone3248 = bitcast i8* %tzone3247 to %mzone*

; let assign value to symbol geom
%geomPtr = alloca %Shader*
%tzone3252 = load i8*, i8** %_impzPtr
%zone3253 = bitcast i8* %tzone3252 to %mzone*

; let assign value to symbol frag
%fragPtr = alloca %Shader*
%val3239 = load i8*, i8** %vsourcePtr
%val3240 = load i32, i32* @GL_VERTEX_SHADER
%res3241 = call fastcc %Shader* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0(i8* %val3239, i32 %val3240)

; let value assignment
%vert = select i1 true, %Shader* %res3241, %Shader* %res3241
store %Shader* %vert, %Shader** %vertPtr

%val3244 = load i8*, i8** %vsourcePtr
%val3245 = load i32, i32* @GL_GEOMETRY_SHADER
%res3246 = call fastcc %Shader* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0(i8* %val3244, i32 %val3245)

; let value assignment
%geom = select i1 true, %Shader* %res3246, %Shader* %res3246
store %Shader* %geom, %Shader** %geomPtr

%val3249 = load i8*, i8** %fsourcePtr
%val3250 = load i32, i32* @GL_FRAGMENT_SHADER
%res3251 = call fastcc %Shader* @Shader_create_adhoc_W1NoYWRlciosaTgqLGkzMl0(i8* %val3249, i32 %val3250)

; let value assignment
%frag = select i1 true, %Shader* %res3251, %Shader* %res3251
store %Shader* %frag, %Shader** %fragPtr

; promote local stack var allocations
%tzone3278 = load i8*, i8** %_impzPtr
%zone3279 = bitcast i8* %tzone3278 to %mzone*
%ifptr3255 = alloca i1
%ifptr3260 = alloca i1
%ifptr3265 = alloca i1
%val3256 = load %Shader*, %Shader** %vertPtr
%val3257 = icmp eq %Shader* %val3256, null
br i1 %val3257, label %then3255, label %else3255

then3255:
%val3258 = load %Shader*, %Shader** %vertPtr
%val3259 = icmp eq %Shader* %val3258, null
store i1 %val3259, i1* %ifptr3255
br label %ifcont3255

else3255:
%val3261 = load %Shader*, %Shader** %geomPtr
%val3262 = icmp eq %Shader* %val3261, null
br i1 %val3262, label %then3260, label %else3260

then3260:
%val3263 = load %Shader*, %Shader** %geomPtr
%val3264 = icmp eq %Shader* %val3263, null
store i1 %val3264, i1* %ifptr3260
br label %ifcont3260

else3260:
%val3266 = load %Shader*, %Shader** %fragPtr
%val3267 = icmp eq %Shader* %val3266, null
br i1 %val3267, label %then3265, label %else3265

then3265:
%val3268 = load %Shader*, %Shader** %fragPtr
%val3269 = icmp eq %Shader* %val3268, null
store i1 %val3269, i1* %ifptr3265
br label %ifcont3265

else3265:
%res3270 = call ccc i1 @impc_false()
store i1 %res3270, i1* %ifptr3265
br label %ifcont3265

ifcont3265:
%ifres3271 = load i1, i1* %ifptr3265

store i1 %ifres3271, i1* %ifptr3260
br label %ifcont3260

ifcont3260:
%ifres3272 = load i1, i1* %ifptr3260

store i1 %ifres3272, i1* %ifptr3255
br label %ifcont3255

ifcont3255:
%ifres3273 = load i1, i1* %ifptr3255

br i1 %ifres3273, label %then3254, label %else3254

then3254:
ret i32 -1

else3254:
%val3274 = load %Shader*, %Shader** %vertPtr
%val3275 = load %Shader*, %Shader** %geomPtr
%val3276 = load %Shader*, %Shader** %fragPtr
%res3277 = call fastcc i32 @ShaderProgram_create_adhoc_W2kzMixTaGFkZXIqLFNoYWRlciosU2hhZGVyKl0(%Shader* %val3274, %Shader* %val3275, %Shader* %val3276)
ret i32 %res3277
}
@gsxtmgl-objects221 = hidden constant [104 x i8] c"ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3299 = load i8*, i8** %_impzPtr
%zone3300 = bitcast i8* %tzone3299 to %mzone*

; let assign value to symbol ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0
%dat_ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0 = call i8* @llvm_zone_malloc(%mzone* %zone3300, i64 8)
%ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr = bitcast i8* %dat_ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0 to { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***
%tzone3280 = load i8*, i8** %_impzPtr
%zone3281 = bitcast i8* %tzone3280 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3281)
; malloc closure structure
%clsptr3282 = call i8* @llvm_zone_malloc(%mzone* %zone3281, i64 24)
%closure3283 = bitcast i8* %clsptr3282 to { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*

; malloc environment structure
%envptr3284 = call i8* @llvm_zone_malloc(%mzone* %zone3281, i64 8)
%environment3285 = bitcast i8* %envptr3284 to {{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***}*

; malloc closure address table
%addytable3286 = call %clsvar* @new_address_table()
%var3287 = bitcast [51 x i8]* @gsxtmgl-objects219 to i8*
%var3288 = bitcast [45 x i8]* @gsxtmgl-objects220 to i8*
%addytable3289 = call %clsvar* @add_address_table(%mzone* %zone3281, i8* %var3287, i32 0, i8* %var3288, i32 3, %clsvar* %addytable3286)
%address-table3290 = bitcast %clsvar* %addytable3289 to i8*

; insert table, function and environment into closure struct
%closure.table3293 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure3283, i32 0, i32 0
store i8* %address-table3290, i8** %closure.table3293
%closure.env3294 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure3283, i32 0, i32 1
store i8* %envptr3284, i8** %closure.env3294
%closure.func3295 = getelementptr { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure3283, i32 0, i32 2
store i32 (i8*, i8*, i8*, i8*, i8*)* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0__3237, i32 (i8*, i8*, i8*, i8*, i8*)** %closure.func3295
%closure_size3296 = call i64 @llvm_zone_mark_size(%mzone* %zone3281)
call void @llvm_zone_ptr_set_size(i8* %clsptr3282, i64 %closure_size3296)
%wrapper_ptr3297 = call i8* @llvm_zone_malloc(%mzone* %zone3281, i64 8)
%closure_wrapper3298 = bitcast i8* %wrapper_ptr3297 to { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**
store { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure3283, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper3298

; let value assignment
%ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0 = select i1 true, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper3298, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_wrapper3298
store { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0, { i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*** %ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr

; add data to environment
; don't need to alloc for env var ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0
%tmp_envptr3292 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***}, {{i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}***}* %environment3285, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*** %ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**** %tmp_envptr3292


%val3301 = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*** %ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0Ptr
ret {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %val3301
}


@ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var = dllexport global [1 x i8*] [ i8* null ]

@ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0(i8* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
ret i32 %result
}


define dllexport ccc i32 @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_native(i8* %arg_0,i8* %arg_1,i8* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
ret i32 %result
}


define dllexport ccc i8*  @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr_or_str(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3302 = bitcast [104 x i8]* @gsxtmgl-objects221 to i8*
call i32 (i8*, ...) @printf(i8* %var3302)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i8*  @cptr_value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr_or_str(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3303 = bitcast [104 x i8]* @gsxtmgl-objects221 to i8*
call i32 (i8*, ...) @printf(i8* %var3303)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i8*  @cptr_value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr_or_str(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3304 = bitcast [104 x i8]* @gsxtmgl-objects221 to i8*
call i32 (i8*, ...) @printf(i8* %var3304)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i8*  @cptr_value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i8*, i8*, i8*}*
%arg_p_0 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 0
%arg_0 = load i8*, i8** %arg_p_0
%arg_p_1 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 1
%arg_1 = load i8*, i8** %arg_p_1
%arg_p_2 = getelementptr {i8*, i8*, i8*}, {i8*, i8*, i8*}* %fstruct, i32 0, i32 2
%arg_2 = load i8*, i8** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @ShaderProgram_create_adhoc_W2kzMixpOCosaTgqLGk4Kl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}*, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}, {i8*, i8*, i32 (i8*, i8*, i8*, i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i8*, i8*, i8*)*,  i32 (i8*, i8*, i8*, i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i8* %arg_0, i8* %arg_1, i8* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


%FBO = type {i32,i32,i32,i32,i32}
@gsxtmgl-objects222 = hidden constant [46 x i8] c"FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0\00"
@gsxtmgl-objects223 = hidden constant [57 x i8] c"{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**\00"
define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0__3305(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3306 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}*
%FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**** %FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr


%tzone3311 = load i8*, i8** %_impzPtr
%zone3312 = bitcast i8* %tzone3311 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %FBO*
%tzone3307 = load i8*, i8** %_impzPtr
%zone3308 = bitcast i8* %tzone3307 to %mzone*
%dat3309 = call i8* @llvm_zone_malloc(%mzone* %zone3308, i64 20)
call i8* @memset(i8* %dat3309, i32 0, i64 20)
%val3310 = bitcast i8* %dat3309 to %FBO*

; let value assignment
%obj = select i1 true, %FBO* %val3310, %FBO* %val3310
store %FBO* %obj, %FBO** %objPtr

%val3313 = load %FBO*, %FBO** %objPtr
%val3314 = load i32, i32* %arg_0Ptr
; set tuple
%val3315 = getelementptr %FBO, %FBO* %val3313, i64 0, i32 0
store i32 %val3314, i32* %val3315
%val3316 = load %FBO*, %FBO** %objPtr
%val3317 = load i32, i32* %arg_1Ptr
; set tuple
%val3318 = getelementptr %FBO, %FBO* %val3316, i64 0, i32 1
store i32 %val3317, i32* %val3318
%val3319 = load %FBO*, %FBO** %objPtr
%val3320 = load i32, i32* %arg_2Ptr
; set tuple
%val3321 = getelementptr %FBO, %FBO* %val3319, i64 0, i32 2
store i32 %val3320, i32* %val3321
%val3322 = load %FBO*, %FBO** %objPtr
%val3323 = load i32, i32* %arg_3Ptr
; set tuple
%val3324 = getelementptr %FBO, %FBO* %val3322, i64 0, i32 3
store i32 %val3323, i32* %val3324
%val3325 = load %FBO*, %FBO** %objPtr
%val3326 = load i32, i32* %arg_4Ptr
; set tuple
%val3327 = getelementptr %FBO, %FBO* %val3325, i64 0, i32 4
store i32 %val3326, i32* %val3327
%val3328 = load %FBO*, %FBO** %objPtr
ret %FBO* %val3328
}
@gsxtmgl-objects224 = hidden constant [99 x i8] c"FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3348 = load i8*, i8** %_impzPtr
%zone3349 = bitcast i8* %tzone3348 to %mzone*

; let assign value to symbol FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0
%dat_FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone3349, i64 8)
%FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***
%tzone3329 = load i8*, i8** %_impzPtr
%zone3330 = bitcast i8* %tzone3329 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3330)
; malloc closure structure
%clsptr3331 = call i8* @llvm_zone_malloc(%mzone* %zone3330, i64 24)
%closure3332 = bitcast i8* %clsptr3331 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr3333 = call i8* @llvm_zone_malloc(%mzone* %zone3330, i64 8)
%environment3334 = bitcast i8* %envptr3333 to {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable3335 = call %clsvar* @new_address_table()
%var3336 = bitcast [46 x i8]* @gsxtmgl-objects222 to i8*
%var3337 = bitcast [57 x i8]* @gsxtmgl-objects223 to i8*
%addytable3338 = call %clsvar* @add_address_table(%mzone* %zone3330, i8* %var3336, i32 0, i8* %var3337, i32 3, %clsvar* %addytable3335)
%address-table3339 = bitcast %clsvar* %addytable3338 to i8*

; insert table, function and environment into closure struct
%closure.table3342 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3332, i32 0, i32 0
store i8* %address-table3339, i8** %closure.table3342
%closure.env3343 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3332, i32 0, i32 1
store i8* %envptr3333, i8** %closure.env3343
%closure.func3344 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3332, i32 0, i32 2
store %FBO* (i8*, i8*, i32, i32, i32, i32, i32)* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0__3305, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %closure.func3344
%closure_size3345 = call i64 @llvm_zone_mark_size(%mzone* %zone3330)
call void @llvm_zone_ptr_set_size(i8* %clsptr3331, i64 %closure_size3345)
%wrapper_ptr3346 = call i8* @llvm_zone_malloc(%mzone* %zone3330, i64 8)
%closure_wrapper3347 = bitcast i8* %wrapper_ptr3346 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3332, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper3347

; let value assignment
%FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper3347, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper3347
store { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*** %FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0
%tmp_envptr3341 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}* %environment3334, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*** %FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**** %tmp_envptr3341


%val3350 = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*** %FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %val3350
}


@FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3351 = bitcast [99 x i8]* @gsxtmgl-objects224 to i8*
call i32 (i8*, ...) @printf(i8* %var3351)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3352 = bitcast [99 x i8]* @gsxtmgl-objects224 to i8*
call i32 (i8*, ...) @printf(i8* %var3352)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3353 = bitcast [99 x i8]* @gsxtmgl-objects224 to i8*
call i32 (i8*, ...) @printf(i8* %var3353)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3354 = bitcast [99 x i8]* @gsxtmgl-objects224 to i8*
call i32 (i8*, ...) @printf(i8* %var3354)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var3355 = bitcast [99 x i8]* @gsxtmgl-objects224 to i8*
call i32 (i8*, ...) @printf(i8* %var3355)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects225 = hidden constant [48 x i8] c"FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0\00"
define dllexport fastcc %FBO* @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0__3356(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3357 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}*
%FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**** %FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr


%tzone3362 = load i8*, i8** %_impzPtr
%zone3363 = bitcast i8* %tzone3362 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %FBO*
%tzone3358 = load i8*, i8** %_impzPtr
%zone3359 = bitcast i8* %tzone3358 to %mzone*
%dat3360 = call i8* @llvm_zone_malloc(%mzone* %zone3359, i64 20)
call i8* @memset(i8* %dat3360, i32 0, i64 20)
%val3361 = bitcast i8* %dat3360 to %FBO*

; let value assignment
%obj = select i1 true, %FBO* %val3361, %FBO* %val3361
store %FBO* %obj, %FBO** %objPtr

%val3364 = load %FBO*, %FBO** %objPtr
%val3365 = load i32, i32* %arg_0Ptr
; set tuple
%val3366 = getelementptr %FBO, %FBO* %val3364, i64 0, i32 0
store i32 %val3365, i32* %val3366
%val3367 = load %FBO*, %FBO** %objPtr
%val3368 = load i32, i32* %arg_1Ptr
; set tuple
%val3369 = getelementptr %FBO, %FBO* %val3367, i64 0, i32 1
store i32 %val3368, i32* %val3369
%val3370 = load %FBO*, %FBO** %objPtr
%val3371 = load i32, i32* %arg_2Ptr
; set tuple
%val3372 = getelementptr %FBO, %FBO* %val3370, i64 0, i32 2
store i32 %val3371, i32* %val3372
%val3373 = load %FBO*, %FBO** %objPtr
%val3374 = load i32, i32* %arg_3Ptr
; set tuple
%val3375 = getelementptr %FBO, %FBO* %val3373, i64 0, i32 3
store i32 %val3374, i32* %val3375
%val3376 = load %FBO*, %FBO** %objPtr
%val3377 = load i32, i32* %arg_4Ptr
; set tuple
%val3378 = getelementptr %FBO, %FBO* %val3376, i64 0, i32 4
store i32 %val3377, i32* %val3378
%val3379 = load %FBO*, %FBO** %objPtr
ret %FBO* %val3379
}
@gsxtmgl-objects226 = hidden constant [101 x i8] c"FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3399 = load i8*, i8** %_impzPtr
%zone3400 = bitcast i8* %tzone3399 to %mzone*

; let assign value to symbol FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0
%dat_FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone3400, i64 8)
%FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***
%tzone3380 = load i8*, i8** %_impzPtr
%zone3381 = bitcast i8* %tzone3380 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3381)
; malloc closure structure
%clsptr3382 = call i8* @llvm_zone_malloc(%mzone* %zone3381, i64 24)
%closure3383 = bitcast i8* %clsptr3382 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr3384 = call i8* @llvm_zone_malloc(%mzone* %zone3381, i64 8)
%environment3385 = bitcast i8* %envptr3384 to {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable3386 = call %clsvar* @new_address_table()
%var3387 = bitcast [48 x i8]* @gsxtmgl-objects225 to i8*
%var3388 = bitcast [57 x i8]* @gsxtmgl-objects223 to i8*
%addytable3389 = call %clsvar* @add_address_table(%mzone* %zone3381, i8* %var3387, i32 0, i8* %var3388, i32 3, %clsvar* %addytable3386)
%address-table3390 = bitcast %clsvar* %addytable3389 to i8*

; insert table, function and environment into closure struct
%closure.table3393 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3383, i32 0, i32 0
store i8* %address-table3390, i8** %closure.table3393
%closure.env3394 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3383, i32 0, i32 1
store i8* %envptr3384, i8** %closure.env3394
%closure.func3395 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3383, i32 0, i32 2
store %FBO* (i8*, i8*, i32, i32, i32, i32, i32)* @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0__3356, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %closure.func3395
%closure_size3396 = call i64 @llvm_zone_mark_size(%mzone* %zone3381)
call void @llvm_zone_ptr_set_size(i8* %clsptr3382, i64 %closure_size3396)
%wrapper_ptr3397 = call i8* @llvm_zone_malloc(%mzone* %zone3381, i64 8)
%closure_wrapper3398 = bitcast i8* %wrapper_ptr3397 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3383, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper3398

; let value assignment
%FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper3398, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper3398
store { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*** %FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0
%tmp_envptr3392 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}* %environment3385, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*** %FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**** %tmp_envptr3392


%val3401 = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*** %FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %val3401
}


@FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3402 = bitcast [101 x i8]* @gsxtmgl-objects226 to i8*
call i32 (i8*, ...) @printf(i8* %var3402)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3403 = bitcast [101 x i8]* @gsxtmgl-objects226 to i8*
call i32 (i8*, ...) @printf(i8* %var3403)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3404 = bitcast [101 x i8]* @gsxtmgl-objects226 to i8*
call i32 (i8*, ...) @printf(i8* %var3404)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3405 = bitcast [101 x i8]* @gsxtmgl-objects226 to i8*
call i32 (i8*, ...) @printf(i8* %var3405)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var3406 = bitcast [101 x i8]* @gsxtmgl-objects226 to i8*
call i32 (i8*, ...) @printf(i8* %var3406)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_z_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects227 = hidden constant [48 x i8] c"FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0\00"
define dllexport fastcc %FBO* @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0__3407(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3408 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}*
%FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**** %FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr


%tzone3411 = load i8*, i8** %_impzPtr
%zone3412 = bitcast i8* %tzone3411 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %FBO*
%dat3409 = call i8* @malloc(i64 20)
call i8* @memset(i8* %dat3409, i32 0, i64 20)
%val3410 = bitcast i8* %dat3409 to %FBO*

; let value assignment
%obj = select i1 true, %FBO* %val3410, %FBO* %val3410
store %FBO* %obj, %FBO** %objPtr

%val3413 = load %FBO*, %FBO** %objPtr
%val3414 = load i32, i32* %arg_0Ptr
; set tuple
%val3415 = getelementptr %FBO, %FBO* %val3413, i64 0, i32 0
store i32 %val3414, i32* %val3415
%val3416 = load %FBO*, %FBO** %objPtr
%val3417 = load i32, i32* %arg_1Ptr
; set tuple
%val3418 = getelementptr %FBO, %FBO* %val3416, i64 0, i32 1
store i32 %val3417, i32* %val3418
%val3419 = load %FBO*, %FBO** %objPtr
%val3420 = load i32, i32* %arg_2Ptr
; set tuple
%val3421 = getelementptr %FBO, %FBO* %val3419, i64 0, i32 2
store i32 %val3420, i32* %val3421
%val3422 = load %FBO*, %FBO** %objPtr
%val3423 = load i32, i32* %arg_3Ptr
; set tuple
%val3424 = getelementptr %FBO, %FBO* %val3422, i64 0, i32 3
store i32 %val3423, i32* %val3424
%val3425 = load %FBO*, %FBO** %objPtr
%val3426 = load i32, i32* %arg_4Ptr
; set tuple
%val3427 = getelementptr %FBO, %FBO* %val3425, i64 0, i32 4
store i32 %val3426, i32* %val3427
%val3428 = load %FBO*, %FBO** %objPtr
ret %FBO* %val3428
}
@gsxtmgl-objects228 = hidden constant [101 x i8] c"FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3448 = load i8*, i8** %_impzPtr
%zone3449 = bitcast i8* %tzone3448 to %mzone*

; let assign value to symbol FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0
%dat_FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0 = call i8* @llvm_zone_malloc(%mzone* %zone3449, i64 8)
%FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr = bitcast i8* %dat_FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***
%tzone3429 = load i8*, i8** %_impzPtr
%zone3430 = bitcast i8* %tzone3429 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3430)
; malloc closure structure
%clsptr3431 = call i8* @llvm_zone_malloc(%mzone* %zone3430, i64 24)
%closure3432 = bitcast i8* %clsptr3431 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr3433 = call i8* @llvm_zone_malloc(%mzone* %zone3430, i64 8)
%environment3434 = bitcast i8* %envptr3433 to {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable3435 = call %clsvar* @new_address_table()
%var3436 = bitcast [48 x i8]* @gsxtmgl-objects227 to i8*
%var3437 = bitcast [57 x i8]* @gsxtmgl-objects223 to i8*
%addytable3438 = call %clsvar* @add_address_table(%mzone* %zone3430, i8* %var3436, i32 0, i8* %var3437, i32 3, %clsvar* %addytable3435)
%address-table3439 = bitcast %clsvar* %addytable3438 to i8*

; insert table, function and environment into closure struct
%closure.table3442 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3432, i32 0, i32 0
store i8* %address-table3439, i8** %closure.table3442
%closure.env3443 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3432, i32 0, i32 1
store i8* %envptr3433, i8** %closure.env3443
%closure.func3444 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3432, i32 0, i32 2
store %FBO* (i8*, i8*, i32, i32, i32, i32, i32)* @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0__3407, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %closure.func3444
%closure_size3445 = call i64 @llvm_zone_mark_size(%mzone* %zone3430)
call void @llvm_zone_ptr_set_size(i8* %clsptr3431, i64 %closure_size3445)
%wrapper_ptr3446 = call i8* @llvm_zone_malloc(%mzone* %zone3430, i64 8)
%closure_wrapper3447 = bitcast i8* %wrapper_ptr3446 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3432, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper3447

; let value assignment
%FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0 = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper3447, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper3447
store { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*** %FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr

; add data to environment
; don't need to alloc for env var FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0
%tmp_envptr3441 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}***}* %environment3434, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*** %FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**** %tmp_envptr3441


%val3450 = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*** %FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0Ptr
ret {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %val3450
}


@FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3451 = bitcast [101 x i8]* @gsxtmgl-objects228 to i8*
call i32 (i8*, ...) @printf(i8* %var3451)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3452 = bitcast [101 x i8]* @gsxtmgl-objects228 to i8*
call i32 (i8*, ...) @printf(i8* %var3452)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3453 = bitcast [101 x i8]* @gsxtmgl-objects228 to i8*
call i32 (i8*, ...) @printf(i8* %var3453)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i32  @i32value(i8* %arg_2_val)
%arg_3_val = call ccc i8* @list_ref(i8* %_sc, i32 3,i8* %args)
%arg_3_rt_check = call i32 @is_integer(i8* %arg_3_val)
%arg_3_bool = icmp ne i32 %arg_3_rt_check, 0
br i1 %arg_3_bool, label %arg_3_true, label %arg_3_false

arg_3_true:
br label %arg_3_continue

arg_3_false:
%var3454 = bitcast [101 x i8]* @gsxtmgl-objects228 to i8*
call i32 (i8*, ...) @printf(i8* %var3454)
%arg_3_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_3_errret

arg_3_continue:
%arg_3 = call ccc i32  @i32value(i8* %arg_3_val)
%arg_4_val = call ccc i8* @list_ref(i8* %_sc, i32 4,i8* %args)
%arg_4_rt_check = call i32 @is_integer(i8* %arg_4_val)
%arg_4_bool = icmp ne i32 %arg_4_rt_check, 0
br i1 %arg_4_bool, label %arg_4_true, label %arg_4_false

arg_4_true:
br label %arg_4_continue

arg_4_false:
%var3455 = bitcast [101 x i8]* @gsxtmgl-objects228 to i8*
call i32 (i8*, ...) @printf(i8* %var3455)
%arg_4_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_4_errret

arg_4_continue:
%arg_4 = call ccc i32  @i32value(i8* %arg_4_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_h_adhoc_W0ZCTyosaTMyLGkzMixpMzIsaTMyLGkzMl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO* (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects229 = hidden constant [49 x i8] c"FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ\00"
@gsxtmgl-objects230 = hidden constant [56 x i8] c"{i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}**\00"
define dllexport fastcc %FBO @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ__3456(i8* %_impz,i8* %_impenv, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3457 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}***}*
%FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}***}* %impenv, i32 0, i32 0
%FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr = load {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}***, {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}**** %FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr_

; setup arguments
%arg_0Ptr = alloca i32
store i32 %arg_0, i32* %arg_0Ptr
%arg_1Ptr = alloca i32
store i32 %arg_1, i32* %arg_1Ptr
%arg_2Ptr = alloca i32
store i32 %arg_2, i32* %arg_2Ptr
%arg_3Ptr = alloca i32
store i32 %arg_3, i32* %arg_3Ptr
%arg_4Ptr = alloca i32
store i32 %arg_4, i32* %arg_4Ptr


%tzone3459 = load i8*, i8** %_impzPtr
%zone3460 = bitcast i8* %tzone3459 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %FBO*
%dat3458 = alloca %FBO, align 16

; let value assignment
%obj = select i1 true, %FBO* %dat3458, %FBO* %dat3458
store %FBO* %obj, %FBO** %objPtr

%val3461 = load %FBO*, %FBO** %objPtr
%val3462 = load i32, i32* %arg_0Ptr
; set tuple
%val3463 = getelementptr %FBO, %FBO* %val3461, i64 0, i32 0
store i32 %val3462, i32* %val3463
%val3464 = load %FBO*, %FBO** %objPtr
%val3465 = load i32, i32* %arg_1Ptr
; set tuple
%val3466 = getelementptr %FBO, %FBO* %val3464, i64 0, i32 1
store i32 %val3465, i32* %val3466
%val3467 = load %FBO*, %FBO** %objPtr
%val3468 = load i32, i32* %arg_2Ptr
; set tuple
%val3469 = getelementptr %FBO, %FBO* %val3467, i64 0, i32 2
store i32 %val3468, i32* %val3469
%val3470 = load %FBO*, %FBO** %objPtr
%val3471 = load i32, i32* %arg_3Ptr
; set tuple
%val3472 = getelementptr %FBO, %FBO* %val3470, i64 0, i32 3
store i32 %val3471, i32* %val3472
%val3473 = load %FBO*, %FBO** %objPtr
%val3474 = load i32, i32* %arg_4Ptr
; set tuple
%val3475 = getelementptr %FBO, %FBO* %val3473, i64 0, i32 4
store i32 %val3474, i32* %val3475
%val3476 = load %FBO*, %FBO** %objPtr
; pointer ref
%val3477 = getelementptr %FBO, %FBO* %val3476, i64 0
%val3478 = load %FBO, %FBO* %val3477
ret %FBO %val3478
}
@gsxtmgl-objects231 = hidden constant [102 x i8] c"FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}** @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3498 = load i8*, i8** %_impzPtr
%zone3499 = bitcast i8* %tzone3498 to %mzone*

; let assign value to symbol FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ
%dat_FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone3499, i64 8)
%FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr = bitcast i8* %dat_FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ to { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}***
%tzone3479 = load i8*, i8** %_impzPtr
%zone3480 = bitcast i8* %tzone3479 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3480)
; malloc closure structure
%clsptr3481 = call i8* @llvm_zone_malloc(%mzone* %zone3480, i64 24)
%closure3482 = bitcast i8* %clsptr3481 to { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}*

; malloc environment structure
%envptr3483 = call i8* @llvm_zone_malloc(%mzone* %zone3480, i64 8)
%environment3484 = bitcast i8* %envptr3483 to {{i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}***}*

; malloc closure address table
%addytable3485 = call %clsvar* @new_address_table()
%var3486 = bitcast [49 x i8]* @gsxtmgl-objects229 to i8*
%var3487 = bitcast [56 x i8]* @gsxtmgl-objects230 to i8*
%addytable3488 = call %clsvar* @add_address_table(%mzone* %zone3480, i8* %var3486, i32 0, i8* %var3487, i32 3, %clsvar* %addytable3485)
%address-table3489 = bitcast %clsvar* %addytable3488 to i8*

; insert table, function and environment into closure struct
%closure.table3492 = getelementptr { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3482, i32 0, i32 0
store i8* %address-table3489, i8** %closure.table3492
%closure.env3493 = getelementptr { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3482, i32 0, i32 1
store i8* %envptr3483, i8** %closure.env3493
%closure.func3494 = getelementptr { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}, { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3482, i32 0, i32 2
store %FBO (i8*, i8*, i32, i32, i32, i32, i32)* @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ__3456, %FBO (i8*, i8*, i32, i32, i32, i32, i32)** %closure.func3494
%closure_size3495 = call i64 @llvm_zone_mark_size(%mzone* %zone3480)
call void @llvm_zone_ptr_set_size(i8* %clsptr3481, i64 %closure_size3495)
%wrapper_ptr3496 = call i8* @llvm_zone_malloc(%mzone* %zone3480, i64 8)
%closure_wrapper3497 = bitcast i8* %wrapper_ptr3496 to { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}**
store { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure3482, { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper3497

; let value assignment
%FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ = select i1 true, { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper3497, { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_wrapper3497
store { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}** %FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ, { i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}*** %FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ
%tmp_envptr3491 = getelementptr {{i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}***}, {{i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}***}* %environment3484, i32 0, i32 0
store {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}*** %FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr, {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}**** %tmp_envptr3491


%val3500 = load {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}**, {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}*** %FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQPtr
ret {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}** %val3500
}


@FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}** @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO %result
}


define dllexport ccc %FBO @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_native(i32 %arg_0,i32 %arg_1,i32 %arg_2,i32 %arg_3,i32 %arg_4) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
ret %FBO %result
}


define dllexport ccc void @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i32, i32, i32}*
%arg_p_0 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 2
%arg_2 = load i32, i32* %arg_p_2
%arg_p_3 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 3
%arg_3 = load i32, i32* %arg_p_3
%arg_p_4 = getelementptr {i32, i32, i32, i32, i32}, {i32, i32, i32, i32, i32}* %fstruct, i32 0, i32 4
%arg_4 = load i32, i32* %arg_p_4
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_val_adhoc_W0ZCTyxpMzIsaTMyLGkzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}**
%closure = load {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}*, {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}, {i8*, i8*, %FBO (i8*, i8*, i32, i32, i32, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  %FBO (i8*, i8*, i32, i32, i32, i32, i32)*,  %FBO (i8*, i8*, i32, i32, i32, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i32 %arg_2, i32 %arg_3, i32 %arg_4)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects232 = hidden constant [28 x i8] c"hcopy_adhoc_W0ZCTyosRkJPKl0\00"
@gsxtmgl-objects233 = hidden constant [39 x i8] c"{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**\00"
define dllexport fastcc %FBO* @hcopy_adhoc_W0ZCTyosRkJPKl0__3506(i8* %_impz,i8* %_impenv, %FBO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3507 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***}*
%hcopy_adhoc_W0ZCTyosRkJPKl0Ptr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%hcopy_adhoc_W0ZCTyosRkJPKl0Ptr = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**** %hcopy_adhoc_W0ZCTyosRkJPKl0Ptr_

; setup arguments
%xPtr = alloca %FBO*
store %FBO* %x, %FBO** %xPtr


%tzone3510 = load i8*, i8** %_impzPtr
%zone3511 = bitcast i8* %tzone3510 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %FBO*
%dat3508 = call i8* @malloc(i64 20)
call i8* @memset(i8* %dat3508, i32 0, i64 20)
%val3509 = bitcast i8* %dat3508 to %FBO*

; let value assignment
%obj = select i1 true, %FBO* %val3509, %FBO* %val3509
store %FBO* %obj, %FBO** %objPtr

%val3512 = load %FBO*, %FBO** %objPtr
%val3513 = load %FBO*, %FBO** %xPtr
; tuple ref
%val3514 = getelementptr %FBO, %FBO* %val3513, i64 0, i32 0
%val3515 = load i32, i32* %val3514
; set tuple
%val3516 = getelementptr %FBO, %FBO* %val3512, i64 0, i32 0
store i32 %val3515, i32* %val3516
%val3517 = load %FBO*, %FBO** %objPtr
%val3518 = load %FBO*, %FBO** %xPtr
; tuple ref
%val3519 = getelementptr %FBO, %FBO* %val3518, i64 0, i32 1
%val3520 = load i32, i32* %val3519
; set tuple
%val3521 = getelementptr %FBO, %FBO* %val3517, i64 0, i32 1
store i32 %val3520, i32* %val3521
%val3522 = load %FBO*, %FBO** %objPtr
%val3523 = load %FBO*, %FBO** %xPtr
; tuple ref
%val3524 = getelementptr %FBO, %FBO* %val3523, i64 0, i32 2
%val3525 = load i32, i32* %val3524
; set tuple
%val3526 = getelementptr %FBO, %FBO* %val3522, i64 0, i32 2
store i32 %val3525, i32* %val3526
%val3527 = load %FBO*, %FBO** %objPtr
%val3528 = load %FBO*, %FBO** %xPtr
; tuple ref
%val3529 = getelementptr %FBO, %FBO* %val3528, i64 0, i32 3
%val3530 = load i32, i32* %val3529
; set tuple
%val3531 = getelementptr %FBO, %FBO* %val3527, i64 0, i32 3
store i32 %val3530, i32* %val3531
%val3532 = load %FBO*, %FBO** %objPtr
%val3533 = load %FBO*, %FBO** %xPtr
; tuple ref
%val3534 = getelementptr %FBO, %FBO* %val3533, i64 0, i32 4
%val3535 = load i32, i32* %val3534
; set tuple
%val3536 = getelementptr %FBO, %FBO* %val3532, i64 0, i32 4
store i32 %val3535, i32* %val3536
%val3537 = load %FBO*, %FBO** %objPtr
ret %FBO* %val3537
}
@gsxtmgl-objects234 = hidden constant [81 x i8] c"hcopy_adhoc_W0ZCTyosRkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** @hcopy_adhoc_W0ZCTyosRkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3557 = load i8*, i8** %_impzPtr
%zone3558 = bitcast i8* %tzone3557 to %mzone*

; let assign value to symbol hcopy_adhoc_W0ZCTyosRkJPKl0
%dat_hcopy_adhoc_W0ZCTyosRkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3558, i64 8)
%hcopy_adhoc_W0ZCTyosRkJPKl0Ptr = bitcast i8* %dat_hcopy_adhoc_W0ZCTyosRkJPKl0 to { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***
%tzone3538 = load i8*, i8** %_impzPtr
%zone3539 = bitcast i8* %tzone3538 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3539)
; malloc closure structure
%clsptr3540 = call i8* @llvm_zone_malloc(%mzone* %zone3539, i64 24)
%closure3541 = bitcast i8* %clsptr3540 to { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr3542 = call i8* @llvm_zone_malloc(%mzone* %zone3539, i64 8)
%environment3543 = bitcast i8* %envptr3542 to {{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable3544 = call %clsvar* @new_address_table()
%var3545 = bitcast [28 x i8]* @gsxtmgl-objects232 to i8*
%var3546 = bitcast [39 x i8]* @gsxtmgl-objects233 to i8*
%addytable3547 = call %clsvar* @add_address_table(%mzone* %zone3539, i8* %var3545, i32 0, i8* %var3546, i32 3, %clsvar* %addytable3544)
%address-table3548 = bitcast %clsvar* %addytable3547 to i8*

; insert table, function and environment into closure struct
%closure.table3551 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure3541, i32 0, i32 0
store i8* %address-table3548, i8** %closure.table3551
%closure.env3552 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure3541, i32 0, i32 1
store i8* %envptr3542, i8** %closure.env3552
%closure.func3553 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure3541, i32 0, i32 2
store %FBO* (i8*, i8*, %FBO*)* @hcopy_adhoc_W0ZCTyosRkJPKl0__3506, %FBO* (i8*, i8*, %FBO*)** %closure.func3553
%closure_size3554 = call i64 @llvm_zone_mark_size(%mzone* %zone3539)
call void @llvm_zone_ptr_set_size(i8* %clsptr3540, i64 %closure_size3554)
%wrapper_ptr3555 = call i8* @llvm_zone_malloc(%mzone* %zone3539, i64 8)
%closure_wrapper3556 = bitcast i8* %wrapper_ptr3555 to { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**
store { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure3541, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_wrapper3556

; let value assignment
%hcopy_adhoc_W0ZCTyosRkJPKl0 = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_wrapper3556, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_wrapper3556
store { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %hcopy_adhoc_W0ZCTyosRkJPKl0, { i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*** %hcopy_adhoc_W0ZCTyosRkJPKl0Ptr

; add data to environment
; don't need to alloc for env var hcopy_adhoc_W0ZCTyosRkJPKl0
%tmp_envptr3550 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}***}* %environment3543, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*** %hcopy_adhoc_W0ZCTyosRkJPKl0Ptr, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**** %tmp_envptr3550


%val3559 = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*** %hcopy_adhoc_W0ZCTyosRkJPKl0Ptr
ret {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %val3559
}


@hcopy_adhoc_W0ZCTyosRkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hcopy_adhoc_W0ZCTyosRkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hcopy_adhoc_W0ZCTyosRkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** @hcopy_adhoc_W0ZCTyosRkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hcopy_adhoc_W0ZCTyosRkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @hcopy_adhoc_W0ZCTyosRkJPKl0(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*)*,  %FBO* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret %FBO* %result
}


define dllexport ccc %FBO* @hcopy_adhoc_W0ZCTyosRkJPKl0_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*)*,  %FBO* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret %FBO* %result
}


define dllexport ccc i8*  @hcopy_adhoc_W0ZCTyosRkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3560 = bitcast [81 x i8]* @gsxtmgl-objects234 to i8*
call i32 (i8*, ...) @printf(i8* %var3560)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*)*,  %FBO* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @hcopy_adhoc_W0ZCTyosRkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hcopy_adhoc_W0ZCTyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*)*,  %FBO* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects235 = hidden constant [28 x i8] c"hfree_adhoc_W3ZvaWQsRkJPKl0\00"
@gsxtmgl-objects236 = hidden constant [38 x i8] c"{i8*, i8*, void (i8*, i8*, %FBO*)*}**\00"
define dllexport fastcc void @hfree_adhoc_W3ZvaWQsRkJPKl0__3561(i8* %_impz,i8* %_impenv, %FBO* %x) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3562 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}*
%hfree_adhoc_W3ZvaWQsRkJPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%hfree_adhoc_W3ZvaWQsRkJPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %FBO*)*}***, {i8*, i8*, void (i8*, i8*, %FBO*)*}**** %hfree_adhoc_W3ZvaWQsRkJPKl0Ptr_

; setup arguments
%xPtr = alloca %FBO*
store %FBO* %x, %FBO** %xPtr


%val3563 = load %FBO*, %FBO** %xPtr
%val3564 = bitcast %FBO* %val3563 to i8*
call ccc void @free(i8* %val3564)
ret void
}
@gsxtmgl-objects237 = hidden constant [81 x i8] c"hfree_adhoc_W3ZvaWQsRkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %FBO*)*}** @hfree_adhoc_W3ZvaWQsRkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3586 = load i8*, i8** %_impzPtr
%zone3587 = bitcast i8* %tzone3586 to %mzone*

; let assign value to symbol hfree_adhoc_W3ZvaWQsRkJPKl0
%dat_hfree_adhoc_W3ZvaWQsRkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3587, i64 8)
%hfree_adhoc_W3ZvaWQsRkJPKl0Ptr = bitcast i8* %dat_hfree_adhoc_W3ZvaWQsRkJPKl0 to { i8*, i8*, void (i8*, i8*, %FBO*)*}***
%tzone3567 = load i8*, i8** %_impzPtr
%zone3568 = bitcast i8* %tzone3567 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3568)
; malloc closure structure
%clsptr3569 = call i8* @llvm_zone_malloc(%mzone* %zone3568, i64 24)
%closure3570 = bitcast i8* %clsptr3569 to { i8*, i8*, void (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr3571 = call i8* @llvm_zone_malloc(%mzone* %zone3568, i64 8)
%environment3572 = bitcast i8* %envptr3571 to {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable3573 = call %clsvar* @new_address_table()
%var3574 = bitcast [28 x i8]* @gsxtmgl-objects235 to i8*
%var3575 = bitcast [38 x i8]* @gsxtmgl-objects236 to i8*
%addytable3576 = call %clsvar* @add_address_table(%mzone* %zone3568, i8* %var3574, i32 0, i8* %var3575, i32 3, %clsvar* %addytable3573)
%address-table3577 = bitcast %clsvar* %addytable3576 to i8*

; insert table, function and environment into closure struct
%closure.table3580 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*)*}, { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure3570, i32 0, i32 0
store i8* %address-table3577, i8** %closure.table3580
%closure.env3581 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*)*}, { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure3570, i32 0, i32 1
store i8* %envptr3571, i8** %closure.env3581
%closure.func3582 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*)*}, { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure3570, i32 0, i32 2
store void (i8*, i8*, %FBO*)* @hfree_adhoc_W3ZvaWQsRkJPKl0__3561, void (i8*, i8*, %FBO*)** %closure.func3582
%closure_size3583 = call i64 @llvm_zone_mark_size(%mzone* %zone3568)
call void @llvm_zone_ptr_set_size(i8* %clsptr3569, i64 %closure_size3583)
%wrapper_ptr3584 = call i8* @llvm_zone_malloc(%mzone* %zone3568, i64 8)
%closure_wrapper3585 = bitcast i8* %wrapper_ptr3584 to { i8*, i8*, void (i8*, i8*, %FBO*)*}**
store { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure3570, { i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_wrapper3585

; let value assignment
%hfree_adhoc_W3ZvaWQsRkJPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_wrapper3585, { i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_wrapper3585
store { i8*, i8*, void (i8*, i8*, %FBO*)*}** %hfree_adhoc_W3ZvaWQsRkJPKl0, { i8*, i8*, void (i8*, i8*, %FBO*)*}*** %hfree_adhoc_W3ZvaWQsRkJPKl0Ptr

; add data to environment
; don't need to alloc for env var hfree_adhoc_W3ZvaWQsRkJPKl0
%tmp_envptr3579 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}* %environment3572, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %FBO*)*}*** %hfree_adhoc_W3ZvaWQsRkJPKl0Ptr, {i8*, i8*, void (i8*, i8*, %FBO*)*}**** %tmp_envptr3579


%val3588 = load {i8*, i8*, void (i8*, i8*, %FBO*)*}**, {i8*, i8*, void (i8*, i8*, %FBO*)*}*** %hfree_adhoc_W3ZvaWQsRkJPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %FBO*)*}** %val3588
}


@hfree_adhoc_W3ZvaWQsRkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@hfree_adhoc_W3ZvaWQsRkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @hfree_adhoc_W3ZvaWQsRkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %FBO*)*}** @hfree_adhoc_W3ZvaWQsRkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @hfree_adhoc_W3ZvaWQsRkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @hfree_adhoc_W3ZvaWQsRkJPKl0(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret void
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsRkJPKl0_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret void
}


define dllexport ccc i8*  @hfree_adhoc_W3ZvaWQsRkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3589 = bitcast [81 x i8]* @gsxtmgl-objects237 to i8*
call i32 (i8*, ...) @printf(i8* %var3589)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @hfree_adhoc_W3ZvaWQsRkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @hfree_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects238 = hidden constant [47 x i8] c"zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ\00"
@gsxtmgl-objects239 = hidden constant [57 x i8] c"{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**\00"
define dllexport fastcc %FBO* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ__3590(i8* %_impz,i8* %_impenv, %FBO* %x, %mzone* %fromz, %mzone* %toz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3591 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***}*
%zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***}* %impenv, i32 0, i32 0
%zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**** %zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr_

; setup arguments
%xPtr = alloca %FBO*
store %FBO* %x, %FBO** %xPtr
%fromzPtr = alloca %mzone*
store %mzone* %fromz, %mzone** %fromzPtr
%tozPtr = alloca %mzone*
store %mzone* %toz, %mzone** %tozPtr


%val3593 = load %mzone*, %mzone** %fromzPtr
%val3594 = load %FBO*, %FBO** %xPtr
%val3595 = bitcast %FBO* %val3594 to i8*
%res3596 = call ccc i1 @llvm_ptr_in_zone(%mzone* %val3593, i8* %val3595)
br i1 %res3596, label %then3592, label %else3592

then3592:
%val3597 = load %mzone*, %mzone** %tozPtr
call void @llvm_push_zone_stack(%mzone* %val3597)
%zone_ptr3598 = bitcast %mzone* %val3597 to i8*
store i8* %zone_ptr3598, i8** %_impzPtr
%tzone3604 = load i8*, i8** %_impzPtr
%zone3605 = bitcast i8* %tzone3604 to %mzone*

; let assign value to symbol obj
%objPtr = alloca %FBO*
%tzone3600 = load i8*, i8** %_impzPtr
%zone3601 = bitcast i8* %tzone3600 to %mzone*
%dat3602 = call i8* @llvm_zone_malloc(%mzone* %zone3601, i64 20)
call i8* @memset(i8* %dat3602, i32 0, i64 20)
%val3603 = bitcast i8* %dat3602 to %FBO*

; let value assignment
%obj = select i1 true, %FBO* %val3603, %FBO* %val3603
store %FBO* %obj, %FBO** %objPtr

%val3606 = load %FBO*, %FBO** %objPtr
%val3607 = load %FBO*, %FBO** %xPtr
; tuple ref
%val3608 = getelementptr %FBO, %FBO* %val3607, i64 0, i32 0
%val3609 = load i32, i32* %val3608
; set tuple
%val3610 = getelementptr %FBO, %FBO* %val3606, i64 0, i32 0
store i32 %val3609, i32* %val3610
%val3611 = load %FBO*, %FBO** %objPtr
%val3612 = load %FBO*, %FBO** %xPtr
; tuple ref
%val3613 = getelementptr %FBO, %FBO* %val3612, i64 0, i32 1
%val3614 = load i32, i32* %val3613
; set tuple
%val3615 = getelementptr %FBO, %FBO* %val3611, i64 0, i32 1
store i32 %val3614, i32* %val3615
%val3616 = load %FBO*, %FBO** %objPtr
%val3617 = load %FBO*, %FBO** %xPtr
; tuple ref
%val3618 = getelementptr %FBO, %FBO* %val3617, i64 0, i32 2
%val3619 = load i32, i32* %val3618
; set tuple
%val3620 = getelementptr %FBO, %FBO* %val3616, i64 0, i32 2
store i32 %val3619, i32* %val3620
%val3621 = load %FBO*, %FBO** %objPtr
%val3622 = load %FBO*, %FBO** %xPtr
; tuple ref
%val3623 = getelementptr %FBO, %FBO* %val3622, i64 0, i32 3
%val3624 = load i32, i32* %val3623
; set tuple
%val3625 = getelementptr %FBO, %FBO* %val3621, i64 0, i32 3
store i32 %val3624, i32* %val3625
%val3626 = load %FBO*, %FBO** %objPtr
%val3627 = load %FBO*, %FBO** %xPtr
; tuple ref
%val3628 = getelementptr %FBO, %FBO* %val3627, i64 0, i32 4
%val3629 = load i32, i32* %val3628
; set tuple
%val3630 = getelementptr %FBO, %FBO* %val3626, i64 0, i32 4
store i32 %val3629, i32* %val3630
%oldzone3631 = call %mzone* @llvm_pop_zone_stack()
%newzone3632 = call %mzone* @llvm_peek_zone_stack()
%zone_ptr3633 = bitcast %mzone* %newzone3632 to i8*
store i8* %zone_ptr3633, i8** %_impzPtr
%val3634 = load %FBO*, %FBO** %objPtr
ret %FBO* %val3634

else3592:
%val3635 = load %FBO*, %FBO** %xPtr
ret %FBO* %val3635
}
@gsxtmgl-objects240 = hidden constant [100 x i8] c"zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3655 = load i8*, i8** %_impzPtr
%zone3656 = bitcast i8* %tzone3655 to %mzone*

; let assign value to symbol zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ
%dat_zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ = call i8* @llvm_zone_malloc(%mzone* %zone3656, i64 8)
%zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr = bitcast i8* %dat_zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ to { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***
%tzone3636 = load i8*, i8** %_impzPtr
%zone3637 = bitcast i8* %tzone3636 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3637)
; malloc closure structure
%clsptr3638 = call i8* @llvm_zone_malloc(%mzone* %zone3637, i64 24)
%closure3639 = bitcast i8* %clsptr3638 to { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*

; malloc environment structure
%envptr3640 = call i8* @llvm_zone_malloc(%mzone* %zone3637, i64 8)
%environment3641 = bitcast i8* %envptr3640 to {{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***}*

; malloc closure address table
%addytable3642 = call %clsvar* @new_address_table()
%var3643 = bitcast [47 x i8]* @gsxtmgl-objects238 to i8*
%var3644 = bitcast [57 x i8]* @gsxtmgl-objects239 to i8*
%addytable3645 = call %clsvar* @add_address_table(%mzone* %zone3637, i8* %var3643, i32 0, i8* %var3644, i32 3, %clsvar* %addytable3642)
%address-table3646 = bitcast %clsvar* %addytable3645 to i8*

; insert table, function and environment into closure struct
%closure.table3649 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure3639, i32 0, i32 0
store i8* %address-table3646, i8** %closure.table3649
%closure.env3650 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure3639, i32 0, i32 1
store i8* %envptr3640, i8** %closure.env3650
%closure.func3651 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure3639, i32 0, i32 2
store %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ__3590, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)** %closure.func3651
%closure_size3652 = call i64 @llvm_zone_mark_size(%mzone* %zone3637)
call void @llvm_zone_ptr_set_size(i8* %clsptr3638, i64 %closure_size3652)
%wrapper_ptr3653 = call i8* @llvm_zone_malloc(%mzone* %zone3637, i64 8)
%closure_wrapper3654 = bitcast i8* %wrapper_ptr3653 to { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**
store { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure3639, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_wrapper3654

; let value assignment
%zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_wrapper3654, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_wrapper3654
store { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ, { i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr

; add data to environment
; don't need to alloc for env var zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ
%tmp_envptr3648 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}***}* %environment3641, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**** %tmp_envptr3648


%val3657 = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*** %zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQPtr
ret {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %val3657
}


@zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var = dllexport global [1 x i8*] [ i8* null ]

@zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ(%FBO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*,  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %FBO* %result
}


define dllexport ccc %FBO* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_native(%FBO* %arg_0,%mzone* %arg_1,%mzone* %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*,  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
ret %FBO* %result
}


define dllexport ccc i8*  @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3658 = bitcast [100 x i8]* @gsxtmgl-objects240 to i8*
call i32 (i8*, ...) @printf(i8* %var3658)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_cptr(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var3659 = bitcast [100 x i8]* @gsxtmgl-objects240 to i8*
call i32 (i8*, ...) @printf(i8* %var3659)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%ttv_1 = call ccc i8* @cptr_value(i8* %arg_1_val)
%arg_1 = bitcast i8* %ttv_1 to %mzone*
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_cptr(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var3660 = bitcast [100 x i8]* @gsxtmgl-objects240 to i8*
call i32 (i8*, ...) @printf(i8* %var3660)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%ttv_2 = call ccc i8* @cptr_value(i8* %arg_2_val)
%arg_2 = bitcast i8* %ttv_2 to %mzone*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*,  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*, %mzone*, %mzone*}*
%arg_p_0 = getelementptr {%FBO*, %mzone*, %mzone*}, {%FBO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
%arg_p_1 = getelementptr {%FBO*, %mzone*, %mzone*}, {%FBO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 1
%arg_1 = load %mzone*, %mzone** %arg_p_1
%arg_p_2 = getelementptr {%FBO*, %mzone*, %mzone*}, {%FBO*, %mzone*, %mzone*}* %fstruct, i32 0, i32 2
%arg_2 = load %mzone*, %mzone** %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @zcopy_adhoc_W0ZCTyosRkJPKixtem9uZSosbXpvbmUqXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}*, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}, {i8*, i8*, %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)*,  %FBO* (i8*, i8*, %FBO*, %mzone*, %mzone*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0, %mzone* %arg_1, %mzone* %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects241 = hidden constant [28 x i8] c"FBO_id_adhoc_W2kzMixGQk8qXQ\00"
@gsxtmgl-objects242 = hidden constant [37 x i8] c"{i8*, i8*, i32 (i8*, i8*, %FBO*)*}**\00"
define dllexport fastcc i32 @FBO_id_adhoc_W2kzMixGQk8qXQ__3661(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3662 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*
%FBO_id_adhoc_W2kzMixGQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%FBO_id_adhoc_W2kzMixGQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %FBO_id_adhoc_W2kzMixGQk8qXQPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val3663 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val3664 = getelementptr %FBO, %FBO* %val3663, i64 0, i32 0
%val3665 = load i32, i32* %val3664
ret i32 %val3665
}
@gsxtmgl-objects243 = hidden constant [81 x i8] c"FBO_id_adhoc_W2kzMixGQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @FBO_id_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3685 = load i8*, i8** %_impzPtr
%zone3686 = bitcast i8* %tzone3685 to %mzone*

; let assign value to symbol FBO_id_adhoc_W2kzMixGQk8qXQ
%dat_FBO_id_adhoc_W2kzMixGQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone3686, i64 8)
%FBO_id_adhoc_W2kzMixGQk8qXQPtr = bitcast i8* %dat_FBO_id_adhoc_W2kzMixGQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}***
%tzone3666 = load i8*, i8** %_impzPtr
%zone3667 = bitcast i8* %tzone3666 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3667)
; malloc closure structure
%clsptr3668 = call i8* @llvm_zone_malloc(%mzone* %zone3667, i64 24)
%closure3669 = bitcast i8* %clsptr3668 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr3670 = call i8* @llvm_zone_malloc(%mzone* %zone3667, i64 8)
%environment3671 = bitcast i8* %envptr3670 to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable3672 = call %clsvar* @new_address_table()
%var3673 = bitcast [28 x i8]* @gsxtmgl-objects241 to i8*
%var3674 = bitcast [37 x i8]* @gsxtmgl-objects242 to i8*
%addytable3675 = call %clsvar* @add_address_table(%mzone* %zone3667, i8* %var3673, i32 0, i8* %var3674, i32 3, %clsvar* %addytable3672)
%address-table3676 = bitcast %clsvar* %addytable3675 to i8*

; insert table, function and environment into closure struct
%closure.table3679 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3669, i32 0, i32 0
store i8* %address-table3676, i8** %closure.table3679
%closure.env3680 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3669, i32 0, i32 1
store i8* %envptr3670, i8** %closure.env3680
%closure.func3681 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3669, i32 0, i32 2
store i32 (i8*, i8*, %FBO*)* @FBO_id_adhoc_W2kzMixGQk8qXQ__3661, i32 (i8*, i8*, %FBO*)** %closure.func3681
%closure_size3682 = call i64 @llvm_zone_mark_size(%mzone* %zone3667)
call void @llvm_zone_ptr_set_size(i8* %clsptr3668, i64 %closure_size3682)
%wrapper_ptr3683 = call i8* @llvm_zone_malloc(%mzone* %zone3667, i64 8)
%closure_wrapper3684 = bitcast i8* %wrapper_ptr3683 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3669, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3684

; let value assignment
%FBO_id_adhoc_W2kzMixGQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3684, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3684
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %FBO_id_adhoc_W2kzMixGQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_id_adhoc_W2kzMixGQk8qXQPtr

; add data to environment
; don't need to alloc for env var FBO_id_adhoc_W2kzMixGQk8qXQ
%tmp_envptr3678 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %environment3671, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_id_adhoc_W2kzMixGQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %tmp_envptr3678


%val3687 = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_id_adhoc_W2kzMixGQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %val3687
}


@FBO_id_adhoc_W2kzMixGQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_id_adhoc_W2kzMixGQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_id_adhoc_W2kzMixGQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_id_adhoc_W2kzMixGQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @FBO_id_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_id_adhoc_W2kzMixGQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_id_adhoc_W2kzMixGQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_id_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @FBO_id_adhoc_W2kzMixGQk8qXQ(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_id_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @FBO_id_adhoc_W2kzMixGQk8qXQ_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_id_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @FBO_id_adhoc_W2kzMixGQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3688 = bitcast [81 x i8]* @gsxtmgl-objects243 to i8*
call i32 (i8*, ...) @printf(i8* %var3688)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_id_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @FBO_id_adhoc_W2kzMixGQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_id_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects244 = hidden constant [39 x i8] c"FBO_color_texture_adhoc_W2kzMixGQk8qXQ\00"
define dllexport fastcc i32 @FBO_color_texture_adhoc_W2kzMixGQk8qXQ__3689(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3690 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*
%FBO_color_texture_adhoc_W2kzMixGQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%FBO_color_texture_adhoc_W2kzMixGQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %FBO_color_texture_adhoc_W2kzMixGQk8qXQPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val3691 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val3692 = getelementptr %FBO, %FBO* %val3691, i64 0, i32 1
%val3693 = load i32, i32* %val3692
ret i32 %val3693
}
@gsxtmgl-objects245 = hidden constant [92 x i8] c"FBO_color_texture_adhoc_W2kzMixGQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3713 = load i8*, i8** %_impzPtr
%zone3714 = bitcast i8* %tzone3713 to %mzone*

; let assign value to symbol FBO_color_texture_adhoc_W2kzMixGQk8qXQ
%dat_FBO_color_texture_adhoc_W2kzMixGQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone3714, i64 8)
%FBO_color_texture_adhoc_W2kzMixGQk8qXQPtr = bitcast i8* %dat_FBO_color_texture_adhoc_W2kzMixGQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}***
%tzone3694 = load i8*, i8** %_impzPtr
%zone3695 = bitcast i8* %tzone3694 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3695)
; malloc closure structure
%clsptr3696 = call i8* @llvm_zone_malloc(%mzone* %zone3695, i64 24)
%closure3697 = bitcast i8* %clsptr3696 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr3698 = call i8* @llvm_zone_malloc(%mzone* %zone3695, i64 8)
%environment3699 = bitcast i8* %envptr3698 to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable3700 = call %clsvar* @new_address_table()
%var3701 = bitcast [39 x i8]* @gsxtmgl-objects244 to i8*
%var3702 = bitcast [37 x i8]* @gsxtmgl-objects242 to i8*
%addytable3703 = call %clsvar* @add_address_table(%mzone* %zone3695, i8* %var3701, i32 0, i8* %var3702, i32 3, %clsvar* %addytable3700)
%address-table3704 = bitcast %clsvar* %addytable3703 to i8*

; insert table, function and environment into closure struct
%closure.table3707 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3697, i32 0, i32 0
store i8* %address-table3704, i8** %closure.table3707
%closure.env3708 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3697, i32 0, i32 1
store i8* %envptr3698, i8** %closure.env3708
%closure.func3709 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3697, i32 0, i32 2
store i32 (i8*, i8*, %FBO*)* @FBO_color_texture_adhoc_W2kzMixGQk8qXQ__3689, i32 (i8*, i8*, %FBO*)** %closure.func3709
%closure_size3710 = call i64 @llvm_zone_mark_size(%mzone* %zone3695)
call void @llvm_zone_ptr_set_size(i8* %clsptr3696, i64 %closure_size3710)
%wrapper_ptr3711 = call i8* @llvm_zone_malloc(%mzone* %zone3695, i64 8)
%closure_wrapper3712 = bitcast i8* %wrapper_ptr3711 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3697, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3712

; let value assignment
%FBO_color_texture_adhoc_W2kzMixGQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3712, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3712
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %FBO_color_texture_adhoc_W2kzMixGQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_color_texture_adhoc_W2kzMixGQk8qXQPtr

; add data to environment
; don't need to alloc for env var FBO_color_texture_adhoc_W2kzMixGQk8qXQ
%tmp_envptr3706 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %environment3699, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_color_texture_adhoc_W2kzMixGQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %tmp_envptr3706


%val3715 = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_color_texture_adhoc_W2kzMixGQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %val3715
}


@FBO_color_texture_adhoc_W2kzMixGQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_color_texture_adhoc_W2kzMixGQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @FBO_color_texture_adhoc_W2kzMixGQk8qXQ(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3716 = bitcast [92 x i8]* @gsxtmgl-objects245 to i8*
call i32 (i8*, ...) @printf(i8* %var3716)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_color_texture_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects246 = hidden constant [39 x i8] c"FBO_depth_texture_adhoc_W2kzMixGQk8qXQ\00"
define dllexport fastcc i32 @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ__3717(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3718 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*
%FBO_depth_texture_adhoc_W2kzMixGQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%FBO_depth_texture_adhoc_W2kzMixGQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %FBO_depth_texture_adhoc_W2kzMixGQk8qXQPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val3719 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val3720 = getelementptr %FBO, %FBO* %val3719, i64 0, i32 2
%val3721 = load i32, i32* %val3720
ret i32 %val3721
}
@gsxtmgl-objects247 = hidden constant [92 x i8] c"FBO_depth_texture_adhoc_W2kzMixGQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3741 = load i8*, i8** %_impzPtr
%zone3742 = bitcast i8* %tzone3741 to %mzone*

; let assign value to symbol FBO_depth_texture_adhoc_W2kzMixGQk8qXQ
%dat_FBO_depth_texture_adhoc_W2kzMixGQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone3742, i64 8)
%FBO_depth_texture_adhoc_W2kzMixGQk8qXQPtr = bitcast i8* %dat_FBO_depth_texture_adhoc_W2kzMixGQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}***
%tzone3722 = load i8*, i8** %_impzPtr
%zone3723 = bitcast i8* %tzone3722 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3723)
; malloc closure structure
%clsptr3724 = call i8* @llvm_zone_malloc(%mzone* %zone3723, i64 24)
%closure3725 = bitcast i8* %clsptr3724 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr3726 = call i8* @llvm_zone_malloc(%mzone* %zone3723, i64 8)
%environment3727 = bitcast i8* %envptr3726 to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable3728 = call %clsvar* @new_address_table()
%var3729 = bitcast [39 x i8]* @gsxtmgl-objects246 to i8*
%var3730 = bitcast [37 x i8]* @gsxtmgl-objects242 to i8*
%addytable3731 = call %clsvar* @add_address_table(%mzone* %zone3723, i8* %var3729, i32 0, i8* %var3730, i32 3, %clsvar* %addytable3728)
%address-table3732 = bitcast %clsvar* %addytable3731 to i8*

; insert table, function and environment into closure struct
%closure.table3735 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3725, i32 0, i32 0
store i8* %address-table3732, i8** %closure.table3735
%closure.env3736 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3725, i32 0, i32 1
store i8* %envptr3726, i8** %closure.env3736
%closure.func3737 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3725, i32 0, i32 2
store i32 (i8*, i8*, %FBO*)* @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ__3717, i32 (i8*, i8*, %FBO*)** %closure.func3737
%closure_size3738 = call i64 @llvm_zone_mark_size(%mzone* %zone3723)
call void @llvm_zone_ptr_set_size(i8* %clsptr3724, i64 %closure_size3738)
%wrapper_ptr3739 = call i8* @llvm_zone_malloc(%mzone* %zone3723, i64 8)
%closure_wrapper3740 = bitcast i8* %wrapper_ptr3739 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3725, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3740

; let value assignment
%FBO_depth_texture_adhoc_W2kzMixGQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3740, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3740
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %FBO_depth_texture_adhoc_W2kzMixGQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_depth_texture_adhoc_W2kzMixGQk8qXQPtr

; add data to environment
; don't need to alloc for env var FBO_depth_texture_adhoc_W2kzMixGQk8qXQ
%tmp_envptr3734 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %environment3727, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_depth_texture_adhoc_W2kzMixGQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %tmp_envptr3734


%val3743 = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_depth_texture_adhoc_W2kzMixGQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %val3743
}


@FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3744 = bitcast [92 x i8]* @gsxtmgl-objects247 to i8*
call i32 (i8*, ...) @printf(i8* %var3744)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects248 = hidden constant [31 x i8] c"FBO_width_adhoc_W2kzMixGQk8qXQ\00"
define dllexport fastcc i32 @FBO_width_adhoc_W2kzMixGQk8qXQ__3745(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3746 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*
%FBO_width_adhoc_W2kzMixGQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%FBO_width_adhoc_W2kzMixGQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %FBO_width_adhoc_W2kzMixGQk8qXQPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val3747 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val3748 = getelementptr %FBO, %FBO* %val3747, i64 0, i32 3
%val3749 = load i32, i32* %val3748
ret i32 %val3749
}
@gsxtmgl-objects249 = hidden constant [84 x i8] c"FBO_width_adhoc_W2kzMixGQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @FBO_width_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3769 = load i8*, i8** %_impzPtr
%zone3770 = bitcast i8* %tzone3769 to %mzone*

; let assign value to symbol FBO_width_adhoc_W2kzMixGQk8qXQ
%dat_FBO_width_adhoc_W2kzMixGQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone3770, i64 8)
%FBO_width_adhoc_W2kzMixGQk8qXQPtr = bitcast i8* %dat_FBO_width_adhoc_W2kzMixGQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}***
%tzone3750 = load i8*, i8** %_impzPtr
%zone3751 = bitcast i8* %tzone3750 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3751)
; malloc closure structure
%clsptr3752 = call i8* @llvm_zone_malloc(%mzone* %zone3751, i64 24)
%closure3753 = bitcast i8* %clsptr3752 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr3754 = call i8* @llvm_zone_malloc(%mzone* %zone3751, i64 8)
%environment3755 = bitcast i8* %envptr3754 to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable3756 = call %clsvar* @new_address_table()
%var3757 = bitcast [31 x i8]* @gsxtmgl-objects248 to i8*
%var3758 = bitcast [37 x i8]* @gsxtmgl-objects242 to i8*
%addytable3759 = call %clsvar* @add_address_table(%mzone* %zone3751, i8* %var3757, i32 0, i8* %var3758, i32 3, %clsvar* %addytable3756)
%address-table3760 = bitcast %clsvar* %addytable3759 to i8*

; insert table, function and environment into closure struct
%closure.table3763 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3753, i32 0, i32 0
store i8* %address-table3760, i8** %closure.table3763
%closure.env3764 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3753, i32 0, i32 1
store i8* %envptr3754, i8** %closure.env3764
%closure.func3765 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3753, i32 0, i32 2
store i32 (i8*, i8*, %FBO*)* @FBO_width_adhoc_W2kzMixGQk8qXQ__3745, i32 (i8*, i8*, %FBO*)** %closure.func3765
%closure_size3766 = call i64 @llvm_zone_mark_size(%mzone* %zone3751)
call void @llvm_zone_ptr_set_size(i8* %clsptr3752, i64 %closure_size3766)
%wrapper_ptr3767 = call i8* @llvm_zone_malloc(%mzone* %zone3751, i64 8)
%closure_wrapper3768 = bitcast i8* %wrapper_ptr3767 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3753, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3768

; let value assignment
%FBO_width_adhoc_W2kzMixGQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3768, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3768
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %FBO_width_adhoc_W2kzMixGQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_width_adhoc_W2kzMixGQk8qXQPtr

; add data to environment
; don't need to alloc for env var FBO_width_adhoc_W2kzMixGQk8qXQ
%tmp_envptr3762 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %environment3755, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_width_adhoc_W2kzMixGQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %tmp_envptr3762


%val3771 = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_width_adhoc_W2kzMixGQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %val3771
}


@FBO_width_adhoc_W2kzMixGQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_width_adhoc_W2kzMixGQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_width_adhoc_W2kzMixGQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_width_adhoc_W2kzMixGQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @FBO_width_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_width_adhoc_W2kzMixGQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_width_adhoc_W2kzMixGQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_width_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @FBO_width_adhoc_W2kzMixGQk8qXQ(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_width_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @FBO_width_adhoc_W2kzMixGQk8qXQ_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_width_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @FBO_width_adhoc_W2kzMixGQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3772 = bitcast [84 x i8]* @gsxtmgl-objects249 to i8*
call i32 (i8*, ...) @printf(i8* %var3772)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_width_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @FBO_width_adhoc_W2kzMixGQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_width_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects250 = hidden constant [32 x i8] c"FBO_height_adhoc_W2kzMixGQk8qXQ\00"
define dllexport fastcc i32 @FBO_height_adhoc_W2kzMixGQk8qXQ__3773(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3774 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*
%FBO_height_adhoc_W2kzMixGQk8qXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%FBO_height_adhoc_W2kzMixGQk8qXQPtr = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}***, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %FBO_height_adhoc_W2kzMixGQk8qXQPtr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%val3775 = load %FBO*, %FBO** %fboPtr
; tuple ref
%val3776 = getelementptr %FBO, %FBO* %val3775, i64 0, i32 4
%val3777 = load i32, i32* %val3776
ret i32 %val3777
}
@gsxtmgl-objects251 = hidden constant [85 x i8] c"FBO_height_adhoc_W2kzMixGQk8qXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @FBO_height_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3797 = load i8*, i8** %_impzPtr
%zone3798 = bitcast i8* %tzone3797 to %mzone*

; let assign value to symbol FBO_height_adhoc_W2kzMixGQk8qXQ
%dat_FBO_height_adhoc_W2kzMixGQk8qXQ = call i8* @llvm_zone_malloc(%mzone* %zone3798, i64 8)
%FBO_height_adhoc_W2kzMixGQk8qXQPtr = bitcast i8* %dat_FBO_height_adhoc_W2kzMixGQk8qXQ to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}***
%tzone3778 = load i8*, i8** %_impzPtr
%zone3779 = bitcast i8* %tzone3778 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3779)
; malloc closure structure
%clsptr3780 = call i8* @llvm_zone_malloc(%mzone* %zone3779, i64 24)
%closure3781 = bitcast i8* %clsptr3780 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr3782 = call i8* @llvm_zone_malloc(%mzone* %zone3779, i64 8)
%environment3783 = bitcast i8* %envptr3782 to {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable3784 = call %clsvar* @new_address_table()
%var3785 = bitcast [32 x i8]* @gsxtmgl-objects250 to i8*
%var3786 = bitcast [37 x i8]* @gsxtmgl-objects242 to i8*
%addytable3787 = call %clsvar* @add_address_table(%mzone* %zone3779, i8* %var3785, i32 0, i8* %var3786, i32 3, %clsvar* %addytable3784)
%address-table3788 = bitcast %clsvar* %addytable3787 to i8*

; insert table, function and environment into closure struct
%closure.table3791 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3781, i32 0, i32 0
store i8* %address-table3788, i8** %closure.table3791
%closure.env3792 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3781, i32 0, i32 1
store i8* %envptr3782, i8** %closure.env3792
%closure.func3793 = getelementptr { i8*, i8*, i32 (i8*, i8*, %FBO*)*}, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3781, i32 0, i32 2
store i32 (i8*, i8*, %FBO*)* @FBO_height_adhoc_W2kzMixGQk8qXQ__3773, i32 (i8*, i8*, %FBO*)** %closure.func3793
%closure_size3794 = call i64 @llvm_zone_mark_size(%mzone* %zone3779)
call void @llvm_zone_ptr_set_size(i8* %clsptr3780, i64 %closure_size3794)
%wrapper_ptr3795 = call i8* @llvm_zone_malloc(%mzone* %zone3779, i64 8)
%closure_wrapper3796 = bitcast i8* %wrapper_ptr3795 to { i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure3781, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3796

; let value assignment
%FBO_height_adhoc_W2kzMixGQk8qXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3796, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_wrapper3796
store { i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %FBO_height_adhoc_W2kzMixGQk8qXQ, { i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_height_adhoc_W2kzMixGQk8qXQPtr

; add data to environment
; don't need to alloc for env var FBO_height_adhoc_W2kzMixGQk8qXQ
%tmp_envptr3790 = getelementptr {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, i32 (i8*, i8*, %FBO*)*}***}* %environment3783, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_height_adhoc_W2kzMixGQk8qXQPtr, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**** %tmp_envptr3790


%val3799 = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*** %FBO_height_adhoc_W2kzMixGQk8qXQPtr
ret {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %val3799
}


@FBO_height_adhoc_W2kzMixGQk8qXQ_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_height_adhoc_W2kzMixGQk8qXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_height_adhoc_W2kzMixGQk8qXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_height_adhoc_W2kzMixGQk8qXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** @FBO_height_adhoc_W2kzMixGQk8qXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_height_adhoc_W2kzMixGQk8qXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_height_adhoc_W2kzMixGQk8qXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_height_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @FBO_height_adhoc_W2kzMixGQk8qXQ(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_height_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i32 @FBO_height_adhoc_W2kzMixGQk8qXQ_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_height_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret i32 %result
}


define dllexport ccc i8*  @FBO_height_adhoc_W2kzMixGQk8qXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3800 = bitcast [85 x i8]* @gsxtmgl-objects251 to i8*
call i32 (i8*, ...) @printf(i8* %var3800)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_height_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @FBO_height_adhoc_W2kzMixGQk8qXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_height_adhoc_W2kzMixGQk8qXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, %FBO*)*}*, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, %FBO*)*}, {i8*, i8*, i32 (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, %FBO*)*,  i32 (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects252 = hidden constant [11 x i8] c"<FBO: 0x0>\00"
@gsxtmgl-objects253 = hidden constant [58 x i8] c"<FBO: id=%d color_tex=%d depth_tex=%d width=%d height=%d>\00"
@gsxtmgl-objects254 = hidden constant [28 x i8] c"print_adhoc_W3ZvaWQsRkJPKl0\00"
define dllexport fastcc void @print_adhoc_W3ZvaWQsRkJPKl0__3801(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3802 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}*
%print_adhoc_W3ZvaWQsRkJPKl0Ptr_ = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%print_adhoc_W3ZvaWQsRkJPKl0Ptr = load {i8*, i8*, void (i8*, i8*, %FBO*)*}***, {i8*, i8*, void (i8*, i8*, %FBO*)*}**** %print_adhoc_W3ZvaWQsRkJPKl0Ptr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr

; promote local stack var allocations
%tzone3822 = load i8*, i8** %_impzPtr
%zone3823 = bitcast i8* %tzone3822 to %mzone*
%ifptr3803 = alloca i32

%val3804 = load %FBO*, %FBO** %fboPtr
%val3805 = icmp eq %FBO* %val3804, null
br i1 %val3805, label %then3803, label %else3803

then3803:
%var3806 = bitcast [11 x i8]* @gsxtmgl-objects252 to i8*

%val3807 = call i32 (i8*, ...) @printf(i8* %var3806)
store i32 %val3807, i32* %ifptr3803
br label %ifcont3803

else3803:
%var3808 = bitcast [58 x i8]* @gsxtmgl-objects253 to i8*
%val3809 = load %FBO*, %FBO** %fboPtr
%res3810 = call fastcc i32 @FBO_id_adhoc_W2kzMixGQk8qXQ(%FBO* %val3809)
%val3811 = load %FBO*, %FBO** %fboPtr
%res3812 = call fastcc i32 @FBO_color_texture_adhoc_W2kzMixGQk8qXQ(%FBO* %val3811)
%val3813 = load %FBO*, %FBO** %fboPtr
%res3814 = call fastcc i32 @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ(%FBO* %val3813)
%val3815 = load %FBO*, %FBO** %fboPtr
%res3816 = call fastcc i32 @FBO_width_adhoc_W2kzMixGQk8qXQ(%FBO* %val3815)
%val3817 = load %FBO*, %FBO** %fboPtr
%res3818 = call fastcc i32 @FBO_height_adhoc_W2kzMixGQk8qXQ(%FBO* %val3817)

%val3819 = call i32 (i8*, ...) @printf(i8* %var3808, i32 %res3810, i32 %res3812, i32 %res3814, i32 %res3816, i32 %res3818)
store i32 %val3819, i32* %ifptr3803
br label %ifcont3803

ifcont3803:
%ifres3820 = load i32, i32* %ifptr3803

ret void
}
@gsxtmgl-objects255 = hidden constant [81 x i8] c"print_adhoc_W3ZvaWQsRkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, void (i8*, i8*, %FBO*)*}** @print_adhoc_W3ZvaWQsRkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3843 = load i8*, i8** %_impzPtr
%zone3844 = bitcast i8* %tzone3843 to %mzone*

; let assign value to symbol print_adhoc_W3ZvaWQsRkJPKl0
%dat_print_adhoc_W3ZvaWQsRkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3844, i64 8)
%print_adhoc_W3ZvaWQsRkJPKl0Ptr = bitcast i8* %dat_print_adhoc_W3ZvaWQsRkJPKl0 to { i8*, i8*, void (i8*, i8*, %FBO*)*}***
%tzone3824 = load i8*, i8** %_impzPtr
%zone3825 = bitcast i8* %tzone3824 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3825)
; malloc closure structure
%clsptr3826 = call i8* @llvm_zone_malloc(%mzone* %zone3825, i64 24)
%closure3827 = bitcast i8* %clsptr3826 to { i8*, i8*, void (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr3828 = call i8* @llvm_zone_malloc(%mzone* %zone3825, i64 8)
%environment3829 = bitcast i8* %envptr3828 to {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable3830 = call %clsvar* @new_address_table()
%var3831 = bitcast [28 x i8]* @gsxtmgl-objects254 to i8*
%var3832 = bitcast [38 x i8]* @gsxtmgl-objects236 to i8*
%addytable3833 = call %clsvar* @add_address_table(%mzone* %zone3825, i8* %var3831, i32 0, i8* %var3832, i32 3, %clsvar* %addytable3830)
%address-table3834 = bitcast %clsvar* %addytable3833 to i8*

; insert table, function and environment into closure struct
%closure.table3837 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*)*}, { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure3827, i32 0, i32 0
store i8* %address-table3834, i8** %closure.table3837
%closure.env3838 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*)*}, { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure3827, i32 0, i32 1
store i8* %envptr3828, i8** %closure.env3838
%closure.func3839 = getelementptr { i8*, i8*, void (i8*, i8*, %FBO*)*}, { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure3827, i32 0, i32 2
store void (i8*, i8*, %FBO*)* @print_adhoc_W3ZvaWQsRkJPKl0__3801, void (i8*, i8*, %FBO*)** %closure.func3839
%closure_size3840 = call i64 @llvm_zone_mark_size(%mzone* %zone3825)
call void @llvm_zone_ptr_set_size(i8* %clsptr3826, i64 %closure_size3840)
%wrapper_ptr3841 = call i8* @llvm_zone_malloc(%mzone* %zone3825, i64 8)
%closure_wrapper3842 = bitcast i8* %wrapper_ptr3841 to { i8*, i8*, void (i8*, i8*, %FBO*)*}**
store { i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure3827, { i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_wrapper3842

; let value assignment
%print_adhoc_W3ZvaWQsRkJPKl0 = select i1 true, { i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_wrapper3842, { i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_wrapper3842
store { i8*, i8*, void (i8*, i8*, %FBO*)*}** %print_adhoc_W3ZvaWQsRkJPKl0, { i8*, i8*, void (i8*, i8*, %FBO*)*}*** %print_adhoc_W3ZvaWQsRkJPKl0Ptr

; add data to environment
; don't need to alloc for env var print_adhoc_W3ZvaWQsRkJPKl0
%tmp_envptr3836 = getelementptr {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, void (i8*, i8*, %FBO*)*}***}* %environment3829, i32 0, i32 0
store {i8*, i8*, void (i8*, i8*, %FBO*)*}*** %print_adhoc_W3ZvaWQsRkJPKl0Ptr, {i8*, i8*, void (i8*, i8*, %FBO*)*}**** %tmp_envptr3836


%val3845 = load {i8*, i8*, void (i8*, i8*, %FBO*)*}**, {i8*, i8*, void (i8*, i8*, %FBO*)*}*** %print_adhoc_W3ZvaWQsRkJPKl0Ptr
ret {i8*, i8*, void (i8*, i8*, %FBO*)*}** %val3845
}


@print_adhoc_W3ZvaWQsRkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@print_adhoc_W3ZvaWQsRkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @print_adhoc_W3ZvaWQsRkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, void (i8*, i8*, %FBO*)*}** @print_adhoc_W3ZvaWQsRkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @print_adhoc_W3ZvaWQsRkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc void @print_adhoc_W3ZvaWQsRkJPKl0(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret void
}


define dllexport ccc void @print_adhoc_W3ZvaWQsRkJPKl0_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret void
}


define dllexport ccc i8*  @print_adhoc_W3ZvaWQsRkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3846 = bitcast [81 x i8]* @gsxtmgl-objects255 to i8*
call i32 (i8*, ...) @printf(i8* %var3846)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%res = call ccc i8* @mk_i1(i8* %_sc, i1 1)
ret i8* %res
}


define dllexport ccc void @print_adhoc_W3ZvaWQsRkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @print_adhoc_W3ZvaWQsRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, void (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, void (i8*, i8*, %FBO*)*}*, {i8*, i8*, void (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, void (i8*, i8*, %FBO*)*}, {i8*, i8*, void (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  void (i8*, i8*, %FBO*)*,  void (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
call fastcc void %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects256 = hidden constant [35 x i8] c"toString_adhoc_W1N0cmluZyosRkJPKl0\00"
@gsxtmgl-objects257 = hidden constant [42 x i8] c"{i8*, i8*, %String* (i8*, i8*, %FBO*)*}**\00"
define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosRkJPKl0__3847(i8* %_impz,i8* %_impenv, %FBO* %fbo) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3848 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %String* (i8*, i8*, %FBO*)*}***}*
%toString_adhoc_W1N0cmluZyosRkJPKl0Ptr_ = getelementptr {{i8*, i8*, %String* (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %FBO*)*}***}* %impenv, i32 0, i32 0
%toString_adhoc_W1N0cmluZyosRkJPKl0Ptr = load {i8*, i8*, %String* (i8*, i8*, %FBO*)*}***, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**** %toString_adhoc_W1N0cmluZyosRkJPKl0Ptr_

; setup arguments
%fboPtr = alloca %FBO*
store %FBO* %fbo, %FBO** %fboPtr


%tzone3855 = load i8*, i8** %_impzPtr
%zone3856 = bitcast i8* %tzone3855 to %mzone*

; let assign value to symbol str
%strPtr = alloca i8*
%val3849 = getelementptr i64, i64* null, i32 1
%zonesize3850 = mul i64 1, 256
%tzone3851 = load i8*, i8** %_impzPtr
%zone3852 = bitcast i8* %tzone3851 to %mzone*
%dat3853 = call i8* @llvm_zone_malloc(%mzone* %zone3852, i64 %zonesize3850)
call i8* @memset(i8* %dat3853, i32 0, i64 %zonesize3850)
%val3854 = bitcast i8* %dat3853 to i8*

; let value assignment
%str = select i1 true, i8* %val3854, i8* %val3854
store i8* %str, i8** %strPtr

; promote local stack var allocations
%tzone3879 = load i8*, i8** %_impzPtr
%zone3880 = bitcast i8* %tzone3879 to %mzone*
%ifptr3857 = alloca i32
%val3858 = load %FBO*, %FBO** %fboPtr
%val3859 = icmp eq %FBO* %val3858, null
br i1 %val3859, label %then3857, label %else3857

then3857:
%val3860 = load i8*, i8** %strPtr
%var3861 = bitcast [11 x i8]* @gsxtmgl-objects252 to i8*

%val3862 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3860, i8* %var3861)
store i32 %val3862, i32* %ifptr3857
br label %ifcont3857

else3857:
%val3863 = load i8*, i8** %strPtr
%var3864 = bitcast [58 x i8]* @gsxtmgl-objects253 to i8*
%val3865 = load %FBO*, %FBO** %fboPtr
%res3866 = call fastcc i32 @FBO_id_adhoc_W2kzMixGQk8qXQ(%FBO* %val3865)
%val3867 = load %FBO*, %FBO** %fboPtr
%res3868 = call fastcc i32 @FBO_color_texture_adhoc_W2kzMixGQk8qXQ(%FBO* %val3867)
%val3869 = load %FBO*, %FBO** %fboPtr
%res3870 = call fastcc i32 @FBO_depth_texture_adhoc_W2kzMixGQk8qXQ(%FBO* %val3869)
%val3871 = load %FBO*, %FBO** %fboPtr
%res3872 = call fastcc i32 @FBO_width_adhoc_W2kzMixGQk8qXQ(%FBO* %val3871)
%val3873 = load %FBO*, %FBO** %fboPtr
%res3874 = call fastcc i32 @FBO_height_adhoc_W2kzMixGQk8qXQ(%FBO* %val3873)

%val3875 = call i32 (i8*,i8*, ...) @sprintf(i8* %val3863, i8* %var3864, i32 %res3866, i32 %res3868, i32 %res3870, i32 %res3872, i32 %res3874)
store i32 %val3875, i32* %ifptr3857
br label %ifcont3857

ifcont3857:
%ifres3876 = load i32, i32* %ifptr3857

%val3877 = load i8*, i8** %strPtr
%res3878 = call fastcc %String* @String_adhoc_W1N0cmluZyosaTgqXQ(i8* %val3877)
ret %String* %res3878
}
@gsxtmgl-objects258 = hidden constant [88 x i8] c"toString_adhoc_W1N0cmluZyosRkJPKl0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** @toString_adhoc_W1N0cmluZyosRkJPKl0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3900 = load i8*, i8** %_impzPtr
%zone3901 = bitcast i8* %tzone3900 to %mzone*

; let assign value to symbol toString_adhoc_W1N0cmluZyosRkJPKl0
%dat_toString_adhoc_W1N0cmluZyosRkJPKl0 = call i8* @llvm_zone_malloc(%mzone* %zone3901, i64 8)
%toString_adhoc_W1N0cmluZyosRkJPKl0Ptr = bitcast i8* %dat_toString_adhoc_W1N0cmluZyosRkJPKl0 to { i8*, i8*, %String* (i8*, i8*, %FBO*)*}***
%tzone3881 = load i8*, i8** %_impzPtr
%zone3882 = bitcast i8* %tzone3881 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3882)
; malloc closure structure
%clsptr3883 = call i8* @llvm_zone_malloc(%mzone* %zone3882, i64 24)
%closure3884 = bitcast i8* %clsptr3883 to { i8*, i8*, %String* (i8*, i8*, %FBO*)*}*

; malloc environment structure
%envptr3885 = call i8* @llvm_zone_malloc(%mzone* %zone3882, i64 8)
%environment3886 = bitcast i8* %envptr3885 to {{i8*, i8*, %String* (i8*, i8*, %FBO*)*}***}*

; malloc closure address table
%addytable3887 = call %clsvar* @new_address_table()
%var3888 = bitcast [35 x i8]* @gsxtmgl-objects256 to i8*
%var3889 = bitcast [42 x i8]* @gsxtmgl-objects257 to i8*
%addytable3890 = call %clsvar* @add_address_table(%mzone* %zone3882, i8* %var3888, i32 0, i8* %var3889, i32 3, %clsvar* %addytable3887)
%address-table3891 = bitcast %clsvar* %addytable3890 to i8*

; insert table, function and environment into closure struct
%closure.table3894 = getelementptr { i8*, i8*, %String* (i8*, i8*, %FBO*)*}, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure3884, i32 0, i32 0
store i8* %address-table3891, i8** %closure.table3894
%closure.env3895 = getelementptr { i8*, i8*, %String* (i8*, i8*, %FBO*)*}, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure3884, i32 0, i32 1
store i8* %envptr3885, i8** %closure.env3895
%closure.func3896 = getelementptr { i8*, i8*, %String* (i8*, i8*, %FBO*)*}, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure3884, i32 0, i32 2
store %String* (i8*, i8*, %FBO*)* @toString_adhoc_W1N0cmluZyosRkJPKl0__3847, %String* (i8*, i8*, %FBO*)** %closure.func3896
%closure_size3897 = call i64 @llvm_zone_mark_size(%mzone* %zone3882)
call void @llvm_zone_ptr_set_size(i8* %clsptr3883, i64 %closure_size3897)
%wrapper_ptr3898 = call i8* @llvm_zone_malloc(%mzone* %zone3882, i64 8)
%closure_wrapper3899 = bitcast i8* %wrapper_ptr3898 to { i8*, i8*, %String* (i8*, i8*, %FBO*)*}**
store { i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure3884, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_wrapper3899

; let value assignment
%toString_adhoc_W1N0cmluZyosRkJPKl0 = select i1 true, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_wrapper3899, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_wrapper3899
store { i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %toString_adhoc_W1N0cmluZyosRkJPKl0, { i8*, i8*, %String* (i8*, i8*, %FBO*)*}*** %toString_adhoc_W1N0cmluZyosRkJPKl0Ptr

; add data to environment
; don't need to alloc for env var toString_adhoc_W1N0cmluZyosRkJPKl0
%tmp_envptr3893 = getelementptr {{i8*, i8*, %String* (i8*, i8*, %FBO*)*}***}, {{i8*, i8*, %String* (i8*, i8*, %FBO*)*}***}* %environment3886, i32 0, i32 0
store {i8*, i8*, %String* (i8*, i8*, %FBO*)*}*** %toString_adhoc_W1N0cmluZyosRkJPKl0Ptr, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**** %tmp_envptr3893


%val3902 = load {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}*** %toString_adhoc_W1N0cmluZyosRkJPKl0Ptr
ret {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %val3902
}


@toString_adhoc_W1N0cmluZyosRkJPKl0_var = dllexport global [1 x i8*] [ i8* null ]

@toString_adhoc_W1N0cmluZyosRkJPKl0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @toString_adhoc_W1N0cmluZyosRkJPKl0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** @toString_adhoc_W1N0cmluZyosRkJPKl0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @toString_adhoc_W1N0cmluZyosRkJPKl0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %String* @toString_adhoc_W1N0cmluZyosRkJPKl0(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %FBO*)*,  %String* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret %String* %result
}


define dllexport ccc %String* @toString_adhoc_W1N0cmluZyosRkJPKl0_native(%FBO* %arg_0) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %FBO*)*,  %String* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
ret %String* %result
}


define dllexport ccc i8*  @toString_adhoc_W1N0cmluZyosRkJPKl0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_cptr(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var3903 = bitcast [88 x i8]* @gsxtmgl-objects258 to i8*
call i32 (i8*, ...) @printf(i8* %var3903)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%ttv_0 = call ccc i8* @cptr_value(i8* %arg_0_val)
%arg_0 = bitcast i8* %ttv_0 to %FBO*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %FBO*)*,  %String* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%tmpres = bitcast %String* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @toString_adhoc_W1N0cmluZyosRkJPKl0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {%FBO*}*
%arg_p_0 = getelementptr {%FBO*}, {%FBO*}* %fstruct, i32 0, i32 0
%arg_0 = load %FBO*, %FBO** %arg_p_0
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @toString_adhoc_W1N0cmluZyosRkJPKl0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %String* (i8*, i8*, %FBO*)*}**
%closure = load {i8*, i8*, %String* (i8*, i8*, %FBO*)*}*, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %String* (i8*, i8*, %FBO*)*}, {i8*, i8*, %String* (i8*, i8*, %FBO*)*}* %closure, i32 0, i32 1
%ff = load  %String* (i8*, i8*, %FBO*)*,  %String* (i8*, i8*, %FBO*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %String* %ff(i8* %_impz, i8* %ee, %FBO* %arg_0)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects259 = hidden constant [19 x i8] c"Error creating FBO\00"
@gsxtmgl-objects260 = hidden constant [26 x i8] c"FBO_create_adhoc_W0ZCTypd\00"
@gsxtmgl-objects261 = hidden constant [32 x i8] c"{i8*, i8*, %FBO* (i8*, i8*)*}**\00"
define dllexport fastcc %FBO* @FBO_create_adhoc_W0ZCTypd__3904(i8* %_impz,i8* %_impenv) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3905 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*)*}***}*
%FBO_create_adhoc_W0ZCTypdPtr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***}* %impenv, i32 0, i32 0
%FBO_create_adhoc_W0ZCTypdPtr = load {i8*, i8*, %FBO* (i8*, i8*)*}***, {i8*, i8*, %FBO* (i8*, i8*)*}**** %FBO_create_adhoc_W0ZCTypdPtr_

; setup arguments


%tzone3908 = load i8*, i8** %_impzPtr
%zone3909 = bitcast i8* %tzone3908 to %mzone*

; let assign value to symbol fbo
%fboPtr = alloca %FBO*
%tzone3911 = load i8*, i8** %_impzPtr
%zone3912 = bitcast i8* %tzone3911 to %mzone*

; let assign value to symbol id
%idPtr = alloca i32*
%dat3906 = call i8* @malloc(i64 20)
call i8* @memset(i8* %dat3906, i32 0, i64 20)
%val3907 = bitcast i8* %dat3906 to %FBO*

; let value assignment
%fbo = select i1 true, %FBO* %val3907, %FBO* %val3907
store %FBO* %fbo, %FBO** %fboPtr

%dat3910 = alloca i32, align 16

; let value assignment
%id = select i1 true, i32* %dat3910, i32* %dat3910
store i32* %id, i32** %idPtr

%val3913 = load i32*, i32** %idPtr
call fastcc void @glGenFramebuffers_adhoc_W3ZvaWQsaTMyLGkzMipd(i32 1, i32* %val3913)
%var3915 = bitcast [19 x i8]* @gsxtmgl-objects259 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var3915)
%val3917 = load %FBO*, %FBO** %fboPtr
%val3918 = load i32*, i32** %idPtr
; pointer ref
%val3919 = getelementptr i32, i32* %val3918, i64 0
%val3920 = load i32, i32* %val3919
; set tuple
%val3921 = getelementptr %FBO, %FBO* %val3917, i64 0, i32 0
store i32 %val3920, i32* %val3921
%val3922 = load %FBO*, %FBO** %fboPtr
ret %FBO* %val3922
}
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*)*}** @FBO_create_adhoc_W0ZCTypd_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone3942 = load i8*, i8** %_impzPtr
%zone3943 = bitcast i8* %tzone3942 to %mzone*

; let assign value to symbol FBO_create_adhoc_W0ZCTypd
%dat_FBO_create_adhoc_W0ZCTypd = call i8* @llvm_zone_malloc(%mzone* %zone3943, i64 8)
%FBO_create_adhoc_W0ZCTypdPtr = bitcast i8* %dat_FBO_create_adhoc_W0ZCTypd to { i8*, i8*, %FBO* (i8*, i8*)*}***
%tzone3923 = load i8*, i8** %_impzPtr
%zone3924 = bitcast i8* %tzone3923 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3924)
; malloc closure structure
%clsptr3925 = call i8* @llvm_zone_malloc(%mzone* %zone3924, i64 24)
%closure3926 = bitcast i8* %clsptr3925 to { i8*, i8*, %FBO* (i8*, i8*)*}*

; malloc environment structure
%envptr3927 = call i8* @llvm_zone_malloc(%mzone* %zone3924, i64 8)
%environment3928 = bitcast i8* %envptr3927 to {{i8*, i8*, %FBO* (i8*, i8*)*}***}*

; malloc closure address table
%addytable3929 = call %clsvar* @new_address_table()
%var3930 = bitcast [26 x i8]* @gsxtmgl-objects260 to i8*
%var3931 = bitcast [32 x i8]* @gsxtmgl-objects261 to i8*
%addytable3932 = call %clsvar* @add_address_table(%mzone* %zone3924, i8* %var3930, i32 0, i8* %var3931, i32 3, %clsvar* %addytable3929)
%address-table3933 = bitcast %clsvar* %addytable3932 to i8*

; insert table, function and environment into closure struct
%closure.table3936 = getelementptr { i8*, i8*, %FBO* (i8*, i8*)*}, { i8*, i8*, %FBO* (i8*, i8*)*}* %closure3926, i32 0, i32 0
store i8* %address-table3933, i8** %closure.table3936
%closure.env3937 = getelementptr { i8*, i8*, %FBO* (i8*, i8*)*}, { i8*, i8*, %FBO* (i8*, i8*)*}* %closure3926, i32 0, i32 1
store i8* %envptr3927, i8** %closure.env3937
%closure.func3938 = getelementptr { i8*, i8*, %FBO* (i8*, i8*)*}, { i8*, i8*, %FBO* (i8*, i8*)*}* %closure3926, i32 0, i32 2
store %FBO* (i8*, i8*)* @FBO_create_adhoc_W0ZCTypd__3904, %FBO* (i8*, i8*)** %closure.func3938
%closure_size3939 = call i64 @llvm_zone_mark_size(%mzone* %zone3924)
call void @llvm_zone_ptr_set_size(i8* %clsptr3925, i64 %closure_size3939)
%wrapper_ptr3940 = call i8* @llvm_zone_malloc(%mzone* %zone3924, i64 8)
%closure_wrapper3941 = bitcast i8* %wrapper_ptr3940 to { i8*, i8*, %FBO* (i8*, i8*)*}**
store { i8*, i8*, %FBO* (i8*, i8*)*}* %closure3926, { i8*, i8*, %FBO* (i8*, i8*)*}** %closure_wrapper3941

; let value assignment
%FBO_create_adhoc_W0ZCTypd = select i1 true, { i8*, i8*, %FBO* (i8*, i8*)*}** %closure_wrapper3941, { i8*, i8*, %FBO* (i8*, i8*)*}** %closure_wrapper3941
store { i8*, i8*, %FBO* (i8*, i8*)*}** %FBO_create_adhoc_W0ZCTypd, { i8*, i8*, %FBO* (i8*, i8*)*}*** %FBO_create_adhoc_W0ZCTypdPtr

; add data to environment
; don't need to alloc for env var FBO_create_adhoc_W0ZCTypd
%tmp_envptr3935 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*)*}***}, {{i8*, i8*, %FBO* (i8*, i8*)*}***}* %environment3928, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*)*}*** %FBO_create_adhoc_W0ZCTypdPtr, {i8*, i8*, %FBO* (i8*, i8*)*}**** %tmp_envptr3935


%val3944 = load {i8*, i8*, %FBO* (i8*, i8*)*}**, {i8*, i8*, %FBO* (i8*, i8*)*}*** %FBO_create_adhoc_W0ZCTypdPtr
ret {i8*, i8*, %FBO* (i8*, i8*)*}** %val3944
}


@FBO_create_adhoc_W0ZCTypd_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_create_adhoc_W0ZCTypd_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_create_adhoc_W0ZCTypd_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_create_adhoc_W0ZCTypd_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*)*}** @FBO_create_adhoc_W0ZCTypd_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_create_adhoc_W0ZCTypd_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_create_adhoc_W0ZCTypd_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_create_adhoc_W0ZCTypd_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_create_adhoc_W0ZCTypd() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_create_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_create_adhoc_W0ZCTypd_native() alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_create_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_create_adhoc_W0ZCTypd_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_create_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_create_adhoc_W0ZCTypd_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = select i1 true, i8* %dat, i8* %dat
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_create_adhoc_W0ZCTypd_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*)*}*, {i8*, i8*, %FBO* (i8*, i8*)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*)*}, {i8*, i8*, %FBO* (i8*, i8*)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*)*,  %FBO* (i8*, i8*)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects262 = hidden constant [33 x i8] c"Error creating FBO depth texture\00"
@gsxtmgl-objects263 = hidden constant [58 x i8] c"Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ\00"
@gsxtmgl-objects264 = hidden constant [40 x i8] c"{i8*, i8*, i32 (i8*, i8*, i32, i32)*}**\00"
define dllexport fastcc i32 @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ__3945(i8* %_impz,i8* %_impenv, i32 %width, i32 %height) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone3946 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, i32 (i8*, i8*, i32, i32)*}***}*
%Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQPtr_ = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32, i32)*}***}* %impenv, i32 0, i32 0
%Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQPtr = load {i8*, i8*, i32 (i8*, i8*, i32, i32)*}***, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}**** %Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQPtr_

; setup arguments
%widthPtr = alloca i32
store i32 %width, i32* %widthPtr
%heightPtr = alloca i32
store i32 %height, i32* %heightPtr


%tzone3948 = load i8*, i8** %_impzPtr
%zone3949 = bitcast i8* %tzone3948 to %mzone*

; let assign value to symbol depth_tex
%depth_texPtr = alloca i32
%res3947 = call fastcc i32 @Texture_create_adhoc_W2kzMl0()

; let value assignment
%depth_tex = select i1 true, i32 %res3947, i32 %res3947
store i32 %depth_tex, i32* %depth_texPtr

%val3950 = load i32, i32* @GL_TEXTURE0
call fastcc void @glActiveTexture_adhoc_W3ZvaWQsaTMyXQ(i32 %val3950)
%val3952 = load i32, i32* @GL_TEXTURE_2D
%val3953 = load i32, i32* %depth_texPtr
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val3952, i32 %val3953)
%val3955 = load i32, i32* @GL_TEXTURE_2D
%val3956 = load i32, i32* @GL_DEPTH_COMPONENT
%val3957 = load i32, i32* %widthPtr
%val3958 = load i32, i32* %heightPtr
%val3959 = load i32, i32* @GL_DEPTH_COMPONENT
%val3960 = load i32, i32* @GL_UNSIGNED_BYTE
%null3961 = bitcast i8* null to i8*
call fastcc void @glTexImage2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %val3955, i32 0, i32 %val3956, i32 %val3957, i32 %val3958, i32 0, i32 %val3959, i32 %val3960, i8* %null3961)
%val3963 = load i32, i32* @GL_TEXTURE_2D
%val3964 = load i32, i32* @GL_TEXTURE_MAG_FILTER
%val3965 = load i32, i32* @GL_NEAREST
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val3963, i32 %val3964, i32 %val3965)
%val3967 = load i32, i32* @GL_TEXTURE_2D
%val3968 = load i32, i32* @GL_TEXTURE_MIN_FILTER
%val3969 = load i32, i32* @GL_NEAREST
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val3967, i32 %val3968, i32 %val3969)
%val3971 = load i32, i32* @GL_TEXTURE_2D
%val3972 = load i32, i32* @GL_TEXTURE_WRAP_S
%val3973 = load i32, i32* @GL_CLAMP_TO_EDGE
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val3971, i32 %val3972, i32 %val3973)
%val3975 = load i32, i32* @GL_TEXTURE_2D
%val3976 = load i32, i32* @GL_TEXTURE_WRAP_T
%val3977 = load i32, i32* @GL_CLAMP_TO_EDGE
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val3975, i32 %val3976, i32 %val3977)
%val3979 = load i32, i32* @GL_FRAMEBUFFER
%val3980 = load i32, i32* @GL_DEPTH_ATTACHMENT
%val3981 = load i32, i32* @GL_TEXTURE_2D
%val3982 = load i32, i32* %depth_texPtr
call fastcc void @glFramebufferTexture2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %val3979, i32 %val3980, i32 %val3981, i32 %val3982, i32 0)
%var3984 = bitcast [33 x i8]* @gsxtmgl-objects262 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var3984)
%val3986 = load i32, i32* %depth_texPtr
ret i32 %val3986
}
@gsxtmgl-objects265 = hidden constant [111 x i8] c"Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, i32 (i8*, i8*, i32, i32)*}** @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4006 = load i8*, i8** %_impzPtr
%zone4007 = bitcast i8* %tzone4006 to %mzone*

; let assign value to symbol Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ
%dat_Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ = call i8* @llvm_zone_malloc(%mzone* %zone4007, i64 8)
%Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQPtr = bitcast i8* %dat_Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ to { i8*, i8*, i32 (i8*, i8*, i32, i32)*}***
%tzone3987 = load i8*, i8** %_impzPtr
%zone3988 = bitcast i8* %tzone3987 to %mzone*
call void @llvm_zone_mark(%mzone* %zone3988)
; malloc closure structure
%clsptr3989 = call i8* @llvm_zone_malloc(%mzone* %zone3988, i64 24)
%closure3990 = bitcast i8* %clsptr3989 to { i8*, i8*, i32 (i8*, i8*, i32, i32)*}*

; malloc environment structure
%envptr3991 = call i8* @llvm_zone_malloc(%mzone* %zone3988, i64 8)
%environment3992 = bitcast i8* %envptr3991 to {{i8*, i8*, i32 (i8*, i8*, i32, i32)*}***}*

; malloc closure address table
%addytable3993 = call %clsvar* @new_address_table()
%var3994 = bitcast [58 x i8]* @gsxtmgl-objects263 to i8*
%var3995 = bitcast [40 x i8]* @gsxtmgl-objects264 to i8*
%addytable3996 = call %clsvar* @add_address_table(%mzone* %zone3988, i8* %var3994, i32 0, i8* %var3995, i32 3, %clsvar* %addytable3993)
%address-table3997 = bitcast %clsvar* %addytable3996 to i8*

; insert table, function and environment into closure struct
%closure.table4000 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32, i32)*}, { i8*, i8*, i32 (i8*, i8*, i32, i32)*}* %closure3990, i32 0, i32 0
store i8* %address-table3997, i8** %closure.table4000
%closure.env4001 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32, i32)*}, { i8*, i8*, i32 (i8*, i8*, i32, i32)*}* %closure3990, i32 0, i32 1
store i8* %envptr3991, i8** %closure.env4001
%closure.func4002 = getelementptr { i8*, i8*, i32 (i8*, i8*, i32, i32)*}, { i8*, i8*, i32 (i8*, i8*, i32, i32)*}* %closure3990, i32 0, i32 2
store i32 (i8*, i8*, i32, i32)* @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ__3945, i32 (i8*, i8*, i32, i32)** %closure.func4002
%closure_size4003 = call i64 @llvm_zone_mark_size(%mzone* %zone3988)
call void @llvm_zone_ptr_set_size(i8* %clsptr3989, i64 %closure_size4003)
%wrapper_ptr4004 = call i8* @llvm_zone_malloc(%mzone* %zone3988, i64 8)
%closure_wrapper4005 = bitcast i8* %wrapper_ptr4004 to { i8*, i8*, i32 (i8*, i8*, i32, i32)*}**
store { i8*, i8*, i32 (i8*, i8*, i32, i32)*}* %closure3990, { i8*, i8*, i32 (i8*, i8*, i32, i32)*}** %closure_wrapper4005

; let value assignment
%Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ = select i1 true, { i8*, i8*, i32 (i8*, i8*, i32, i32)*}** %closure_wrapper4005, { i8*, i8*, i32 (i8*, i8*, i32, i32)*}** %closure_wrapper4005
store { i8*, i8*, i32 (i8*, i8*, i32, i32)*}** %Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ, { i8*, i8*, i32 (i8*, i8*, i32, i32)*}*** %Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQPtr

; add data to environment
; don't need to alloc for env var Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ
%tmp_envptr3999 = getelementptr {{i8*, i8*, i32 (i8*, i8*, i32, i32)*}***}, {{i8*, i8*, i32 (i8*, i8*, i32, i32)*}***}* %environment3992, i32 0, i32 0
store {i8*, i8*, i32 (i8*, i8*, i32, i32)*}*** %Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQPtr, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}**** %tmp_envptr3999


%val4008 = load {i8*, i8*, i32 (i8*, i8*, i32, i32)*}**, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}*** %Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQPtr
ret {i8*, i8*, i32 (i8*, i8*, i32, i32)*}** %val4008
}


@Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_var = dllexport global [1 x i8*] [ i8* null ]

@Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, i32 (i8*, i8*, i32, i32)*}** @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, i32 (i8*, i8*, i32, i32)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc i32 @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, i32)*}*, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i32)*}, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i32)*}, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, i32)*,  i32 (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i32 @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_native(i32 %arg_0,i32 %arg_1) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, i32)*}*, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i32)*}, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i32)*}, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, i32)*,  i32 (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
ret i32 %result
}


define dllexport ccc i8*  @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4009 = bitcast [111 x i8]* @gsxtmgl-objects265 to i8*
call i32 (i8*, ...) @printf(i8* %var4009)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4010 = bitcast [111 x i8]* @gsxtmgl-objects265 to i8*
call i32 (i8*, ...) @printf(i8* %var4010)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, i32)*}*, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i32)*}, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i32)*}, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, i32)*,  i32 (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%res = call ccc i8* @mk_i32(i8* %_sc, i32 %result)
ret i8* %res
}


define dllexport ccc void @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32}*
%arg_p_0 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32}, {i32, i32}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, i32 (i8*, i8*, i32, i32)*}**
%closure = load {i8*, i8*, i32 (i8*, i8*, i32, i32)*}*, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i32)*}, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, i32 (i8*, i8*, i32, i32)*}, {i8*, i8*, i32 (i8*, i8*, i32, i32)*}* %closure, i32 0, i32 1
%ff = load  i32 (i8*, i8*, i32, i32)*,  i32 (i8*, i8*, i32, i32)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc i32 %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


@gsxtmgl-objects266 = hidden constant [27 x i8] c"Error creating framebuffer\00"
@gsxtmgl-objects267 = hidden constant [38 x i8] c"Error creating FBO & backing textures\00"
@gsxtmgl-objects268 = hidden constant [55 x i8] c"FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0\00"
@gsxtmgl-objects269 = hidden constant [46 x i8] c"{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**\00"
define dllexport fastcc %FBO* @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0__4011(i8* %_impz,i8* %_impenv, i32 %width, i32 %height, i1 %depth_p) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%zone4012 = bitcast i8* %_impz to %mzone*
; setup environment
%impenv = bitcast i8* %_impenv to {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***}*
%FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr_ = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***}* %impenv, i32 0, i32 0
%FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**** %FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr_

; setup arguments
%widthPtr = alloca i32
store i32 %width, i32* %widthPtr
%heightPtr = alloca i32
store i32 %height, i32* %heightPtr
%depth_pPtr = alloca i1
store i1 %depth_p, i1* %depth_pPtr


%tzone4014 = load i8*, i8** %_impzPtr
%zone4015 = bitcast i8* %tzone4014 to %mzone*

; let assign value to symbol fbo
%fboPtr = alloca %FBO*
%tzone4017 = load i8*, i8** %_impzPtr
%zone4018 = bitcast i8* %tzone4017 to %mzone*

; let assign value to symbol color_tex
%color_texPtr = alloca i32
%tzone4019 = load i8*, i8** %_impzPtr
%zone4020 = bitcast i8* %tzone4019 to %mzone*

; let assign value to symbol depth_tex
%depth_texPtr = alloca i32
%res4013 = call fastcc %FBO* @FBO_create_adhoc_W0ZCTypd()

; let value assignment
%fbo = select i1 true, %FBO* %res4013, %FBO* %res4013
store %FBO* %fbo, %FBO** %fboPtr

%res4016 = call fastcc i32 @Texture_create_adhoc_W2kzMl0()

; let value assignment
%color_tex = select i1 true, i32 %res4016, i32 %res4016
store i32 %color_tex, i32* %color_texPtr


; let value assignment
%depth_tex = select i1 true, i32 -1, i32 -1
store i32 %depth_tex, i32* %depth_texPtr

; promote local stack var allocations
%tzone4094 = load i8*, i8** %_impzPtr
%zone4095 = bitcast i8* %tzone4094 to %mzone*
%ifptr4057 = alloca i32
%val4021 = load i32, i32* @GL_TEXTURE_2D
%val4022 = load i32, i32* %color_texPtr
call fastcc void @glBindTexture_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val4021, i32 %val4022)
%val4024 = load i32, i32* @GL_TEXTURE_2D
%val4025 = load i32, i32* @GL_RGBA
%val4026 = load i32, i32* %widthPtr
%val4027 = load i32, i32* %heightPtr
%val4028 = load i32, i32* @GL_RGBA
%val4029 = load i32, i32* @GL_UNSIGNED_BYTE
%null4030 = bitcast i8* null to i8*
call fastcc void @glTexImage2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMixpMzIsaTMyLGkzMixpOCpd(i32 %val4024, i32 0, i32 %val4025, i32 %val4026, i32 %val4027, i32 0, i32 %val4028, i32 %val4029, i8* %null4030)
%val4032 = load i32, i32* @GL_TEXTURE_2D
%val4033 = load i32, i32* @GL_TEXTURE_WRAP_S
%val4034 = load i32, i32* @GL_REPEAT
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4032, i32 %val4033, i32 %val4034)
%val4036 = load i32, i32* @GL_TEXTURE_2D
%val4037 = load i32, i32* @GL_TEXTURE_WRAP_T
%val4038 = load i32, i32* @GL_REPEAT
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4036, i32 %val4037, i32 %val4038)
%val4040 = load i32, i32* @GL_TEXTURE_2D
%val4041 = load i32, i32* @GL_TEXTURE_MIN_FILTER
%val4042 = load i32, i32* @GL_NEAREST
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4040, i32 %val4041, i32 %val4042)
%val4044 = load i32, i32* @GL_TEXTURE_2D
%val4045 = load i32, i32* @GL_TEXTURE_MAG_FILTER
%val4046 = load i32, i32* @GL_NEAREST
call fastcc void @glTexParameteri_adhoc_W3ZvaWQsaTMyLGkzMixpMzJd(i32 %val4044, i32 %val4045, i32 %val4046)
%val4048 = load i32, i32* @GL_FRAMEBUFFER
%val4049 = load %FBO*, %FBO** %fboPtr
%res4050 = call fastcc i32 @FBO_id_adhoc_W2kzMixGQk8qXQ(%FBO* %val4049)
call fastcc void @glBindFramebuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val4048, i32 %res4050)
%val4052 = load i32, i32* @GL_FRAMEBUFFER
%val4053 = load i32, i32* @GL_COLOR_ATTACHMENT0
%val4054 = load i32, i32* @GL_TEXTURE_2D
%val4055 = load i32, i32* %color_texPtr
call fastcc void @glFramebufferTexture2D_adhoc_W3ZvaWQsaTMyLGkzMixpMzIsaTMyLGkzMl0(i32 %val4052, i32 %val4053, i32 %val4054, i32 %val4055, i32 0)
%val4058 = load i1, i1* %depth_pPtr
br i1 %val4058, label %then4057, label %else4057

then4057:
; do set!
%val4059 = load i32, i32* %widthPtr
%val4060 = load i32, i32* %heightPtr
%res4061 = call fastcc i32 @Texture_create_FBO_depth_texture_adhoc_W2kzMixpMzIsaTMyXQ(i32 %val4059, i32 %val4060)
store i32 %res4061, i32* %depth_texPtr
store i32 %res4061, i32* %ifptr4057
br label %ifcont4057

else4057:
br label %ifcont4057

ifcont4057:
%ifres4062 = load i32, i32* %ifptr4057

%val4064 = load i32, i32* @GL_FRAMEBUFFER
%res4065 = call fastcc i32 @glCheckFramebufferStatus_adhoc_W2kzMixpMzJd(i32 %val4064)
%val4066 = load i32, i32* @GL_FRAMEBUFFER_COMPLETE
%cmp4067 = icmp ne i32 %res4065, %val4066
br i1 %cmp4067, label %then4063, label %else4063

then4063:
%var4068 = bitcast [3 x i8]* @gsxtmgl-objects12 to i8*
%var4069 = bitcast [27 x i8]* @gsxtmgl-objects266 to i8*

%val4070 = call i32 (i8*, ...) @printf(i8* %var4068, i8* %var4069)
call fastcc void @print_return_adhoc_W3ZvaWRd()
%var4072 = bitcast [38 x i8]* @gsxtmgl-objects267 to i8*
call fastcc void @gl_print_error_adhoc_W3ZvaWQsaTgqXQ(i8* %var4072)
%null4074 = bitcast i8* null to %FBO*
ret %FBO* %null4074

else4063:
%val4075 = load %FBO*, %FBO** %fboPtr
%val4076 = load %FBO*, %FBO** %fboPtr
%res4077 = call fastcc i32 @FBO_id_adhoc_W2kzMixGQk8qXQ(%FBO* %val4076)
; set tuple
%val4078 = getelementptr %FBO, %FBO* %val4075, i64 0, i32 0
store i32 %res4077, i32* %val4078
%val4079 = load %FBO*, %FBO** %fboPtr
%val4080 = load i32, i32* %color_texPtr
; set tuple
%val4081 = getelementptr %FBO, %FBO* %val4079, i64 0, i32 1
store i32 %val4080, i32* %val4081
%val4082 = load %FBO*, %FBO** %fboPtr
%val4083 = load i32, i32* %depth_texPtr
; set tuple
%val4084 = getelementptr %FBO, %FBO* %val4082, i64 0, i32 2
store i32 %val4083, i32* %val4084
%val4085 = load %FBO*, %FBO** %fboPtr
%val4086 = load i32, i32* %widthPtr
; set tuple
%val4087 = getelementptr %FBO, %FBO* %val4085, i64 0, i32 3
store i32 %val4086, i32* %val4087
%val4088 = load %FBO*, %FBO** %fboPtr
%val4089 = load i32, i32* %heightPtr
; set tuple
%val4090 = getelementptr %FBO, %FBO* %val4088, i64 0, i32 4
store i32 %val4089, i32* %val4090
%val4091 = load i32, i32* @GL_FRAMEBUFFER
call fastcc void @glBindFramebuffer_adhoc_W3ZvaWQsaTMyLGkzMl0(i32 %val4091, i32 0)
%val4093 = load %FBO*, %FBO** %fboPtr
ret %FBO* %val4093
}
@gsxtmgl-objects270 = hidden constant [108 x i8] c"FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0 Scheme wrapper error: check the arg arity and types
\00"
define dllexport ccc {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_maker(i8* %_impz) nounwind {
entry:
%_impzPtr = alloca i8*
store i8* %_impz, i8** %_impzPtr
%tzone4115 = load i8*, i8** %_impzPtr
%zone4116 = bitcast i8* %tzone4115 to %mzone*

; let assign value to symbol FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0
%dat_FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0 = call i8* @llvm_zone_malloc(%mzone* %zone4116, i64 8)
%FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr = bitcast i8* %dat_FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***
%tzone4096 = load i8*, i8** %_impzPtr
%zone4097 = bitcast i8* %tzone4096 to %mzone*
call void @llvm_zone_mark(%mzone* %zone4097)
; malloc closure structure
%clsptr4098 = call i8* @llvm_zone_malloc(%mzone* %zone4097, i64 24)
%closure4099 = bitcast i8* %clsptr4098 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*

; malloc environment structure
%envptr4100 = call i8* @llvm_zone_malloc(%mzone* %zone4097, i64 8)
%environment4101 = bitcast i8* %envptr4100 to {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***}*

; malloc closure address table
%addytable4102 = call %clsvar* @new_address_table()
%var4103 = bitcast [55 x i8]* @gsxtmgl-objects268 to i8*
%var4104 = bitcast [46 x i8]* @gsxtmgl-objects269 to i8*
%addytable4105 = call %clsvar* @add_address_table(%mzone* %zone4097, i8* %var4103, i32 0, i8* %var4104, i32 3, %clsvar* %addytable4102)
%address-table4106 = bitcast %clsvar* %addytable4105 to i8*

; insert table, function and environment into closure struct
%closure.table4109 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure4099, i32 0, i32 0
store i8* %address-table4106, i8** %closure.table4109
%closure.env4110 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure4099, i32 0, i32 1
store i8* %envptr4100, i8** %closure.env4110
%closure.func4111 = getelementptr { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure4099, i32 0, i32 2
store %FBO* (i8*, i8*, i32, i32, i1)* @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0__4011, %FBO* (i8*, i8*, i32, i32, i1)** %closure.func4111
%closure_size4112 = call i64 @llvm_zone_mark_size(%mzone* %zone4097)
call void @llvm_zone_ptr_set_size(i8* %clsptr4098, i64 %closure_size4112)
%wrapper_ptr4113 = call i8* @llvm_zone_malloc(%mzone* %zone4097, i64 8)
%closure_wrapper4114 = bitcast i8* %wrapper_ptr4113 to { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**
store { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure4099, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_wrapper4114

; let value assignment
%FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0 = select i1 true, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_wrapper4114, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_wrapper4114
store { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0, { i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*** %FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr

; add data to environment
; don't need to alloc for env var FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0
%tmp_envptr4108 = getelementptr {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***}, {{i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}***}* %environment4101, i32 0, i32 0
store {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*** %FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**** %tmp_envptr4108


%val4117 = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*** %FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0Ptr
ret {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %val4117
}


@FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var = dllexport global [1 x i8*] [ i8* null ]

@FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var_zone = dllexport global [1 x i8*] [ i8* null ]

define dllexport ccc void @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_setter() alwaysinline nounwind {
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%oldzone1 = getelementptr [1 x i8*], [1 x i8*]* @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var_zone, i32 0, i32 0
%oldzone2 = load i8*, i8** %oldzone1
%oldzone3 = bitcast i8* %oldzone2 to %mzone*
store i8* %_impz, i8** %oldzone1
%closure = call ccc {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_maker(i8* %_impz)
%ptr = bitcast {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure to i8*
%varptr = bitcast [1 x i8*]* @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var to i8**
store i8* %ptr, i8** %varptr
; destroy oldzone if not null
%test = icmp ne %mzone* %oldzone3, null
br i1 %test, label %then, label %cont
then:
call ccc void @llvm_destroy_zone_after_delay(%mzone* %oldzone3, i64 441000)
br label %cont
cont:
ret void
}


define dllexport ccc i8* @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_getter() alwaysinline nounwind {
entry:
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var, i32 0, i32 0
%func = load i8*, i8** %ptr
ret i8* %func
}


define dllexport fastcc %FBO* @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0(i32 %arg_0,i32 %arg_1,i1 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i1)*,  %FBO* (i8*, i8*, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i1 %arg_2)
ret %FBO* %result
}


define dllexport ccc %FBO* @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_native(i32 %arg_0,i32 %arg_1,i1 %arg_2) alwaysinline nounwind 
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i1)*,  %FBO* (i8*, i8*, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i1 %arg_2)
ret %FBO* %result
}


define dllexport ccc i8*  @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_scheme(i8* %_sc, i8* %args) nounwind
{
entry:
%_zone = call ccc %mzone* @llvm_peek_zone_stack()
%_impz = bitcast %mzone* %_zone to i8*
%arg_0_val = call ccc i8* @list_ref(i8* %_sc, i32 0,i8* %args)
%arg_0_rt_check = call i32 @is_integer(i8* %arg_0_val)
%arg_0_bool = icmp ne i32 %arg_0_rt_check, 0
br i1 %arg_0_bool, label %arg_0_true, label %arg_0_false

arg_0_true:
br label %arg_0_continue

arg_0_false:
%var4118 = bitcast [108 x i8]* @gsxtmgl-objects270 to i8*
call i32 (i8*, ...) @printf(i8* %var4118)
%arg_0_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_0_errret

arg_0_continue:
%arg_0 = call ccc i32  @i32value(i8* %arg_0_val)
%arg_1_val = call ccc i8* @list_ref(i8* %_sc, i32 1,i8* %args)
%arg_1_rt_check = call i32 @is_integer(i8* %arg_1_val)
%arg_1_bool = icmp ne i32 %arg_1_rt_check, 0
br i1 %arg_1_bool, label %arg_1_true, label %arg_1_false

arg_1_true:
br label %arg_1_continue

arg_1_false:
%var4119 = bitcast [108 x i8]* @gsxtmgl-objects270 to i8*
call i32 (i8*, ...) @printf(i8* %var4119)
%arg_1_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_1_errret

arg_1_continue:
%arg_1 = call ccc i32  @i32value(i8* %arg_1_val)
%arg_2_val = call ccc i8* @list_ref(i8* %_sc, i32 2,i8* %args)
%arg_2_rt_check = call i32 @is_integer(i8* %arg_2_val)
%arg_2_bool = icmp ne i32 %arg_2_rt_check, 0
br i1 %arg_2_bool, label %arg_2_true, label %arg_2_false

arg_2_true:
br label %arg_2_continue

arg_2_false:
%var4120 = bitcast [108 x i8]* @gsxtmgl-objects270 to i8*
call i32 (i8*, ...) @printf(i8* %var4120)
%arg_2_errret = call ccc i8* @mk_i64(i8* %_sc, i64 0)
ret i8* %arg_2_errret

arg_2_continue:
%arg_2 = call ccc i1  @i1value(i8* %arg_2_val)
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i1)*,  %FBO* (i8*, i8*, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i1 %arg_2)
%tmpres = bitcast %FBO* %result to i8*
%res = call ccc i8* @mk_cptr(i8* %_sc, i8* %tmpres)
ret i8* %res
}


define dllexport ccc void @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_callback(i8* %dat, %mzone* %inzone) alwaysinline nounwind {
entry:
%fstruct = bitcast i8* %dat to {i32, i32, i1}*
%arg_p_0 = getelementptr {i32, i32, i1}, {i32, i32, i1}* %fstruct, i32 0, i32 0
%arg_0 = load i32, i32* %arg_p_0
%arg_p_1 = getelementptr {i32, i32, i1}, {i32, i32, i1}* %fstruct, i32 0, i32 1
%arg_1 = load i32, i32* %arg_p_1
%arg_p_2 = getelementptr {i32, i32, i1}, {i32, i32, i1}* %fstruct, i32 0, i32 2
%arg_2 = load i1, i1* %arg_p_2
call ccc void @llvm_push_zone_stack(%mzone* %inzone)
%_impz = bitcast %mzone* %inzone to i8*
%ptr = getelementptr [1 x i8*], [1 x i8*]* @FBO_create_with_textures_adhoc_W0ZCTyosaTMyLGkzMixpMV0_var, i32 0, i32 0
%ptrvar = load i8*, i8** %ptr
%closure_tmp = bitcast i8* %ptrvar to {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}**
%closure = load {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}*, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}** %closure_tmp 
%fPtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 2
%ePtr = getelementptr {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}, {i8*, i8*, %FBO* (i8*, i8*, i32, i32, i1)*}* %closure, i32 0, i32 1
%ff = load  %FBO* (i8*, i8*, i32, i32, i1)*,  %FBO* (i8*, i8*, i32, i32, i1)** %fPtr
%ee = load i8*, i8** %ePtr
%result = call fastcc %FBO* %ff(i8* %_impz, i8* %ee, i32 %arg_0, i32 %arg_1, i1 %arg_2)
%_nowoldzone = call ccc %mzone* @llvm_pop_zone_stack()
call ccc void @llvm_zone_destroy(%mzone* %_nowoldzone)
ret void
}


